<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019百度之星 初赛（一）]]></title>
    <url>%2F2019%2F08%2F18%2F2019baiduB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 65 题解]]></title>
    <url>%2F2019%2F08%2F07%2Fcontest-cf1197%2F</url>
    <content type="text"><![CDATA[过于失败的一场比赛。。。 A题目大意：长度为 $k$ 的梯子由两根 $k+1$ 长度的木板和 $k$ 个正长度的木板构成。给出所有可以用的木板，求出最长的梯子。 理解错了题意导致开门红。实际上就是对所有木板长度排序，然后在第二长木板长 -1 和 木板数目 -2 中取 $\min$。 B题目大意：有 $n$ 个盘子排成一列。盘子的半径各不相同，半径小的盘子可以放在半径大的盘子上，但可以移动的只有一个盘子（也就是说叠起来的盘子不能移动），且只能移动到相邻的位置。判定若干次移动后能不能移动成只有一堆盘子。 如果盘子构成的序列是单峰的就可以。证明显然。 C题目大意：给定一个长度是 $n$ 的有序序列，需要将其切分成 $k$ 个连续的非空部分，要求最小化：每一部分中，最大值和最小值的差，的和。 一开始被样例”骗“了，以为是非常简单的题目，结果交了两发 WA。因为是有序序列所以可以直接考察最大值和最小值之间的差，这个差可以看作是差分序列中的部分和，所以转而考虑差分序列。发现选取 $k$ 个部分等价于选取差分序列中的 $n-k$ 个数，代价就是这些数的和，那么就选取其中最小的 $n-k$ 个即可。 123456789101112131415int n, k, a[300005], d[300005];void init()&#123; n = read(), k = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 2; i &lt;= n; ++i) d[i - 1] = a[i] - a[i - 1]; sort(d + 1, d + n);&#125;void solve()&#123; ll ans = 0; for (int i = 1; i &lt;= n - k; ++i) ans += 1ll * d[i]; printf("%I64d\n", ans);&#125; （后面的题目就不会做了。。。） D题目大意：给定数列 $a$，定义代价函数，对于空子列代价为 0，对于 $[l, r]$ 区间内的代价函数为 \sum_{i=l}^{r} a_{i}-k\left\lceil\frac{r-l+1}{m}\right\rceil（$k$ 是一个常数）最大化代价。 先按照 $m$ 为单位长度求出最大子段和，然后因为是向上取整，所以可以对于每一个右端点，都额外向右增加一段长在 $[1, m)$ 之间的序列，加上其的代价。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 65 题解]]></title>
    <url>%2F2019%2F05%2F17%2Fcontest-cf1167%2F</url>
    <content type="text"><![CDATA[时隔多日又写题解]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Hard难度 题解]]></title>
    <url>%2F2019%2F04%2F26%2Fleetcode-hard%2F</url>
    <content type="text"><![CDATA[只写简单和中等题就是在摸鱼罢。 4真是一个不错的题。考虑二分。可以发现，如果两个序列归并，那么第一个中位数之前会有 $tot=\frac{n+m-1}{2}$ 个数。考虑把这些数的来源，设第一个序列的前 $p$ 个数，和第二个序列的前 $tot-p$ 个数构成了这些数。对 $p$ 二分，设当前值为 $mid$ ，判定方法是如果第一个序列下标为 $mid$ 的数小于第二个序列下标为 $tot-mid-1$ 的数，则说明 $p$ 太小。边界情况很多，包括二分的上下限和答案的位置，需要多次特判。1234567891011121314151617181920212223242526272829class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n = nums1.size(), m = nums2.size(); if(!n &amp;&amp; !m) return 0.0; int pos = (n + m - 1) &gt;&gt; 1; int l = max(0, pos - m), r = min(pos, n); // 取好答案的上下界 while(l &lt; r)&#123; int mid = (l + r) &gt;&gt; 1; if(nums1[mid] &lt; nums2[pos - mid - 1]) l = mid + 1; else r = mid; &#125; if((n + m) &amp; 1) &#123; if(l &gt;= n) return nums2[pos - l]; if(pos - l &gt;= m) return nums1[l]; if(nums1[l] &lt; nums2[pos - l]) return nums1[l]; return nums2[pos - l]; &#125;else&#123; if(l &gt;= n) return 0.5 * (nums2[pos - l] + nums2[pos - l + 1]); if(pos - l &gt;= m) return 0.5 * (nums1[l] + nums1[l + 1]); if(pos - l + 1 &lt; m &amp;&amp; nums1[l] &gt; nums2[pos - l + 1]) return 0.5 * (nums2[pos - l] + nums2[pos - l + 1]); else if(l + 1 &lt; n &amp;&amp; nums2[pos - l] &gt; nums1[l + 1]) return 0.5 * (nums1[l] + nums1[l + 1]); else return 0.5 * (nums1[l] + nums2[pos - l]); &#125; &#125;&#125;; 10有点神奇的 DP。首先这个题在某种意义上有点复杂，如果能够把诸如 x* 的字符匹配形式换成单个字符的话，代码会简便一些。下面为了方便起见，认为形式 x* 是一个字符。考虑 s 串的前 $i$ 个字符去和 $p$ 的前 $j$ 个字符匹配，成功与否由 $f[i][j]$ 指示。现在匹配到了 $s[i]$ 和 $p[j]$： 如果 $p[j]$ 是字母，那么答案仅仅是 $f[i-1][j-1]$ 和 $s[i]=p[j]$ 的逻辑与。 如果 $p[j]$ 是 .，那么答案仅仅是 $f[i-1][j-1]$。 如果 $p[j]$ 具有 x* 形式，那么答案可能来自 $f[i][j-1]$（表明该星号没有匹配到任何一个字符）： 如果 $p[j]$ 是 .*，那么答案还可以来自 $f[i-1][j-1]$ 和 $f[i-1][j]$。前者表明开始匹配，后者表明沿着之前利用星号匹配的部分继续匹配。 否则，根据 $x=s[i]$ 与否判断： 是，那么答案还可以来自 $f[i-1][j-1]$，表明开始匹配；如果 $s[i-1]$ 和 $s[i]$ 相同，那么答案还可以来自 $f[i-1][j]$，表明沿着之前利用星号匹配的部分继续匹配。 否，那么不能匹配任何字符。 一开始有一个初始化：$f[0][0]=\text{true}$。但是注意，星号可以匹配空串，所以一开始还要检查如果 $p$ 以星号开头，那么匹配空串是成功的。1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; int n = s.length(), rm = p.length(), m = rm; for (char c: p) if (c == '*') --m; vector&lt;vector&lt;bool&gt; &gt; f(n + 1, vector&lt;bool&gt;(m + 1, false)); f[0][0] = true; for (int j = 2; j &lt;= rm; j += 2)&#123; if (p[j - 1] != '*') break; f[0][j &gt;&gt; 1] = true; &#125; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1, j_ = 1; j &lt;= rm; ++j)&#123; if (j &lt; rm &amp;&amp; p[j] == '*') continue; if (isalpha(p[j - 1]))&#123; f[i][j_] = (f[i - 1][j_ - 1] &amp;&amp; s[i - 1] == p[j - 1]); &#125;else if (p[j - 1] == '.')&#123; f[i][j_] = f[i - 1][j_ - 1]; &#125;else&#123; if (p[j - 2] != '.' &amp;&amp; p[j - 2] == s[i - 1])&#123; f[i][j_] = f[i][j_ - 1] || f[i - 1][j_ - 1]; if (i &gt;= 2 &amp;&amp; s[i - 1] == s[i - 2]) f[i][j_] = f[i][j_] || f[i - 1][j_]; &#125;else if (p[j - 2] == '.') &#123; f[i][j_] = f[i][j_ - 1] || f[i - 1][j_ - 1] || f[i - 1][j_]; &#125;else&#123; f[i][j_] = f[i][j_ - 1]; &#125; &#125; ++j_; &#125; &#125; return f[n][m]; &#125;&#125;; 23经典问题。用一个堆可以解决。具体操作是：先把所有链表的第一个节点放进小根堆里（按照值比较），然后每一次从堆中弹出当前最小值对应的节点，向堆中放入它的下一个节点，再从它所属的链表中将其删去。设总共有 $N$ 个节点，那么堆的大小不超过 $K$ ，总时间复杂度是 $O(N\log K)$ 。1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; struct P&#123; int val, id; P(int v, int i): val(v), id(i) &#123;&#125; &#125;; struct cmp&#123; bool operator ()(const P &amp;p1, const P &amp;p2)&#123; return p1.val &gt; p2.val; &#125; &#125;; priority_queue&lt;P, vector&lt;P&gt;, cmp&gt; pq; ListNode *head = new ListNode(0), *res = head; int n = lists.size(); for (int i = 0; i &lt; n; ++i) if(lists[i] != NULL) pq.push(P(lists[i]-&gt;val, i)); while(!pq.empty())&#123; P t = pq.top(); pq.pop(); head-&gt;next = lists[t.id], head = head-&gt;next; lists[t.id] = lists[t.id]-&gt;next; if(lists[t.id] != NULL) pq.push(P(lists[t.id]-&gt;val, t.id)); &#125; return res-&gt;next; &#125;&#125;; 还有一个做法就是将这些链表先两两合并，然后再两两合并，循环往复，经过 $\log_2 k$ 轮后只剩下一个链表，这就是答案。因为整个合并的过程可以看作是一棵由链表作为节点的满二叉树从底向上的构建过程，而向上一层的时间复杂度是 $O(N)$ ，总共有 $\log_2 k$ 层，所以总时间复杂度和上面是一样的。 25画个图就行了。注意链表不要链来链去链出环来，那就很麻烦了。12345678910111213141516171819202122232425class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; ListNode *hhd = new ListNode(-1), *res = hhd; hhd-&gt;next = head; while(hhd-&gt;next != NULL)&#123; int cnt = 0; ListNode *tt; for (tt = hhd; tt-&gt;next != NULL &amp;&amp; cnt &lt; k; tt = tt-&gt;next) ++cnt; if(cnt &lt; k) break; ListNode *bef = hhd, *cur = hhd-&gt;next, *tmp, *tmp2 = tt-&gt;next; for (int i = 0; i &lt; k; ++i)&#123; tmp = cur-&gt;next; cur-&gt;next = bef; bef = cur, cur = tmp; &#125; hhd-&gt;next-&gt;next = tmp2; tmp2 = hhd-&gt;next; hhd-&gt;next = tt; hhd = tmp2; &#125; return res-&gt;next; &#125;&#125;; 30方法一经典的暴力 DFS。不需要剪枝也可以过。12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;int&gt; wpos, vis; vector&lt;int&gt; ans; void dfs(int pos, int cur, int left, string&amp; s, vector&lt;string&gt;&amp; words)&#123; int nn = words[cur].length(), id = wpos[cur]; for (int i = 0; i &lt; nn; ++i) if (s[pos + i] != words[id][i]) return ; if (left == 1)&#123; ans.push_back(pos + nn); return ; &#125; --vis[cur]; for (int i = 0; i &lt; wpos.size(); ++i) &#123; if (vis[i] == 0) continue; dfs(pos + nn, i, left - 1, s, words); &#125; ++vis[cur]; &#125; vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; int m = words.size(); if (!m) return vector&lt;int&gt;(); sort(words.begin(), words.end()); for (int i = 0; i &lt; m; )&#123; int j = i; while (j &lt; m &amp;&amp; words[i] == words[j]) ++j; wpos.push_back(i), vis.push_back(j - i); i = j; &#125; int cnt = 0, real_size = wpos.size(); for (string&amp; ss: words) cnt += ss.length(); if (cnt &gt; s.length()) return vector&lt;int&gt;(); for (int i = 0; i &lt;= s.length() - cnt; ++i) for (int j = 0; j &lt; real_size; ++j) dfs(i, j, m, s, words); for (int &amp;aans: ans) aans -= cnt; return ans; &#125;&#125;; 在这里如果加上记忆化什么的反而会导致效率的下降。 方法二利用每一个单词的长度都相同的特性构建滑动窗口，这样可以避免大量的重复判定。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: vector&lt;int&gt; vis, ans; vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; int m = words.size(); if (!m) return vector&lt;int&gt;(); unordered_map&lt;string, int&gt; mp; sort(words.begin(), words.end()); for (int i = 0, rz = 0; i &lt; m; )&#123; int j = i; while (j &lt; m &amp;&amp; words[i] == words[j]) ++j; vis.push_back(j - i); mp[words[i]] = rz, rz++; i = j; &#125; int unit_len = words[0].length(), s_len = s.length(); int cnt = unit_len * m; if (cnt &gt; s_len) return vector&lt;int&gt;(); queue&lt;int&gt; que; for (int i = 0; i &lt; unit_len &amp;&amp; i + cnt &lt;= s_len; ++i)&#123; int left = m; for (int j = 0; j &lt; m; ++j)&#123; if (mp.count(s.substr(j * unit_len + i, unit_len)))&#123; int id = mp[s.substr(j * unit_len + i, unit_len)]; --vis[id]; if (vis[id] &gt;= 0) --left; que.push(id); &#125;else que.push(-1); &#125; int rt = i + cnt; if (!left) ans.push_back(i); while (rt + unit_len &lt;= s_len)&#123; int tp = que.front(); que.pop(); if (tp &gt;= 0)&#123; ++vis[tp]; if (vis[tp] &gt;= 1) ++left; &#125; if (mp.count(s.substr(rt, unit_len)))&#123; int id = mp[s.substr(rt, unit_len)]; --vis[id]; if (vis[id] &gt;= 0) --left; que.push(id); &#125;else que.push(-1); rt += unit_len; if (!left) ans.push_back(rt - cnt); &#125; while (!que.empty()) &#123; if (que.front() &gt;= 0) ++vis[que.front()]; que.pop(); &#125; &#125; return ans; &#125;&#125;; 不得不说，c++ 的切片真的很鸡肋。。。 方法三构建 AC 自动机（等待更新） 3237方法一采用一些简单的剪枝手法。用一个三元组 $(\text{type}, \text{id}, \text{digit})$ 来表示当前的填写状态，其中 type=0 表示行，type=1 表示列，type=2 表示 3 * 3 的方格。同时用一个列表 lis 记录当前尚未填写的位置。每次 DFS 时，填写一个空之后就在列表中剩下没有填写的位置里找出自由度最低的空格，将其作为下一个搜索对象，直到所有空格都被填写为止。经实践，这种方法的效率在面对一般的数独题目还是非常好的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: bool vis[3][11][11]; // 0 行 1 列 2 宫 int lis[81][2], len_lis; void get(int at)&#123; int mini = 99, targ = -1; for(int i = at + 1; i &lt; len_lis; ++i)&#123; int x = lis[i][0], y = lis[i][1], o = 0; for(int j = 1; j &lt;= 9; ++j)&#123; if(vis[0][x][j] || vis[1][y][j] || vis[2][(x / 3) * 3 + y / 3][j]) continue; ++o; &#125; if(o &lt; mini) mini = o, targ = i; &#125; swap(lis[targ][0], lis[at + 1][0]); swap(lis[targ][1], lis[at + 1][1]); &#125; bool dfs(int at, vector&lt;vector&lt;char&gt;&gt;&amp; board)&#123; int x = lis[at][0], y = lis[at][1]; int block_id = (x / 3) * 3 + y / 3; for(int i = 1; i &lt;= 9; ++i)&#123; if (vis[0][x][i] || vis[1][y][i] || vis[2][block_id][i]) continue; vis[0][x][i] = vis[1][y][i] = vis[2][block_id][i] = true, board[x][y] = i + '0'; if(at &lt; len_lis - 1)&#123; if (at != len_lis - 2) get(at); if (dfs(at + 1, board)) return true; &#125;else return true; vis[0][x][i] = vis[1][y][i] = vis[2][block_id][i] = 0; &#125; return false; &#125; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; memset(vis, 0, sizeof(vis)); memset(lis, 0, sizeof(lis)); len_lis = 0; for (int i = 0; i &lt; 9; ++i) for (int j = 0; j &lt; 9; ++j)&#123; if (board[i][j] == '.')&#123; lis[len_lis][0] = i, lis[len_lis++][1] = j; &#125;else &#123; int id = board[i][j] - '0'; vis[0][i][id] = vis[1][j][id] = vis[2][(i / 3) * 3 + j / 3][id] = true; &#125; &#125; dfs(0, board); &#125;&#125;; 方法二DLX 算法。（等待更新）12 41基本同448，物归原主方法。1234567891011121314151617181920class Solution(object): def firstMissingPositive(self, nums): """ :type nums: List[int] :rtype: int """ if nums == []: return 1 len1 = len(nums) for i in range(0, len1): while True: if nums[i] &gt; len1 or nums[i] &lt;= 0 or nums[nums[i] - 1] == nums[i] or i == nums[i] - 1: break nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] i = 0 while i &lt; len1: if nums[i] != i + 1: break i += 1 return i + 1 42一开始写了半天单调栈，发现单调栈好像根本搞不出来。。。于是放弃，写了一个前缀和后缀最大值，两个间的较小值减掉该位置的高度就是该位置水应当有的高度。这个值可能为负，所以要和0取max。说白了写不出就是基础不扎实。。。1234567891011121314class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); vector&lt;int&gt; l(n, 0), r(n, 0); int ans = 0; for (int i = 1; i &lt; n; ++i) l[i] = max(l[i - 1], height[i - 1]); for (int i = n - 2; i &gt;= 0; --i) r[i] = max(r[i + 1], height[i + 1]), ans += max(0, min(l[i], r[i]) - height[i]); return ans; &#125;&#125;; 44第 10 题的弱化版。 方法一直接把第 10 题大部分的代码照搬就行。123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; int n = s.length(), m = p.length(); vector&lt;vector&lt;bool&gt; &gt; f(n + 1, vector&lt;bool&gt;(m + 1, false)); f[0][0] = true; for (int j = 1; j &lt;= m; ++j)&#123; if (p[j - 1] != '*') break; f[0][j] = true; &#125; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= m; ++j)&#123; if (isalpha(p[j - 1]))&#123; f[i][j] = (f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1]); &#125;else if (p[j - 1] == '?')&#123; f[i][j] = f[i - 1][j - 1]; &#125;else&#123; f[i][j] = f[i][j - 1] || f[i - 1][j - 1] || f[i - 1][j]; &#125; &#125; &#125; return f[n][m]; &#125;&#125;; 方法二45写了一个谜一样的树状数组。。。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;int&gt; bb; int lowbit(int x)&#123; return x &amp; (-x); &#125; void update(int k, int r, int n)&#123; while(k &lt;= n) bb[k] = min(bb[k], r), k += lowbit(k); &#125; int query(int k)&#123; int res = 0x3f3f3f3f; while(k) res = min(res, bb[k]), k -= lowbit(k); return res; &#125; int jump(vector&lt;int&gt;&amp; nums) &#123; vector&lt;pair&lt;int, int&gt; &gt; nnums; vector&lt;int&gt; f; int n = nums.size(); for (int i = 0; i &lt; n; ++i) nnums.push_back(make_pair(-i - nums[i], i)); sort(nnums.begin(), nnums.end()); f = vector&lt;int&gt;(n, 0x3f3f3f3f); bb = vector&lt;int&gt;(n + 1, 0x3f3f3f3f); &#123; f[0] = 0; int iid = lower_bound(nnums.begin(), nnums.end(), make_pair(-nums[0], 0)) - nnums.begin(); update(iid + 1, 0, n); &#125; for (int i = 1; i &lt; n; ++i)&#123; int id = upper_bound(nnums.begin(), nnums.end(), make_pair(-i, n)) - nnums.begin(); f[i] = query(id) + 1; int iid = lower_bound(nnums.begin(), nnums.end(), make_pair(-i - nums[i], i)) - nnums.begin(); update(iid + 1, f[i], n); &#125; return f[n - 1]; &#125;&#125;; 但实际上这个题没有这么麻烦， 51比下面这个难123456789101112131415161718192021222324class Solution: def solveNQueens(self, n: int) -&gt; List[List[str]]: """ :type n: int :rtype: int """ ans = [0] * n aans = [] def solve(n, cur_id, left, straight, right): nonlocal ans if cur_id == n + 1: lst = [("." * ans[i]) + "Q" + ("." * (n - ans[i] - 1)) for i in range(0, n)] aans.append(lst) return cur = ((left &amp; ((1 &lt;&lt; n) - 1)) | straight | right) for i in range(0, n): j = 1 &lt;&lt; i if cur &amp; j: continue else: ans[cur_id - 1] = i solve(n, cur_id + 1, (left | j) &lt;&lt; 1, straight | j, (right | j) &gt;&gt; 1) solve(n, 1, 0, 0, 0) return ans 52这算困难吗。。。算了还是写在这123456789101112131415161718192021class Solution: def totalNQueens(self, n): """ :type n: int :rtype: int """ ans = 0 def solve(n, cur_id, left, straight, right): nonlocal ans if cur_id == n + 1: ans += 1 return cur = ((left &amp; ((1 &lt;&lt; n) - 1)) | straight | right) for i in range(0, n): j = 1 &lt;&lt; i if cur &amp; j: continue else: solve(n, cur_id + 1, (left | j) &lt;&lt; 1, straight | j, (right | j) &gt;&gt; 1) solve(n, 1, 0, 0, 0) return ans 57两次二分，第一次找所有区间中，第一个右端点大于等于给定区间左端点的区间；第二次找所有区间中，第一个左端点大于给定区间右端点的区间。后者的前一个区间就是最后一个左端点小于等于给定区间右端点的区间。然后就可以合并了。合并过程比较容易，但不知道为什么空间花费很多。需要注意的是，二分的结果中有些极端情况需要特判。1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; int n = intervals.size(); int l1 = 0, r1 = n; while (r1 &gt; l1)&#123; int mid = (l1 + r1) &gt;&gt; 1; if (intervals[mid][1] &lt; newInterval[0]) l1 = mid + 1; else r1 = mid; &#125; if (l1 == n)&#123; intervals.push_back(newInterval); return intervals; &#125; int l2 = 0, r2 = n; while (r2 &gt; l2)&#123; int mid = (l2 + r2) &gt;&gt; 1; if (intervals[mid][0] &lt;= newInterval[1]) l2 = mid + 1; else r2 = mid; &#125; --l2; if (l2 == -1)&#123; intervals.insert(intervals.begin(), newInterval); &#125;else if (l2 == n - 1)&#123; int rr = max(newInterval[1], intervals[n - 1][1]); while (l1 &lt; intervals.size() - 1) intervals.pop_back(); intervals[l1][0] = min(newInterval[0], intervals[l1][0]); intervals[l1][1] = rr; &#125;else &#123; int ll = min(newInterval[0], intervals[l1][0]); int rr = max(newInterval[1], intervals[l2][1]); if (l1 &lt;= l2)&#123; intervals[l1][0] = ll, intervals[l1][1] = rr; intervals.erase(intervals.begin() + l1 + 1, intervals.begin() + l2 + 1); &#125;else &#123; intervals.insert(intervals.begin() + l1, vector&lt;int&gt;&#123;ll, rr&#125;); &#125; &#125; return intervals; &#125;&#125;; 65偷懒1234567class Solution(object): def isNumber(self, s): try: a = complex(s) except ValueError: return False return True 68大模拟，大力分类讨论1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123; int cur = 0, n = words.size(); vector&lt;string&gt; ans; while(cur &lt; n)&#123; string curstr(maxWidth, ' '); int j = cur + 1, cnt = words[cur].size(); while(j &lt; n &amp;&amp; cnt + words[j].size() + j - cur &lt;= maxWidth) cnt += words[j].size(), ++j; int num_of_space = maxWidth - cnt; if(j - cur == 1)&#123; for (int i = 0; i &lt; cnt; ++i) curstr[i] = words[cur][i]; &#125;else if(j == n)&#123; for (int i = 0, len = 0; i &lt; n - cur; ++i)&#123; int siz = words[cur + i].size(); for (int j = 0; j &lt; siz; ++j) curstr[len++] = words[cur + i][j]; len++; &#125; &#125;else&#123; int pos = (j - cur - 1), bas = num_of_space / pos; int left = num_of_space % pos; for (int i = 0, len = 0; i &lt;= pos; ++i)&#123; int siz = words[cur + i].size(); for (int j = 0; j &lt; siz; ++j) curstr[len++] = words[cur + i][j]; len += bas; if(left) len++, left--; &#125; &#125; ans.push_back(curstr); cur = j; &#125; return ans; &#125;&#125;; 72简单DP123456789101112131415161718192021class Solution &#123;public: int minDistance(string word1, string word2) &#123; int len1 = word1.size(), len2 = word2.size(); if(!len1 || !len2) return len1 + len2; vector&lt;vector&lt;int&gt; &gt; f(len1 + 1, vector&lt;int&gt;(len2 + 1, 0)); for (int i = 0; i &lt;= len1; ++i) f[i][0] = i; for (int i = 0; i &lt;= len2; ++i) f[0][i] = i; for (int i = 1; i &lt;= len1; ++i) for (int j = 1; j &lt;= len2; ++j)&#123; f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; if(word1[i - 1] == word2[j - 1]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); &#125; return f[len1][len2]; &#125;&#125;; 76尺取法1234567891011121314151617181920212223242526272829class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; cnt(129, 0), cnt2(129, 0); int i = 0, j = -1, n = s.size(), m = t.size(); int tot = 0, curtot = 0; int ans = n + 1, posi = -1, posj = -1; for (int k = 0; k &lt; m; ++k)&#123; cnt2[t[k]]++; if(cnt2[t[k]] == 1) tot++; &#125; for(; i &lt; n &amp;&amp; j &lt; n - 1; )&#123; while(j &lt; n - 1 &amp;&amp; curtot &lt; tot)&#123; ++j, cnt[s[j]]++; if(cnt[s[j]] == cnt2[s[j]]) curtot++; &#125; if(j == n - 1 &amp;&amp; curtot &lt; tot) break; while(i &lt; j)&#123; if(cnt[s[i]] == cnt2[s[i]]) break; cnt[s[i]]--, ++i; &#125; if(ans &gt; j - i + 1) ans = j - i + 1, posi = i, posj = j; cnt[s[i]]--, --curtot, ++i; &#125; if(ans == n + 1) return string(""); return s.substr(posi, ans); &#125;&#125;; 84单调栈经典题12345678910111213141516171819class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int ans = 0; heights.push_back(0); int n = heights.size(); vector&lt;int&gt; id, w; for (int i = 0; i &lt; n; ++i)&#123; int curw = 0; while(!id.empty() &amp;&amp; heights[id.back()] &gt;= heights[i])&#123; curw += w.back(); ans = max(ans, curw * heights[id.back()]); id.pop_back(), w.pop_back(); &#125; id.push_back(i), w.push_back(curw + 1); &#125; return ans; &#125;&#125;; 85扩展单调栈1234567891011121314151617181920212223242526272829class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); if(!n) return 0; int m = matrix[0].size(), ans = 0; stack&lt;int&gt; st, w; vector&lt;int&gt; h(m + 1, 0); for (int i = 0, cur = 0; i &lt; m; ++i)&#123; if(matrix[0][i] == '1') h[i] = 1, cur++, ans = max(ans, cur); else cur = 0, h[i] = 0; &#125; for (int i = 1; i &lt; n; ++i)&#123; for (int j = 0; j &lt; m; ++j)&#123; if(matrix[i][j] == '1') h[j]++; else h[j] = 0; &#125; while(!st.empty()) st.pop(), w.pop(); for (int j = 0; j &lt;= m; ++j)&#123; int curw = 0; while(!st.empty() &amp;&amp; st.top() &gt;= h[j]) curw += w.top(), ans = max(ans, curw * st.top()), st.pop(), w.pop(); w.push(curw + 1), st.push(h[j]); &#125; &#125; return ans; &#125;&#125;; 87考虑将两个字符串切分，只有两种可能： 第一个的前半部分配第二个的前半部分，第一个的后半部分配第二个的后半部分。 第一个的前半部分配第二个的后半部分，第一个的后半部分配第二个的前半部分。 然后判定配对成功与否用一个桶即可，这样递归下去也跑的比较快。123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool dfs(string&amp; s1, string&amp; s2, int l1, int r1, int l2, int r2, bool flag)&#123; if (r1 - l1 == 1) return s1[l1] == s2[l2]; int vec[128] = &#123;0&#125;, cnt = 0; for (int i = 1; i &lt; r1 - l1; ++i)&#123; if (vec[s1[l1 + i - 1]] == 0) ++cnt; else if (vec[s1[l1 + i - 1]] == -1) --cnt; ++vec[s1[l1 + i - 1]]; if (flag) &#123; if (vec[s2[l2 + i - 1]] == 1) --cnt; else if (vec[s2[l2 + i - 1]] == 0) ++cnt; --vec[s2[l2 + i - 1]]; if (cnt == 0 &amp;&amp; (dfs(s1, s2, l1, l1 + i, l2, l2 + i, true) || dfs(s1, s2, l1, l1 + i, l2, l2 + i, false)) &amp;&amp; (dfs(s1, s2, l1 + i, r1, l2 + i, r2, true) || dfs(s1, s2, l1 + i, r1, l2 + i, r2, false))) return true; &#125;else &#123; if (vec[s2[r2 - i]] == 1) --cnt; else if (vec[s2[r2 - i]] == 0) ++cnt; --vec[s2[r2 - i]]; if (cnt == 0 &amp;&amp; (dfs(s1, s2, l1, l1 + i, r2 - i, r2, true) || dfs(s1, s2, l1, l1 + i, r2 - i, r2, false)) &amp;&amp; (dfs(s1, s2, l1 + i, r1, l2, r2 - i, true) || dfs(s1, s2, l1 + i, r1, l2, r2 - i, false))) return true; &#125; &#125; return false; &#125; bool isScramble(string s1, string s2) &#123; return dfs(s1, s2, 0, s1.length(), 0, s2.length(), true) || dfs(s1, s2, 0, s1.length(), 0, s2.length(), false); &#125;&#125;; 97简单的 DP。可以压成一维。12345678910111213141516171819202122232425262728class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if ( s1.empty() ) return s2 == s3; if ( s2.empty() ) return s1 == s3; int n = s1.length(), m = s2.length(); if ( n + m != s3.length() ) return false; vector&lt;vector&lt;bool&gt; &gt; f( n + 1, vector&lt;bool&gt;( m + 1, false )); f[0][0] = true; for (int i = 0; i &lt; n; ++i)&#123; if ( s1[i] == s3[i] &amp;&amp; f[i][0] ) f[i + 1][0] = true; else break; &#125; for (int i = 0; i &lt; m; ++i)&#123; if ( s2[i] == s3[i] &amp;&amp; f[0][i] ) f[0][i + 1] = true; else break; &#125; for (int i = 0; i &lt; n; ++i)&#123; for (int j = 0; j &lt; m; ++j)&#123; if ( s1[i] == s3[i + j + 1] &amp;&amp; f[i][j + 1] ) f[i + 1][j + 1] = true; else if ( s2[j] == s3[i + j + 1] &amp;&amp; f[i + 1][j] ) f[i + 1][j + 1] = true; &#125; &#125; return f[n][m]; &#125;&#125;; 99观察可以发现：整个中序遍历序列中，只会出现一或两次前一元素大于后一元素的情况。而且一次的情况可以视作是两次该结构出现在同一位置的特殊情况。这样规约后得到：对于序列中靠前的该结构，其前一元素是被交换的；对于序列中靠后的该结构，其后一元素是被交换的。这样就找到了两个交换了的元素。12345678910111213141516171819class Solution &#123;public: TreeNode *lst1, *targ1, *targ2; void dfs(TreeNode* root)&#123; if (root == NULL) return ; dfs(root-&gt;left); if (lst1 != NULL &amp;&amp; lst1-&gt;val &gt; root-&gt;val)&#123; if (targ1 == NULL) targ1 = lst1, targ2 = root; else targ2 = root; &#125; lst1 = root; dfs(root-&gt;right); &#125; void recoverTree(TreeNode* root) &#123; lst1 = NULL, targ1 = targ2 = NULL; dfs(root); swap(targ1-&gt;val, targ2-&gt;val); &#125;&#125;; 注：这里的代码并不是一开始交上去的代码，而是做了精简的版本。原版考虑了一个更加复杂的结构，但也是对的。 115一个挺水的计数DP，但是可以优化到不错的效果。可以层层优化。12345678910111213141516171819class Solution &#123;public: int numDistinct(string s, string t) &#123; int n = s.size(), m = t.size(); vector&lt;vector&lt;unsigned&gt; &gt; f(n + 1, vector&lt;unsigned&gt;(m + 1, 0)); for (int i = 0; i &lt;= n; ++i) f[i][0] = 1; for (int j = 0; j &lt; m; ++j)&#123; for (int i = 0; i &lt; n; ++i)&#123; if(s[i] == t[j])&#123; f[i + 1][j + 1] = f[i][j] + f[i][j + 1]; &#125;else&#123; f[i + 1][j + 1] = f[i][j + 1]; &#125; &#125; &#125; return f[n][m]; &#125;&#125;; 123对122的DP方程稍微做些修改即可。1234567891011121314151617181920class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if(n &lt;= 1) return 0; vector&lt;int&gt; f(n, 0); int mini = prices[0]; for (int i = 1; i &lt; n; ++i)&#123; f[i] = max(prices[i] - mini, f[i - 1]); mini = min(mini, prices[i]); &#125; int pst1 = -prices[0], ans = 0; for (int i = 1; i &lt; n; ++i)&#123; int tmp = prices[i] + pst1; ans = max(ans, tmp); pst1 = max(pst1, f[i - 1] - prices[i]); &#125; return ans; &#125;&#125;; 124简单的树形DP，考虑以当前节点为LCA的最大路径和，那么只需要求出左、右两个节点为根时对应的最大路径和相加即可。可以设计成下面的递归函数求解。12345678910111213141516class Solution &#123;public: int ans; int dfs(TreeNode *root)&#123; if(root == NULL) return -2147483648; int ll = max(0, dfs(root-&gt;left)); int rr = max(0, dfs(root-&gt;right)); ans = max(ans, root-&gt;val + ll + rr); return root-&gt;val + max(ll, rr); &#125; int maxPathSum(TreeNode* root) &#123; ans = -2147483648; dfs(root); return ans; &#125;&#125;; 128一开始想到的是万能的排序，后来想到这种依附关系用并查集很好维护，进而推想出可以不用并查集而是用 Hash Table 直接扫区间。所以就是 $O(n)$ 了。这里偷了懒，用的是自带的 unordered_map。123456789101112131415161718192021class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; mp; for (int i = 0; i &lt; nums.size(); ++i) mp[nums[i]] = i; int ans = 0; for (int i = 0; i &lt; nums.size(); ++i)&#123; if ( !mp.count( nums[i] ) ) continue; mp.erase( nums[i] ); int res = 1, tmp = nums[i]; while ( mp.count( tmp + 1 ) ) ++res, mp.erase( tmp + 1 ), ++tmp; tmp = nums[i]; while ( mp.count( tmp - 1 ) ) ++res, mp.erase( tmp - 1 ), --tmp; ans = max( ans, res ); &#125; return ans; &#125;&#125;; 132比较标准的一维 $O(n^2)$ DP，不知道有没有更好的方法。。。1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pos; vector&lt;int&gt; ans; int minCut(string s) &#123; int n = s.length(); pos = vector&lt;vector&lt;int&gt; &gt;(n, vector&lt;int&gt;()); ans = vector&lt;int&gt;(n, n); for (int i = 0; i &lt; n; ++i) for (int j = i, k = i; j &gt;= 0 &amp;&amp; k &lt; n &amp;&amp; s[j] == s[k]; --j, ++k) pos[k].push_back(j); for (int i = 0; i &lt; n - 1; ++i) for (int j = i, k = i + 1; j &gt;= 0 &amp;&amp; k &lt; n &amp;&amp; s[j] == s[k]; --j, ++k) pos[k].push_back(j); ans[0] = 0; for (int i = 1; i &lt; n; ++i) &#123; for (int j: pos[i])&#123; if (j == 0)&#123; ans[i] = 0; break; &#125;else ans[i] = min(ans[i], ans[j - 1] + 1); &#125; &#125; return ans[n - 1]; &#125;&#125;; 135一个比较水的递推。可以发现这个题只有在分数不断下降的时候比较难搞，我们就记录一下总共下降的长度和这个下降坡对应第一个人的糖果数目。在下降的时候，我们先认为每一个人都只分到 0 个糖，在整个下降序列结束的时候再结算。然后就是简单的数学问题：对于第一个人，考虑要不要增加他的糖果数，使得其糖果数至少等于下降序列的长度；对于其他人，他们的糖果数依次递减，最后递减到 1，所以很容易算出这一部分的糖果总数。最后统计答案即可。为了节省空间，我们只记录前一个人的糖果数，而不是把糖果数记录成为一个数组。 12345678910111213141516171819202122class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int ans = 1, n = ratings.size(), lst = 1; int len = 1, st = 1; for (int i = 1; i &lt; n; ++i)&#123; if (ratings[i] &gt; ratings[i - 1])&#123; ans += lst + 1, ++lst; ans += (len * (len - 1) &gt;&gt; 1) + max(len - st, 0); len = 1, st = lst; &#125;else if (ratings[i] == ratings[i - 1])&#123; ++ans, lst = 1; ans += (len * (len - 1) &gt;&gt; 1) + max(len - st, 0); len = 1, st = lst; &#125;else &#123; lst = 1, ++len; &#125; &#125; ans += (len * (len - 1) &gt;&gt; 1) + max(len - st, 0); return ans; &#125;&#125;; 140在 139 的基础上修改一下，记录路径即可。12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; ans; void dfs(int cur, string str, vector&lt;vector&lt;int&gt;&gt;&amp; e, vector&lt;string&gt;&amp; wordDict)&#123; if (!cur) &#123; str.pop_back(); ans.push_back(str); return ; &#125; for (int v: e[cur]) dfs(cur - wordDict[v].length(), wordDict[v] + " " + str, e, wordDict); &#125; vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int l = s.length(), n = wordDict.size(); vector&lt;vector&lt;int&gt;&gt; edges(l + 1, vector&lt;int&gt;()); edges[0].push_back(-1); for (int i = 1; i &lt;= l; ++i)&#123; for (int j = 0; j &lt; n; ++j)&#123; int l1 = wordDict[j].length(); if (i &gt;= l1 &amp;&amp; s.substr(i - l1, l1) == wordDict[j] &amp;&amp; !edges[i - l1].empty())&#123; edges[i].push_back(j); &#125; &#125; &#125; dfs(l, "", edges, wordDict); return ans; &#125;&#125;; 145这很难？123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: if root == None: return [] ans = [] def travell(curn): if curn.left != None: travell(curn.left) if curn.right != None: travell(curn.right) ans.append(curn.val) travell(root) return ans 不过要想到这个比较精巧的非递归方法，是挺难的。 149本来以为这个题目要用什么非常高深的方法，结果发现就是暴力 $O(N^2)$。。。用一个 map 记录一下就行了，要开 long double，因为有数据专门卡这个。不过看评论区发现更暴力的 $O(N^3)$ 好像更快，应该是因为用的是整数的叉积，同时没有用到什么数据结构。 123456789101112131415161718192021222324class Solution &#123;public: int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; unordered_map&lt;long double, int&gt; mp; int ans = 0; for (int i = 0; i &lt; points.size(); ++i)&#123; mp.clear(); int vect = 0, self = 1, maxi = 0; for (int j = i + 1; j &lt; points.size(); ++j)&#123; if (points[j][0] == points[i][0]) if (points[j][1] == points[i][1]) self++; else vect++; else&#123; long double k = (long double) (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]); if (!mp.count(k)) mp[k] = 1, maxi = max(maxi, 1); else ++mp[k], maxi = max(maxi, mp[k]); &#125; &#125; maxi = max(maxi, vect) + self; ans = max(ans, maxi); &#125; return ans; &#125;&#125;; 164邓公的计算几何里面讲到过这个题。大体思路就是按照元素个数分配相应个数的桶，然后把数据放进桶里，比较左边桶的最大值和右边桶的最小值之间的差值。12 174非常傻的一个解法（我写的）是二分答案。实际上根本没必要，只要从终点开始 DP 就行了。状态表示为从当前位置到终点需要的最小 HP。这可能也说明了一些问题：一些用二分可以做的题目，实际上可能倒推更好做。12345678910111213141516171819class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; if ( dungeon.empty() ) return 1; int n = dungeon.size(), m = dungeon[0].size(); for (int i = n - 1; i &gt;= 0; --i) for (int j = m - 1; j &gt;= 0; --j)&#123; if ( i == n - 1 &amp;&amp; j == m - 1 ) dungeon[i][j] = max( 0, -dungeon[i][j] ) + 1; else &#123; int mini = 2147483647; if ( i + 1 &lt; n ) mini = min( mini, dungeon[i + 1][j] ); if ( j + 1 &lt; m ) mini = min( mini, dungeon[i][j + 1] ); dungeon[i][j] = max( 1, mini - dungeon[i][j] ); &#125; &#125; return dungeon[0][0]; &#125;&#125;; 188对123再次修改，不断迭代求解，直到解的大小不再变化为止（因为$k$可以很大）。12345678910111213141516171819202122232425262728293031class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if(n &lt;= 1) return 0; vector&lt;vector&lt;int&gt; &gt; f(2, vector&lt;int&gt;(n, 0)); int mini = prices[0]; for (int i = 1; i &lt; n; ++i)&#123; f[1][i] = max(prices[i] - mini, f[1][i - 1]); mini = min(mini, prices[i]); &#125; int lstans = 0; for (int i = 2; i &lt;= k; ++i)&#123; int B = i &amp; 1, B_ = 1 - B; fill(f[B].begin(), f[B].end(), 0); int pst1 = -prices[0], curans = 0; for (int j = 1; j &lt; n; ++j)&#123; int tmp = prices[j] + pst1; f[B][j] = max(tmp, f[B][j - 1]); curans = max(tmp, f[B][j]); pst1 = max(pst1, f[B_][j - 1] - prices[j]); &#125; if(curans == lstans) return curans; lstans = curans; &#125; int ans = 0; for (int i = 0; i &lt; n; ++i) ans = max(ans, f[k &amp; 1][i]); return ans; &#125;&#125;; 212普通 DFS 加上一个 Trie 树。题目里给了这个提示。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;;class WordDictionary &#123;public: struct Node&#123; int al[26], isend; Node() &#123; memset(al, 0, sizeof(al)); isend = 0; &#125; &#125;; vector&lt;Node&gt; trie; int cnt; WordDictionary() &#123; trie.push_back(Node()), trie.push_back(Node()); cnt = 1; &#125; void addWord(string&amp; word, int iid) &#123; int rt = 1; for (char c: word)&#123; if(!trie[rt].al[c - 'a']) trie.push_back(Node()), trie[rt].al[c - 'a'] = ++cnt; rt = trie[rt].al[c - 'a']; &#125; trie[rt].isend = iid; &#125;&#125;;class Solution &#123;public: WordDictionary wc; int n, m; vector&lt;vector&lt;bool&gt; &gt; vis; vector&lt;bool&gt; stat; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, int rt)&#123; if (wc.trie[rt].isend &gt; 0) stat[wc.trie[rt].isend - 1] = true; for (int i = 0; i &lt; 4; ++i)&#123; int cx = x + dx[i], cy = y + dy[i]; if (cx &lt; 0 || cx &gt;= n || cy &lt; 0 || cy &gt;= m || vis[cx][cy]) continue; if (!wc.trie[rt].al[board[cx][cy] - 'a']) continue; int new_rt = wc.trie[rt].al[board[cx][cy] - 'a']; vis[cx][cy] = true; dfs(board, cx, cy, new_rt); vis[cx][cy] = false; &#125; &#125; vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; vector&lt;string&gt; ans; if (board.empty()) return ans; if (words.empty()) return ans; n = board.size(), m = board[0].size(); vis = vector&lt;vector&lt;bool&gt; &gt;(n, vector&lt;bool&gt;(m, false)); int wz = words.size(); stat = vector&lt;bool&gt;(wz, false); for (int i = 0; i &lt; wz; ++i) wc.addWord(words[i], i + 1); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j)&#123; if (!wc.trie[1].al[board[i][j] - 'a']) continue; int new_rt = wc.trie[1].al[board[i][j] - 'a']; vis[i][j] = true, dfs(board, i, j, new_rt), vis[i][j] = false; &#125; for (int i = 0; i &lt; wz; ++i) if (stat[i]) ans.push_back(words[i]); return ans; &#125;&#125;; 214一开始手搓了一个暴力，结果在最后一个点炸上天去了。于是果断上 manacher。其实要求的东西很简单，就是最长的回文前缀。123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void manacher(string&amp; s, vector&lt;int&gt;&amp; res)&#123; int n = s.length(); res[0] = 0; for (int i = 1; i &lt; (n &lt;&lt; 1) - 1; ++i) res[i] = -1; for (int i = 1, rmost = 0; i &lt; (n &lt;&lt; 1) - 1; ++i)&#123; int l = (i &gt;&gt; 1), r = i - l, rpos = ((rmost + 1) &gt;&gt; 1) + res[rmost] - 1; if ((rmost &lt;&lt; 1) &gt;= i) res[i] = min(rpos - r + 1, res[(rmost &lt;&lt; 1) - i]); while (l - res[i] - 1 &gt;= 0 &amp;&amp; r + res[i] + 1 &lt; n &amp;&amp; s[l - res[i] - 1] == s[r + res[i] + 1]) ++res[i]; if (r + res[i] - 1 &gt; rpos) rmost = i; &#125; &#125; string shortestPalindrome(string s) &#123; int n = s.length(), ans = 0; if (!n) return s; vector&lt;int&gt; res((n &lt;&lt; 1) - 1, 0); manacher(s, res); for (int i = 0; i &lt; (n &lt;&lt; 1) - 1; ++i)&#123; if (res[i] + (i &amp; 1) == ((i + 1) &gt;&gt; 1)) ans = max(ans, (res[i] &lt;&lt; 1) + (i &amp; 1) + 1); &#125; string sans = s; reverse(sans.begin(), sans.end()); for (int i = ans; i &lt; n; ++i) sans.push_back(s[i]); return sans; &#125;&#125;; 224简单表达式计算注意坑爹的21474836471234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int calculate(string s) &#123; s = "(" + s + ")"; stack&lt;int&gt; operand; stack&lt;char&gt; oprt; auto calc = [&amp;operand, &amp;oprt]() -&gt; void&#123; int r2 = operand.top(); operand.pop(); int r1 = operand.top(); operand.pop(); if(oprt.top() == '+') operand.push(r1 + r2); else operand.push(r1 - r2); oprt.pop(); &#125;; int n = s.size(); for (int i = 0, t = -1; i &lt; n; ++i)&#123; if(s[i] == ' ') continue; if(isdigit(s[i]))&#123; if(t &lt; 0) t = s[i] - '0'; else t = t * 10 + (s[i] - '0'); &#125;else&#123; if(s[i] == '(')&#123; oprt.push(s[i]); &#125;else&#123; if(t &gt;= 0) operand.push(t), t = -1; while(oprt.top() != '(') calc(); if(s[i] == ')') oprt.pop(); else oprt.push(s[i]); &#125; &#125; &#125; return operand.top(); &#125;&#125;; 295对顶堆1234567891011121314151617181920212223242526272829303132333435class MedianFinder &#123;public: /** initialize your data structure here. */ priority_queue&lt;int&gt; pq1; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq2; int n; MedianFinder() &#123; n = 0; &#125; void addNum(int num) &#123; if(n &amp; 1)&#123; pq1.push(num); pq2.push(pq1.top()); pq1.pop(); &#125;else&#123; if(pq1.empty() || pq1.top() &gt;= num) pq1.push(num); else&#123; pq2.push(num); pq1.push(pq2.top()); pq2.pop(); &#125; &#125; ++n; &#125; double findMedian() &#123; if(!n) return 0; if(n &amp; 1)&#123; return pq1.top(); &#125;else&#123; return (pq1.top() + pq2.top()) * 0.5; &#125; &#125;&#125;; 297比较简单的想法是把所有叶子节点表示出来，然后用前序遍历去记录。注意数据可能带符号。12345678910111213141516171819202122232425262728293031323334353637383940414243class Codec &#123;public: void dfs( TreeNode* root, string&amp; ans )&#123; if (root == NULL) &#123; ans.push_back(' '); ans.push_back('#'); return ; &#125; ans.push_back(' '); ans += to_string( root-&gt;val ); dfs( root-&gt;left, ans ); dfs( root-&gt;right, ans ); &#125; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string ans(""); dfs( root, ans ); return ans; &#125; pair&lt;TreeNode*, int&gt; dfs2( string&amp; data, int l )&#123; ++l; if ( data[l] == '#' ) return make_pair( ( TreeNode* ) NULL, l + 1 ); int x = 0, flag = 1; if ( data[l] == '-' ) flag = -1, ++l; while ( data[l] != ' ' ) x = x * 10 + data[l] - '0', ++l; x = x * flag; TreeNode* root = new TreeNode(x); pair&lt;TreeNode*, int&gt; res = dfs2 ( data, l ); root-&gt;left = res.first, l = res.second; res = dfs2 ( data, l ); root-&gt;right = res.first, l = res.second; return make_pair( root, l ); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; return dfs2( data, 0 ).first; &#125;&#125;; 312简单的区间DP，状态设成戳破两个区间端点之间的气球可以得到的最大的分数。1234567891011121314class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; nums.push_back(1); nums.insert(nums.begin(), 1); int n = nums.size(); vector&lt;vector&lt;int&gt; &gt; f(n, vector&lt;int&gt;(n, 0)); for (int i = 2; i &lt; n; ++i) for (int j = 0; j + i &lt; n; ++j) for (int k = j + 1; k &lt; j + i; ++k) f[j][j + i] = max(f[j][i + j], f[j][k] + f[k][j + i] + nums[k] * nums[i + j] * nums[j]); return f[0][n - 1]; &#125;&#125;; 327multiset维护前缀和1234567891011121314151617class Solution &#123;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; set&lt;long long&gt; st; st.insert(0); int n = nums.size(), ans = 0; long long ss = 0; for (int i = 0; i &lt; n; ++i)&#123; ss += 1ll * nums[i]; ans += distance(st.lower_bound(ss - upper), st.upper_bound(ss - lower)); st.insert(ss); &#125; //Si - Sj &gt;= lower -&gt; Sj &lt;= Si - lower //Si - Sj &lt;= upper -&gt; Sj &gt;= Si - upper return ans; &#125;&#125;; 329先对矩阵中的数排序，然后从小到大转移。或者记忆化搜索也可以。1234567891011121314151617181920212223242526class Solution &#123;public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; typedef pair&lt;int, pair&lt;int, int&gt; &gt; T; vector&lt;T&gt; vec; int n = matrix.size(); if(!n) return 0; int m = matrix[0].size(), ans = 0; vector&lt;vector&lt;int&gt; &gt; f(n, vector&lt;int&gt;(m, 1)); int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) vec.push_back(make_pair(matrix[i][j], make_pair(i, j))); sort(vec.begin(), vec.end()); for (T &amp;t: vec)&#123; int h = t.first, x = t.second.first, y = t.second.second; for (int i = 0; i &lt; 4; ++i)&#123; int cx = x + dx[i], cy = y + dy[i]; if(cx &lt; 0 || cy &lt; 0 || cx &gt;= n || cy &gt;= m) continue; if(matrix[cx][cy] &lt; h) f[x][y] = max(f[x][y], f[cx][cy] + 1); &#125; ans = max(ans, f[x][y]); &#125; return ans; &#125;&#125;; 336方法一暴力能过，惊了（对，卡过去的）12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123; int n = words.size(); vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; n; ++i)&#123; int len1 = words[i].length(); for (int j = 0; j &lt; n; ++j)&#123; if (i == j) continue; int len2 = words[j].length(); int len = len1 + len2; bool flag = true; for (int u = 0, v = len - 1; u &lt; v; ++u, --v)&#123; if ((u &lt; len1 ? words[i][u]: words[j][u - len1]) != (v &gt;= len1 ? words[j][v - len1]: words[i][v]))&#123; flag = false; break; &#125; &#125; if (flag) ans.push_back(vector&lt;int&gt;&#123;i, j&#125;); &#125; &#125; return ans; &#125;&#125;; 方法二这个的思想和添加最短前缀变成回文串相似，考虑把字符串截成某两部分，检查前/后一部分是不是回文串，是的话把另一部分对称过去即可。注意考虑空字符串。不得不说，c++ 里面操纵字符串确实比 python 麻烦挺多。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123; int n = words.size(); unordered_map&lt;string, int&gt; mp; for (int i = 0; i &lt; n; ++i) mp[words[i]] = i; auto check = [](string&amp; x, int i, int j)&#123; for (; i &lt; j; ++i, --j) if (x[i] != x[j]) return false; return true; &#125;; vector&lt;vector&lt;int&gt;&gt; ans; string emptystr(""); for (int i = 0; i &lt; n; ++i)&#123; int l = words[i].length(); if (!l) continue; if (check(words[i], 0, l - 1))&#123; if (mp.count(emptystr)) &#123; int id = mp[emptystr]; ans.push_back(vector&lt;int&gt;&#123;i, id&#125;), ans.push_back(vector&lt;int&gt;&#123;id, i&#125;); &#125; &#125;else &#123; string tmp = words[i]; reverse(tmp.begin(), tmp.end()); if (mp.count(tmp))&#123; int id = mp[tmp]; ans.push_back(vector&lt;int&gt;&#123;id, i&#125;); &#125; &#125; string tmpa = words[i]; reverse(tmpa.begin(), tmpa.end()); for (int j = 0; j &lt; l - 1; ++j)&#123; if (check(words[i], 0, j))&#123; string tmp = tmpa.substr(0, l - j - 1); if (mp.count(tmp)) ans.push_back(vector&lt;int&gt;&#123;mp[tmp], i&#125;); &#125; if (check(words[i], j + 1, l - 1))&#123; string tmp = tmpa.substr(l - j - 1); if (mp.count(tmp)) ans.push_back(vector&lt;int&gt;&#123;i, mp[tmp]&#125;); &#125; &#125; &#125; return ans; &#125;&#125;; 354经典的二位偏序问题。 方法一最水的方法就是先按点对的方式排一个序，然后做 $O(n^2)$ 的朴素 DP。1234567891011121314151617181920class Solution &#123;public: int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) &#123; int n = envelopes.size(), ans = 0; sort(envelopes.begin(), envelopes.end(), [](vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2)&#123; if (v1[0] == v2[0]) return v1[1] &lt; v2[1]; return v1[0] &lt; v2[0]; &#125;); vector&lt;int&gt; f(n, 1); for (int i = 1; i &lt; n; ++i)&#123; for (int j = 0; j &lt; i; ++j)&#123; if (envelopes[i][0] &gt; envelopes[j][0] &amp;&amp; envelopes[i][1] &gt; envelopes[j][1]) f[i] = max(f[i], f[j] + 1); &#125; &#125; for (int i = 0; i &lt; n; ++i) ans = max(ans, f[i]); return ans; &#125;&#125;; 方法二363还是这种二维化一维的题目，先枚举要选择的两列，然后对行扫描，用一个 set 保存前面遇到的前缀和，每一次查询当前和减掉 $K$ 的 lower_bound 就行了。1234567891011121314151617181920212223242526272829class Solution &#123;public: int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int n = matrix.size(); if (!n) return 0; int m = matrix[0].size(), ans = INT_MIN; if (!m) return 0; vector&lt;vector&lt;int&gt; &gt; sum(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) sum[i + 1][j + 1] = sum[i + 1][j] + matrix[i][j]; set&lt;int&gt; st; for (int i = 1; i &lt;= m; ++i)&#123; for (int j = i; j &lt;= m; ++j)&#123; st.clear(); st.insert(0); int ssm = 0; for (int t = 1; t &lt;= n; ++t)&#123; ssm += sum[t][j] - sum[t][i - 1]; auto iter = st.lower_bound(ssm - k); if (iter != st.end()) ans = max(ans, ssm - *iter); st.insert(ssm); &#125; &#125; &#125; return ans; &#125;&#125;; 483外部枚举该进制可能的位数，内部二分出该进制。1234567891011121314151617181920class Solution: def smallestGoodBase(self, n: str) -&gt; str: from math import floor def db(x, t): fz = x ** (t + 1) - 1 return fz // (x - 1) n = int(n) for t in range(64, 1, -1): ll, rr = 2, floor(n ** (1 / t)) while ll &lt; rr: mid = (ll + rr) &gt;&gt; 1 if db(mid, t) &lt; n: ll = mid + 1 else: rr = mid if db(ll, t) == n: return str(ll) return str(n - 1) 552划分情况，总共可划分出 7 种情况： 当前位不是 L，是第一个 L，是第二个 L，且之前没有出现过 A。 当前位不是 L，是第一个 L，是第二个 L，且之前出现过 A。 当前位是 A。（这种情况可以合并掉，所以总共可以只有 6 种，不过貌似用矩阵快速幂这种情况不能舍去？） 然后就是一个比较显而易见的线性递推。可以用矩阵快速幂优化。当然这里数据比较小，可以不用。1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int checkRecord(int n) &#123; int f0 = 1, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0, f6 = 0; for (int i = 0; i &lt; n; ++i)&#123; int ff0 = ((f0 + f1) % 1000000007 + f2) % 1000000007; int ff1 = f0; int ff2 = f1; int ff3 = ((f3 + f4) % 1000000007 + f5) % 1000000007; ff3 += f6; if (ff3 &gt;= 1000000007) ff3 -= 1000000007; int ff4 = (f3 + f6) % 1000000007; int ff5 = f4; int ff6 = ((f0 + f1) % 1000000007 + f2) % 1000000007; f0 = ff0, f1 = ff1, f2 = ff2, f3 = ff3, f4 = ff4, f5 = ff5, f6 = ff6; &#125; int ans = f0 + f1; if (ans &gt;= 1000000007) ans -= 1000000007; ans += f2; if (ans &gt;= 1000000007) ans -= 1000000007; ans += f3; if (ans &gt;= 1000000007) ans -= 1000000007; ans += f4; if (ans &gt;= 1000000007) ans -= 1000000007; ans += f5; if (ans &gt;= 1000000007) ans -= 1000000007; ans += f6; if (ans &gt;= 1000000007) ans -= 1000000007; return ans; &#125;&#125;; 632看起来就像是那种经常出现的堆的题目。用堆维护一个滑动窗口即可，时间复杂度 $O(N\log K)$。1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;int&gt; smallestRange(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; struct N&#123; int id; vector&lt;int&gt;::iterator iter; N ( int _id, vector&lt;int&gt;::iterator _v ): id( _id ), iter( _v ) &#123;&#125; &#125;; struct cmp&#123; bool operator() ( const N&amp; n1, const N&amp; n2 )&#123; return *(n1.iter) &gt; *(n2.iter); &#125; &#125;; priority_queue&lt;N, vector&lt;N&gt;, cmp&gt; pq; int n = nums.size(); int ansl = 2147483647, ansr = -2147483648; for (int i = 0; i &lt; n; ++i)&#123; if ( nums[i].empty() ) continue; pq.push( N( i, nums[i].begin() ) ); ansl = min( ansl, nums[i].front() ); ansr = max( ansr, nums[i].front() ); &#125; int curl = ansl, curr = ansr; for (; ansr &gt; ansl &amp;&amp; !pq.empty(); )&#123; N nn = pq.top(); pq.pop(); if ( nn.iter + 1 != nums[nn.id].end() )&#123; curl = ( pq.size() == n - 1 ) ? *pq.top().iter: curl; ++nn.iter; curl = min( curl, *nn.iter ), curr = max( curr, *nn.iter ); pq.push( nn ); &#125; if ( ansr - ansl &gt; curr - curl ) ansl = curl, ansr = curr; &#125; return vector&lt;int&gt; &#123; ansl, ansr &#125;; &#125;&#125;; 689其实就是把两个的情况再叠加一个上去。12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; sum(n + 1), f1(n + 1, 0), f2(n + 1, 0); int ss = 0, maxi = -1, ans = 0; for (int i = 0; i &lt; n; ++i) ss += nums[i], sum[i + 1] = ss; for (int i = 2 * k, lst = k; i &lt;= n; ++i)&#123; f1[i] = lst; if(sum[i - k + 1] - sum[i + 1 - k - k] &gt; sum[lst] - sum[lst - k]) lst = i - k + 1; &#125; for (int i = 3 * k, lst = k + k; i &lt;= n; ++i)&#123; f2[i] = lst; if(sum[f1[i + 1 - k]] - sum[f1[i + 1 - k] - k] + sum[i + 1 - k] - sum[i + 1 - k - k] &gt; sum[f1[lst]] - sum[f1[lst] - k] + sum[lst] - sum[lst - k]) lst = i - k + 1; if(sum[i] - sum[i - k] + sum[f2[i]] - sum[f2[i] - k] + sum[f1[f2[i]]] - sum[f1[f2[i]] - k] &gt; maxi) maxi = sum[i] - sum[i - k] + sum[f2[i]] - sum[f2[i] - k] + sum[f1[f2[i]]] - sum[f1[f2[i]] - k], ans = i; &#125; vector&lt;int&gt; rans; rans.push_back(f1[f2[ans]] - k); rans.push_back(f2[ans] - k); rans.push_back(ans - k); return rans; &#125;&#125;; 786如果常数足够小可能可以用堆卡过去。这里考虑二分，判定当前总共有多少个分数小于或等于 $mid$。如果刚好是 $K$ 个就作为答案返回最大的那个分数。在二分的时候可以发现对于每一个分母，第一个大于 $mid$ 的分子是递增的。可以利用这一点在 $O(n)$ 时间内完成一次二分的判定。所以总的时间复杂度是 $O(nk)$，$k$ 是二分的次数。12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; kthSmallestPrimeFraction(vector&lt;int&gt;&amp; A, int K) &#123; double l = 0.0, r = 1.0; int n = A.size(); for (; ; )&#123; double mid = (l + r) * 0.5; int cnt = 0, p = 0, q = 1; for (int i = 1, j = 0; i &lt; n; ++i)&#123; while (j &lt; n &amp;&amp; A[j] &lt;= A[i] * mid) ++j; cnt += j; if (j &gt; 0 &amp;&amp; p * A[i] &lt; q * A[j - 1]) p = A[j - 1], q = A[i]; &#125; if (cnt == K) return vector&lt;int&gt;&#123;p, q&#125;; if (cnt &lt; K) l = mid; else r = mid; &#125; return vector&lt;int&gt;(); &#125;&#125;; 793二分1234567891011121314151617181920212223242526272829class Solution &#123;public: int preimageSizeFZF(int K) &#123; if(K == 0) return 5; typedef long long ll; auto calc = [](ll x) -&gt; int&#123; int res = 0; ll cur = 5; while(x &gt;= cur) res += x / cur, cur *= 5ll; return res; &#125;; ll l1 = 0, r1 = K * 5ll; while(l1 &lt; r1)&#123; ll mid = (l1 + r1) &gt;&gt; 1; if(calc(mid) &lt; K) l1 = mid + 1; else r1 = mid; &#125; ll l2 = 0, r2 = (K + 1) * 5ll; while(l2 &lt; r2)&#123; ll mid = (l2 + r2) &gt;&gt; 1; if(calc(mid) &lt;= K) l2 = mid + 1; else r2 = mid; &#125; return r2 - r1; &#125;&#125;; 805方法一DP123456789101112131415161718192021222324class Solution &#123;public: bool splitArraySameAverage(vector&lt;int&gt;&amp; A) &#123; int n = A.size(), sum = 0; if(n &lt;= 1) return false; for (int i: A) sum += i; vector&lt;vector&lt;bool&gt; &gt; f((n &gt;&gt; 1) + 1, vector&lt;bool&gt;(1 + (n &gt;&gt; 1) * sum / n, 0)); f[0][0] = true; for (int i = 0; i &lt; n; ++i)&#123; for (int j = (n &gt;&gt; 1); j &gt;= 1; --j) for (int k = (n &gt;&gt; 1) * sum / n; k &gt;= A[i]; --k)&#123; if(f[j - 1][k - A[i]]) f[j][k] = true; &#125; &#125; for (int i = (n &gt;&gt; 1); i &gt;= 1; --i)&#123; if(i * sum % n) continue; int targ = i * sum / n; if(f[i][targ]) return true; &#125; return false; &#125;&#125;; 方法二暴搜（好像非常快？）12 810这种博弈论的神奇题目一般都不能大力递推。。。可以发现，一个平凡的结论是：只要开局异或和是 0，那么先手必胜。然后有一个并不是很平凡的结论：除了这种情况之外，黑板在游戏结束的时候都会被擦干净。（等待更新）12345678class Solution &#123;public: bool xorGame(vector&lt;int&gt;&amp; nums) &#123; int a = 0; for (int i: nums) a ^= i; return (!a) || (nums.size() % 2 == 0); &#125;&#125;; 827这题为什么是 Hard？枚举所有为 0 的点，然后看上下左右是否连接着岛和岛的大小。不断更新答案即可。注意同一个岛不要重复统计。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;; int n = grid.size(); if(!n) return 0; int m = grid[0].size(), tot_island = 0; vector&lt;pair&lt;int, int&gt; &gt; q; vector&lt;int&gt; siz; auto v = [&amp;grid, &amp;q, dx, dy, n, m](int x, int y)&#123; int hd = q.size(), tl = hd; q.push_back(make_pair(x, y)), ++tl; grid[x][y] = -1; while(tl &gt; hd)&#123; x = q[hd].first, y = q[hd].second, ++hd; for (int i = 0; i &lt; 4; ++i)&#123; int cx = x + dx[i], cy = y + dy[i]; if(cx &lt; 0 || cy &lt; 0 || cx &gt;= n || cy &gt;= m) continue; if(grid[cx][cy] &lt; 0 || grid[cx][cy] == 0) continue; grid[cx][cy] = -1; q.push_back(make_pair(cx, cy)), ++tl; &#125; &#125; &#125;; int ans = 0; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) if(grid[i][j] == 1)&#123; int lst = q.size(); v(i, j), ++tot_island; for (int k = lst; k &lt; q.size(); ++k) grid[q[k].first][q[k].second] = -tot_island; siz.push_back(q.size() - lst), ans = max(ans, siz.back()); &#125; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) if(grid[i][j] == 0)&#123; int tot = 1; for (int k = 0; k &lt; 4; ++k)&#123; int cx = i + dx[k], cy = j + dy[k]; if(cx &lt; 0 || cy &lt; 0 || cx &gt;= n || cy &gt;= m || grid[cx][cy] == 0) continue; if (siz[-grid[cx][cy] - 1] &lt; 0) continue; tot += siz[-grid[cx][cy] - 1], siz[-grid[cx][cy] - 1] = -siz[-grid[cx][cy] - 1]; &#125; ans = max(tot, ans); for (int k = 0; k &lt; 4; ++k)&#123; int cx = i + dx[k], cy = j + dy[k]; if(cx &lt; 0 || cy &lt; 0 || cx &gt;= n || cy &gt;= m || grid[cx][cy] == 0) continue; if (siz[-grid[cx][cy] - 1] &gt; 0) continue; siz[-grid[cx][cy] - 1] = -siz[-grid[cx][cy] - 1]; &#125; &#125; return ans; &#125;&#125;; 854暴搜？1234567891011121314151617181920212223242526272829class Solution &#123;public: int n, ans; void dfs(string&amp; A, string&amp; B, int st, int cur)&#123; if(cur == n)&#123; ans = min(ans, st); return ; &#125; while(cur &lt; n &amp;&amp; A[cur] == B[cur]) ++cur; if(cur == n)&#123; ans = min(ans, st); return ; &#125; for (int i = cur + 1; i &lt; n &amp;&amp; st &lt; ans - 1; ++i)&#123; if(A[i] == B[cur])&#123; swap(A[i], A[cur]), dfs(A, B, st + 1, cur + 1), swap(A[i], A[cur]); &#125; &#125; &#125; int kSimilarity(string A, string B) &#123; n = A.length(); ans = n; dfs(A, B, 0, 0); return ans; &#125;&#125;; 862感觉好像没有做过这种题。。。 878简单数论题123456789101112131415161718192021class Solution &#123;public: int gcd(int a, int b)&#123; return (!b) ? a: gcd(b, a % b); &#125; int nthMagicalNumber(int N, int A, int B) &#123; int lcm = A * B / gcd(A, B); int r = lcm / A + lcm / B - 1; int ans = 1ll * (N / r) * lcm % 1000000007; N %= r; if(N)&#123; int j = A, k = B, res; for (int i = 0; i &lt; N; ++i)&#123; if(j &lt;= k) res = j, j += A; else res = k, k += B; &#125; ans = (ans + res) % 1000000007; &#125; return ans; &#125;&#125;; 895按照频率维护栈即可，按栈里保存的元素顺序pop相应的结果12345678910111213141516171819202122232425class FreqStack: def __init__(self): self.freq = &#123;&#125; self.maxi = 0 self.stacks = &#123;&#125; def push(self, x: int) -&gt; None: if not x in self.freq: self.freq[x] = 1 else: self.freq[x] += 1 f = self.freq[x] if f &gt; self.maxi: self.maxi = f if not self.maxi in self.stacks: self.stacks[self.maxi] = [] self.stacks[f].append(x) def pop(self) -&gt; int: x = self.stacks[self.maxi].pop() self.freq[x] -= 1 if not self.stacks[self.maxi]: self.maxi -= 1 return x 982小暴力12345678910111213141516171819class Solution &#123;public: int countTriplets(vector&lt;int&gt;&amp; A) &#123; int n = A.size(), maxi = 1, ans = 0; vector&lt;int&gt; cnt(65536, 0); for (int i = 0; i &lt; n; ++i)&#123; for (int j = 0; j &lt; n; ++j) cnt[A[i] &amp; A[j]]++; while(maxi &lt;= A[i]) maxi &lt;&lt;= 1; &#125; for (int i = 0; i &lt; n; ++i)&#123; for (int j = 0; j &lt; maxi; ++j)&#123; if(A[i] &amp; j) continue; ans += cnt[j]; &#125; &#125; return ans; &#125;&#125;; 995写了一个十分睿智的树状数组。。。其实根本不需要，只要记录前缀和就行了。123456789101112131415161718192021class Solution &#123;public: int minKBitFlips(vector&lt;int&gt;&amp; A, int K) &#123; int n = A.size(), ans = 0; vector&lt;int&gt; ss(n + 1, 0); for (int i = 0; i &lt;= n - K; ++i)&#123; int res = (ss[i] - ss[max(i - K + 1, 0)] + A[i]) % 2; if(!res)&#123; ans++; ss[i + 1]++; &#125; ss[i + 1] += ss[i]; &#125; for (int i = n - K + 1; i &lt; n; ++i)&#123; int res = (ss[i] - ss[max(i - K + 1, 0)] + A[i]) % 2; if(!res) return -1; ss[i + 1] = ss[i]; &#125; return ans; &#125;&#125;; 996小暴搜，先记录所有可以结成的对，然后搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;bool&gt; &gt; f; int ans; void dfs(int used, int cur, int lst, vector&lt;int&gt;&amp; A)&#123; int n = A.size(); if(cur == n)&#123; ans++; return ; &#125; for (int i = 0; i &lt; n; )&#123; int j = i; while(j &lt; n &amp;&amp; A[i] == A[j]) ++j; while(i &lt; j &amp;&amp; ((1 &lt;&lt; i) &amp; used)) ++i; if(i == j) continue; if(!f[lst][i])&#123; i = j; continue; &#125; dfs(used | (1 &lt;&lt; i), cur + 1, i, A); i = j; &#125; &#125; int numSquarefulPerms(vector&lt;int&gt;&amp; A) &#123; sort(A.begin(), A.end()); int n = A.size(); f = vector&lt;vector&lt;bool&gt; &gt;(n, vector&lt;bool&gt;(n, 0)); auto judge = [](int x)&#123; int sqt = (int)floor(sqrt(x) + 0.5); if(sqt * sqt &gt; x) sqt--; return sqt * sqt == x; &#125;; for (int i = 0; i &lt; n; ++i) for (int j = i + 1; j &lt; n; ++j)&#123; if(judge(A[i] + A[j])) f[i][j] = f[j][i] = true; &#125; ans = 0; for (int i = 0; i &lt; n; )&#123; int j = i; while(j &lt; n &amp;&amp; A[i] == A[j]) ++j; dfs(1 &lt;&lt; i, 1, i, A); i = j; &#125; return ans; &#125;&#125;; 1000类似于原版的石子归并，其实就是原来的两部分合并成一部分成了 K 部分合并成一部分。只需要递归的做就行了。时间复杂度好像是 $O(n^3k)$？1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; f; vector&lt;int&gt; sum; int KK; void dfs(int k, int l, int r, int acc, int&amp; res)&#123; if (k == 1)&#123; acc += sum[r + 1] - sum[l] + f[l][r]; res = min(res, acc); return ; &#125; for (int t = 0; t + k - 1 &lt;= r - l; t += (KK - 1)) dfs(k - 1, l + t + 1, r, acc + sum[l + t + 1] - sum[l] + f[l][l + t], res); &#125; int mergeStones(vector&lt;int&gt;&amp; stones, int K) &#123; int n = stones.size(); if((n - 1) % (K - 1)) return -1; f = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0x3f3f3f3f)); sum = vector&lt;int&gt;(n + 1, 0); KK = K; for (int i = 0; i &lt; n; ++i) sum[i + 1] = sum[i] + stones[i], f[i][i] = 0; for (int i = K - 1; i &lt; n; i += K - 1) for (int j = 0; j + i &lt; n; ++j) dfs(K, j, j + i, 0, f[j][j + i]); return f[0][n - 1]; &#125;&#125;; 1074一般这样的问题都是考虑降维打击。也就是通过枚举某一维，将二维问题变换到一维上去解决。这个题目也是，先尝试枚举矩形的上下两条边，然后可以用矩阵前缀和在常数时间内算出两条边之间的和。这样就变成了一维意义上的找和为目标值的问题。时间复杂度 $O(n^3)$（设 $n$ 和 $m$ 同阶）。12345678910111213141516171819202122232425262728class Solution &#123;public: int numSubmatrixSumTarget(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; sum(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) sum[i + 1][j + 1] = sum[i][j + 1] + matrix[i][j]; unordered_map&lt;int, int&gt; mp; int ans = 0; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = i; j &lt;= n; ++j)&#123; mp.clear(); mp[0] = 1; int ssm = 0; for (int k = 1; k &lt;= m; ++k)&#123; ssm += sum[j][k] - sum[i - 1][k]; if (mp.count(ssm - target)) ans += mp[ssm - target]; if (mp.count(ssm)) ++mp[ssm]; else mp[ssm] = 1; &#125; &#125; &#125; return ans; &#125;&#125;; 1106比较简单的一个递归求表达式的值的题目。难度感觉没有 Hard 那种程度，最多是 Normal 把。。。1234567891011121314151617181920212223242526272829class Solution &#123;public: int n, cur; bool calc(string&amp; expr)&#123; if (isalpha(expr[cur])) return (expr[cur] == 't' ? true: false); if (expr[cur] == '!') &#123; cur += 2; bool res = !calc(expr); ++cur; return res; &#125; bool flag = (expr[cur] == '&amp;' ? true: false), res = flag; for (; ; )&#123; cur += 2; if (flag) res &amp;= calc(expr); else res |= calc(expr); if (expr[cur + 1] == ')') break; &#125; ++cur; return res; &#125; bool parseBoolExpr(string expression) &#123; n = expression.length(), cur = 0; return calc(expression); &#125;&#125;; 1147直觉上可以贪心，实际上就是贪心。只要能切割就切割。（具体的证明等待补充）123456789class Solution: def longestDecomposition(self, text: str) -&gt; int: if text == "": return 0 len1 = len(text) // 2 for i in range(1, len1 + 1): if text[0: i] == text[-i: ]: return self.longestDecomposition(text[i: -i]) + 2 return 1 1153很难让人在有限的样例下把握关键的题目。（比赛时我 WA 了 5 次，全靠 WA 出来的样例找出规律）首先基本的，把每一个字符的映射找出来。然后是关键，答案是 true 的充要条件是下面两个的逻辑或： 存在某个字符，它没有出现在 str1 中。这表明了某些字符可以将其作为中转站，从而变化成为别的字符。 不存在某个环（自环不算），使得只有通过环上面的点才能进入到该环内。也就是说，没有某个入度为 0 的点能到达该环。 第二个条件有些奇怪，可以这么想：如果第一个条件成立，那么即使存在这样的环也可以通过某个空余字符将环拆解。（考虑 str1=”ab”, str2=”ba”）第一个条件不成立，而第二个条件也不成立的话，那么对于这样的环，其上面的字符必须沿着某一方向逐步映射，而这样必然会丢失起始的字符。如果第二个条件成立，第一个条件不成立也好办。这一步可以试着画个图理解一下。12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool canConvert(string str1, string str2) &#123; int l1 = str1.length(), l2 = str2.length(); vector&lt;int&gt; mp(26, -1); for (int i = 0; i &lt; l1; )&#123; int j = i, j2 = i; while (j &lt; l1 &amp;&amp; str1[i] == str1[j]) ++j; while (j2 &lt; l2 &amp;&amp; str2[i] == str2[j2]) ++j2; if (j2 &lt; j) return false; if (mp[str1[i] - 'a'] &lt; 0) mp[str1[i] - 'a'] = str2[i] - 'a'; else &#123; if (mp[str1[i] - 'a'] != str2[i] - 'a') return false; &#125; i = j; &#125; int occ = 0, cnt = 26; int deg[26] = &#123;0&#125;; bool vis[26] = &#123;0&#125;; for (int i = 0; i &lt; 26; ++i)&#123; if (mp[i] &lt; 0) ++occ; else if (mp[i] == i) mp[i] = -1; else ++deg[mp[i]]; &#125; for (int i = 0; i &lt; 26; ++i)&#123; if (deg[i]) continue; int tp = i; --cnt, vis[tp] = true; while (mp[tp] &gt;= 0)&#123;// 沿着环走 if (vis[mp[tp]]) break; --cnt, vis[mp[tp]] = true, tp = mp[tp]; &#125; &#125; return occ || cnt == 0; &#125;&#125;; 1157python 暴力居然卡了过去。。。这可能是一个失误，因为比赛的时候是小数据（最多 500 次询问），而在正式题目中变成了 10000。 其实这道题就是区间众数，这个问题有很多种解法，下面给出一些解法。 1163后缀数组裸题，找最大后缀。1234567891011121314151617181920212223242526272829303132333435char r[100005];int sa[100005], wa[100005], wb[100005], wv[100005], cnt[100005] = &#123;0&#125;;int cmp(int *r, int a, int b, int l)&#123; return r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];&#125;void build_sa(char *r, int *sa, int n, int m)&#123; int i, j, p, *x = wa, *y = wb; for(i = 0; i &lt; m; ++i) cnt[i]=0; for(i = 0; i &lt; n; ++i) cnt[x[i] = r[i]]++; for(i = 1; i &lt; m; ++i) cnt[i] += cnt[i - 1]; for(i = n - 1; i &gt;= 0; --i) sa[--cnt[x[i]]] = i; for(j = 1, p = 1; p &lt; n; j &lt;&lt;= 1, m = p)&#123; for(p = 0, i = n - j; i &lt; n; ++i) y[p++] = i; for(i = 0; i &lt; n; ++i) if(sa[i] - j &gt;= 0) y[p++] = sa[i] - j; for(i = 0; i &lt; n; ++i) wv[i] = x[y[i]]; for(i = 0; i &lt; m; ++i) cnt[i] = 0; for(i = 0; i &lt; n; ++i) cnt[wv[i]]++; for(i = 1; i &lt; m; ++i) cnt[i] += cnt[i - 1]; for(i = n - 1; i &gt;= 0; --i) sa[--cnt[wv[i]]] = y[i]; swap(x, y); for(p = 1, x[sa[0]] = 0, i = 1; i &lt; n; ++i) x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1: p++; &#125;&#125;class Solution &#123;public: string lastSubstring(string s) &#123; int l = s.length(); for (int i = 0; i &lt; l; ++i) r[i] = s[i] - 'a' + 1; r[l] = 0; build_sa(r, sa, l + 1, 26 + 1); return s.substr(sa[l]); &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UVa836 Largest Submatrix]]></title>
    <url>%2F2019%2F04%2F23%2Fuva836%2F</url>
    <content type="text"><![CDATA[题目大意：给定01矩阵，求全1矩阵的最大面积。 题解这个题类似于最大柱状图面积的升级版，只需要枚举每一行为底，从之前一行的每一条柱的高度推出这一行的高度，然后用单调栈计算即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[50][50];int n, st[50], w[50], top, h[50] = &#123;0&#125;;void init()&#123; scanf("%s", s[0]); n = strlen(s[0]); for (int i = 1; i &lt; n; ++i) scanf("%s", s[i]);&#125;void solve()&#123; int ans = 0; for (int i = 0, cur = 0; i &lt; n; ++i)&#123; if(s[0][i] == '1') h[i] = 1, cur++, ans = max(ans, cur); else cur = 0, h[i] = 0; &#125; for (int i = 1; i &lt; n; ++i)&#123; for (int j = 0; j &lt; n; ++j)&#123; if(s[i][j] == '1') h[j]++; else h[j] = 0; &#125; top = 0; for (int j = 0; j &lt;= n; ++j)&#123; int curw = 0; while(top &amp;&amp; st[top] &gt;= h[j]) curw += w[top], ans = max(ans, curw * st[top]), top--; w[++top] = curw + 1, st[top] = h[j]; &#125; &#125; printf("%d\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); if(T) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 2 题解]]></title>
    <url>%2F2019%2F04%2F07%2Fcontest-cf1119%2F</url>
    <content type="text"><![CDATA[难题不会写，简单题写的慢绝了 A题目大意：数轴上有$n$个点，每一个点间距$1$，每一个点有一个颜色，求选出距离最远，颜色不同的两个点，输出此距离。 只要考虑第一个点的颜色和其他颜色，其他颜色最远延伸到第一个点，和第一个点颜色相同的点延伸到最左端第一个颜色和第一个点颜色不同的点。123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, col[300005];void init()&#123; n = read(); for (int i = 1; i &lt;= n; ++i)&#123; col[i] = read(); &#125;&#125;void solve()&#123; int lst = 2; while(lst &lt;= n &amp;&amp; col[lst] == col[1]) lst++; int ans = 0; for (int i = 1; i &lt;= n; ++i)&#123; if(col[i] == col[1]) ans = max(ans, i - lst); else ans = max(ans, i - 1); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; B题目大意：给一个冰箱，高为$h$，宽度为$2$，有$n$瓶牛奶，每瓶牛奶有一个高度，宽度都是1。冰箱可以在任意非负整数高度安放隔板，牛奶必须放在隔板上。问最多可以按编号放多少牛奶进去。 可以看出这个问题的答案是确定的，并且有单调性，因此可以二分。设二分的答案是$k$，对前$k$瓶牛奶的高度排序，然后跑一个DP即可（这里可以用DP，但可以发现实际上答案就是降序排序后，奇数位置牛奶的高度之和）。下面用的是不带二分的做法，时间复杂度$O(n^2\log n)$。用二分的话时间复杂度是$O(n\log ^2 n)$。实际上用平衡树应该可以做成$O(n\log n)$。（考虑奇偶转化）123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, h, hh[3005], f[3005], hhh[3005];void init()&#123; n = read(), h = read(); for (int i = 1; i &lt;= n; ++i) hh[i] = read();&#125;void solve()&#123; int ans = 0; for (ans = 1; ans &lt;= n; ++ans)&#123; for (int i = 1; i &lt;= ans; ++i) hhh[i] = hh[i]; sort(hhh + 1, hhh + ans + 1); f[0] = 0, f[1] = hhh[1]; for (int i = 2; i &lt;= ans; ++i)&#123; int mm = max(hhh[i], hhh[i - 1]); f[i] = min(f[i - 1] + hhh[i], f[i - 2] + mm); &#125; if(f[ans] &gt; h) break; &#125; ans--; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; C题目大意：对01矩阵定义一个操作：选定一个大小至少是$2\times 2$的子矩阵，对矩阵的4个角做异或操作。给定两个矩阵$A$和$B$，问$A$可否通过有限次这样的操作变成$B$。 设$C=A \text{ xor } B$，观察（这听起来实在玄学）发现$A$可通过操作变成$B$的充要条件是$C$的每一行、每一列的含$1$数目都是偶数。然后就很简单了。这个充要条件主要是观察出来的，但其实是可以证明的，可以通过构造进行证明。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, aa[505][505], bb[505][505];void init()&#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) aa[i][j] = read(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) bb[i][j] = read(), bb[i][j] ^= aa[i][j];&#125;void solve()&#123; int flag = 1; for (int i = 1; i &lt;= n; ++i)&#123; int cnt = 0; for (int j = 1; j &lt;= m; ++j) cnt ^= bb[i][j]; if(cnt) flag = 0; &#125; for (int i = 1; i &lt;= m; ++i)&#123; int cnt = 0; for (int j = 1; j &lt;= n; ++j) cnt ^= bb[j][i]; if(cnt) flag = 0; &#125; printf("%s\n", flag ? "Yes" : "No"); &#125;int main()&#123; init(); solve(); return 0;&#125; D题目大意：给定一个$n\times (10^{18}+1)$矩阵$A$，A_{ij}=s_i+j，s_i是给定的数列。有$q$个询问，每次询问两个数$l, r$，求矩阵第$l$列到第$r$列中不同数的个数。 行之间的顺序和答案无关。先对s_i升序排序，然后发现：对于一个询问$l, r$，第$i$行和第$i+1$行相重复的数的个数是\max \lbrace s_i-s_{i+1}+r-l+1, 0 \rbrace。答案就是$n(r-l+1)-tot$，$tot$就是每一行这些重复数的个数之和。然而这个$\max$不好搞。我们用离线做法，把$r-l+1$排序，然后依次处理就行了。时间复杂度$O(n\log n + q\log q)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;ll s[100005], sum[100005];ll gap[100005];pair&lt;ll, int&gt; pp[100005];ll ans[100005] = &#123;0&#125;;void init()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) scanf("%I64d", &amp;s[i]); sort(s + 1, s + n + 1);&#125;void solve()&#123; for (int i = 1; i &lt; n; ++i) gap[i] = s[i] - s[i + 1]; sort(gap + 1, gap + n); sum[0] = 0; for (int i = 1; i &lt; n; ++i) sum[i] = sum[i - 1] + gap[i]; int q = read(); for (int i = 1; i &lt;= q; ++i)&#123; ll l, r; scanf("%I64d%I64d", &amp;l, &amp;r); pp[i].first = r - l + 1, pp[i].second = i; &#125; sort(pp + 1, pp + q + 1); int cur = n - 1; for (int i = 1; i &lt;= q; ++i)&#123; ll ggap = pp[i].first; while(cur &gt; 0 &amp;&amp; ggap + gap[cur] &gt;= 0ll) cur--; ans[pp[i].second] = 1ll * n * ggap - (sum[n - 1] - sum[cur]); ans[pp[i].second] -= 1ll * (n - 1 - cur) * ggap; &#125; for (int i = 1; i &lt;= q; ++i) printf("%I64d ", ans[i]);&#125;int main()&#123; init(); solve(); return 0;&#125; E题目大意：有一堆木棒，长度分别为$2^1, 2^2, \cdots, 2^n$。给出每一种长度的木棒的个数a_i，求用这些木棒最多可以拼出多少个三角形。 这题应该是贪心，但我好像是用DP的手法把答案弄了出来。（？）首先要发现的是：只有用两根同样长的木棒和一根不长于它们的木棒才能拼成三角形。设$f(i)$为到第$i$种木棒为止，总共可以拼出的三角形的最大数目。设用$2k$根该长度木棒去和长度比$2^i$小的，没有拼成三角形的木棒拼三角形，这样可以拼出$k$个；那么剩下a_i-2k根这种长度的木棒自行构成等边三角形。答案就是f(i)=\frac{a_i + k}{3}。所以$k$要尽量大。这样每一个长度过一遍就是答案。1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[300005];ll sum[300005] = &#123;0&#125;;void init()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(), sum[i] = sum[i - 1] + 1ll * a[i];&#125;void solve()&#123; ll ans = 0, ssum = 0; for (int i = 1; i &lt;= n; ++i)&#123; ll half = min((1ll * a[i]) &gt;&gt; 1, ssum); ans += half + (a[i] - half - half) / 3; ssum = sum[i] - ans * 3ll; &#125; printf("%I64d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125; F题目大意：给定一棵$n$个点的带权树，对于每一个$x\in [0, n-1]$，求出需要移除的边的最小权值和，使得整棵树没有度超过$x$的点。 对于一个固定的$x$，容易通过树形DP求出答案。我们可以把问题转换成为保留最大权的问题。设$f(i, 0)$为对以$i$为根的子树，使其度$\le x$的最大权值和，$f(i, 1)$为对以$i$为根的子树，使其度$\le x -1$的最大权值和。这样容易在$O(n\log n)$的时间内求出答案，因为只要先把所有子节点的$f(j, 0)$加上，然后按照$f(j, 1)+w-f(j, 0)$值排序，选取其中最大的$x$（或者$x-1$，根据当前要更新$f(i, 0)$还$f(i, 1)$而定）项就可以拼出当前节点的答案（$w$是连接这个点和子节点的边权）。这样实际上对于所有度数小于等于$x$的点的$f$是没什么用的，因为在这种情况下必然会选满。所以在具体操作时，处理到$x$时我们令$x$从$0$开始递增，每次对所有度数大于$x$的点跑一次DP。然后需要注意到 \sum_{i=0}^{n-1} \sum_{j=1}^{n} [\text{degree}_i > i]=\sum_{i =1}^{n} \text{degree}_i = 2(n-1)对这个式子的理解可以从看每一个点对左边式子的贡献，一个度是$x$的点会被计算$x$次，因而导出右式。每一个点用一个平衡树维护，所以总复杂度还是$O(n\log n)$。12 G题目大意：你有$n$个士兵，有$m$组敌人，每一组敌人有一个血量。你要把兵分成$m$组，可以有没有人的组。每一回合都可以令每一组兵攻击一组敌人，敌人掉血量为这组兵的人数，一组敌人血量为0或负数时这组敌人阵亡。求怎么安排兵可以使得所有敌人阵亡的回合数最少。 显然答案的下界是总血量除以$n$（向上取整）。所以就需要看怎么分配可以达到这个下界。这里有一个神奇的构造方法：先令所有人攻击第一组敌人，直到敌人的血量小于$n$，为k_1。那么令某一些组的兵的人数为k_1。再令所有人攻击第二组敌人，直到敌人的血量小于$n$，为k_2。那么令某一些组的兵的人数为k_2。以此类推。可以发现k_i=\sum_{j=1}^i \tet{hp}_j \mod n。对最后一组就并不限定某一组兵的人数，因为我们假设所有兵一起对最后一组兵进行攻击。这样就可以达成效果（虽然不知道这是为什么）。可能是因为这么做可以保证每一次把一组敌人击杀的时候都不会导致兵力的浪费？然后分配每一组兵的人数。对k_i排序，利用差分就可以做到使前$i$组兵的总兵力为k_i。然后就是模拟。12]]></content>
  </entry>
  <entry>
    <title><![CDATA[uva11971]]></title>
    <url>%2F2019%2F03%2F23%2Fuva11971%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[POJ1742 Coins]]></title>
    <url>%2F2019%2F03%2F23%2Fpoj1742%2F</url>
    <content type="text"><![CDATA[题目大意：给定$N$种硬币及其面值$a$和$c$，给定$M$，求$1~M$中有多少种不同的面值可以被这些硬币表示出。 题解可以用基本的多重背包方法解决。提供另外一种书上看到的做法：用一个数组表示为了达到某个状态需要的该种硬币的个数，然后利用该数组进行转移，这样就可以不用单调队列而把复杂度降到$O(nm)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[105], c[105], used[100005];bool f[100005];void init()&#123; for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) c[i] = read(); memset(f, 0, sizeof(f));&#125;void solve()&#123; f[0] = true; for (int i = 1; i &lt;= n; ++i)&#123; memset(used, 0, sizeof(int) * (m + 1)); for (int j = a[i]; j &lt;= m; ++j)&#123; if(!f[j] &amp;&amp; f[j - a[i]] &amp;&amp; used[j - a[i]] + 1 &lt;= c[i]) used[j] = used[j - a[i]] + 1, f[j] = true; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= m; ++i) if(f[i]) ans++; printf("%d\n", ans);&#125;int main()&#123; while(n = read(), m = read(), n)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1015 Jury Compromise]]></title>
    <url>%2F2019%2F03%2F23%2Fpoj1015%2F</url>
    <content type="text"><![CDATA[题目链接 题解该题不难，但是很坑，如果单纯按照二维背包做容易出现最优解重复的问题。所以要完整的记录路径。其他的就是基本的背包了，把一维体积设定为两和之差即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[205], b[205];int f[25][1005] = &#123;0&#125;, pos[25][1005], aans[25];int sel[25][1005][25] = &#123;0&#125;;void init()&#123; for(int i = 1; i &lt;= n; ++i) a[i] = read(), b[i] = read(); memset(f, 0xc0, sizeof(f)); memset(pos, 0, sizeof(pos)); memset(sel, 0, sizeof(sel));&#125;void solve()&#123; f[0][500] = 0; for(int i = n; i &gt;= 1; --i)&#123; for(int j = m; j &gt;= 1; --j)&#123; int dif = a[i] - b[i]; int lim = min(0, dif) + 500; for(int k = -500 + max(0, dif); k &lt;= lim; ++k)&#123; if(f[j - 1][k + 500 - dif] &lt; 0) continue; if(f[j - 1][k + 500 - dif] + a[i] + b[i] &gt; f[j][k + 500])&#123; f[j][k + 500] = f[j - 1][k - dif + 500] + a[i] + b[i], pos[j][k + 500] = k - dif + 500; for (int o = j - 1; o &gt;= 1; --o) sel[j][k + 500][o] = sel[j - 1][k - dif + 500][o]; sel[j][k + 500][j] = i; &#125; &#125; &#125; &#125; int ans, jj, kk, dif; for(int i = 0; i &lt;= 500; ++i) if(f[m][500 - i] &gt;= 0 || f[m][500 + i] &gt;= 0)&#123; if(f[m][500 - i] &lt; f[m][500 + i]) ans = f[m][500 + i], dif = i, jj = m, kk = 500 + i; else ans = f[m][500 - i], dif = -i, jj = m, kk = 500 - i; break; &#125; printf("Best jury has value %d for prosecution and value %d for defence:\n", (ans + dif) &gt;&gt; 1, (ans - dif) &gt;&gt; 1); for(int i = 1; i &lt;= m; ++i) aans[i] = sel[jj][kk][i]; sort(aans + 1, aans + m + 1); for(int i = 1; i &lt;= m; ++i) printf(" %d", aans[i]); printf("\n\n");&#125;int main()&#123; int T = 1; while((n = read()) &amp;&amp; (m = read()))&#123; printf("Jury #%d\n", T); init(); solve(); T++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3666 Making the Grade]]></title>
    <url>%2F2019%2F03%2F18%2Fpoj3666%2F</url>
    <content type="text"><![CDATA[题目大意：给定一个数列A_n，求将这个数列修改为一个单调数列B_n，使得代价\sum_{i=1}^{n} \left| A_i-B_i\right|最小。 题解可以证明有一种方案使得新数列中的所有数都来自于老数列，并且代价最小。因此可以把原数列离散化后跑DP，设$f(i, j)$为安排完前$i-1$个数，当前数为$j$（这里的$j$是离散化后的值，即按顺序排列的数列$A$的第$j$个值）时的最小代价。数列递增时，转移方程是 f(i, j)=\min_{1\le k\le j} \lbrace f(i-1, k)\rbrace+ \left| A_i-j\right|里面那一项可以用一个变量维护最小值，随着$j$的增长而更新。数列递减时相似。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;int n, a[2005], b[2005];ll f1[2005][2005], f2[2005][2005];int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]), b[i] = a[i]; sort(b + 1, b + n + 1); memset(f1, 0x3f, sizeof(f1)); memset(f2, 0x3f, sizeof(f2)); for(int i = 1; i &lt;= n; ++i) f1[1][i] = f2[1][i] = abs(a[1] - b[i]); for(int i = 2; i &lt;= n; ++i)&#123; ll mini1 = f1[i - 1][1], mini2 = f2[i - 1][n]; for(int j = 1; j &lt;= n; ++j) f1[i][j] = mini1 + 1ll * abs(b[j] - a[i]), mini1 = min(mini1, f1[i - 1][j + 1]); for(int j = n; j &gt;= 1; --j) f2[i][j] = mini2 + 1ll * abs(b[j] - a[i]), mini2 = min(mini2, f2[i - 1][j + 1]); &#125; ll ans = f1[0][0]; for(int i = 1; i &lt;= n; ++i) ans = min(ans, min(f1[n][i], f2[n][i])); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广东工业大学第十四届程序设计竞赛 题解]]></title>
    <url>%2F2019%2F03%2F18%2Fcontest-gdut2019%2F</url>
    <content type="text"><![CDATA[菜鸡是怎样炼成的 A题目大意：有2个人，每一个人会随机得到0和1两个数，只要有一个人能猜出这两个数就可以过关，请问最优情况下两人的过关概率。 一个人猜和自己不同的，一个人猜和自己相同的，就必胜。1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;void init()&#123;&#125;void solve()&#123; printf("1.00\n1.00\n1.00\n1.00\n");&#125;int main()&#123; init(); solve(); return 0;&#125; B题目链接 实际上就是求区间$[4a+b+1, 4c+d+1]$范围上的斐波那契平方和。注意可能会$4a+b+1&gt;4c+d+1$。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int f[50005], sum[50005], M = 192600817;void init()&#123; f[0] = 0, f[1] = 1, sum[1] = 1; for(int i = 2; i &lt;= 50000; ++i) f[i] = (f[i - 2] + f[i - 1]) % M, sum[i] = (sum[i - 1] + 1ll * f[i] * f[i]) % M;&#125;void solve()&#123; int Q; while(scanf("%d", &amp;Q) == 1)&#123; while(Q--)&#123; int a = read(), b = read(), c = read(), d = read(); if(4 * a + b &gt; 4 * c + d) swap(a, c), swap(b, d); printf("%d\n", (sum[4 * c + d + 1] - sum[4 * a + b] + M) % M); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; C题目大意：定义一个鸽子数为这样的一个数：将其每一位上的数的平方相加，得到一个新的数，再对新的数如此操作，循环往复，最终能得到1。求从小到大第$k$个鸽子数。多次询问。 由于每一个数位的平方和不会很大，因此可以认为鸽子数的分布不会很宽泛，因此直接暴力。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;bool vis[5000005] = &#123;0&#125;;int num[150005] = &#123;0&#125;, cnt = 0;inline int sqr(int x)&#123; return x * x;&#125;bool judge(int x)&#123; if(vis[x]) return false; if(x == 1) return true; int t = x, res = 0; vis[x] = true; while(t &gt; 0) res += sqr(t % 10), t /= 10; bool rres = judge(res); vis[x] = false; return rres;&#125;void init()&#123; for(int i = 1; cnt &lt; 150000; ++i)&#123; if(judge(i)) num[++cnt] = i; &#125;&#125;int main()&#123; init(); int Q = read(); while(Q--)&#123; int k = read(); printf("%d\n", num[k]); &#125; return 0;&#125; D题目大意：有$Q$个操作，操作1会向序列中添加$a$个$b$，操作2给出$a$和$b$，求将序列排序后下标位于$[a, b]$间的数的和。 离线应该可以做，就是倒着做，把插入改成删除，然后用树状数组维护最终的序列。然后WA了，还WA了6发，比赛结束都没有调试出来。（我也不知道为什么）所以还是乖乖地用权值线段树，操作1直接更新，操作2用前缀和得到答案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int Q, a[100005], tot = 0, M = 1000000007;ll seg1[2000005] = &#123;0&#125;, q[100005][3];int seg2[2000005] = &#123;0&#125;, cnt = 0, siz;void update(int id, int v)&#123; int k = id + siz - 1; seg1[k] += 1ll * v; int res = 1ll * v * a[id - 1] % M; seg2[k] = (seg2[k] + res) % M; while(k &gt; 1)&#123; k &gt;&gt;= 1; seg1[k] += 1ll * v; seg2[k] = (seg2[k] + res) % M; &#125;&#125;int query(int id, int l, int r, ll k)&#123; if(l == r) return k * a[id - siz] % M; int lc = (id &lt;&lt; 1), rc = (id &lt;&lt; 1 | 1), mid = (l + r) &gt;&gt; 1; if(k &gt;= seg1[lc]) return (query(rc, mid + 1, r, k - seg1[lc]) + seg2[lc]) % M; else return query(lc, l, mid, k);&#125;void init()&#123; Q = read(); for(int i = 0; i &lt; Q; ++i)&#123; scanf("%lld%lld%lld", &amp;q[i][0], &amp;q[i][1], &amp;q[i][2]); if(q[i][0] == 1ll) a[tot++] = q[i][2]; &#125; sort(a, a + tot); tot = unique(a, a + tot) - a; for(siz = 1; siz &lt; tot; siz &lt;&lt;= 1);&#125;void solve()&#123; for(int i = 0; i &lt; Q; ++i)&#123; if(q[i][0] == 1)&#123; int id = lower_bound(a, a + tot, q[i][2]) - a; update(id + 1, q[i][1]); &#125;else&#123; int res1 = query(1, 1, siz, q[i][2]), res2 = query(1, 1, siz, q[i][1] - 1); printf("%d\n", (res1 - res2 + M) % M); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; E题目链接 整个变换可以拆分成2个部分：平移和旋转放缩。后者是一个线性变换，因此可以用矩阵表示。设原来三角形的后两个顶点和第一个点构成的两个向量构成的矩阵为$A$，变换后三角形的后两个顶点和第一个点构成的两个向量构成的矩阵为$B$。那么我们希望能求出变换矩阵$T$。因为有$TA=B$，因此$T=BA^{-1}$。然后每次给定一个点，就先求出它相对于三角形第一个点的向量，设为$x$，那么变换后的向量就是$Tx$，之后把平移补上即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;pair&lt;int, int&gt; p1[3], p2[3];int mat[2][2];double det;void init()&#123; for(int i = 0; i &lt; 3; ++i) p1[i].first = read(), p1[i].second = read(); for(int i = 0; i &lt; 3; ++i) p2[i].first = read(), p2[i].second = read(); mat[0][0] = (p2[1].first - p2[0].first) * (p1[2].second - p1[0].second) + (p2[2].first - p2[0].first) * (p1[0].second - p1[1].second); mat[0][1] = (p2[1].first - p2[0].first) * (p1[0].first - p1[2].first) + (p2[2].first - p2[0].first) * (p1[1].first - p1[0].first); mat[1][0] = (p2[1].second - p2[0].second) * (p1[2].second - p1[0].second) + (p2[2].second - p2[0].second) * (p1[0].second - p1[1].second); mat[1][1] = (p2[1].second - p2[0].second) * (p1[0].first - p1[2].first) + (p2[2].second - p2[0].second) * (p1[1].first - p1[0].first); det = 1.0 / ((p1[1].first - p1[0].first) * (p1[2].second - p1[0].second) - (p1[2].first - p1[0].first) * (p1[1].second - p1[0].second));&#125;void solve()&#123; int Q = read(); while(Q--)&#123; int x = read(), y = read(); int ax = x - p1[0].first, ay = y - p1[0].second; int aax = ax * mat[0][0] + ay * mat[0][1], aay = ax * mat[1][0] + ay * mat[1][1]; double bx = aax * det, by = aay * det; printf("%.2lf %.2lf\n", bx + p2[0].first, by + p2[0].second); &#125;&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; F题目链接 12 G题目大意：求\sum_{i = 1} ^{n}(i\times \sum_{j=i}^{n} \binom{j}{i}) \mod 1000000007 和式变换，原式化为\sum_{i = 1} ^{n}(\sum_{j=1}^{i} j \binom{i}{j})，对里面那个式子有：由求导规则，(x+1)^n = \sum_{i=0}^{n} \binom{n}{i}x^n \implies n(x+1)^{n-1} = \sum_{i=1}^{n} n\binom{n}{i}x^{n-1}，因此把$x=1$带进去，可以把里面的式子化成$i\times 2^{i-1}$。这样就变成了一个数列求和。然后这个和是可以错位相减算出来的，化简出答案是$(i-1)2^i + 1$。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int M = 1000000007;ll n;int poww(int a, int b, int c)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = 1ll * res * a % M; a = 1ll * a * a % M, b &gt;&gt;= 1; &#125; return res;&#125;void init()&#123;&#125;void solve()&#123; int res = 1; res = 1ll * (n + 1ll) * res % M; res = 1ll * res * poww(2, n % 1000000006ll, M) % M; res = (res + 1) % M; res = (res - (poww(2, (n + 1ll) % 1000000006ll, M)) + M) % M; printf("%d\n", res);&#125;int main()&#123; while(scanf("%lld", &amp;n) == 1)&#123; init(); solve(); &#125; return 0;&#125; J题目大意：给定公式f_n=2f_{n-2}+f_{n-1}+n^3\quad (n>2), f_1=1, f_2=2，求f_n \mod 123456789。 基本的矩阵乘法，列向量里面保留$1, n, n^2, n^3$四项用于凑出$(n+1)^3$即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int M = 123456789;ll n;struct Mat&#123; int mt[7][7], r, c; Mat()&#123; memset(mt, 0, sizeof(mt)); &#125; Mat(int _r, int o)&#123; memset(mt, 0, sizeof(mt)); this-&gt;r = this-&gt;c = _r; if(o)&#123; for(int i = 0; i &lt; _r; ++i) this-&gt;mt[i][i] = 1; &#125; &#125;&#125;;void mul(Mat &amp;a, Mat &amp;b, Mat &amp;res)&#123; res.r = a.r, res.c = b.c; for(int i = 0; i &lt; a.r; ++i) for(int j = 0; j &lt; b.c; ++j)&#123; int sum = 0; for(int k = 0; k &lt; a.c; ++k)&#123; sum += (1ll * a.mt[i][k] * b.mt[k][j] % M); if(sum &gt;= M) sum -= M; &#125; res.mt[i][j] = sum; &#125;&#125;Mat poww(Mat a, ll p)&#123; Mat I(a.r, 1), tmp(a.r, 0); while(p)&#123; if(p &amp; 1ll) mul(I, a, tmp), I = tmp, memset(tmp.mt, 0, sizeof(tmp.mt)); mul(a, a, tmp), a = tmp, memset(tmp.mt, 0, sizeof(tmp.mt)); p &gt;&gt;= 1; &#125; return I;&#125;Mat m1, ini;void init()&#123; m1.r = m1.c = 6; m1.mt[0][0] = 1, m1.mt[0][1] = 2, m1.mt[0][2] = 1, m1.mt[0][3] = 3, m1.mt[0][4] = 3, m1.mt[0][5] = 1; m1.mt[1][0] = 1, m1.mt[1][1] = 0, m1.mt[1][2] = 0, m1.mt[1][3] = 0, m1.mt[1][4] = 0, m1.mt[1][5] = 0; m1.mt[2][0] = 0, m1.mt[2][1] = 0, m1.mt[2][2] = 1, m1.mt[2][3] = 3, m1.mt[2][4] = 3, m1.mt[2][5] = 1; m1.mt[3][0] = 0, m1.mt[3][1] = 0, m1.mt[3][2] = 0, m1.mt[3][3] = 1, m1.mt[3][4] = 2, m1.mt[3][5] = 1; m1.mt[4][0] = 0, m1.mt[4][1] = 0, m1.mt[4][2] = 0, m1.mt[4][3] = 0, m1.mt[4][4] = 1, m1.mt[4][5] = 1; m1.mt[5][0] = 0, m1.mt[5][1] = 0, m1.mt[5][2] = 0, m1.mt[5][3] = 0, m1.mt[5][4] = 0, m1.mt[5][5] = 1; ini.r = 6, ini.c = 1; ini.mt[0][0] = 2, ini.mt[1][0] = 1, ini.mt[2][0] = 8, ini.mt[3][0] = 4, ini.mt[4][0] = 2, ini.mt[5][0] = 1;&#125;void solve()&#123; Mat m2 = poww(m1, n - 2); Mat res; mul(m2, ini, res); printf("%d\n", res.mt[0][0]);&#125;int main()&#123; int T = read(); init(); while(T--)&#123; scanf("%lld", &amp;n); solve(); &#125; return 0;&#125; 总结codeforces到了黄名之后有点飘]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>线段树</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2008 奖励关]]></title>
    <url>%2F2019%2F03%2F16%2Fluogu2473%2F</url>
    <content type="text"><![CDATA[题目链接 题解一道经典的期望DP题。看到数据范围就很自然会想到进行状态压缩。因此，设$f(i, S)$为完成第$i$轮及以后，已经完成的情况为$S$的期望收益的最大值。因此有：如果第$j$个抛出的宝物能吃，那么就有$f(i, S) = \max \lbrace f(i + 1, S \bigcup {j}) + P[j], f(i+1, S) \rbrace$，代表选择吃或者不吃。如果第$j$个抛出的宝物不能吃，那么就有$f(i, S) = f(i+1, S)$，代表只能不吃。完成这$n$个选项后，$f(i, S)$要除以$n$。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int k, n, a[105], restraint[105] = &#123;0&#125;;double f[105][70005] = &#123;0&#125;;void init()&#123; k = read(), n = read(); for(int i = 0; i &lt; n; ++i)&#123; a[i] = read(); int t; while(t = read()) restraint[i] |= (1 &lt;&lt; (t - 1)); &#125;&#125;void solve()&#123; int bin = (1 &lt;&lt; n); for(int i = k; i &gt;= 1; --i)&#123; for(int j = 0; j &lt; bin; ++j)&#123; for(int t = 0; t &lt; n; ++t)&#123; if((restraint[t] &amp; j) == restraint[t]) f[i][j] += max(f[i + 1][j], f[i + 1][j | (1 &lt;&lt; t)] + a[t]); else f[i][j] += f[i + 1][j]; &#125; f[i][j] *= 1.0 / n; //n个来源 &#125; &#125; printf("%.6lf\n", f[1][0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>省选</category>
      </categories>
      <tags>
        <tag>期望DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 541 (Div. 2) 题解]]></title>
    <url>%2F2019%2F02%2F24%2Fcontest-cf1131%2F</url>
    <content type="text"><![CDATA[这次的题目比较常规，就是各种神奇的分类讨论很多。 A题目大意：两个矩形拼在一起，上面的矩形宽度小于下面的矩形，求离这两个矩形最近的方块个数（不包含矩形本身）。 模拟。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int ww1, hh1, ww2, hh2;void init()&#123; ww1 = read(), hh1 = read(), ww2 = read(), hh2 = read();&#125;void solve()&#123; cout &lt;&lt; ww1 + hh1 + hh1 + hh2 + ww2 + hh2 + ww1 - ww2 + 4 &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; B题目大意：有两个队伍比赛，某一个时候比分为$a: b$，那么某一队得分之后就可能变为$a+1: b$或者$a: b+1$。按时间顺序给出一系列时间点的比分，问最多可能有多少个时刻，满足两队比分相同（包含$0: 0$）。 模拟，但是情况比较繁琐。按照前后两个时刻$a&gt;b, a=b, a&lt; b$讨论。虽然这样就有9种情况，但有些情况是对称的。数学上分析的话有更简单的做法：设前后两个时刻的比分分别是$a: b$和$c: d$，那么如果形如$x: x$的平局出现就有$a\le x \le c, b \le x \le d\implies \max\lbrace a, b\rbrace \le x \le \min \lbrace c, d \rbrace$。但不能立即得出$x$有$\min \lbrace c, d \rbrace - \max\lbrace a, b\rbrace + 1$个，因为如果$a=b=c=d$就会出现重复计算的情况，因此这种情况还要特殊考虑。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[10005], b[10005];void init()&#123; n = read();&#125;void solve()&#123; for(int i = 1; i &lt;= n; ++i) a[i] = read(), b[i] = read(); a[0] = b[0] = 0; int ans = 1; for(int i = 1; i &lt;= n; ++i)&#123; if(a[i - 1] == b[i - 1])&#123; if(a[i] == b[i]) ans += b[i] - b[i - 1]; else if(a[i] &lt; b[i]) ans += a[i] - a[i - 1]; else ans += b[i] - b[i - 1]; &#125;else if(a[i - 1] &lt; b[i - 1])&#123; if(a[i] == b[i]) ans += b[i] - b[i - 1] + 1; else if(a[i] &lt; b[i]) ans += max(a[i] - b[i - 1] + 1, 0); else ans += b[i] - b[i - 1] + 1; &#125;else if(a[i - 1] &gt; b[i - 1])&#123; if(a[i] == b[i]) ans += a[i] - a[i - 1] + 1; else if(a[i] &lt; b[i]) ans += a[i] - a[i - 1] + 1; else ans += max(b[i] - a[i - 1] + 1, 0); &#125; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125; C题目大意：给定一个长度为$n$的数列$a$，将其重排使得\left| a_1-a_2 \right| + \cdots + \left| a_{n-1}-a_n \right| + \left| a_n-a_1 \right|最小。 可能容易根据数据猜出来当a_i呈现“山峰型”排列（也就是先对数列排序，然后前半部分：正着排列奇数位置元素，后半部分：倒着排列偶数位置元素）时该值达到最小。确实如此，不过我们需要一个证明。 D题目大意：给定两组菜，第一组有$n$道菜，第二组有$m$道菜，给定这两组菜之间每一对菜的美味程度相比关系（前者大于，小于或等于后者），共$nm$对。要求对每一个菜赋予一个美味值，要求是正整数，且每一对菜美味值的关系和美味程度的关系相符合，且最大的美味值最小。如果无法赋予，输出No。 缩点+拓扑排序。将关系是等于的两个菜之间连一条无向边，否则从美味程度低的菜连一条边到美味程度高的菜。然后缩点，按拓扑序分配美味值。最后再检查，如果分配的美味值和所给信息相矛盾就输出No。上面的缩点可以改成并查集。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;struct Edge&#123; int v, nxt;&#125;;Edge e[2000005], e_[2000005];int at[2005] = &#123;0&#125;, n, m, cnt = 0;int at_[2005] = &#123;0&#125;, cnt_ = 0;int dfn[2005] = &#123;0&#125;, low[2005], D = 0, in[2005] = &#123;0&#125;; int st[2005], top = 0, du[2005] = &#123;0&#125;;int repre[2005] = &#123;0&#125;, rk[2005];int que[2005], hd = 0, tl = 0;char mat[1005][1005];void addEdge(int u, int v)&#123; e[++cnt].v = v; e[cnt].nxt = at[u], at[u] = cnt;&#125;void addEdge_(int u, int v)&#123; e_[++cnt_].v = v; e_[cnt_].nxt = at_[u], at_[u] = cnt_;&#125;void tarjan_scc(int id)&#123; dfn[id] = low[id] = ++D; in[id] = true; st[top++] = id; int i = at[id], vv; while(i)&#123; vv = e[i].v; if(!dfn[vv]) tarjan_scc(vv), low[id] = min(low[id], low[vv]); else if(in[vv]) low[id] = min(low[id], dfn[vv]); i = e[i].nxt; &#125; if(dfn[id] == low[id])&#123; for(; ; )&#123; top--; in[st[top]] = false; repre[st[top]] = id; if(st[top] == id) break; &#125; &#125;&#125;void getDu()&#123; for(int i = 1; i &lt;= n + m; ++i)&#123; for(int j = at[i]; j; j = e[j].nxt)&#123; if(repre[i] == repre[e[j].v]) continue; addEdge_(repre[i], repre[e[j].v]); du[repre[e[j].v]]++; &#125; &#125; for(int i = 1; i &lt;= n + m; ++i)&#123; if(repre[i] != i) continue; if(!du[i]) rk[i] = 1, que[tl++] = i; &#125; while(tl &gt; hd)&#123; int id = que[hd++]; for(int i = at_[id]; i; i = e_[i].nxt)&#123; du[e_[i].v]--; if(!du[e_[i].v]) rk[e_[i].v] = rk[id] + 1, que[tl++] = e_[i].v; &#125; &#125; for(int i = 1; i &lt;= n + m; ++i) rk[i] = rk[repre[i]];&#125;void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= n; ++i)&#123; scanf("%s", &amp;mat[i][1]); for(int j = 1; j &lt;= m; ++j)&#123; if(mat[i][j] != '&lt;') addEdge(n + j, i); if(mat[i][j] != '&gt;') addEdge(i, n + j); &#125; &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= n + m; ++i) if(!dfn[i]) tarjan_scc(i); getDu(); for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= m; ++j)&#123; if((mat[i][j] == '&lt;' &amp;&amp; rk[i] &gt;= rk[j + n]) || (mat[i][j] == '=' &amp;&amp; rk[i] != rk[j + n]) || (mat[i][j] == '&gt;' &amp;&amp; rk[i] &lt;= rk[j + n])) goto label; &#125; &#125; printf("Yes\n"); for(int i = 1; i &lt; n; ++i) printf("%d ", rk[i]); printf("%d\n", rk[n]); for(int i = 1; i &lt; m; ++i) printf("%d ", rk[i + n]); printf("%d\n", rk[m + n]); return ; label: printf("No\n");&#125;int main()&#123; init(); solve(); return 0;&#125; E题目链接 我们按不同的字母考虑，对每一个字母都求一个最长子串。对于一个字母，可以发现$s\cdot t$的最长子串长度只取决于$s$和$t$的最长子串长度。因此，我们不需要算出具体的$s\cdot t$，只需要根据当前字符串$t$和之前处理过的$s$算出结果即可。这样就可以按照字符串连乘的顺序，一步一步推出最终答案。设$f(s, a)$为串$s$中字母$a$构成的最长子串长度。对$t$分类讨论： $t$是纯字符串，即本身只由一个字母构成。那么设$t$中只有字母$a$，则$f(s\cdot t, a) = (f(s, a) + 1)\left| t \right| +f(s, a)$。对其他字母$b$有$f(s\cdot t, b) = \max(\min(f(s, b), 1), 0)$。 $t$的第一个字母和最后一个字母相同。设其前后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, f[100005][28] = &#123;0&#125;, ans = 0, tmp[28] = &#123;0&#125;;char s[100005];void init()&#123; n = read();&#125;void solve()&#123; scanf("%s", s); int len = strlen(s); for(int i = 0; i &lt; len; )&#123; int j = i, iid = s[i] - 'a'; while(j &lt; len &amp;&amp; s[i] == s[j]) ++j; f[1][iid] = max(f[1][iid], j - i); i = j; &#125; for(int i = 2; i &lt;= n; ++i)&#123; scanf("%s", s); len = strlen(s); for(int ii = 0; ii &lt; len; )&#123; int j = ii, iid = s[ii] - 'a'; while(j &lt; len &amp;&amp; s[ii] == s[j]) ++j; tmp[iid] = max(tmp[iid], j - ii); ii = j; &#125; if(tmp[s[0] - 'a'] == len)&#123; //纯色 for(int j = 0; j &lt; 26; ++j)&#123; if(j == s[0] - 'a') continue; f[i][j] = 0; if(f[i - 1][j]) f[i][j] = 1; &#125; int nn = f[i - 1][s[0] - 'a']; f[i][s[0] - 'a'] = (nn + 1) * len + nn; &#125;else if(s[0] == s[len - 1])&#123; //头尾相同色 for(int j = 0; j &lt; 26; ++j)&#123; if(j == s[0] - 'a') continue; f[i][j] = tmp[j]; if(f[i - 1][j]) f[i][j] = max(f[i][j], 1); &#125; int bb = 0, iii; for(iii = 0; iii &lt; len; ++iii) if(s[iii] != s[0]) break; bb += iii; for(iii = len - 1; iii &gt;= 0; --iii) if(s[iii] != s[0]) break; bb += len - iii - 1; if(f[i - 1][s[0] - 'a']) f[i][s[0] - 'a'] = bb + 1; else f[i][s[0] - 'a'] = tmp[s[0] - 'a']; &#125;else&#123; int bb1 = 0, bb2 = 0, iii; for(iii = 0; iii &lt; len; ++iii) if(s[iii] != s[0]) break; bb1 = iii; for(iii = len - 1; iii &gt;= 0; --iii) if(s[iii] != s[len - 1]) break; bb2 = len - iii - 1; for(int j = 0; j &lt; 26; ++j)&#123; f[i][j] = tmp[j]; if(j == s[0] - 'a') &#123; if(f[i - 1][j]) f[i][j] = max(f[i][j], bb1 + 1); &#125;else if(j == s[len - 1] - 'a') &#123; if(f[i - 1][j]) f[i][j] = max(f[i][j], bb2 + 1); &#125;else&#123; if(f[i - 1][j]) f[i][j] = max(f[i][j], 1); &#125; &#125; &#125; memset(tmp, 0, sizeof(tmp)); &#125; int ans = 0; for(int i = 0; i &lt; 26; ++i) ans = max(ans, f[n][i]); printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125; F题目链接 这题比D和E简单了一倍。。。由于答案任意，完全可以用一个链表来维护数之间的顺序，每次操作$(a, b)$就是把$b$所在链表连在$a$之后。不过这需要更新链表的头节点和尾节点，用并查集可以做到。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, hd[160005], nxt[160005], tl[160005];int Findh(int x)&#123; if(x == hd[x]) return x; return hd[x] = Findh(hd[x]);&#125;int Findt(int x)&#123; if(x == tl[x]) return x; return tl[x] = Findt(tl[x]);&#125;void init()&#123; n = read(); for(int i = 1; i &lt;= n; ++i)&#123; hd[i] = tl[i] = i, nxt[i] = 0; &#125;&#125;void solve()&#123; int a, b; for(int i = 1; i &lt; n; ++i)&#123; a = read(), b = read(); int tla = Findt(a), tlb = Findt(b); int hda = Findh(a), hdb = Findh(b); hd[hdb] = hda, tl[tla] = tlb; nxt[tla] = hdb; &#125; int root; for(int i = 1; i &lt;= n; ++i)&#123; if(hd[i] == i)&#123; root = i; break; &#125; &#125; for(int cur = root; cur; cur = nxt[cur]) printf("%d ", cur);&#125;int main()&#123; init(); solve(); return 0;&#125; G题目链接 DP。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>线性DP</tag>
        <tag>并查集</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 非线性筛法]]></title>
    <url>%2F2019%2F02%2F21%2Ftemplate-underlinear-sieve%2F</url>
    <content type="text"><![CDATA[常见的非线性筛法有两种：杜教筛和min25筛。 杜教筛杜教筛是用来求一类积性函数和的算法。它的优点就在于它有着低于线性的时间复杂度。 直接应用杜教筛的时间复杂度是$O(n^{\frac{3}{4}})$。如果事先用线性筛处理$O(n^{\frac{2}{3}})$级别大小的前缀和，在杜教筛的递归过程中使用的话，时间复杂度会降到$O(n^{\frac{2}{3}})$。因为杜教筛一般的数据规模都在$10^9$以上，所以要用某种数据结构保存那些$i$过大的$S(i)$。一般用map，如果时间效率要求高可以用一个数组：对于$i&gt; \sqrt n$，保存$S(i)$到$\lfloor \frac{n}{i} \rfloor$位置。 欧拉函数$\varphi$12 杜教筛常见模型]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷3768 简单的数学题]]></title>
    <url>%2F2019%2F02%2F21%2Fluogu3768%2F</url>
    <content type="text"><![CDATA[题目大意：求$\sum{i = 1}^{n} \sum{j = 1}^{n} ij\gcd(i, j) \mod p$。 题解遇到gcd的题目不仅仅可以反演，也可以采用一些其他方法。这道题目就是，直接反演非常麻烦，所以采用下面的变换： \begin{aligned} Ans &= \sum_{d=1}^{n} d \sum_{i = 1}^{n} \sum_{j = 1}^{n} ij[\gcd(i, j)=d] \\ &= \sum_{d=1}^{n} d^3 \sum_{i = 1}^{n} \sum_{j = 1}^{n} \frac{i}{d}\frac{j}{d}[\gcd(\frac{i}{d}, \frac{j}{d})=1] \\ &= \sum_{d=1}^{n} d^3 \sum_{i = 1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j = 1}^{\lfloor \frac{n}{d}\rfloor} ij[\gcd(i, j)=1] \\ &= \sum_{d=1}^{n} d^3 \sum_{i = 1}^{\lfloor \frac{n}{d}\rfloor}i \sum_{j = 1}^{\lfloor \frac{n}{d}\rfloor} j[\gcd(i, j)=1] \\ &= \sum_{d=1}^{n} d^3 \sum_{i = 1}^{\lfloor \frac{n}{d}\rfloor}i\cdot i\phi(i) \\ &= \sum_{d=1}^{n} d^3 \sum_{i = 1}^{\lfloor \frac{n}{d}\rfloor}i^2 \phi(i) \end{aligned}设$S(n)=\sum_{i = 1}^{n}i^2 \phi(i)$，那么有 \begin{aligned} S(n) &= \sum_{i = 1}^{n}i^2 (i - \sum_{d\mid i, d < i}\phi(d)) \\ &= \sum_{i = 1}^{n}i^3 - \sum_{i = 1}^{n}\sum_{d\mid i, d < i}\phi(d) \\ &= \sum_{i = 1}^{n}i^3 - \sum_{i = 2}^{n}\sum_{d=1}^{\lfloor \frac{n}{i}\rfloor}(id)^2 \phi(d) \\ &= \sum_{i = 1}^{n}i^3 - \sum_{i = 2}^{n} i^2 \sum_{d=1}^{\lfloor \frac{n}{i}\rfloor}d^2 \phi(d) \\ &= \sum_{i = 1}^{n}i^3 - \sum_{i = 2}^{n} i^2 S(\lfloor \frac{n}{i}\rfloor) \end{aligned}用杜教筛，时间复杂度$O(n^{\frac{2}{3}})$。 貌似这种做法的底层原理还是莫比乌斯反演加上狄利克雷卷积，这个其实我没有太多的考证（其实是还没学到）。。。不过运气比较好，这道题的两个维度都是$n$，如果是$m$和$n$就很难办了。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define INF 2000000000#define MAXN 4641600using namespace std;typedef long long ll;ll n;int phi[MAXN + 5], tot = 0, prime[MAXN &gt;&gt; 1], p, inv2, inv4, inv6;int sum[MAXN + 5] = &#123;0&#125;, sum2[MAXN + 5];bool vis[MAXN + 5] = &#123;0&#125;;map&lt;ll, int&gt; mp;int poww(int a, int b, int c)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = 1ll * res * a % c; a = 1ll * a * a % c, b &gt;&gt;= 1; &#125; return res;&#125;inline int poww3(int r)&#123; int res = 1ll * r * r % p; int res2 = 1ll * (r + 1) * (r + 1) % p; res = 1ll * res * res2 % p; res = 1ll * res * inv4 % p; return res;&#125;inline int poww2(int r)&#123; int res = 1ll * r * (r + 1) % p; int res2 = 1ll * (r + r + 1) * inv6 % p; res = 1ll * res * res2 % p; return res;&#125;inline int q3(int l, int r)&#123; int res = poww3(r) - poww3(l - 1); if(res &lt; 0) res += p; return res;&#125;inline int q2(int l, int r)&#123; int res = poww2(r) - poww2(l - 1); if(res &lt; 0) res += p; return res;&#125;void getPhi(int N)&#123; phi[1] = sum[1] = sum2[1] = 1; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i]) prime[++tot] = i, phi[i] = i - 1; for(int j = 1; j &lt;= tot; ++j)&#123; ll t = 1ll * i * prime[j]; if(t &gt; 1ll * N) break; vis[t] = true, phi[t] = phi[i] * (prime[j] - 1); if(i % prime[j] == 0)&#123; phi[t] += phi[i]; break; &#125; &#125; sum[i] = sum[i - 1] + phi[i]; if(sum[i] &gt;= p) sum[i] -= p; int term = 1ll * i * i % p; term = 1ll * term * phi[i] % p; sum2[i] = sum2[i - 1] + term; if(sum2[i] &gt;= p) sum2[i] -= p; &#125;&#125;int solve_s(ll N)&#123; if(N &lt;= MAXN) return sum2[N]; if(mp.count(N)) return mp[N]; int ans = poww3(N % p); for(ll i = 2, lst = 0; i &lt;= N; i = lst + 1)&#123; lst = N / (N / i); int distract = 1ll * q2(i % p, lst % p) * solve_s(N / i) % p; ans -= distract; if(ans &lt; 0) ans += p; &#125; mp[N] = ans; return ans;&#125;void init()&#123; scanf("%d%lld", &amp;p, &amp;n); getPhi(MAXN); inv2 = poww(2, p - 2, p); inv4 = poww(4, p - 2, p); inv6 = poww(6, p - 2, p);&#125;void solve()&#123; int ans = 0; for(ll i = 1, lst = 0; i &lt;= n; i = lst + 1)&#123; lst = n / (n / i); int term = 1ll * q3(i % p, lst % p) * solve_s(n / i) % p; ans += term; if(ans &gt;= p) ans -= p; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3939 数颜色]]></title>
    <url>%2F2019%2F02%2F20%2Fluogu3939%2F</url>
    <content type="text"><![CDATA[题目大意：给定一系列格子，每个格子有一种颜色。有2种操作：询问区间$[l, r]$种有多少颜色是$c$的格子，或者将$i$和$i+1$位置的格子交换颜色。 题解数据结构学傻了。。。一看题目就以为这是一个主席树，结果看题解发现根本没有必要那么麻烦。如果不看修改操作，这道题完全可以这么做：用一个vector保存每一个属于这种颜色的格子的位置，然后对于要查询的颜色，因为位置在保存的时候有单调性，所以可以直接用二分查找求出在规定区间内该颜色格子的数目。同时因为本题的修改操作很简单，基本不会破坏位置之间的单调性，所以用vector+二分的方法是可行的。好像这种数颜色的题目常用vector+二分？123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[300005];vector&lt;int&gt; pos[300005];void init()&#123; n = read(), m = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(), pos[a[i]].push_back(i);&#125;void solve()&#123; while(m--)&#123; int o = read(); if(o == 1)&#123; int l = read(), r = read(), c = read(); int lt = lower_bound(pos[c].begin(), pos[c].end(), l) - pos[c].begin(); int rt = upper_bound(pos[c].begin(), pos[c].end(), r) - pos[c].begin(); printf("%d\n", rt - lt); &#125;else&#123; int pp = read(); if(a[pp] == a[pp + 1]) continue; int d1 = lower_bound(pos[a[pp]].begin(), pos[a[pp]].end(), pp) - pos[a[pp]].begin(); pos[a[pp]][d1]++; int d2 = lower_bound(pos[a[pp + 1]].begin(), pos[a[pp + 1]].end(), pp + 1) - pos[a[pp + 1]].begin(); pos[a[pp + 1]][d2]--; swap(a[pp], a[pp + 1]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2653 Pick-up sticks]]></title>
    <url>%2F2019%2F02%2F20%2Fpoj2653%2F</url>
    <content type="text"><![CDATA[题目大意：依次给出若干条线段，后给出的线段是后放置的，可能会“盖在”先前的线段上。求所有没有被盖住的线段。 题解容易知道最后一根放上去的线段肯定不会被盖住。那么只需要对当前线段不断向后枚举，看看是否会被后来的线段盖住就行了。注意线段盖住可能有覆盖一部分的情况，这个要做特殊判定。时间复杂度理论上是$O(n^2)$的，但因为数据是随机的所以比较快。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;double eps = 1e-8;const double pi = acos(-1.0);int cmp(double x)&#123; if(fabs(x) &lt; eps) return 0; return (x &gt; 0 ? 1: -1);&#125;struct Point&#123; double x, y; Point()&#123;&#125; Point(double _x, double _y)&#123; x = _x, y = _y; &#125; void input()&#123; scanf("%lf%lf", &amp;x, &amp;y); &#125; void output()&#123; printf("%.3lf %.3lf\n", x, y); &#125; friend bool operator == (const Point &amp;pa, const Point &amp;pb) &#123; return cmp(pa.x - pb.x) == 0 &amp;&amp; cmp(pa.y - pb.y) == 0; &#125; friend bool operator &lt; (const Point &amp;pa, const Point &amp;pb) &#123; return cmp(pa.x - pb.x) == 0 ? cmp(pa.y - pb.y) &lt; 0: pa.x &lt; pb.x; &#125; friend Point operator + (const Point &amp;pa, const Point &amp;pb) &#123; return Point(pa.x + pb.x, pa.y + pb.y); &#125; friend Point operator - (const Point &amp;pa, const Point &amp;pb) &#123; return Point(pa.x - pb.x, pa.y - pb.y); &#125; friend Point operator * (const Point &amp;pa, const double &amp;rat) &#123; return Point(pa.x * rat, pa.y * rat); &#125; friend Point operator / (const Point &amp;pa, const double &amp;rat) &#123; return Point(pa.x / rat, pa.y / rat); &#125; //逆时针旋转 friend Point operator &lt;&lt; (const Point &amp;pa, const double &amp;rat) &#123; double sine = sin(rat), cosi = cos(rat); return Point(pa.x * cosi - pa.y * sine, pa.x * sine + pa.y * cosi); &#125; //顺时针旋转 friend Point operator &gt;&gt; (const Point &amp;pa, const double &amp;rat) &#123; double sine = sin(rat), cosi = cos(rat); return Point(pa.x * cosi + pa.y * sine, pa.y * cosi - pa.x * sine); &#125; double norm() const&#123; return hypot(x, y); &#125; double sqr() const&#123; return x * x + y * y; &#125;&#125;;double dot(const Point &amp;pa, const Point &amp;pb) &#123; return pa.x * pb.x + pa.y * pb.y;&#125;double cross(const Point &amp;pa, const Point &amp;pb) &#123; return pa.x * pb.y - pa.y * pb.x;&#125;double dist(const Point &amp;pa, const Point &amp;pb) &#123; return hypot(pa.x - pb.x, pa.y - pb.y);&#125;//线段之间角double rad(const Point &amp;pa, const Point &amp;pb)&#123; return acos(dot(pa, pb) / (pa.norm() * pb.norm()));&#125;//线段共同点之间角double rad(const Point &amp;pa, const Point &amp;pb, const Point &amp;pc)&#123; return acos(dot(pa - pc, pb - pc) / ((pa - pc).norm() * (pb - pc).norm()));&#125;struct Segment&#123; Point s, e; Segment() &#123;&#125; Segment(const Point &amp;st, const Point &amp;ed)&#123; if(st &lt; ed) s = st, e = ed; else s = ed, e = st; &#125; friend bool operator == (const Segment &amp;sa, const Segment &amp;sb) &#123; return sa.s == sb.s &amp;&amp; sa.e == sb.e; &#125; friend double operator * (const Segment &amp;sa, const Segment &amp;sb) &#123; return dot(sa.e - sa.s, sb.e - sb.s); &#125; friend bool operator / (const Segment &amp;sa, const Segment &amp;sb) &#123; return cross(sa.e - sa.s, sb.e - sb.s); &#125; friend Point operator ^ (const Segment &amp;sa, const Segment &amp;sb)&#123; double det1 = cross(sa.s - sb.s, sb.e - sb.s); double det2 = cross(sa.e - sb.s, sb.e - sb.s); return (sa.e * det1 - sa.s * det2) / (det1 - det2); &#125; bool includes(const Point &amp;pa) const&#123; return cmp(cross(pa - s, pa - e)) == 0 &amp;&amp; cmp(dot(pa - s, pa - e)) &lt;= 0; &#125; //严格在内部 bool str_includes(const Point &amp;pa) const&#123; return cmp(cross(pa - s, pa - e)) == 0 &amp;&amp; cmp(dot(pa - s, pa - e)) &lt; 0; &#125; bool parallel(const Segment &amp;sa) const&#123; return cmp(cross(sa.e - sa.s, e - s)) == 0; &#125; double len() const&#123; return dist(s, e); &#125;&#125;;Segment make_seg(const Point &amp;st, const Point &amp;ed)&#123; return Segment(st, ed);&#125;int n, ans[1005], tot = 0;Segment seg[100005];int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; if(!n) break; for(int i = 1; i &lt;= n; ++i)&#123; Point p1, p2; p1.input(), p2.input(); seg[i] = make_seg(p1, p2); &#125; tot = 0, ans[++tot] = n; for(int i = n - 1; i &gt;= 1; --i)&#123; int flag = 1; for(int j = n; j &gt; i; --j)&#123; if(seg[i].parallel(seg[j]))&#123; if(seg[i].str_includes(seg[j].s) || seg[i].str_includes(seg[j].e))&#123; flag = 0; break; &#125; &#125;else&#123; Point pp = seg[i] ^ seg[j]; if(seg[i].str_includes(pp) &amp;&amp; seg[j].str_includes(pp))&#123; flag = 0; break; &#125; &#125; &#125; if(flag) ans[++tot] = i; &#125; printf("Top sticks: "); for(int i = tot; i &gt; 1; --i) printf("%d, ", ans[i]); printf("%d.\n", ans[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1127 Jack Straws]]></title>
    <url>%2F2019%2F02%2F20%2Fpoj1127%2F</url>
    <content type="text"><![CDATA[题目大意：给定一些线段，线段之间可能直接连接，也可能间接相连，两种情况都算相连。给定多组询问，判断某两根线段是否相连。 题解线段的直接相连有两种情况：线段间所在直线有交点，且交点在两条线段上；或者两条线段平行，其中一条线段的端点在另外一条线段上。线段的间接相连情况可以用Floyd算法求出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;double eps = 1e-8;const double pi = acos(-1.0);int cmp(double x)&#123; if(fabs(x) &lt; eps) return 0; return (x &gt; 0 ? 1: -1);&#125;struct Point&#123; double x, y; Point()&#123;&#125; Point(double _x, double _y)&#123; x = _x, y = _y; &#125; void input()&#123; scanf("%lf%lf", &amp;x, &amp;y); &#125; void output()&#123; printf("%.3lf %.3lf\n", x, y); &#125; friend bool operator == (const Point &amp;pa, const Point &amp;pb) &#123; return cmp(pa.x - pb.x) == 0 &amp;&amp; cmp(pa.y - pb.y) == 0; &#125; friend bool operator &lt; (const Point &amp;pa, const Point &amp;pb) &#123; return cmp(pa.x - pb.x) == 0 ? cmp(pa.y - pb.y) &lt; 0: pa.x &lt; pb.x; &#125; friend Point operator + (const Point &amp;pa, const Point &amp;pb) &#123; return Point(pa.x + pb.x, pa.y + pb.y); &#125; friend Point operator - (const Point &amp;pa, const Point &amp;pb) &#123; return Point(pa.x - pb.x, pa.y - pb.y); &#125; friend Point operator * (const Point &amp;pa, const double &amp;rat) &#123; return Point(pa.x * rat, pa.y * rat); &#125; friend Point operator / (const Point &amp;pa, const double &amp;rat) &#123; return Point(pa.x / rat, pa.y / rat); &#125; //逆时针旋转 friend Point operator &lt;&lt; (const Point &amp;pa, const double &amp;rat) &#123; double sine = sin(rat), cosi = cos(rat); return Point(pa.x * cosi - pa.y * sine, pa.x * sine + pa.y * cosi); &#125; //顺时针旋转 friend Point operator &gt;&gt; (const Point &amp;pa, const double &amp;rat) &#123; double sine = sin(rat), cosi = cos(rat); return Point(pa.x * cosi + pa.y * sine, pa.y * cosi - pa.x * sine); &#125; double norm() const&#123; return hypot(x, y); &#125; double sqr() const&#123; return x * x + y * y; &#125;&#125;;double dot(const Point &amp;pa, const Point &amp;pb) &#123; return pa.x * pb.x + pa.y * pb.y;&#125;double cross(const Point &amp;pa, const Point &amp;pb) &#123; return pa.x * pb.y - pa.y * pb.x;&#125;double dist(const Point &amp;pa, const Point &amp;pb) &#123; return hypot(pa.x - pb.x, pa.y - pb.y);&#125;//线段之间角double rad(const Point &amp;pa, const Point &amp;pb)&#123; return acos(dot(pa, pb) / (pa.norm() * pb.norm()));&#125;//线段共同点之间角double rad(const Point &amp;pa, const Point &amp;pb, const Point &amp;pc)&#123; return acos(dot(pa - pc, pb - pc) / ((pa - pc).norm() * (pb - pc).norm()));&#125;struct Segment&#123; Point s, e; Segment() &#123;&#125; Segment(const Point &amp;st, const Point &amp;ed)&#123; if(st &lt; ed) s = st, e = ed; else s = ed, e = st; &#125; friend bool operator == (const Segment &amp;sa, const Segment &amp;sb) &#123; return sa.s == sb.s &amp;&amp; sa.e == sb.e; &#125; friend double operator * (const Segment &amp;sa, const Segment &amp;sb) &#123; return dot(sa.e - sa.s, sb.e - sb.s); &#125; friend bool operator / (const Segment &amp;sa, const Segment &amp;sb) &#123; return cross(sa.e - sa.s, sb.e - sb.s); &#125; friend Point operator ^ (const Segment &amp;sa, const Segment &amp;sb)&#123; double det1 = cross(sa.s - sb.s, sb.e - sb.s); double det2 = cross(sa.e - sb.s, sb.e - sb.s); return (sa.e * det1 - sa.s * det2) / (det1 - det2); &#125; bool includes(const Point &amp;pa) const&#123; return cmp(cross(pa - s, pa - e)) == 0 &amp;&amp; cmp(dot(pa - s, pa - e)) &lt;= 0; &#125; bool parallel(const Segment &amp;sa) const&#123; return cmp(cross(sa.e - sa.s, e - s)) == 0; &#125; double len() const&#123; return dist(s, e); &#125;&#125;;Segment make_seg(const Point &amp;st, const Point &amp;ed)&#123; return Segment(st, ed);&#125;int n;Segment seg[15];int con[15][15] = &#123;0&#125;;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; if(!n) break; for(int i = 1; i &lt;= n; ++i)&#123; Point p1, p2; p1.input(), p2.input(); seg[i] = make_seg(p1, p2); &#125; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(i == j)&#123; con[i][j] = 1; continue; &#125; if(seg[i].parallel(seg[j]))&#123; if(seg[j].includes(seg[i].s) || seg[j].includes(seg[i].e)) con[i][j] = 1; &#125;else&#123; Point pp = (seg[i] ^ seg[j]); if(seg[i].includes(pp) &amp;&amp; seg[j].includes(pp)) con[i][j] = 1; &#125; &#125; &#125; for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) con[i][j] |= (con[i][k] &amp; con[k][j]); int u, v; while(scanf("%d%d", &amp;u, &amp;v) == 2)&#123; if(!u &amp;&amp; !v) break; printf("%s\n", con[u][v] ? "CONNECTED" : "NOT CONNECTED"); &#125; memset(con, 0, sizeof(con)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 计算几何]]></title>
    <url>%2F2019%2F02%2F18%2Ftemplate-cg%2F</url>
    <content type="text"><![CDATA[计算几何基本模板。 判断符号计算几何中有大量的浮点数运算，因此需要手写函数以判断一个数是否为0。12345double eps;int cmp(double x)&#123; if(fabs(x) &lt; eps) return 0; return (x &gt; 0 ? 1: -1);&#125; 平面点类平面中大多数对象都能通过点来表示。下面给出一份涉及大部分点相关运算的模板。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Point&#123; double x, y; Point()&#123;&#125; Point(double _x, double _y)&#123; x = _x, y = _y; &#125; void input()&#123; scanf("%lf%lf", &amp;x, &amp;y); &#125; void output()&#123; printf("%.3lf %.3lf\n", x, y); &#125; friend bool operator == (const Point &amp;pa, const Point &amp;pb) &#123; return cmp(pa.x - pb.x) == 0 &amp;&amp; cmp(pa.y - pb.y) == 0; &#125; friend bool operator &lt; (const Point &amp;pa, const Point &amp;pb) &#123; return cmp(pa.x - pb.x) == 0 ? cmp(pa.y - pb.y) &lt; 0: pa.x &lt; pb.x; &#125; friend Point operator + (const Point &amp;pa, const Point &amp;pb) &#123; return Point(pa.x + pb.x, pa.y + pb.y); &#125; friend Point operator - (const Point &amp;pa, const Point &amp;pb) &#123; return Point(pa.x - pb.x, pa.y - pb.y); &#125; friend Point operator * (const Point &amp;pa, const double &amp;rat) &#123; return Point(pa.x * rat, pa.y * rat); &#125; friend Point operator / (const Point &amp;pa, const double &amp;rat) &#123; return Point(pa.x / rat, pa.y / rat); &#125; friend Point operator &lt;&lt; (const Point &amp;pa, const double &amp;rat) &#123; double sine = sin(rat), cosi = cos(rat); return Point(pa.x * cosi - pa.y * sine, pa.x * sine + pa.y * cosi); &#125; friend Point operator &gt;&gt; (const Point &amp;pa, const double &amp;rat) &#123; double sine = sin(rat), cosi = cos(rat); return Point(pa.x * cosi + pa.y * sine, pa.y * cosi - pa.x * sine); &#125; double norm() const&#123; return hypot(x, y); &#125; double sqr() const&#123; return x * x + y * y; &#125;&#125;;double dot(const Point &amp;pa, const Point &amp;pb) &#123; return pa.x * pb.x + pa.y * pb.y;&#125;double cross(const Point &amp;pa, const Point &amp;pb) &#123; return pa.x * pb.y - pa.y * pb.x;&#125;double dist(const Point &amp;pa, const Point &amp;pb) &#123; return hypot(pa.x - pb.x, pa.y - pb.y);&#125;double rad(const Point &amp;pa, const Point &amp;pb)&#123; return acos(dot(pa, pb) / (pa.norm() * pb.norm()));&#125;double rad(const Point &amp;pa, const Point &amp;pb, const Point &amp;pc)&#123; return acos(dot(pa - pc, pb - pc) / ((pa - pc).norm() * (pb - pc).norm()));&#125; 平面线段/直线平面线段或者直线一般用两个端点来表示。为了方便，一般用有向线段的方式存储线段。12]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NOI2015 程序自动分析]]></title>
    <url>%2F2019%2F02%2F16%2Fnoi2015t1%2F</url>
    <content type="text"><![CDATA[题目链接 题解离散化+并查集。用并查集维护的是相等关系。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,rec[100005][3],sma[200005],cnt,par[400005],tmp[200005];int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar(); return x;&#125;void pre()&#123; register int i; n=read(); for(i=0;i&lt;n;i++) rec[i][0]=read(),rec[i][1]=read(),rec[i][2]=read(), sma[i]=rec[i][0],sma[i+n]=rec[i][1]; sort(sma,sma+n+n); for(i=0,cnt=0;i&lt;n+n;i++)&#123; while(i&lt;n+n&amp;&amp;sma[i]==sma[i+1])i++; tmp[cnt++]=sma[i]; &#125; for(i=0;i&lt;cnt+cnt;i++) par[i]=i; for(i=0;i&lt;n;i++) rec[i][0]=lower_bound(tmp,tmp+cnt,rec[i][0])-tmp, rec[i][1]=lower_bound(tmp,tmp+cnt,rec[i][1])-tmp; //,printf("%d:%d %d\n",i,rec[i][0],rec[i][1]); &#125;int find(int a)&#123; if(par[a]==a)return a; return (par[a]=find(par[a]));&#125;inline void unite(int a,int b)&#123; par[find(a)]=find(b);&#125;bool solve()&#123; int i; for(i=0;i&lt;n;i++) if(rec[i][2]) unite(rec[i][0],rec[i][1]); for(i=0;i&lt;n;i++) if(!rec[i][2]) if(find(rec[i][0])==find(rec[i][1]))return false; return true;&#125;int main()&#123; T=read(); while(T--)&#123; pre(); printf("%s\n",solve()?"YES":"NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 数据结构（1）]]></title>
    <url>%2F2019%2F02%2F16%2Ftemplate-data-structure-1%2F</url>
    <content type="text"><![CDATA[数据结构的第一份模板。 并查集基本实现并查集是一个实现起来较为简单的数据结构。它维护的是一系列不相交集合，每一个集合都由该集合中的一个代表元表示。整个并查集实际上是一个森林，每一个元素$x$都有一个属性$fa[x]$作为$x$所在的树的父节点。树根的父节点设为它本身。这样只要不断沿着$fa[x]$走就能走到这一棵树的根，从而知道一个元素的归属。事实上整棵树的形态并不重要，因为我们需要知道的是一个元素所在树的根节点。因此可以在递归找根时，令经过路径上的节点的$fa$全部设为最后找到的根，这样可以方便之后的查询。这种优化称为路径压缩。路径压缩后的并查集查找操作的均摊时间复杂度是$O(\log n)$。并查集还要支持合并两个集合的操作。这个操作的基本实现方式是找出两个集合对应的树根，然后令其中一个根的$fa$设为另外一个树根。这时的合并是可以指定方向的，即指定新集合的代表元是哪一个根。如果不需要指定代表元就可以使用按秩合并。它是一种启发式合并。它将秩（一般定义为集合大小或者合并次数）较小的集合合并到秩较大的集合上，这样就只增加了小集合的查询代价。这样总共增加的总代价是$O(n\log n)$级别的。这时查询操作的均摊时间复杂度也是$O(\log n)$。两种优化都使用的并查集的查询时间复杂度近似于常数级别。12345678910111213141516171819202122int fa[100005], rank[100005], n;void init()&#123; for(int i = 1; i &lt;= n; ++i) fa[i] = i, rank[i] = 1;&#125;int Find(int x)&#123; if(x == fa[x]) return x; return (fa[x] = Find(fa[x]));&#125;void joint(int x, int y)&#123; int xa = Find(x), ya = Find(y); if(xa == ya) return ; if(rank[xa] &gt; rank[ya]) fa[ya] = xa, rank[xa] += rank[ya]; else fa[xa] = ya, rank[ya] += rank[xa];&#125;void joint(int from, int to)&#123; int xa = Find(from), ya = Find(to); if(xa == ya) return ; fa[xa] = ya;&#125; 基于并查集树的性质，可以将并查集的树边视作有向边或者无向边，这两种视角可以分别处理不同的问题。无向边的并查集常用于维护无向图的连通性。这在Kruskal算法中得到了体现。扩展一下：并查集擅长维护等价关系（集合即等价类）。有向边的并查集常用于维护一个数组中空闲和占用的情况。比如，可以令一个集合的根表示当前可用位置，如果占用了这个位置就把该位置所在集合和该位置之前的一个位置所在集合合并。也可以用来维护链状或者树形的关系。 带权并查集并查集的边可以拥有边权，而边权可以表示一些信息。带权并查集和普通并查集主要在两个地方有所不同：一是在查找操作中，路径压缩时要进行边权的更新；二是在合并操作中，要确定合并方向，以及合并中新产生的边的边权。根据不同的问题会有不同的处理方法。重点在于弄清楚边权的意义。12345678910111213int fa[100005], dis[100005], n;int Find(int x)&#123; if(x == fa[x]) return x; int rt = Find(fa[x]); //更新边权操作 return (fa[x] = rt);&#125;void joint(int from, int to)&#123; int xa = Find(from), ya = Find(to); if(xa == ya) return ; fa[xa] = ya; //更新dis[xa]&#125; 多重关系并查集联想到并查集能够维护一系列等价关系，我们可以将一个点拆成多个点，每一个点表示“满足某一个条件的集合”，如和x相同或者和x不同。这样如果题目中给出的都是双蕴含（或者异或）类型的条件，就可以利用这种并查集高效地维护这样的关系。典型例题：NOI2001 食物链 树状数组能用一个二进制数分出$O(\log n)$个小区间：从$[x - \text{lowbit}(x) + 1, x]$递归下去。利用这种思想，对于一个数组$a[i]$，可以构造出一个数组$c[i]$，其中$c[x] = \sum _{i=x - \text{lowbit}(x) + 1}^{x} a[i]$。树状数组就是这样一个数组。 单点修改，单点求值树状数组的基本模型是单点修改和求和。要修改$a[i]$，就要修改掉所有包含$a[i]$的$c[x]$。根据$c[x]$的公式，只有所有$x\ge i$且$\text{lowbit}(x) \ge \text{lowbit}(i)$的$x$满足条件。因此可以使用i += lowbit(i)不断获取下一个要更新的节点。要查询$a[1]+\cdots + a[r]$，就按照上面分区间的思想，使用r -= lowbit(r)不断获取下一个要累计的区间。上面两个操作的时间复杂度均为$O(\log n)$。12345678910111213int lowbit(int x)&#123; return (-x) &amp; x;&#125;void add(int k, int v)&#123; while(k &lt;= n) c[k] += v, k += lowbit(k);&#125;int query(int r)&#123; int res = 0; while(r) res += c[r], r -= lowbit(r); return res;&#125; 初始化初始化一个树状数组可以使用依次单点更新的方法，这样做是$O(n\log n)$的。实际上，可以使用和堆类似的建立方法，先对相邻的2个元素建立，再对相邻的4个元素建立，如此反复。这样做是$n+\frac{n}{2}+\frac{n}{4}+\cdots = O(n)$的。123456void build(int a[], int n)&#123; memcpy(c, a, sizeof(a)); for(int len = 2; len &lt;= n; len &lt;&lt;= 1) for(int i = len; i &lt;= n; i += len) c[i] += c[i - (len &gt;&gt; 1)];&#125; 区间修改，单点求值维护原来数列的差分数列即可。 区间修改，区间求值还是维护原来数列的差分数列。设$a[0]=0$，则$d[i] = a[i] - a[i - 1], a[i]=\sum_{j = 1}^{i}d[j]$。因此有 \sum_{i = 1}^{r} a[i] = \sum_{i = 1}^{r}\sum_{j = 1}^{i}d[j] = \sum_{i = 1}^{r} (r-i + 1)d[i] = (r+1)\sum_{i = 1}^{r} d[i] - \sum_{i = 1}^{r} i\times d[i]所以另外维护一个$i\times d[i]$的树状数组即可。1234567891011int c1[100005], c2[100005], n;void add(int r, int k)&#123; for(int i = r; i &lt;= n; i += lowbit(i)) c1[i] += k, c2[i] += k * r;&#125;ll query(int r)&#123; ll res = 0; for(int i = r; i &gt; 0; i -= lowbit(i)) res += 1ll * (r + 1) * c1[i] - c2[i]; return res;&#125; 扩展树状数组不仅能够维护前缀和，还能够维护其他具有和前缀有关的，具有和性质的量，如前缀最大值。 二维树状数组线段树线段树是一种比树状数组更为通用的数据结构：它将一个区间不断二分，父区间和子区间都作为树的节点，且最终形成一系列长度为0的叶子节点，并且对每一个区间节点附加一些信息以维护。线段树的这种结构使得它能在$O(\log n)$的时间内完成许多任务。 权值线段树权值线段树是线段树的一种，它的节点记录在该节点代表的区间内，出现过的数的个数。它常用于解决区间第$k$小/大问题。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 538 (Div. 2) 题解]]></title>
    <url>%2F2019%2F02%2F11%2Fcontest-cf1114%2F</url>
    <content type="text"><![CDATA[这次比赛好像出了很多常见题。。。 A题目大意：有三个人和三种葡萄，三个人分别要吃$x, y, z$个葡萄，三种葡萄分别有$a, b, c$个。第一个人只吃第一种葡萄，第二个人不吃第三种葡萄，第三个人什么葡萄都能吃。问三个人能不能吃够葡萄。 模拟。1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int x, y, z, a, b, c;void init()&#123; x = read(), y = read(), z = read(), a = read(), b = read(), c = read();&#125;void solve()&#123; int flag = 0; do&#123; if(x &gt; a) break; a -= x; if(y &gt; a + b) break; int res = a + b + c - y; if(z &gt; res) break; flag = 1; &#125;while(0); printf("%s\n", flag ? "YES": "NO");&#125;int main()&#123; init(); solve(); return 0;&#125; B题目大意：给定长度为$n$的数列，求一种方案，将数列划分为$k$段，每一段长度不小于$m$，并且使$\Sigma \text{每一段中前}m \text{大的数的和}$最大。 可以发现答案一定是整个数列前$mk$大数的和，所以只要考虑怎么划分即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, k;int a[200005], pos[200005];int gap[200005];pair&lt;int, int&gt; pp[200005];void init()&#123; n = read(), m = read(), k = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(), pp[i].first = -a[i], pp[i].second = i; sort(pp + 1, pp + n + 1); for(int i = 1; i &lt;= m * k; ++i) pos[i] = pp[i].second; sort(pos + 1, pos + m * k + 1);&#125;void solve()&#123; ll ans = 0; for(int i = 1; i &lt;= m * k; ++i)&#123; ans += 1ll * (-pp[i].first); if(i % m == 0) gap[i / m] = pos[i + 1] - 1; &#125; printf("%I64d\n", ans); for(int i = 1; i &lt; k - 1; ++i) printf("%d ", gap[i]); printf("%d\n", gap[k - 1]);&#125;int main()&#123; init(); solve(); return 0;&#125; C题目大意：求$n!$在$b$进制下末尾连续0的个数。 先考虑十进制的情况。可以发现，若十进制下$n!$末尾0个数为$k$，则$n!$就有$10^k$作为约数。由于$10=2\times 5$，这时只要计算$n!$的分解中$2, 5$的次数的较小值即可算出$k$。因为这个较小值说明了$n!$中至多只有这么多$10$的次幂。回到这一题。本题中末尾的0的个数由$b$的次幂构成，因而对$b$做分解，然后对$b$的每一个质因子$p^a$，算得$n!$分解中$p$的次数，设为$e$，得到该质因数最多可以贡献$\frac{e}{a}$个末尾0。对其取最小值即可。时间复杂度大约为$O(\sqrt{n} \log \sqrt{n})$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll n, b, ans;ll calc(ll x)&#123; ll res = 0; for(ll tt = x; ; )&#123; res += n / tt; if(1.0 * tt * x &gt; 1.0 * n) break; tt *= x; &#125; return res;&#125;void init()&#123; scanf("%I64d%I64d", &amp;n, &amp;b); ans = n;&#125;void solve()&#123; ll t = b; for(ll i = 2; i * i &lt;= b; ++i)&#123; if(t % i == 0)&#123; int al = 0; ll res = 1; do&#123; t /= i, al++, res *= i; &#125;while(t % i == 0); ans = min(ans, calc(i) / al); &#125; if(t == 1ll) break; &#125; if(t != 1ll)&#123; ans = min(ans, calc(t)); &#125; printf("%I64d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125; D题目大意：给定一个长度为$n$的线段，线段上每一段都染上了某种颜色，一次操作可以将一段连续的颜色转换为另一种颜色，求最少的操作次数使得整个线段都是同一种颜色。 先把段抽象成点，即把一段相同颜色的区间抽象称为一个该颜色的点。再设$f(i, j)$为使得$[i, j]$同色最少的操作次数。考虑整个区间的颜色都和区间的左/右端点相同，就有： f(i, j) = \begin{cases} f(i + 1, j - 1) + 1 \quad & \text{if color[i] = color[j]} \\ \min \lbrace f(i + 1, j) , f(i, j - 1) \rbrace + 1\quad & \text{if color[i]} \neq \text{color[j]} \\ \end{cases}1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, c[5005], cc[5005], cp = 0;int f[5005][5005];void init()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) c[i] = read(); for(int i = 1; i &lt;= n; )&#123; int j = i; while(j &lt;= n &amp;&amp; c[i] == c[j]) ++j; cc[++cp] = c[i]; i = j; &#125;&#125;void solve()&#123; memset(f, 0x3f, sizeof(f)); for(int i = 1; i &lt;= cp; ++i) f[i][i] = 0; for(int i = 1; i &lt; cp; ++i)&#123; for(int j = 1; j + i &lt;= cp; ++j)&#123; if(cc[j] == cc[j + i]) f[j][j + i] = min(f[j][j + i], f[j + 1][j + i - 1] + 1); else&#123; f[j][j + i] = min(f[j + 1][j + i] + 1, f[j][j + i]); f[j][j + i] = min(f[j][j + i - 1] + 1, f[j][j + i]); &#125; &#125; &#125; printf("%d\n", f[1][cp]);&#125;int main()&#123; init(); solve(); return 0;&#125; E题目大意：有一个长度为$n$，公差为$d(d&gt;0)$的等差数列。每一项大小都位于$[0, 10^9]$之间。你可以有2种询问方式：询问数列的第$k$项是多少，或者询问数列中有没有严格大于$x$的项。至多询问60次。目标是找出这个数列的最小值和公差。 首先用第二个询问找出数列的]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>二分</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1431 找出伪币]]></title>
    <url>%2F2019%2F02%2F09%2Fluogu1431%2F</url>
    <content type="text"><![CDATA[题目大意：给你$n$个硬币，其中有一枚假币，你可能会知道假币比真币轻或者重也可能不知道。再给你一个无刻度天平，问最少称几次可以保证找出假币并且知道它相对于真币是轻还是重。多组数据。 题解这是一道经典题，但在网上好像没有找到讲解。如果已知假币是更轻还是更重，那么判断就很方便。]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>信息论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 1 题解]]></title>
    <url>%2F2019%2F02%2F08%2Fcontest-cf1110%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷1329 数列]]></title>
    <url>%2F2019%2F02%2F07%2Fluogu1329%2F</url>
    <content type="text"><![CDATA[题目大意：求长度为$n$的数列\lbrace a_i\rbrace的数目，使得a_1=0，且\left| a_{i + 1} - a_{i}\right| =1，且数列前$n$项和为$S$。同时要求输出字典序最小的至多100个方案。 题解对于给定的这个条件，需要考虑差分数列。显然，根据条件，差分数列中每一个数只能是$1$或者$-1$。设$f(i, j)$为到第$i$项为止，为数列贡献的和为$j$的方案数目。转移时考虑第$i$项和第$i-1$项的差分是$1$还是$-1$，可以计算得到这一项的差分对数列总和的贡献为$n-i+1$或者$i-n-1$。从而得到转移方程: f(i, j) = f(i - 1, j + n - i + 1) + f(i - 1, j + i - n - 1)打印方案时先反过来，确定哪些状态是合法的，然后从头开始，一路沿着合法的转移行动即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define offset 5000using namespace std;typedef long long ll;int n, S, cnt = 0;ll f[105][10005] = &#123;0&#125;;bool able[105][10005] = &#123;0&#125;;int ans[105] = &#123;0&#125;, aans[105];void dfs(int cur, int SS)&#123; if(cnt == 100) return ; if(cur == n + 1)&#123; if(SS == S &amp;&amp; cnt &lt; 100)&#123; aans[1] = 0; for(int i = 1; i &lt; n; ++i) printf("%d ", aans[i]), aans[i + 1] = aans[i] + ans[i + 1]; printf("%d\n", aans[n]); cnt++; &#125; return ; &#125; if(able[cur][SS - (n - cur + 1) + offset]) ans[cur] = -1, dfs(cur + 1, SS - (n - cur + 1)); if(able[cur][SS + n - cur + 1 + offset]) ans[cur] = 1, dfs(cur + 1, SS + n - cur + 1);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; S; f[1][0 + offset] = 1; for(int i = 2; i &lt;= n; ++i)&#123; int lim = (n - 1 + n - i + 1) * (i - 1) / 2; for(int j = -lim + offset; j &lt;= lim + offset; ++j)&#123; f[i][j] = f[i - 1][j - (n - i + 1)] + f[i - 1][j + (n - i + 1)]; &#125; &#125; able[n][S + offset] = true; for(int i = n; i &gt;= 2; --i)&#123; int lim = (n - 1 + n - i + 1) * (i - 1) / 2; for(int j = -lim + offset; j &lt;= lim + offset; ++j)&#123; if(able[i][j]) able[i - 1][j + (n - i + 1)] = able[i - 1][j - (n - i + 1)] = true; &#125; &#125; cout &lt;&lt; f[n][S + offset] &lt;&lt; endl; dfs(2, 0); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 568A Primes or Palindromes?]]></title>
    <url>%2F2019%2F02%2F05%2Fcf568a%2F</url>
    <content type="text"><![CDATA[题目大意：给定一个有理数$A$，定于$S$为小于等于$N$的质数个数，$T$为小于等于$N$的回文数的个数。求一个最大的正整数$N$使得$S\le AT$。 题解由质数定理，$S\approx \frac{N}{\ln N}$，且容易看出$T\approx \sqrt N$（前一半等于后一半，一半的长度相当于开方）。可以推测$N$足够大时，$S&gt;T$。所以可以在一个范围内枚举。因为$A\le 42$，所以可以根据这个极端情况调整最大枚举的$N$的大小。大概是2e6以内。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int p, q;int prime[1000005], tot = 0, ans = 1;bool vis[2000005] = &#123;0&#125;;void init()&#123; p = read(), q = read();&#125;bool ispali(int x)&#123; if(x &lt; 10) return true; int t = 10; while(x &gt;= 10 * t) t *= 10; while(t &gt;= 10)&#123; if(x % 10 != x / t) return false; x %= t, x /= 10, t /= 100; &#125; return true;&#125;void solve()&#123; for(int i = 2; i &lt;= 2000000; ++i)&#123; if(!vis[i]) prime[++tot] = i; for(int j = 1; j &lt;= tot; ++j)&#123; if(1ll * prime[j] * i &gt; 2000000ll) break; vis[i * prime[j]] = true; if(i % prime[j] == 0) break; &#125; &#125; int cur = 1, sum1 = 1, sum2 = 0; for(int i = 2; i &lt;= 2000000; ++i)&#123; if(ispali(i)) sum1++; if(cur &lt;= tot &amp;&amp; prime[cur] == i) sum2++, cur++; if(1ll * q * sum2 &lt;= 1ll * p * sum1) ans = max(ans, i); &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 537 (Div. 2) 题解]]></title>
    <url>%2F2019%2F02%2F05%2Fcontest-cf1111%2F</url>
    <content type="text"><![CDATA[这次比赛难度适中，有一些题目的idea比较巧妙。 A题目大意：给定两个字符串，定义一次转换为将某一个元音（或者辅音）字母转换为另一个元音（或者辅音）字母。判断第一个字符串能否经过有限次数的转换得到第二个字符串。 只要判断两个字符串对应位置的字母种类是否相同即可。12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005], t[1005];void init()&#123; scanf("%s%s", s, t);&#125;bool isv(char ss)&#123; return ss == 'a' || ss == 'e' || ss == 'i' || ss == 'o' || ss == 'u';&#125;void solve()&#123; int len = strlen(s); if(strlen(t) != len)&#123; printf("No\n"); return ; &#125; for(int i = 0; i &lt; len; ++i)&#123; if(isv(s[i]) ^ isv(t[i]))&#123; printf("No\n"); return ; &#125; &#125; printf("Yes\n");&#125;int main()&#123; init(); solve(); return 0;&#125; B题目大意：给定长度为$n$的数列。定义一次操作为：将数列中一个数移除，或者将其中一个数加1。总共可以做$m$次操作，对一个数最多做$k$次操作。求操作后数列（非空）均值的最大值。 枚举删除序列的长度。长度一定时，删去数列中最小的那些数，给剩下的数进行自增是最优操作。因此对原序列排序，构造前缀和，然后枚举长度，计算并更新答案即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, k, m, a[100005];ll sum[100005];void init()&#123; n = read(), k = read(), m = read(); sum[0] = 0; for(int i = 1; i &lt;= n; ++i) a[i] = read();&#125;void solve()&#123; sort(a + 1, a + n + 1); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + 1ll * a[i]; if(n == 1) &#123; printf("%d\n", a[1] + min(k, m)); &#125;else&#123; double ans = 0; for(int i = 0; i &lt;= min(n - 1, m); ++i)&#123; ll tt = sum[n] - sum[i] + min(1ll * k * (n - i), 1ll * (m - i)); ans = max(ans, (double)tt / (n - i)); &#125; printf("%.15lf\n", ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; C题目链接 分治，先对每个敌人所在位置排序，然后设$solve(l, r, l’, r’)$返回的是长度区间是$[l’, r’]$，敌人下标为$l$到$r$，且敌人的坐标全部在区间内的代价。然后分类讨论： 区间内没有敌人，直接返回$A$。 区间内有敌人，设$mid’=\frac{l’+r’}{2}$，二分出$mid$使得下标从$l$到$mid$的敌人全部在$[l’, mid’]$上，下标从$mid+1$到$r$的敌人全部在$[mid’+1, r’]$上，然后返回$\min\lbrace B(r-l+1)(r’-l’+1),solve(l, mid, l’, mid’)+solve(mid+1, r, mid’+1, r’) \rbrace$。前者表示直接消灭这一段的代价，后者表示分两半消灭的代价。 这个算法的时间复杂度感觉是比$O(nk\log k)$小？12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, k, A, B;int pos[100005];ll solve1(int hd, int tl, int st, int ed, int rk)&#123; if(tl &lt; hd) return A; if(ed == st) return 1ll * B * (tl - hd + 1); ll res = 1ll * B * (tl - hd + 1) * (ed - st + 1); int mid = (st + ed) &gt;&gt; 1, cur; cur = upper_bound(pos + hd, pos + tl + 1, mid) - pos; res = min(res, solve1(hd, cur - 1, st, mid, rk - 1) + solve1(cur, tl, mid + 1, ed, rk - 1)); return res;&#125;void init()&#123; n = read(), k = read(), A = read(), B = read(); for(int i = 1; i &lt;= k; ++i) pos[i] = read(); sort(pos + 1, pos + 1 + k);&#125;void solve()&#123; printf("%I64d\n", solve1(1, k, 1, 1 &lt;&lt; n, n));&#125;int main()&#123; init(); solve(); return 0;&#125; D题目大意：给定一个偶数长度的字符串，可以将字符串中的任意两个字符交换位置。定义一个串是合法的，当且仅当该串中某一种类的字符全部出现在串的前半部分或者后半部分。有$q$次询问，每次询问求下标为$x$和$y$的字符在同一个半部分时，不同的合法的串数目。 只有52种字符，而询问高达1e5次，显然要预处理出所有答案。合法串数目的计算可以归约为背包问题和组合问题，前者把一种字符的数目抽象为物品的体积，串长的一半抽象为背包的容纳量，后者考虑字符分配完之后排列的种数。根据公式答案为\frac{(\frac{n}{2} !)^2}{\prod n_i!}，其中$n$为串长，n_i为每一种字符的数目。现在考虑删去两个物品之后的背包问题如何从原问题得到。因为背包问题中，物品的顺序不影响最终答案，因此可以假定这两个物品是最后考虑的。之前的遍历方式是体积从大到小加，现在要减就从小到大减，即：12for(int k = w[j]; k &lt;= (n &gt;&gt; 1); ++k)&#123; ff[k] -= ff[k - w[j]]; 这样就可以去除掉一个物品的影响。如此，整个算法的时间复杂度为$O(2704n+q)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define INF 2000000000#define P 1000000007using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[100005];int n, f[50005] = &#123;0&#125;, ans[55][55] = &#123;0&#125;, w[55] = &#123;0&#125;;int ff[50005] = &#123;0&#125;, cons;int dfac[50005], inv[50005];int getid(char c)&#123; return islower(c) ? c - 'a' + 26: c - 'A';&#125;void init()&#123; scanf("%s", s); n = strlen(s); for(int i = 0; i &lt; n; ++i) w[getid(s[i])]++; dfac[0] = dfac[1] = inv[1] = 1; int fac = 1; for(int i = 2; i &lt;= (n &gt;&gt; 1); ++i)&#123; inv[i] = 1ll * (P - P / i) * inv[P % i] % P; fac = 1ll * fac * i % P; dfac[i] = 1ll * dfac[i - 1] * inv[i] % P; &#125; cons = 1ll * fac * fac % P; for(int i = 0; i &lt; 52; ++i) if(w[i] &lt;= (n &gt;&gt; 1)) cons = 1ll * cons * dfac[w[i]] % P; else &#123; cons = 0; break; &#125; f[0] = 1; for(int i = 0; i &lt; 52; ++i)&#123; if(!w[i]) continue; for(int j = (n &gt;&gt; 1); j &gt;= w[i]; --j) f[j] = (f[j] + f[j - w[i]]) % P; &#125; for(int i = 0; i &lt; 52; ++i)&#123; for(int j = i; j &lt; 52; ++j)&#123; memcpy(ff, f, sizeof(f)); for(int k = w[i]; k &lt;= (n &gt;&gt; 1); ++k)&#123; ff[k] -= ff[k - w[i]]; if(ff[k] &lt; 0) ff[k] += P; &#125; if(i != j)&#123; for(int k = w[j]; k &lt;= (n &gt;&gt; 1); ++k)&#123; ff[k] -= ff[k - w[j]]; if(ff[k] &lt; 0) ff[k] += P; &#125; &#125; ans[i][j] = ans[j][i] = ff[n &gt;&gt; 1]; &#125; &#125;&#125;void solve()&#123; int q = read(); while(q--)&#123; int i = read() - 1, j = read() - 1; printf("%d\n", 2ll * cons * ans[getid(s[i])][getid(s[j])] % P); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; E题目大意：给定一棵无根树，有$q$个询问，每次询问给出$k$个节点编号，要求该树以$r$为根时，这$k$个节点分为最多$m$个非空组的方案数目，且要求不能有节点是同一组内另一节点的祖先。 假设1是根，那么设$f[i][j]$为分完前$i$个点，分为$j$组的方案数。有 f[i][j]=f[i-1][j]\times (j-anc[i]) +f[i-1][j-1]其中$anc[i]$表示第$i$个节点之前有多少个节点是它的祖先，为了使转移更方便，应当对节点序列排序使得$anc[i]$不下降，这样后面节点的祖先在前面就可以全部出现了。前一个式子表示可以把第$i$个顶点分配到已存在的组里，后一个式子表示可以第$i$个点自成一组。再考虑根不定的情形。可以发现难点在于计算$anc[i]$。事实上，一个点是另一个点的祖先表明它出现在了该点到根的路径上，因此问题转化为快速统计两点间路径上被标定了的点数目。这个用树的DFS序+BIT+LCA可以解决。（树剖应该也可以）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, q, to[200005], nxt[200005], at[100005] = &#123;0&#125;, cnt = 0;int vs[200005], lvs = 0, dep[100005], dfn[100005];int f[200005][20] = &#123;0&#125;, in[100005], out[100005], D = 0;int dp[100005][305], bit[200005] = &#123;0&#125;, par[100005];int lis[100005], lis2[100005];inline int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int k, int r)&#123; while(r &lt;= n + n) bit[r] += k, r += lowbit(r);&#125;int _q(int r)&#123; int res = 0; while(r) res += bit[r], r -= lowbit(r); return res;&#125;void dfs(int cur, int fa)&#123; vs[++lvs] = cur, dfn[cur] = lvs, dep[cur] = dep[fa] + 1; in[cur] = ++D, par[cur] = fa; for(int i = at[cur]; i; i = nxt[i])&#123; if(to[i] == fa) continue; dfs(to[i], cur), vs[++lvs] = cur; &#125; out[cur] = ++D;&#125;inline int minp(int u, int v)&#123; return dep[u] &lt; dep[v] ? u: v;&#125;void build_ST()&#123; for(int i = 1; i &lt;= lvs; ++i) f[i][0] = vs[i]; int logg = 1; while((1 &lt;&lt; logg) &lt; lvs) logg++; for(int i = 1; i &lt; logg; ++i)&#123; int p = (1 &lt;&lt; i); for(int j = 1; j + p - 1 &lt;= lvs; ++j) f[j][i] = minp(f[j][i - 1], f[j + (p &gt;&gt; 1)][i - 1]); &#125; f[1][logg] = minp(f[1][logg - 1], f[1 &lt;&lt; (logg - 1)][logg - 1]);&#125;int query(int l, int r)&#123; if(l &gt; r) swap(l, r); int od = 0; while((1 &lt;&lt; od) &lt;= (r - l + 1)) od++; od--; return minp(f[l][od], f[r - (1 &lt;&lt; od) + 1][od]);&#125;int calc(int u, int v)&#123; int lca = query(dfn[u], dfn[v]); return _q(in[u]) + _q(in[v]) - _q(in[lca]) - _q(in[par[lca]]);&#125;void init()&#123; n = read(), q = read(); for(int i = 1; i &lt; n; ++i)&#123; int u = read(), v = read(); to[++cnt] = v, nxt[cnt] = at[u], at[u] = cnt; to[++cnt] = u, nxt[cnt] = at[v], at[v] = cnt; &#125; dep[0] = 0, in[0] = 0, dfs(1, 0); build_ST();&#125;void solve()&#123; while(q--)&#123; int k = read(), m = read(), r = read(); for(int i = 1; i &lt;= k; ++i) lis2[i] = read(), add(1, in[lis2[i]]), add(-1, out[lis2[i]]); for(int i = 1; i &lt;= k; ++i) lis[i] = calc(lis2[i], r) - 1; for(int i = 1; i &lt;= k; ++i) add(-1, in[lis2[i]]), add(1, out[lis2[i]]); sort(lis + 1, lis + k + 1); dp[0][0] = 1; for(int i = 1; i &lt;= k; ++i)&#123; int lim = min(i, m); for(int j = 1; j &lt;= lim; ++j)&#123; if(j &lt;= lis[i]) dp[i][j] = 0; else dp[i][j] = (1ll * dp[i - 1][j] * (j - lis[i]) + dp[i - 1][j - 1]) % 1000000007; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= m; ++i) ans = (ans + dp[k][i]) % 1000000007; printf("%d\n", ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 小结这次比赛失误挺多，总共贡献了5发WA，还只写出来3道题目。。。不过收获也很多。D题背包的逆是一个巧妙的想法，E中先建立转移方程，再根据转移方程中的关键变量可以发现问题的本质所在，这一点很值得参考。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>背包DP</tag>
        <tag>贪心</tag>
        <tag>树形DP</tag>
        <tag>字符串</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 536 (Div. 2) 题解]]></title>
    <url>%2F2019%2F02%2F03%2Fcontest-cf1106%2F</url>
    <content type="text"><![CDATA[学长出题orz，不过cf服务器炸了也是。。。 A题目大意：给定一个字符矩阵，如果某个字符及其左上，左下，右上，右下的临近字符都是X那么就说以该字符为中心构成一个“X”。求中心不同的“X”个数。 遍历找一遍就行了。1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;char mat[505][505] = &#123;0&#125;;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)&#123; scanf("%s", &amp;mat[i][1]); &#125; int ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(mat[i][j] == 'X' &amp;&amp; mat[i + 1][j + 1] == 'X' &amp;&amp; mat[i - 1][j - 1] == 'X' &amp;&amp; mat[i + 1][j - 1] == 'X' &amp;&amp; mat[i - 1][j + 1] == 'X') ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B题目链接 按照题目的意思进行模拟即可。因为不同菜品之间的价格不会变，所以可以直接在开始时对所有菜品排序，然后用一个指针指示当前最便宜的菜品的编号。之后就是按题意模拟了。本题有一个坑，就是如果菜没了cost就直接置为0了。。。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pp;int n, m;int a[100005], c[100005];ll ans[100005] = &#123;0&#125;;pp p[100005];int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;c[i]), p[i].first = c[i], p[i].second = i; sort(p + 1, p + n + 1); int cur = 1; for(int i = 1; i &lt;= m; ++i)&#123; int t, d; scanf("%d%d", &amp;t, &amp;d); if(a[t] &gt;= d) ans[i] += 1ll * d * c[t], a[t] -= d; else&#123; ans[i] += 1ll * a[t] * c[t], d -= a[t], a[t] = 0; while(d)&#123; while(cur &lt;= n &amp;&amp; a[p[cur].second] == 0) cur++; if(cur &gt; n) break; int id = p[cur].second; int bb = min(a[id], d); ans[i] += 1ll * bb * c[id]; a[id] -= bb, d -= bb; &#125; if(cur &gt; n) &#123; ans[i] = 0; break; &#125; &#125; &#125; for(int i = 1; i &lt;= m; ++i) printf("%I64d\n", ans[i]); return 0;&#125; C题目大意：给定$n$个数，求一种划分，将所有数分为若干组，每个组至少包含两个数，使得$\Sigma\text{每一个组内数的和的平方}$最小。 贪心。可以证明当每个组里只有2个元素的时候答案可以最小，然后组合方式就是当前最小元素搭配当前最大元素。123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[300005];ll ans = 0;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); sort(a + 1, a + n + 1); for(int i = 1; i &lt;= (n &gt;&gt; 1); ++i) ans += 1ll * (a[i] + a[n - i + 1]) * (a[i] + a[n - i + 1]); printf("%I64d\n", ans); return 0;&#125; D题目大意：给定一张无向图，起点在1处，每走过一个之前没有经过的顶点就会将这个顶点的编号写在之前顶点编号的后面，形成一个顶点编号序列。显然序列的开头是1。每一条边和每一个顶点都可以重复经过。求一个序列，使其字典序最小。 一开始以为是强连通分量分解，后来发现也是一个贪心。先把1放入小根堆，然后每次取出堆顶元素，设其为$v$，与$v$相邻的且未经过的点放进堆里，如此反复就可以得到答案。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Edge&#123; int v, nxt;&#125;;Edge e[200005];int at[100005], cnt = 0;int V, E;int in[100005] = &#123;0&#125;; int st[100005], top = 0;int ans[100005];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;void addEdge(int u, int v)&#123; e[++cnt].v = v, e[cnt].nxt = at[u], at[u] = cnt;&#125;int main()&#123; scanf("%d%d", &amp;V, &amp;E); for(int i = 1; i &lt;= E; ++i)&#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; in[1] = true, ans[1] = 1; for(int i = at[1]; i; i = e[i].nxt)&#123; if(in[e[i].v]) continue; pq.push(e[i].v), in[e[i].v] = true; &#125; for(int i = 2; i &lt;= V; ++i)&#123; int dd = pq.top(); pq.pop(); ans[i] = dd; for(int j = at[dd]; j; j = e[j].nxt)&#123; if(in[e[j].v]) continue; pq.push(e[j].v), in[e[j].v] = true; &#125; &#125; for(int i = 1; i &lt; V; ++i) printf("%d ", ans[i]); printf("%d\n", ans[V]); return 0;&#125; E题目链接 容易看出每一个时间点Bob的动作是唯一确定的，所以可以先用排序和堆处理出每一个时间点的动作。然后DP，设$f(i, j)$为第$i$天结束时，用了$j$次妨碍机会后，所得到的钱的最小值。那么在一个时间点，如果有红包可抢，如果抢就用$f(i-1, j)+w$更新$f(d, j)$，不抢就用$f(i-1, j-1)$更新$f(i, j)$。没有红包抢就用$f(i-1, j)$更新$f(i, j)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;pair&lt;int, int&gt;, int&gt; ppp;int n, m, k;int l[100005], r[100005], mon[100005], d[100005];ll f[100005][205] = &#123;0&#125;, ans = 0;pair&lt;int, int&gt; pp[100005];priority_queue&lt;ppp&gt; pq;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= k; ++i) scanf("%d%d%d%d", &amp;l[i], &amp;r[i], &amp;d[i], &amp;mon[i]), pp[i].first = l[i], pp[i].second = i, ans += mon[i]; sort(pp + 1, pp + k + 1); memset(f, 0x3f, sizeof(f)); f[0][0] = 0; int cur = 1; for(int i = 1; i &lt;= n; ++i)&#123; while(cur &lt;= k &amp;&amp; pp[cur].first == i)&#123; int id = pp[cur].second; pq.push(make_pair(make_pair(mon[id], d[id]), r[id])); cur++; &#125; if(pq.empty())&#123; f[i][0] = min(f[i - 1][0], f[i][0]); for(int j = 1; j &lt;= m; ++j)&#123; f[i][j] = min(f[i - 1][j], f[i][j]); f[i][j] = min(f[i - 1][j - 1], f[i][j]); &#125; &#125;else&#123; ppp pt = pq.top(); int curd = pt.first.second; ll curm = pt.first.first; f[curd][0] = min(f[curd][0], f[i - 1][0] + curm); for(int j = 1; j &lt;= m; ++j)&#123; f[curd][j] = min(f[curd][j], f[i - 1][j] + curm); f[i][j] = min(f[i][j], f[i - 1][j - 1]); &#125; &#125; while(!pq.empty() &amp;&amp; pq.top().second &lt;= i) pq.pop(); &#125; for(int i = 0; i &lt;= m; ++i) ans = min(ans, f[n][i]); printf("%I64d\n", ans); return 0;&#125; F题目大意：给定一个递推数列： f_i = (\prod_{j = 1}^{k} f_{i - j}^{b_j})\mod p其中$i&gt;k, p=998244353$。已知k, n, f_n, b_1, \cdots, b_k，且f_1=\cdots=f_{k-1}=1，求f_k的可能值。 由于$f$的前$k-1$项全部是$1$，所以可以只考察f_n中f_k的指数。这个可以用快速幂来做。已知指数和幂求底数，这就是一个经典的k次剩余问题，由于本题没有额外的限制，所以使用原根和BSGS算法解决。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int c[10005] = &#123;0&#125;, bb[10005] = &#123;0&#125;, tmp[20005] = &#123;0&#125;;int k, n, m, b[105];const int p = 998244353;void mul(int *a1, int *a2)&#123; for(int i = 0; i &lt;= (k &lt;&lt; 1); ++i) tmp[i] = 0; for(int i = 0; i &lt;= k; ++i)&#123; for(int j = 0; j &lt;= k; ++j)&#123; tmp[i + j] = (tmp[i + j] + 1ll * a1[i] * a2[j]) % (p - 1); &#125; &#125; for(int i = k &lt;&lt; 1; i &gt;= k; --i)&#123; for(int j = 0; j &lt; k; ++j)&#123; tmp[i - k + j] = (tmp[i - k + j] + 1ll * tmp[i] * b[k - j]) % (p - 1); &#125; tmp[i] = 0; &#125; for(int i = 0; i &lt; k; ++i) a1[i] = tmp[i];&#125;void poww(int *a1, int t, int *a2)&#123; while(t)&#123; if(t &amp; 1) mul(a2, a1); mul(a1, a1), t &gt;&gt;= 1; &#125;&#125;int poww_i(int a, int b, int c)&#123; a %= c; int res = 1; while(b)&#123; if(b &amp; 1) res = (1ll * res * a) % c; a = (1ll * a * a) % c, b &gt;&gt;= 1; &#125; return res;&#125;int extgcd(int a, int b, int &amp;x, int &amp;y)&#123; int d = a; if(b) d = extgcd(b, a % b, y, x), y = y - (a / b) * x; else x = 1, y = 0; return d;&#125;int inv(int x, int m)&#123; int u, v; if(extgcd(x, m, u, v) != 1) return -1; return u &lt; 0 ? u + m: u;&#125;int BSGS(int y, int z, int m)&#123; map&lt;int, int&gt; rec; int s = (int)floor(sqrt(m - 1) + 0.5), cur = 1; int v = inv(poww_i(y, s, m), m); if(v == -1) return -1; for(int i = 0; i &lt; s; ++i) rec[cur] = i, cur = 1ll * cur * y % m; for(int i = 0; i &lt;= s; ++i)&#123; if(rec.count(z)) return i * s + rec[z]; z = 1ll * z * v % m; &#125; return -1;&#125;int main()&#123; scanf("%d", &amp;k); for(int i = 1; i &lt;= k; ++i) scanf("%d", &amp;b[i]); scanf("%d%d", &amp;n, &amp;m); bb[1] = 1, c[0] = 1; if(k &gt; 1) poww(bb, n - 1, c); //c[k - 1] else c[k - 1] = poww_i(b[1], n - 1, p - 1); int exp1 = BSGS(3, m, p), u, v; int d = extgcd(c[k - 1], p - 1, u, v); if(exp1 % d) printf("-1\n"); else&#123; u = (u + p - 1) % (p - 1); u = 1ll * (exp1 / d) * u % (p - 1); printf("%d\n", poww_i(3, u, p)); &#125; return 0;&#125; 小结这次比赛相对而言比较看重基本功，并没有什么非常难的题目（然鹅我还是只A了4题orz）。不过这次比赛的失误比较多，先是在A和B上各贡献了一发WA，又是在F上把k次剩余看成了离散对数。。。导致排名比较难看。总之：线上比赛要拼手速，更要拼准确度；要巩固好数学基础；掌握更好的DP姿势。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4992 Primitive Roots]]></title>
    <url>%2F2019%2F02%2F02%2Fhdu4992%2F</url>
    <content type="text"><![CDATA[题目大意：给定正整数$n$，求出$n$的所有原根。多组数据。 题解模板题，但这个题卡时间卡的比较紧，所以要先用线性筛筛出质数，顺便预处理出每一个范围内的数的欧拉函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma G++ optimize(2)#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int p, pri[105], cnt, ans[1000005], len;int phi[1000005], prime[500005], tot = 0;bool vis[1000005] = &#123;0&#125;, ok[1000005] = &#123;0&#125;;void getPhi(int N)&#123; phi[1] = 1; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; prime[++tot] = i, phi[i] = i - 1; if(i &amp; 1)&#123; for(int j = i; ; j *= i)&#123; ok[j] = true; if(j + j &lt;= N) ok[j + j] = true; if(1ll * j * i &gt; N) break; &#125; &#125; &#125; for(int j = 1; j &lt;= tot; ++j)&#123; ll t = 1ll * i * prime[j]; if(t &gt; N) break; vis[t] = true, phi[t] = phi[i] * (prime[j] - 1); if(i % prime[j] == 0)&#123; phi[t] += phi[i]; break; &#125; &#125; &#125;&#125;int poww(int a, int b, int M)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (1ll * res * a) % M; a = (1ll * a * a) % M, b &gt;&gt;= 1; &#125; return res;&#125;void getFac(int x)&#123; cnt = 0; int t = x; for(int i = 1; i &lt;= 168; ++i)&#123; if(t % prime[i] == 0)&#123; do&#123; t /= prime[i]; &#125;while(t % prime[i] == 0); pri[++cnt] = prime[i]; &#125; if(t == 1) break; &#125; if(t != 1) pri[++cnt] = t;&#125;bool judge_pr(int x)&#123; if(poww(x, phi[p], p) != 1) return false; for(int i = 1; i &lt;= cnt; ++i) if(poww(x, phi[p] / pri[i], p) == 1) return false; return true;&#125;int get_pr(int p)&#123; for(int i = 2; i &lt;= p; ++i) if(judge_pr(i)) return i; return -1;&#125;int gcd(int a, int b)&#123; return (!b) ? a: gcd(b, a % b);&#125;void solve()&#123; if(p == 1 || p == 2) &#123; printf("1\n"); return ; &#125; if(p == 4) &#123; printf("3\n"); return ; &#125; if(!ok[p])&#123; printf("-1\n"); return ; &#125; getFac(phi[p]); int res = get_pr(p); len = 0, ans[++len] = res; for(int i = 2, j = 1ll * res * res % p; i &lt; phi[p]; ++i, j = 1ll * j * res % p)&#123; if(gcd(i, phi[p]) == 1) ans[++len] = j; &#125; sort(ans + 1, ans + len + 1); for(int i = 1; i &lt; len; ++i) printf("%d ", ans[i]); printf("%d\n", ans[len]);&#125;int main()&#123; getPhi(1000000); while(~scanf("%d", &amp;p))&#123; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa10559 Blocks]]></title>
    <url>%2F2019%2F01%2F28%2Fuva10559%2F</url>
    <content type="text"><![CDATA[题目大意：有$n$个带有颜色的方块，消除一段长度为$x$的连续的相同颜色的方块可以得到$x^2$的分数，求一种最优的消除顺序消除所有方块使得得分最多。 题解设$f(i, j, k)$为当前区间为$[i, j]$，且区间中消除到有$k$个和$i$处颜色相同的方块时，可以得到的最大分数。显然，答案为$f(1, n, 0)$。当$k\neq 0$时，要考虑从$k-1$转移过来。此时考虑从$[i, j]$中遍历$l$，当第$l$个方块颜色和第$i$个相同时，将从$l$左或者从$l$右开始的一部分作为从$k-1$转移过来的部分，另一部分消去。因为消去的顺序不影响结果，此处将右边一半消去。从而有： f(i, j, k) = \max_{i\le l\le j}\lbrace f(i, l - 1, k - 1) + f(l + 1, j, 0) \rbrace当$k=0$时，考虑将积累下来的方块消去，就有： f(i, j, 0) = \max\lbrace f(i, j, k) + k^2\rbrace12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[205] = &#123;0&#125;;int f[205][205][205] = &#123;0&#125;;int main()&#123; int T; scanf("%d", &amp;T); for(int TT = 1; TT &lt;= T; ++TT)&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i) f[i][i][1] = 0, f[i][i][0] = 1; for(int i = 0; i &lt;= n; ++i) for(int j = i - 1; j &gt;= 0; --j) f[i][j][0] = 0; f[n + 1][n][0] = 0; for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j + i &lt;= n; ++j)&#123; for(int k = 1; k &lt;= i + 1; ++k)&#123; for(int l = j; l &lt;= j + i; ++l)&#123; if(a[j] != a[l]) continue; if(f[j][l - 1][k - 1] &gt;= 0) f[j][j + i][k] = max(f[j][j + i][k], f[j][l - 1][k - 1] + f[l + 1][j + i][0]); &#125; &#125; for(int k = 1; k &lt;= i + 1; ++k)&#123; if(f[j][j + i][k] &gt;= 0) f[j][j + i][0] = max(f[j][j + i][0], f[j][j + i][k] + k * k); &#125; &#125; &#125; printf("Case %d: %d\n", TT, f[1][n][0]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nowcoder-hanjia]]></title>
    <url>%2F2019%2F01%2F28%2Fnowcoder-hanjia%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 10C Digital Root]]></title>
    <url>%2F2019%2F01%2F28%2Fcf10c%2F</url>
    <content type="text"><![CDATA[题目大意：定义$d(x)$为$x$的“数字根”，给定$N$，求三元组$(A, B, C)(A, B, C\in [1, N])$的个数，其中$d(d(A)d(B))=d(C)$且$AB\neq C$。 题解可以发现$d(xy)=d(d(x)y)=d(d(x)d(y))$。所以可以先求出所有不包含条件$AB\neq C$的三元组的数目N_1，然后减掉包含该条件的三元组的数目N_2。 N_2容易求出，等同于$1, \cdots, N$每一个数的约数的数目之和，即N_2=\sum_{i=1}^{N} \lfloor \frac{N}{i} \rfloor。 N_1也容易求，由$d(xy)=d(d(x)d(y))$可知对于不同的$A, B$，$d(AB)$具有周期性。故可以先求出$N=9$的情况，然后根据周期性算出N_1。（这里可以想象一个$N\times N$的棋盘上相邻的$9\times 9$宫格之间情况是相同的）答案就是N_1-N_2。12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int n, ss[10][10][10] = &#123;0&#125;;long long ans = 0, cnt[10] = &#123;0&#125;;int dr(int x)&#123; return (x % 9 ? x % 9: 9);&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= 9; ++i)&#123; for(int j = 1; j &lt;= 9; ++j)&#123; ss[i][j][dr(i * j)]++; for(int k = 1; k &lt;= 9; ++k) ss[i][j][k] += ss[i][j - 1][k]; &#125; &#125; for(int i = 1; i &lt;= 9; ++i) for(int j = 1; j &lt;= 9; ++j) for(int k = 1; k &lt;= 9; ++k) ss[i][j][k] += ss[i - 1][j][k]; long long res = 0; for(int i = 1; i &lt;= n; ++i)&#123; res += 1ll * (n / i); &#125; int kk = n / 9, r = n % 9; for(int i = 1; i &lt;= 9; ++i) cnt[i] += 1ll * kk * kk * ss[9][9][i], cnt[i] += 2ll * kk * ss[r][9][i], cnt[i] += 1ll * ss[r][r][i]; for(int i = 1; i &lt;= 9; ++i) ans += ((n + 9 - i) / 9) * cnt[i]; cout &lt;&lt; ans - res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 59 题解]]></title>
    <url>%2F2019%2F01%2F28%2Fcontest-cf1107%2F</url>
    <content type="text"><![CDATA[这场比赛区分度比较大。E，F，G题均比较难。 A题目大意：给定一个数字串，求一种方法将该串分割成至少两个非空部分，并且每个部分形成的数从左到右严格递增。如123456，可以分割成3个部分1，23，456。 由于没有更多的限制条件，所以可以直接把这个串分割成两个部分，前一部分只包含第一个数字。这样如果串长大于2就必然可行，否则需要特判。1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;char s[305];int main()&#123; int q; cin &gt;&gt; q; while(q--)&#123; cin &gt;&gt; n; scanf("%s", s); if(n == 2)&#123; if(s[1] &lt;= s[0]) printf("NO\n"); else printf("YES\n2\n%c %c\n", s[0], s[1]); &#125;else&#123; printf("YES\n2\n%c %s\n", s[0], s + 1); &#125; &#125; return 0;&#125; B题目大意：给定$k, x$，求第$k$个“数字根”为$x$的数。多组询问。 知道了数字根的性质这道题就会做了。答案就是$9(k-1)+x$。12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;ll q, x;int main()&#123; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; q &gt;&gt; x; cout &lt;&lt; (q - 1ll) * 9ll + x &lt;&lt; endl; &#125; return 0;&#125; C题目链接 可以发现我们只要对字符串分段处理即可，即对于每一个连续的相同字母构成的串，只要取其中能获得的分数最大的$k$个字母进行敲击即可。用排序或者堆都可以，时间复杂度$O(n\log n)$。1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, k;int a[200005];char s[200005];ll ans = 0;int tmp[200005], cnt = 0;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); scanf("%s", s + 1); for(int i = 1; i &lt;= n; )&#123; int j = i; ll sum = 0; while(j &lt;= n &amp;&amp; s[i] == s[j]) sum += 1ll * a[j], j++; if(j - i &lt;= k)&#123; ans += sum; &#125;else&#123; for(cnt = 0; cnt + i &lt; j; ++cnt) tmp[cnt] = a[i + cnt]; sort(tmp, tmp + cnt); for(int t = 0; t &lt; k; ++t) ans += 1ll * tmp[cnt - 1 - t]; &#125; i = j; &#125; printf("%I64d\n", ans); return 0;&#125; D题目大意：找到最大的$x$使得$n\times n$的01矩阵$A$能被压缩成为$\frac{n}{x} \times \frac{n}{x}$矩阵$B$，使得$\forall i \in [1, n], j \in [1, n], A[i][j] = B[\lceil \frac{n}{x} \rceil][\lceil \frac{n}{x} \rceil]$。 大暴力。枚举$n$的约数，从大到小判断即可。所谓判断，即判断每一个$x\times x$的矩阵中的数据是否完全相同。使用二维前缀和辅助判断过程。注意不要写成二分$x$，因为答案不一定有单调性。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;int ds[10005], cnt = 0;int ma[5205][5205], sum[5205][5205] = &#123;0&#125;;char s[1305];bool judge(int x)&#123; for(int i = x; i &lt;= n; i += x) for(int j = x; j &lt;= n; j += x)&#123; int res = sum[i][j] - sum[i - x][j] - sum[i][j - x] + sum[i - x][j - x]; if(res &gt; 0 &amp;&amp; res &lt; x * x) return false; &#125; return true;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) if(n % i == 0) ds[++cnt] = i; for(int i = 1; i &lt;= n; ++i)&#123; scanf("%s", s + 1); int tt = n &gt;&gt; 2; for(int j = 1; j &lt;= tt; ++j)&#123; int re = (isdigit(s[j]) ? s[j] - '0': s[j] - 'A' + 10); for(int k = 1, t = 4; k &lt;= 8; k &lt;&lt;= 1, --t) if(k &amp; re) ma[i][(j - 1) * 4 + t] = 1; else ma[i][(j - 1) * 4 + t] = 0; &#125; &#125; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) sum[i][j] = sum[i][j - 1] + ma[i][j]; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) sum[i][j] += sum[i - 1][j]; int ans = 1; for(int i = cnt; i &gt;= 2; --i)&#123; if(judge(ds[i]))&#123; ans = ds[i]; break; &#125; &#125; printf("%d\n", ans); return 0;&#125; E题目大意：给定一个01串，每次可以对一段0或者一段1进行消除，得到的分数和长度有关，消除之后被消除的段的两侧合并。求整个串被全部消除时最大的分数。 这道题的状态设计非常有意思。容易将当前区间的两端位置加入到状态中，但这还不够。设$f(dig, i, j, k)$为当前区间为$[i, j]$，且区间中消除到有$k$个$dig$时，可以得到的最大分数。显然，答案为$f(0, 1, n, 0)$。这样就能方便的转移了。当$k\neq 0$时，要考虑从$k-1$转移过来。此时考虑从$[i, j]$中遍历$l$，令$dig=s[l]$，并将从$l$左或者从$l$右开始的一部分作为从$k-1$转移过来的部分，另一部分消去。因为消去的顺序不影响结果，此处将左边一半消去。从而有： f(dig, i, j, k) = \max_{i\le l\le j, dig=s[l]}\lbrace f(0, i, l - 1, 0) + f(dig, l + 1, j, k - 1) \rbrace当$k=0$时，考虑将积累下来的数消去，就有： f(0, i, j, 0) = \max\lbrace f(dig, i, j, k) + a[k]\rbrace123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[105] = &#123;0&#125;;char s[105];int sum[105] = &#123;0&#125;;ll f[2][105][105][105] = &#123;0&#125;;int main()&#123; scanf("%d%s", &amp;n, s + 1); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + s[i] - '0'; memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i)&#123; if(s[i] == '0')&#123; f[0][i][i][1] = 0; &#125;else&#123; f[1][i][i][1] = 0; &#125; f[0][i][i][0] = f[1][i][i][0] = a[1]; &#125; for(int i = 1; i &lt;= n; ++i) for(int j = i - 1; j &gt;= 0; --j) f[0][i][j][0] = f[1][i][j][0] = 0; for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j + i &lt;= n; ++j)&#123; int lim = max(i + 1 - (sum[j + i] - sum[j - 1]), sum[j + i] - sum[j - 1]); for(int k = 1; k &lt;= lim; ++k)&#123; for(int l = j; l &lt; j + i; ++l)&#123; int sig = s[l] - '0'; ll &amp;dp = f[sig][j][j + i][k]; if(f[sig][l + 1][j + i][k - 1] &gt;= 0) dp = max(dp, f[0][j][l - 1][0] + f[sig][l + 1][j + i][k - 1]); &#125; &#125; int sig = s[j + i] - '0'; ll &amp;dp = f[sig][j][j + i][1]; dp = max(dp, f[0][j][j + i - 1][0]); for(int k = 1; k &lt;= lim; ++k)&#123; if(f[0][j][j + i][k] &gt;= 0) f[0][j][j + i][0] = max(f[0][j][j + i][k] + a[k], f[0][j][j + i][0]); if(f[1][j][j + i][k] &gt;= 0) f[0][j][j + i][0] = max(f[1][j][j + i][k] + a[k], f[0][j][j + i][0]); &#125; f[1][j][j + i][0] = f[0][j][j + i][0]; &#125; &#125; printf("%I64d\n", f[0][1][n][0]); return 0;&#125; 事实上，根据上面所述，可以将状态改设为$f(i, j, k)$，压掉$dig$一维，将$dig$锁定为$i$位置的数。这样也可以进行状态转移。转移方法和上面基本相同。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[105] = &#123;0&#125;;char s[105];int sum[105] = &#123;0&#125;;ll f[105][105][105] = &#123;0&#125;;int main()&#123; scanf("%d%s", &amp;n, s + 1); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + s[i] - '0'; memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i) f[i][i][1] = 0, f[i][i][0] = a[1]; for(int i = 0; i &lt;= n; ++i) for(int j = i - 1; j &gt;= 0; --j) f[i][j][0] = 0; f[n + 1][n][0] = 0; for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j + i &lt;= n; ++j)&#123; int lim = max(i + 1 - (sum[j + i] - sum[j - 1]), sum[j + i] - sum[j - 1]); for(int k = 1; k &lt;= lim; ++k)&#123; for(int l = j; l &lt;= j + i; ++l)&#123; if(s[j] != s[l]) continue; if(f[j][l - 1][k - 1] &gt;= 0) f[j][j + i][k] = max(f[j][j + i][k], f[j][l - 1][k - 1] + f[l + 1][j + i][0]); &#125; &#125; for(int k = 1; k &lt;= lim; ++k)&#123; if(f[j][j + i][k] &gt;= 0) f[j][j + i][0] = max(f[j][j + i][0], f[j][j + i][k] + a[k]); &#125; &#125; &#125; printf("%I64d\n", f[1][n][0]); return 0;&#125; F题目大意：有$n$份贷款，每一份贷款有三个参数$a, b, k$，表示贷款当月可以获得$a$元，之后$k$个月每个月要还$b$元。一个月最多贷一次款，一种款只能贷一次。求某个月可能可以持有的金额的最大值。 建立矩阵A_{ij}=a_j-\min\lbrace i, b_j\rbrace \cdot k_j，每一列表示一种贷款带来的收益/负债。问题转化为从这$n\times n$矩阵中选出$n$个数，使得每个数所在行列均不相交，并且和最大。这是一个经典问题，用匈牙利算法可以解决。12]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 535 (Div. 3) 题解]]></title>
    <url>%2F2019%2F01%2F25%2Fcontest-cf1108%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 534 题解]]></title>
    <url>%2F2019%2F01%2F23%2Fcontest-cf1103and1104%2F</url>
    <content type="text"><![CDATA[我坑我自己本次比赛中有亮点的题目：Div2 D(Div1 B)。 Div2 A题目大意：给定一个数$n$，求出它的一种整数分拆a_1, \cdots, a_n，使得对于任何$i$有1\le a_i \le 9，且使得a_i中不同的数种数尽量少。 所以全输出1就行了。就一种数。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;int main()&#123; scanf("%d", &amp;n); printf("%d\n", n); for(int i = 0; i &lt; n - 1; ++i) printf("1 "); printf("1\n"); return 0;&#125; Div2 B题目大意：给定只包含小写字母的字符串$s$，两个人对串做操作，一个人可以选择串中任意一个相邻的相同字母对删去，然后另一个人操作，如此反复，最后无法操作的人输。假设两人足够聪明，判断输赢情况。 类似于括号序列，用一个栈处理消除事件，最后根据总共消去的对数的奇偶性判断即可。123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[100005];int n, cnt = 0, top = 0;char st[100005] = &#123;0&#125;;int main()&#123; scanf("%s", s); n = strlen(s); for(int i = 0; i &lt; n; ++i)&#123; if(top &amp;&amp; st[top - 1] == s[i]) top--, cnt++; else st[top++] = s[i]; &#125; printf("%s\n", cnt % 2 == 0 ? "No" : "Yes"); return 0;&#125; Div2 C(Div1 A)题目大意：（太长不说，看这里） 只要找到一种可行性方案即可，一种简单的做法是把最左边一列专门用来放竖直的牌，中间两列用来放横着的牌。另外一种是仿照样例构造模式，具体见代码。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[10005];int main()&#123; scanf("%s", s); int len = strlen(s); int modee = 0; for(int i = 0; i &lt; len; i += 2)&#123; if(len - i == 1) break; if(s[i] == '0')&#123; if(s[i + 1] == '0')&#123; if(modee == 0) printf("1 1\n3 1\n"); else printf("3 1\n1 1\n"); &#125;else&#123; if(modee == 0) printf("1 1\n1 2\n"), modee = 1; else printf("1 4\n2 2\n"), modee = 0; &#125; &#125;else&#123; if(s[i + 1] == '0')&#123; if(modee == 0) printf("1 2\n1 1\n"), modee = 1; else printf("2 2\n1 4\n"), modee = 0; &#125;else&#123; if(modee == 0) printf("1 1\n1 3\n"); else printf("3 1\n3 3\n"); &#125; &#125; &#125; if(len % 2 == 1) printf("3 3\n"); return 0;&#125; Div2 D(Div1 B)题目大意：根据提问结果猜一个数$a$，每次提问给出2个数$x, y$，返回x（或y），表示$x \mod a \ge y \mod a$（或$x \mod a &lt; y \mod a$）。至多提问60次。 很少见的一个交互题。这道题基于一个倍增的想法：首先询问$(0, 1)$，如果答案在$(0, 1]$上那么就会返回x，否则再询问$(1, 2)$，如果答案在$(1, 2]$上就返回x，否则再询问$(2, 4)$…如此反复，根据归纳法，询问到$(n, 2n)$的时候，已经能够确认$a$不在$[1, n]$上了，因此如果返回值是x就可以判断$a$落在当前区间上。依照此法找到$a$所在区间之后，按照上面的方法再对所在区间二分即可。由于$\log n \approx 30$，因此询问在60次内可以完成。1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[105];int main()&#123; for(; ; )&#123; scanf("%s", s); if(s[0] == 'e') break; int l = 0, r = 1; for(; ; )&#123; printf("? %d %d\n", l, r); fflush(stdout); scanf("%s", s); if(s[0] == 'x') break; l = r, r &lt;&lt;= 1; &#125; while(r - 1 &gt; l)&#123; int mid = (r + l) &gt;&gt; 1; printf("? %d %d\n", l, mid); fflush(stdout); scanf("%s", s); if(s[0] == 'x') r = mid; else l = mid; &#125; printf("! %d\n", r); fflush(stdout); &#125; return 0;&#125; Div2 E(Div1 C)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 533 (Div. 2) 题解]]></title>
    <url>%2F2019%2F01%2F21%2Fcontest-cf1105%2F</url>
    <content type="text"><![CDATA[感觉这次比较简单…? A题目链接 一个简单的贪心。对每一个棍子，设其长度为$k$，分别选取$k+1,k,k-1$作为$t$，然后求出总代价，选总代价最小的方案即可。123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[1005], ans = 2000000000, t = 0;int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; n; ++i)&#123; for(int j = max(1, a[i] - 1); j &lt;= a[i] + 1; ++j)&#123; int s = 0; for(int k = 0; k &lt; n; ++k)&#123; if(abs(a[k] - j) &lt;= 1) continue; if(a[k] &gt; j) s += a[k] - j - 1; else s += j - a[k] - 1; &#125; if(s &lt; ans) ans = s, t = j; &#125; &#125; printf("%d %d\n", t, ans); return 0;&#125; B题目链接 先用类似滑动窗口的方法找到这些子串并在相应子串的末尾处打上标记，然后DP即可。设$f(i, j)$表示到第$i$位为止，所有已选择的子串均包含字母$j$+&#39;a&#39;的情况下，不相交子串的最大数目，则： f(i, j) = max\lbrace f(i-1, j), f(i-k, j)+a(i, j)\rbrace其中$a(i, j)$表示以下标为$i$的字符为结尾的子串是否存在，存在为$1$，不存在为$0$。1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;char s[200005];int n, k, f[200005][27] = &#123;0&#125;;int cnt[27] = &#123;0&#125;;int main()&#123; scanf("%d%d%s", &amp;n, &amp;k, s); for(int i = 0; i &lt; k; ++i) cnt[s[i] - 'a']++; if(cnt[s[0] - 'a'] == k) f[k - 1][s[0] - 'a']++; for(int i = k; i &lt; n; ++i)&#123; cnt[s[i - k] - 'a']--, cnt[s[i] - 'a']++; if(cnt[s[i] - 'a'] == k) f[i][s[i] - 'a']++; &#125; int ans = 0; for(int i = 0; i &lt; 26; ++i) ans = max(ans, f[k - 1][i]); for(int i = k; i &lt; n; ++i) for(int j = 0; j &lt; 26; ++j) f[i][j] = max(f[i][j] + f[i - k][j], f[i - 1][j]), ans = max(ans, f[i][j]); printf("%d\n", ans); return 0;&#125; C题目链接 分别算出$l$和$r$之间有多少模$3$余$0, 1, 2$的数，然后按数列的每一位，根据到这一位为止的数列之和的模$3$余数DP。具体见代码。123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, l, r, c1, c2, c3;ll f[200005][4] = &#123;0&#125;, M = 1000000007;int main()&#123; scanf("%d%d%d", &amp;n, &amp;l, &amp;r); int t1, t2; t1 = (l - 2) / 3, t2 = (r - 1) / 3; c1 = t2 - t1; if(l == 1) c1++;//特判1 f[0][1] = c1; t1 = (l - 3) / 3, t2 = (r - 2) / 3; c2 = t2 - t1; if(l &lt;= 2 &amp;&amp; r &gt;= 2) c2++;//特判2 f[0][2] = c2; t1 = (l - 1) / 3, t2 = r / 3; c3 = t2 - t1, f[0][0] = c3; //printf("%d %d %d\n", c1, c2, c3); for(int i = 1; i &lt; n; ++i)&#123; f[i][0] = ((f[i - 1][1] * c2) % M + (f[i - 1][2] * c1) % M + (f[i - 1][0] * c3) % M) % M; f[i][1] = ((f[i - 1][2] * c2) % M + (f[i - 1][0] * c1) % M + (f[i - 1][1] * c3) % M) % M; f[i][2] = ((f[i - 1][0] * c2) % M + (f[i - 1][1] * c1) % M + (f[i - 1][2] * c3) % M) % M; &#125; printf("%I64d\n", f[n - 1][0]); return 0;&#125; D题目链接 一个大模拟，每一回合对每一个人做一次BFS即可。注意可能有格子被障碍围了起来，无法接触！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pp;int n, m, p, s[11], cur[11] = &#123;0&#125;;int grid[1005][1005] = &#123;0&#125;, cnt = 0;vector&lt;pp&gt; inte[11];char ss[1005];int que[2000005][3], hd = 0, ra = 0;int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;;void expand(int id)&#123; for(int &amp;i = cur[id]; i &lt; inte[id].size(); ++i) que[ra][0] = inte[id][i].first, que[ra][1] = inte[id][i].second, que[ra++][2] = 0; while(ra &gt; hd)&#123; int xx, yy, step; xx = que[hd][0], yy = que[hd][1], step = que[hd++][2]; if(step == s[id]) continue; for(int i = 0; i &lt; 4; ++i)&#123; int cx = xx + dx[i], cy = yy + dy[i]; if(cx &lt; 0 || cx &gt;= n || cy &lt; 0 || cy &gt;= m) continue; if(grid[cx][cy] == 0) grid[cx][cy] = id + 1, cnt++, que[ra][0] = cx, que[ra][1] = cy, que[ra++][2] = step + 1, inte[id].push_back(make_pair(cx, cy)); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for(int i = 0; i &lt; p; ++i) scanf("%d", &amp;s[i]), s[i] = min(s[i], n + m); for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", ss); for(int j = 0; j &lt; m; ++j) if(isdigit(ss[j]))&#123; int id = ss[j] - '0' - 1; inte[id].push_back(make_pair(i, j)); grid[i][j] = id + 1; cnt++; &#125;else if(ss[j] == '#') grid[i][j] = -1, cnt++; &#125; while(cnt != n * m)&#123; int flag = 0; for(int i = 0; i &lt; p; ++i)&#123; int ori = inte[i].size(); expand(i); if(ori &lt; inte[i].size()) flag = 1; &#125; if(!flag) break; &#125; for(int i = 0; i &lt; p - 1; ++i) printf("%d ", inte[i].size()); printf("%d\n", inte[p - 1].size()); return 0;&#125; E题目链接 可以发现多个1事件连在一起时效果和只有一个1事件是一样的，所以在读入时可以做处理。考虑每一个1事件后跟着的一连串2事件。在这一连串2事件中，如果有两个不同的人，那么就出现“有我没他”的局面，选了一个人另一个人就不能选。因此可以考虑向图论问题转化，把人视作点，如果出现了上述局面就在两个人之间连一条边，然后问题变为求该图的最大独立集。用求补图最大团的方法解决。顺带一提，这题时限很紧，要用各种压位。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, m, tot = 0, lis[45], cnt = 0, ans = 0;map&lt;string, int&gt; mp;ll conn[45] = &#123;0&#125;;int count1(ll x)&#123; int res = 0; while(x)&#123; if(x &amp; 1) res++; x &gt;&gt;= 1; &#125; return res;&#125;void bron_kerbosch(ll R, ll P, ll X)&#123; if(!P &amp;&amp; !X)&#123; ans = max(ans, count1(R)); return ; &#125; ll pv = P | X, P_ = P; int id = 0; while(((1ll &lt;&lt; id) &amp; pv) == 0) id++; P_ -= (P_ &amp; conn[id]); for(ll i = 1, j = 0; i &lt;= P_; i &lt;&lt;= 1, ++j)&#123; if(!(i &amp; P)) continue; bron_kerbosch(R | i, P &amp; conn[j], X &amp; conn[j]); P ^= i, X |= i; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); char name[45]; int d; scanf("%d", &amp;d); for(int i = 1; i &lt; n; )&#123; int j = i, d; for(; j &lt; n; )&#123; scanf("%d", &amp;d); if(d == 1) j++; else break; &#125; if(j == n) break; cnt = 0; ll in = 0; for(; j &lt; n; )&#123; scanf("%s", name); string st(name); if(!mp.count(st)) mp[st] = ++tot; int id = mp[st] - 1; if(!((1ll &lt;&lt; id) &amp; in))&#123; in += (1ll &lt;&lt; id), lis[cnt] = id; for(int k = 0; k &lt; cnt; ++k) conn[id] |= (1ll &lt;&lt; lis[k]), conn[lis[k]] |= (1ll &lt;&lt; id); cnt++; &#125; if(j &lt; n - 1) scanf("%d", &amp;d); if(d == 2) j++; else break; &#125; i = j + 2; &#125; ll mask = (1ll &lt;&lt; m) - 1ll; for(int i = 0; i &lt; m; ++i) conn[i] ^= mask, conn[i] ^= (1ll &lt;&lt; i); bron_kerbosch(0, (1ll &lt;&lt; m) - 1, 0); printf("%d\n", ans); return 0;&#125; 小结时隔很长时间的一次CF，因为题目比较容易没有看起来太菜，但是E还是没有写出来。。。知识漏洞补全刻不容缓。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>线性DP</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（七） 进阶语法]]></title>
    <url>%2F2019%2F01%2F01%2Fpython-7%2F</url>
    <content type="text"><![CDATA[第七篇学习笔记，内容包含Python中一些进阶语法，如条件控制，循环控制等。 条件控制用if...elif...else语句进行条件控制。每一个条件之后都需要使用冒号，每一个代码块都要使用缩进来标志。如：123456if a == 1: b = 1elif a == 2: b = 2else a == 3: b = 3 python中没有switch...case型的语句。条件控制可以缩写在一行之中，形成所谓的“三目运算符”。其表达形式为val1 if exp else val2，即如果exp为True则运算结果为val1，exp为False则运算结果为val2。如：1234&gt;&gt;&gt; b = 9&gt;&gt;&gt; a = 1 if b &gt; 5 else 2&gt;&gt;&gt; a1 循环语句用while...或者for...来实现循环。 while语句在使用while语句时采用以下的格式：1234while &lt;judgement&gt;: &lt;statements&gt;else: &lt;statements&gt; 后面的else是在条件为False的时候执行的，相当于一个收尾语句，收完这个尾之后退出整个循环体。如：123456789&gt;&gt;&gt; a = 1&gt;&gt;&gt; while a == 1:... print("a is 1")... a = a + 1... else:... print("a is not 1")...a is 1a is not 1 要执行一个死循环的时候可以这么写：12while True: ... 使用break语句来终止一个循环。若使用break中止，则else部分不会执行。如果循环体只有一条语句，那么可以将while和这条语句写在一行。不过这一般没有什么用处。python中没有do...while循环。 for语句for结构的一般形式如下：1234for &lt;variable&gt; in &lt;seq&gt;: &lt;statements&gt;else: &lt;statements&gt; 当for循环到末尾时就执行else处的语句并退出整个循环体。如：1234567891011list1 = [1, 2, 3]for i in list1: passelse: print(i)# 输出为3for i in range(10): passelse: print(i)# 输出为9 使用break语句来终止一个循环。若使用break中止，则else部分不会执行。有一些函数经常会和for循环搭配使用。如：range()函数。该函数产生一系列等距的数。其语法为range(start, stop[, step])，三个参数均为整数，表示从start开始按step的步长到stop为止。如：123for i in range(0, 10, 4): print(i)# 输出为0 4 8 enumerate函数。该函数可以生成一系列的index-item对，即索引-元素对（为元组）。该函数一般需要传入2个参数，第一个参数为可迭代对象；第二个参数是下标的初始值，缺省值为0。一般的使用方法如下：12for index, item in enumerate(thelist, start): ... 注意，这个初始值并不是指从哪里开始，而是计数时从哪一个值开始计数。比如初始值为1，那么就按1, 2, 3, …的方式数数；初始值是0，就按照0, 1, 2, …的方式数数。 断言使用assert语句进行断言，如果断言失败就抛出AssertionError的异常。 try结构此部分在异常部分会进行介绍。 del语句可以使用del语句删除对象引用（即解除变量名称和具体数据之间的绑定），也可以移除数据结构中具体的某部分（如列表中的值，字典的键值对等）。它不直接删除值，因为值会通过垃圾回收的方式进行移除。 del语句的语法是del var1[,var2[,var3[....,varN]]]]，这意味着可以一次性删除多个目标。示例如下：1234567891011121314&gt;&gt;&gt; v = 1&gt;&gt;&gt; v1&gt;&gt;&gt; del v # 删去某个对象引用&gt;&gt;&gt; vTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'v' is not defined&gt;&gt;&gt; s = [1, 2, 3, 4, 5]&gt;&gt;&gt; del s[3: 5] # 删除切片的方式删除一整段&gt;&gt;&gt; s[1, 2, 3]&gt;&gt;&gt; u, v, w = 1, 2, 3&gt;&gt;&gt; del u, v, s[0: 1] # 删除多个目标]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（六） 数据结构]]></title>
    <url>%2F2019%2F01%2F01%2Fpython-6%2F</url>
    <content type="text"><![CDATA[第六篇学习笔记，内容包含Python中常用的数据结构：元组（tuple），列表（list），字典（dictionary），集合（set）四种。 元组元组是一种非常简单的结构，它类似于数学上的序对，属于不可变类型。它的优点在于运行效率比列表要高。 定义定义一个元组只需要在圆括号中添加元素，并使用逗号隔开即可（圆括号可以省略）。如：123456&gt;&gt;&gt; a = (1, 2, 3)&gt;&gt;&gt; type(a)&lt;class 'tuple'&gt;&gt;&gt;&gt; tp = 12, 3, 4&gt;&gt;&gt; tp(12, 3, 4) 空元组即为()。元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。如：123456789&gt;&gt;&gt; b = (50)&gt;&gt;&gt; type(b)&lt;class 'int'&gt;&gt;&gt;&gt; b = (50, )&gt;&gt;&gt; type(b)&lt;class 'tuple'&gt;&gt;&gt;&gt; tp = 12,&gt;&gt;&gt; tp(12,) 生成一个元组使用tuple()函数将一个列表或者一个字符串（一个可迭代结构也可以）转换成为一个元组。当参数是列表的时候，元组中包含的就是列表中的元素。参数是字符串的话字符串的每一位就会被拆开，放到列表中的每一位中去。 访问元组中的元素访问方式和字符串基本相同，可以使用下标也可以使用切片（切片得到的是元组）。如：12345&gt;&gt;&gt; tp1 = (1, 2, 3, 4)&gt;&gt;&gt; tp1[0]1&gt;&gt;&gt; tp1[2: 4](3, 4) 元组的运算元组的+，*运算方法和字符串相似，前者用于前后连接，后者用于重复。在此不赘述。使用in运算符可以获取一个元素是否在元组中。 元组的修改元组不允许修改，因此只能通过运算生成新元组或者使用del将整个元组删除。试图修改元组的元素会报错，如：12345678&gt;&gt;&gt; tp1[0] = 1Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment&gt;&gt;&gt; del tp1[0]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object doesn't support item deletion 元组在赋值中的应用事实上，同时赋值的基础就是元组。可以将同时赋值时右边的式子看作是一个元组，这样就可以理解为左边的被赋值对象和右边元组中的元素一一对应。提供以下例子用于理解：1234&gt;&gt;&gt; tp = 1, 2, 3&gt;&gt;&gt; a, b, c = tp&gt;&gt;&gt; print(a, b, c)1 2 3 但是右边不能有多个元组，如：123456&gt;&gt;&gt; tp = 1, 2, 3&gt;&gt;&gt; tp1 = 4, 5, 6&gt;&gt;&gt; a, b, c, d, e, f = tp, tp1Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: not enough values to unpack (expected 6, got 2) 这种方法称为packing（把元素打包）和unpacking（把元素解包）。 列表列表是一种类似于其他编程语言中数组的存在，但它的功能比数组更为强大。它的数据项不需要具有相同的数据类型。python中列表是链式储存的，这和数组有很大的不同。 定义列表的形式是用中括号括起来一些用逗号分隔开来的数据。空列表仅仅包含一对中括号。如：12list1 = [1, 2, 3]list_empty = [] 生成一个列表可以使用list()函数将一个元组或者一个字符串（一个可迭代结构也可以）转换成为一个列表。当参数是元组的时候，列表中包含的就是元组中的元素。参数是字符串的话字符串的每一位就会被拆开，放到列表中的每一位中去。生成一个列表还可以使用列表推导式（在后续笔记中提及）。 列表的嵌套列表可以层层嵌套，从而实现类似于多维数组（或者矩阵）的功能。如：1a = [[1, 2], [3, 4], [5, 6]] # (3*2)矩阵 访问列表中的元素访问方式和字符串基本相同，可以使用下标也可以使用切片（切片得到的是列表）。如：12345&gt;&gt;&gt; list1 = [1, 2, 3, 4]&gt;&gt;&gt; list1[0]1&gt;&gt;&gt; list1[2: 4][3, 4] 添加列表元素可以用列表的append(val)方法在列表的末尾添加一个元素val。也可以用列表的insert(index, val)方法在下标为index处添加一个元素val，然后将原来index处的元素以及其后面的元素都向后移动一位。使用extend(list)方法可以在列表的末尾一次性按顺序添加上一个另一个列表的全部元素。 删除列表元素使用del语句可以删除列表中若干个元素，如：1234&gt;&gt;&gt; list1 = [1, 2, 3, ]&gt;&gt;&gt; del list1[0], list1[1]&gt;&gt;&gt; list1[2] 可以使用列表的pop(index = -1)方法来删除列表的下标为index的元素，并且将这一个元素返回。index参数缺省时为-1，即为最后一个元素的下标。如：12345&gt;&gt;&gt; list1 = [1, 2, 3, ]&gt;&gt;&gt; print(list1.pop())3&gt;&gt;&gt; list1[1, 2] 也可以用remove(val)方法删除从前到后，列表中第一个值为val的元素。如果没有这样的元素就会报错。如：12345678&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; list1.remove(3)&gt;&gt;&gt; list1[1, 2, 4, 3]&gt;&gt;&gt; list1.remove(5)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list1.remove(x): x not in list1 列表的运算列表的+，*运算方法和字符串相似，前者用于前后连接，后者用于重复。在此不赘述。使用in运算符可以获取一个元素是否在列表中。 组织列表对列表排序使用sort(reverse = False)方法对列表进行永久性的排序，这个方法会改变列表中元素的顺序。其中缺少reverse参数时默认为升序排序，加上reverse = True时会降序排序。如：1234567&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; list1.sort()&gt;&gt;&gt; list1[1, 2, 3, 3, 4]&gt;&gt;&gt; list1.sort(reverse = True)&gt;&gt;&gt; list1[4, 3, 3, 2, 1] 使用sorted(list, reverse = False)函数可以将list进行临时的排序，这不会改变list内部数据的排列顺序。如：1234567&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; sorted(list1)[1, 2, 3, 3, 4]&gt;&gt;&gt; sorted(list1, reverse = True)[4, 3, 3, 2, 1]&gt;&gt;&gt; list1[1, 2, 3, 4, 3] 翻转列表使用reverse()方法永久性翻转列表。如：1234&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; list1.reverse()&gt;&gt;&gt; list1[3, 4, 3, 2, 1] 列表的其他实用方法查找使用count(val)方法可以查找列表中值为val的元素个数。不存在这样的元素的时候会简单地返回0。如：123&gt;&gt;&gt; list1 = [3, 4, 3, 2, 1]&gt;&gt;&gt; list1.count(0)0 使用index(val)方法可以查找从前到后，列表中第一个值为val的元素，并返回它的下标。如果没有这样的元素就会报错。如：1234567&gt;&gt;&gt; list1 = [3, 4, 3, 2, 1]&gt;&gt;&gt; list1.index(0)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 0 is not in list1&gt;&gt;&gt; list1.index(3)0 清除用clear()方法清除列表中的所有元素。 复制用切片操作或者copy()方法可以获得一份当前列表的副本。 字典字典保存的是对象间的映射关系，在python中用大括号表示。它是另一种可变容器模型，且可存储任意类型对象。字典和列表、元组不同，没有+和*运算符。字典在python3.6版本之后默认保持插入时的顺序。 创建一个字典字典中键-&gt;值的映射是通过冒号来表示的，按如下方式即可创建一个字典：1dict1 = &#123;1: 2, 2: 3&#125; 其中键必须是唯一而不可变的。但值没有这样的限制。使用dict()函数也可以创建一个字典。该函数的语法比较复杂，以下举一些例子： 不传入参数，返回一个空字典。如dict1 = dict()，得到{}。 传入的参数是一个字典，则返回该字典。如dict1 = dict({&#39;a&#39;: 1, &#39;b&#39;: 2})，得到{&#39;a&#39;: 1, &#39;b&#39;: 2}。 传入的参数是由二元组构成的列表，则返回由这些二元组构成的字典。若键发生重复则以后面出现的键值对为准。如dict1 = dict([(12, 25), (13, 14), (12, 28)])，得到{12: 28, 13: 14}。 按关键字形式传入参数，则返回由“关键字-参数”键值对构成的字典。如dict1 = dict(a = 1, b = 2)，得到{&#39;a&#39;: 1, &#39;b&#39;: 2}。 传入的参数是zip类型的对象，则和3的情况类似。如dict1 = dict(zip([1, 2, 3, 2], [4, 5, 6, 7]))，得到{1: 4, 2: 7, 3: 6}。 传入的参数是dict.items类型，则返回由该参数包含的键值对构成的字典（相当于将此字典还原）。如dict1 = dict({1: 2}.items())，得到{1: 2}。 也可以使用字典推导式创建字典（在后续笔记中提及）。也可以使用一些字典的方法实现字典的创建，具体见下。 访问一个字典将键作为索引可以得到键对应的值。如果没有这样的键就会报错。可以使用get()方法防止报错。该方法语法是dict.get(key, default = None)，可以获取key对应的值，如果这个值不存在就返回default。使用key in dict可以判断一个键是否在字典中，但不能判断值是否在字典中。使用for key in dict也是按照键对字典进行遍历。 修改一个字典修改键对应的值将键作为索引并赋值可以改变键对应的值。如果没有这样的键就会在字典中增加一个这样的键-值对。如：123dict1 = &#123;&#125; # 空字典dict1['a'] = 1 # 创建一个新键-值对dict1['a'] = 2 # 修改键对应的值 删除键-值对使用del可以删除键-值对。如：12dict1 = &#123;1: 2, 2: 3&#125;del dict1[1] # 删除这个键对应的键-值对 如果要删除的键不存在会报出KeyError异常。可以使用pop()方法防止报错。该方法语法是pop(key[, default])，key为要删除的键，如果key存在就返回被删除的值，不存在就返回default（此时如果省略default会报出KeyError异常）。使用popitem()方法可以删除字典中的某一个键值对。至于是哪一个就只有python知道。如果此时字典为空，则报错。 字典相关方法求字典的大小使用len()函数可以求出字典中键的数目。 求字典的键/值/键-值对方法keys()，values()，items()分别返回dict_keys，dict_values，dict_items类型的迭代器，它们分别含有字典的所有键，值和键-值对。可以使用list()方法将这些迭代器转换成为列表使用。可以使用for语句遍历这三种结构，如：1234for k in dict1.values(): passfor k, v in dict1.items(): pass 打印字典将字典作为str()函数的参数即可按照特定格式将字典输出。 清空字典使用clear()方法清空字典。 复制字典用copy()方法可以产生一个字典的副本。 创建字典使用fromkeys()方法可以创建一个新的字典。它的语法是dict.fromkeys(seq[, value])（fromkeys()是类方法），其中seq是键的列表（该列表中可以包含相同元素），value为新字典中所有键对应的初始值，缺省时为None。该方法返回一个字典。值得一提的是，在该方法中，初始值被“复制”了。而做实验可以发现该复制是浅复制。如下程序：1234&gt;&gt;&gt; dict1 = dict.fromkeys([1, 2], [2, 3])&gt;&gt;&gt; dict1[1][0] = 0&gt;&gt;&gt; dict1&#123;1: [0, 3], 2: [0, 3]&#125; # 列表全部被改变了!!! 合并字典字典合并有多种方法。以下均以dict1和dict2合并为dict3来举例。方法一是使dict3 = dict(list(dict1.items()) + list(dict2.items()))。由此可看出，当dict1和dict2中有相同的键时，后者会覆盖前者。如：12345&gt;&gt;&gt; dict1 = &#123;1: 2, 2: 4&#125;&gt;&gt;&gt; dict2 = &#123;1: 3&#125;&gt;&gt;&gt; dict3 = dict(list(dict1.items()) + list(dict2.items()))&gt;&gt;&gt; dict3&#123;1: 3, 2: 4&#125; 方法二是使dict3 = dict(dict1, **dict2)。此时dict2中的键值对会覆盖dict1的。该方法容易扩展到多个字典合并到一个字典的情况，即dictn = dict(dict1, **dict2, **dict3, ...)。对于多合并的情况，要注意后面加了两个星号的字典两两不能有重复的键，且键必须为字符串。如：12345&gt;&gt;&gt; dict1 = &#123;'a': 1, 'b': 2&#125;&gt;&gt;&gt; dict2 = &#123;'c': 3, 'd': 4&#125;&gt;&gt;&gt; dict3 = dict(dict1, **dict2)&gt;&gt;&gt; dict3&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; 方法三是遍历字典并把键值对放入新字典中。该方法比较直观，不赘述。方法四是使用字典的update()方法。该方法将一个字典的键值对更新到调用方法的字典中，如有重复则覆盖。如：12345&gt;&gt;&gt; dict1 = &#123;1: 2, 3: 4&#125;&gt;&gt;&gt; dict2 = &#123;2: 5, 1: 6&#125;&gt;&gt;&gt; dict1.update(dict2)&gt;&gt;&gt; dict1&#123;1: 6, 3: 4, 2: 5&#125; 集合集合在数学上是一个包含无序的不重复元素的结构。在Python中也是如此。 定义集合的形式是用大括号括起来一些用逗号分隔开来的数据。如：123&gt;&gt;&gt; a = set((1, 2, 3, 4, 5, 5, 6))&gt;&gt;&gt; a&#123;1, 2, 3, 4, 5, 6&#125; 需要注意的是，空集合并不是一对大括号，而是这样的形式：123&gt;&gt;&gt; a = set()&gt;&gt;&gt; aset() 生成一个集合可以使用set()函数将一个可迭代结构/序列转换成为一个集合。参数是字符串的话字符串的每一位就会被拆开，去重后放入集合。生成一个集合还可以使用集合推导式（在后续笔记中提及）。 添加集合元素使用add()方法向集合内添加一个元素。如果该元素已经存在则不进行操作。如：123456&gt;&gt;&gt; a = set((1, 2, 3, 4))&gt;&gt;&gt; a&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; a.add(1)&gt;&gt;&gt; a&#123;1, 2, 3, 4&#125; 也可以使用update()方法一次性添加多个元素，只需要传入一个可迭代结构即可。如：1234&gt;&gt;&gt; a = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; a.update([5, 6, 7])&gt;&gt;&gt; a&#123;1, 2, 3, 4, 5, 6, 7&#125; 删除集合元素使用discard()或remove()方法移除某个指定的元素。如果该元素不存在，前者不会报错，后者会。如：123456789&gt;&gt;&gt; C = &#123;1, 2&#125;&gt;&gt;&gt; C.discard(1)&gt;&gt;&gt; C&#123;2&#125;&gt;&gt;&gt; C.discard(1)&gt;&gt;&gt; C.remove(1)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 1 集合相关操作基本运算设A, B为两个set。则A &amp; B，A | B，A ^ B，A - B分别返回A和B的交，并，对称差和差，分别对应的方法为intersection()，union()，symmetric_difference()和difference()。前两个方法可以传入多个集合作为参数，表示多个集合参与交/并运算。如：1234567891011121314151617&gt;&gt;&gt; A = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; B = &#123;2, 3, 4, 5&#125;&gt;&gt;&gt; C = &#123;3, 4, 5, 6&#125;&gt;&gt;&gt; A &amp; B&#123;2, 3, 4&#125;&gt;&gt;&gt; A | B&#123;1, 2, 3, 4, 5&#125;&gt;&gt;&gt; A ^ B&#123;1, 5&#125;&gt;&gt;&gt; A - B&#123;1&#125;&gt;&gt;&gt; A &amp; B &amp; C&#123;3, 4&#125;&gt;&gt;&gt; A.intersection(B, C)&#123;3, 4&#125;&gt;&gt;&gt; A.union(B, C)&#123;1, 2, 3, 4, 5, 6&#125; 如果在交/对称差/差运算对应的方法名后加入_update，则表示进行运算后把结果赋给调用该方法的集合。如：123456789&gt;&gt;&gt; A = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; B = &#123;2, 3, 4, 5&#125;&gt;&gt;&gt; C = &#123;3, 4, 5, 6&#125;&gt;&gt;&gt; A.intersection_update(B, C)&gt;&gt;&gt; A&#123;3, 4&#125;&gt;&gt;&gt; B.symmetric_difference_update(C)&gt;&gt;&gt; B&#123;2, 6&#125; 从属关系用in可以检查一个元素是否在一个集合中。 包含关系使用issubset()方法判断一个集合是否是另一个的子集，使用issuperset()方法判断一个集合是否是另一个的超集。如：123456&gt;&gt;&gt; A = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; B = &#123;1, 2, 3&#125;&gt;&gt;&gt; B.issubset(A)True&gt;&gt;&gt; A.issuperset(B)True 用&gt;=和&lt;=也可以判断包含关系。用&gt;和&lt;可以判断真包含关系。 相交关系使用isdisjoint()方法判断两个集合是否不相交，返回值为布尔类型。如：1234567&gt;&gt;&gt; A = set()&gt;&gt;&gt; B = &#123;1&#125;&gt;&gt;&gt; C = &#123;1, 2&#125;&gt;&gt;&gt; C.isdisjoint(B)False&gt;&gt;&gt; C.isdisjoint(A)True 复制集合使用copy()方法产生一个集合的副本。 清空集合使用clear()方法清空集合中所有的元素。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（五） 字符串]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-5%2F</url>
    <content type="text"><![CDATA[第五篇学习笔记，内容和Python的字符串类型相关。 概述python中的字符串是一种包含了一串字符的基本数据结构。字符串可以使用一对单引号或者双引号括起来。当字符串内含有单引号或者双引号时，要用另外一种引号。而当单引号和双引号全都有的时候，需要使用三单引号或者三双引号。其中使用三单引号或者三双引号可以创建字面引用，即按照原样处理三引号里面的所有字符。需要注意的是，python中没有字符的概念，单个字符也是用字符串来实现的。 访问字符串访问字符串中的某一个字符（当然，得到的不是字符而是字符串）可以使用一般访问数组的形式，如:123456&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; a[0]'a'&gt;&gt;&gt; a[-1]'c'&gt;&gt;&gt; python中支持负数下标，下标-1表示最后一个字符，以此类推。访问字符串中的一段字符则需要使用切片（在后续笔记中会提到）。 打印字符串使用print函数可以打印字符串。在字符串前面加上一个r可以输出未转义的转义字符（即输出原始字符串），如:12&gt;&gt;&gt; print(r"a \t b \n c")a \t b \n c 要打印一些特殊的字符需要使用一些转义字符。常用的转义字符如下： 转义字符 作用（真实值） \（在行尾时） 续行符 \\ 反斜杠符\ \&#39; 单引号&#39; \&quot; 双引号&quot; \0, \000 空字符 \a 响铃 \b 退格 \f 换页 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符 \ooo 某个字符，其ascii码在八进制下为ooo \xhh 某个字符，其ascii码在十六进制下为hh 作为特殊情况，\other输出\other，其中other是某个没有转义意义的字符，如p。 拆分字符串可以对字符串类型使用list()函数，从而将字符串中的每一个字符都拆出来，并且放置在一个序列之中。如：123&gt;&gt;&gt; str1 = "abcabc"&gt;&gt;&gt; list(str1)['a', 'b', 'c', 'a', 'b', 'c'] 转换成字符串可以使用str()或者repr()函数将某一个对象转换成为一个字符串。其中str()函数将对象转换成为一个用户容易读的形式，而repr()将对象转换成为python解释器容易理解的形式。需要根据用途使用这两个函数。一般情况下，这两个函数的返回值并没有区别。但在某一些情况下会有一些不同。下举一例：12345&gt;&gt;&gt; dict = &#123;'runoob': 'runoob.com', 'google': 'google.com'&#125;&gt;&gt;&gt; str(dict)"&#123;'runoob': 'runoob.com', 'google': 'google.com'&#125;"&gt;&gt;&gt; repr(dict)"&#123;'google': 'google.com', 'runoob': 'runoob.com'&#125;" 字符串的运算使用+可以将字符串连接起来。如：1234&gt;&gt;&gt; name = 'Abc'&gt;&gt;&gt; age = '123'&gt;&gt;&gt; name + age'Abc123' 使用*可以重复输出字符串，如：1234567891011&gt;&gt;&gt; age = '123'&gt;&gt;&gt; age * 2'123123'&gt;&gt;&gt; age * 0.5Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: can't multiply sequence by non-int of type 'float'&gt;&gt;&gt; age * -3''&gt;&gt;&gt; age * 0'' 可知，当乘的数是负数或者0时，字符串为空。并且不能乘小数。字符串之间的比较运算基于字符串的字典序。这里的字典序是在ASCII码（或unicode码）语境下。如：123456&gt;&gt;&gt; '11' &gt; '2'False&gt;&gt;&gt; 'abc' &gt; '123'True&gt;&gt;&gt; '啊' &gt; 'zzzzzzzzzzzzzzzzzzzzz'True 字符串的格式化python中的字符串可以做到像c/c++中一样的格式化。格式化的方式一般为2种。 怀旧方式：标识符形式字符串支持标识符方式的填充，如：1234567&gt;&gt;&gt; msg = "I am %s." %("huyutou")&gt;&gt;&gt; msg'I am huyutou.'&gt;&gt;&gt; a, b = 10, 1.0&gt;&gt;&gt; msg = "get %d and %f." %(a, b)&gt;&gt;&gt; msg'get 10 and 1.000000.' 标识符的使用方式几乎和c语言相同，下面列出一些主要的标识符： 标识符 对应替换目标 %s 字符串 (采用str()的显示) %r 字符串 (采用repr()的显示) %c 单个字符 %b 二进制整数 %d 十进制整数 %i 十进制整数 %o 八进制整数 %x 十六进制整数 %e 指数 (基底写为e) %E 指数 (基底写为E) %f 浮点数 %F 浮点数，与上相同 %g 指数(e)或浮点数 (根据显示长度) %G 指数(E)或浮点数 (根据显示长度) %% 字符% 对于标识符还可以追加一些额外的参数，如：%[(name)][flags][width][.precision]type其中(name)表示当使用字典来匹配模板时，要匹配的键的名称。如：123&gt;&gt;&gt; dict = &#123;"zqy":"nb", "is":"is not"&#125;&gt;&gt;&gt; print("zqy %(is)s %(zqy)s." % (dict))zqy is not nb. flag可以为+,-,`,0，分别表示加上一个正号（字符串是向右对齐），加上一个负号（字符串是向左对齐），前导部分用空格填充，前导部分用0填充。width表示输出的宽度，当实际宽度小于width时根据数据类型采用不同的字符填充前导部分。（字符串是不会填充前导0的）。.precision用于控制小数点后的位数。type`即为表中列出的一系列标识符。 新方式：format函数使用字符串对象的format函数可以容易地实现字符串中对应内容的填充。format函数可以接受不限个参数，并且填充的时候可以不按照顺序填充。如：12&gt;&gt;&gt; "&#123;1&#125; &#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置'world hello world' 可以看出，只要在对应的大括号里面写上format内参数的下标，就可以输出对应的参数。也可以传入一个元组，一次性按顺序填入多个值。如：12345&gt;&gt;&gt; tp = (1, 2, 3, 4)&gt;&gt;&gt; print("&#123;&#125; &#123;&#125; &#123;&#125;".format(*tp))1 2 3&gt;&gt;&gt; print("&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;".format(*tp))1 2 3 4 还可以在format函数里面对参数进行命名，并且在大括号里面使用参数的名称，这样就可以像使用字典一样根据参数的名称填入对应的参数。如：12&gt;&gt;&gt; print("&#123;name&#125; &#123;P&#125;".format(name = 2, P = 1))2 1 使用字典做类似的事情也是可以的，但是要在字典之前加入两个*号。如：123&gt;&gt;&gt; dict = &#123;"zqy":"nb", "is":"is not"&#125;&gt;&gt;&gt; print("zqy &#123;is&#125; &#123;zqy&#125;.".format(**dict))zqy is not nb. 或者使用如下的方法：12dict1 = &#123;'name': 1, 'age': 2&#125;print("&#123;0[name]&#125; &#123;0[age]&#125;".format(dict1)) #输出为1 2 甚至还可以做到用列表来索引参数。如：1234&gt;&gt;&gt; list = ["nb", "is not"]&gt;&gt;&gt; list2 = ["Why"]&gt;&gt;&gt; &gt;&gt;&gt; print("zqy &#123;0[1]&#125; &#123;0[0]&#125;. &#123;1[0]&#125;?".format(list, list2)) zqy is not nb. Why? 中括号里面的就是列表中要填充元素的下标了。还可以向str.format()中传入对象，如：12345class A: passa = A()a.b = 1print('&#123;0.b&#125;'.format(a)) # 输出1 可以看出，一般来说可以使用传入参数的索引来指向某个参数，如上述在列表的中括号前面加上0和1表示是第几个列表。以上这些可以任意的组合使用。如：12345678dict1 = &#123;'name': 1, 'age': 2&#125;list1 = [3, 4, 5]class A: passa = A()a.pp = 6print("&#123;0&#125; &#123;1[2]&#125; &#123;2[name]&#125; &#123;3.pp&#125; &#123;other&#125;".format(8, list1, dict1, a, other = 10))# 输出为8 5 1 6 10 除了填充之外，还有格式化的多种方式，以下以公式形式列出：（冒号放在与填充相关的之后，如{0:.2f}）:[[fill]align][sign][#][0][width][,][.precision][type]fill为空白处填充的字符，align为对齐方式（一般配合width使用，width意义见下），用一个字符表示：左对齐为&lt;，右对齐（默认情况）为&gt;，居中为^，=为右对齐，并将符号放置在填充字符的左侧，且只对数字类型有效，即符号+填充符+数字。以下举一些例子：12345678&gt;&gt;&gt; '&#123;:&gt;10&#125;'.format(4)' 4'&gt;&gt;&gt; '&#123;:q&gt;10&#125;'.format(4)'qqqqqqqqq4'&gt;&gt;&gt; '&#123;:q^10&#125;'.format(4)'qqqq4qqqqq'&gt;&gt;&gt; '&#123;:q=10&#125;'.format(-4)'-qqqqqqqq4' sign表示是否显示符号，用一个字符表示：为+时正负数都显示符号，为-时仅负数显示符号，为空格时正数加空格，负数加负号。如：12345678&gt;&gt;&gt; '&#123;:&lt; 10&#125;'.format(4)' 4 '&gt;&gt;&gt; '&#123;:&lt;+10&#125;'.format(4)'+4 '&gt;&gt;&gt; '&#123;:&gt;-10&#125;'.format(4)' 4'&gt;&gt;&gt; '&#123;:=-10&#125;'.format(-4)'- 4' #为一个开关，如果该位置有#号则对于某些特殊的数，会显示某种特殊形式，如二/八/十六进制会显示0b/0o/0x的前缀。如：1234&gt;&gt;&gt; '&#123;:#b&#125;'.format(0b0101001)'0b101001'&gt;&gt;&gt; '&#123;:#x&#125;'.format(0x0122FFFF01001)'0x122ffff01001' 0为一个开关，如果该位置有0对于长度不足width的数会在前面补足前导0。如：12&gt;&gt;&gt; '&#123;:09&#125;'.format(1223)'000001223' width表示格式化位所占用的宽度，当总长度不足宽度的时候采用各种填充方法使总长度达到宽度，总长度大于宽度时按原样输出。如：1234&gt;&gt;&gt; '&#123;:9&#125;'.format(1223)' 1223'&gt;&gt;&gt; '&#123;:9&#125;'.format(121111111111111111111123)'121111111111111111111123' ,为一个开关，如果该位置有,对于数字会增加分割符。如：12&gt;&gt;&gt; '&#123;:,&#125;'.format(1000000000)'1,000,000,000' .precision和type的意义和旧版相似，在此不赘述。一个特殊情况是type为%时显示百分比（默认为小数点后6位），如：12&gt;&gt;&gt; '&#123;:%&#125;'.format(1000000000)'100000000000.000000%' 需要额外注意的是，使用了format()函数，要在字符串中输出大括号需要用转义字符，即&#123;&#123;（输出&#123;）和&#125;&#125;（输出&#125;）。 与单个字符有关的函数ord()和chr()是两个和字符使用有关的函数。前者可以返回一个字符的ASCII码（或unicode码），后者可以返回一个ASCII码（或unicode码）对应的字符。如：12345678&gt;&gt;&gt; ord("a")97&gt;&gt;&gt; chr(95)'_'&gt;&gt;&gt; ord('上')19978&gt;&gt;&gt; chr(19978)'上' ord()只能接受一个字符，否则报错。chr()同理。 字符串的大小写的修改title()输入为123name = 'abc'name = 'aBc'name = 'ABC' 对于任意一种，输出name.title()都是1'Abc' 并且有：123456789&gt;&gt;&gt; name = 'abc123'&gt;&gt;&gt; name.title()'Abc123'&gt;&gt;&gt; name = '123abc'&gt;&gt;&gt; name.title()'123Abc'&gt;&gt;&gt; name = 'aBc123abC'&gt;&gt;&gt; name.title()'Abc123Abc' 说明该函数作用是将一段英文的开头字母变为大写，其余均变为小写。对每一段英文字母（即每一个单词）都进行这样的变换。当分隔符是其他符号，如下划线的时候亦如此。 capitalize()capitalize的使用可以使字符串的第一个英文字符变为大写，而对其他的英文字符不产生影响。如：123&gt;&gt;&gt; a = "it is good."&gt;&gt;&gt; a.capitalize()'It is good.' lower(),upper()有如下输入输出：1234567&gt;&gt;&gt; name = 'aBcD'&gt;&gt;&gt; name.upper()'ABCD'&gt;&gt;&gt; name.lower()'abcd'&gt;&gt;&gt; name'aBcD' 说明这两个函数和c++的tolower(),toupper()意义相似，都可以将字母格式化为大/小写。 swapcase()使用swapcase()交换整个字符串中大小写的格式。如：123&gt;&gt;&gt; a = 'aBcDeFg'&gt;&gt;&gt; a.swapcase()'AbCdEfG' 字符串的判断isalnum()用于判断一个字符串非空并且字符全部是字母或阿拉伯数字。isalpha()和isdigit()则分别用来检测对应的全为字母/阿拉伯数字的情况。检测数字的情况分为多种，其中isdigit()最为万能，可以检测包含阿拉伯数字在内的多种数字，但是检测不了汉字数字。使用isnumeric()可以检测汉字数字。islower(),isupper(),isspace()同理。istitle()可以判断字符串是不是标题格式。isdemical()可以判断字符串是否仅包含十进制字符。以上函数都是作为字符串对象的方法存在的。 字符串的相关操作以下操作均为字符串对象的方法。 查找某一个字符串是否出现使用in或者not in判断一个字符串在整个字符串中出现/不出现。如：12345&gt;&gt;&gt; a = "abcde"&gt;&gt;&gt; "bc" in aTrue&gt;&gt;&gt; "efg" not in aTrue 使用find(pattern, begin = 0, end = len(str))可以在指定区间内从左到右寻找要匹配的字符串，并且返回该字符串第一个字符的下标。使用index(pattern, begin = 0, end = len(str))函数也可以，但是前者找不到会返回-1，后者会报错。类似的有rfind和rindex，这两个寻找的时候是从右到左。如：1234567891011&gt;&gt;&gt; a = "abcabcabc"&gt;&gt;&gt; a.rfind("abc", 0)6&gt;&gt;&gt; a.find("abc", 0)0&gt;&gt;&gt; a.index("abc", 0)0&gt;&gt;&gt; a.index("aaa", 0)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found 数一个字符串出现了几次使用count()方法数一个字符串在另一个串内出现了几次。该方法的语法为str.count(sub, start = 0, end = len(string))，其中sub为要查找的字串。如：123456&gt;&gt;&gt; 'aaaaa'.count('aa')2&gt;&gt;&gt; 'excite'.count('e', 1, 4)0&gt;&gt;&gt; 'excite'.count('e', 1, 11)1 可以看出，count()查找的字串是不相互重叠的。 分割和连成字符串使用split()方法把一个字符串分割，得到一个列表。该方法语法为str.split(str = &quot;&quot;, num = string.count(str))。其中str参数默认为所有的空字符，包括空格、换行、制表符等。num参数表示最终从前到后分割出num+1个字符串，默认为全部分割。如：12345678910&gt;&gt;&gt; 'a#b#c#d'.split('#', 0)['a#b#c#d']&gt;&gt;&gt; 'a#b#c#d'.split('#', 1)['a', 'b#c#d']&gt;&gt;&gt; 'a#b#c#d'.split('#', 2)['a', 'b', 'c#d']&gt;&gt;&gt; 'a#b#c#d'.split('#', 3)['a', 'b', 'c', 'd']&gt;&gt;&gt; 'a#b#c#d'.split('#', -1)['a', 'b', 'c', 'd'] 使用splitlines()方法把一个字符串按照行分割，即按照换行符，回车符分割。该方法语法为str.splitlines([keepends])，其中keepends为布尔值，默认为False，表示分割后行末不保留换行符号。若为True则保留。使用join()方法把一个包含字符串的序列连成一个字符串。该方法语法为str.join(sequence)，其中sequence为某个序列结构。该方法可视为split()的逆方法，因为它连成的字符串之间的分割符即为str。如：1234&gt;&gt;&gt; ' '.join(('a', 'b'))'a b'&gt;&gt;&gt; '#'.join(['a', 'b', 'c', 'd'])'a#b#c#d' 判断一个字符串是否为前/后缀使用startswith()方法判断一个字符串是否是另一个的前缀。该方法语法为str.startswith(substr, beg = 0, end = len(string))，意义和前几个方法基本相同。使用endswith()方法判断一个字符串是否是另一个的后缀。语法和startswith()基本相同。如：12345678&gt;&gt;&gt; 'ssss'.startswith('ss')True&gt;&gt;&gt; 'ssss'.startswith('sa')False&gt;&gt;&gt; 'ssss'.endswith('ss')True&gt;&gt;&gt; 'ssss'.endswith('as')False 替换字符串使用replace()方法替换一个字符串中的某些模式串。该方法语法为str.replace(old, new[, max])，old表示被替换的串，new表示新串，max表示最多替换次数，省略表示全部替换。如：1234&gt;&gt;&gt; 'aaaaa'.replace('a', 'b', 3)'bbbaa'&gt;&gt;&gt; 'aaaaa'.replace('aa', 'b')'bba' 字符串的样式调整使用zfill(width)可以返回长度为width的字符串，其中原字符串向右对其，前面不足的部分使用0填充。如：123&gt;&gt;&gt; a = "123z"&gt;&gt;&gt; a.zfill(6)'00123z' 使用strip()去除字符串两端的空白字符。特别的，使用lstrip()仅去除字符串左端的空白字符，使用rstrip()仅去除字符串右端的空白字符。使用center()方法可以使字符串居中。该方法的语法为str.center(width[, fillchar])，其中width为总宽度，fillchar为填充到总宽度所用的字符。如：12&gt;&gt;&gt; s.center(10, '0')'000aaa0000' 使用ljust()和rjust()方法分别可以使字符串左居中和右居中，语法和center()相同。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（四） 其他类型运算]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-4%2F</url>
    <content type="text"><![CDATA[第四篇学习笔记，内容围绕Python除数学运算外的其他运算。 比较运算比较运算符包括==，!=，&gt;，&lt;，&gt;=，&lt;=。比较运算符和大多数编程语言一样，和数学上的意义也相近，在此不做过多的解释。但python中比较运算符的连接则和大多数语言不同，python支持多个比较运算符之间的多次连接，如：1234&gt;&gt;&gt; 1 &lt; 2 &gt; 1 &lt; 2 &gt; 1 &lt; 2 &gt; 1True&gt;&gt;&gt; 3 &gt;= 2 &gt;= 1 &gt;= 0True 位运算位运算对数字的二进制位进行计算。python中位运算包含&amp;，|，~，^，&gt;&gt;，&lt;&lt;六种，分别对应与，或，取反，异或，右移和左移。具体在此不做介绍。python中的移位是算术移位。如：1234&gt;&gt;&gt; (-1) &gt;&gt; 10-1&gt;&gt;&gt; (-1) &lt;&lt; 10-1024 逻辑运算逻辑运算符包含and, or和not三个。 逻辑值python中任何数据类型都有对应的逻辑值。只要数据类型非零（非空）就是True，否则就是False。可以使用bool()函数取得某一个对象的逻辑值。如：123456&gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool(123)True&gt;&gt;&gt; bool(&#123;1: 2&#125;)True 逻辑值参与数值运算的时候，True视作1，False视作0。如True * True + False - True为1。 逻辑运算符一般情况下，python中逻辑运算符都对逻辑值进行运算，但运算结果不仅限于True和False。 and运算and运算返回的值以运算时出现的第一个逻辑值为False的对象为主。如果两个运算数都不是False那么就返回最后那个对象。如：123456789101112&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 20&gt;&gt;&gt; a and b20&gt;&gt;&gt; a = 0&gt;&gt;&gt; a and b0&gt;&gt;&gt; a, b = 10, 0&gt;&gt;&gt; a and b0&gt;&gt;&gt; [1, 2, 3] and &#123;1: 2&#125;&#123;1: 2&#125; or运算or运算返回的值以运算时出现的第一个逻辑值为True的对象为主。如果两个运算数都是False那么就返回最后那个对象。如：123456789101112&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 20&gt;&gt;&gt; a or b10&gt;&gt;&gt; a = 0&gt;&gt;&gt; a or b20&gt;&gt;&gt; a, b = 10, 0&gt;&gt;&gt; a or b10&gt;&gt;&gt; [1, 2, 3] or &#123;1: 2&#125;[1, 2, 3] not运算not运算返回的值只是逻辑值，也即，它仅对运算数的逻辑值进行取反的操作。如：123&gt;&gt;&gt; a = 10&gt;&gt;&gt; not aFalse 成员运算符成员运算符用于测试给定的一个对象是否是另一个对象的“成员”，即，是否包含在另一个对象之中。成员运算符只有两种：in和not in。对于x in y，如果y包含x则返回True，否则返回False。not in与in刚好相反。 身份运算符身份运算符用于比较两个对象的存储单元（内存地址）是否同一，可以理解为“本质是否相同”。身份运算符只有两种：is和is not。x is y类似id(x) == id(y)，如果x和y引用的对象相同（即两者指向同一储存单元）则返回True，否则返回False。is not与is刚好相反。 运算优先级根据python官方文档，python的运算符优先级如下：（从高到低优先级递减） 运算符 描述 ** 乘方运算 +, -, ~ 加减法（一元），按位取反 *, /, //, % 乘除法类（含取余） +, - 加减法（二元） &lt;&lt;, &gt;&gt; 左移，右移 &amp; 按位与 ^ 按位异或 &#124; 按位或 in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == 比较运算符，身份运算符，成员运算符 not 逻辑非 and 逻辑与 or 逻辑或 if-else 三目运算符（在后续笔记中提及） lambda lambda运算（在后续笔记中提及） = 赋值运算]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（三） 数字类型和数学运算]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-3%2F</url>
    <content type="text"><![CDATA[第三篇学习笔记，内容和Python的数字类型相关。 类型python3中支持int，float和complex三种，其中int支持任意长度的运算，float实现的是小数的运算，complex支持了复数的运算。 整数整数没有长度的限制，同时可以使用十六进制，八进制或者二进制的整数，对应的前缀分别是0x，0o和0b。例如：12345678&gt;&gt;&gt; 0b101011086&gt;&gt;&gt; 0xFFFF65535&gt;&gt;&gt; 0xffff65535&gt;&gt;&gt; 0o7654332099 浮点数浮点数可以用小数来表示，也可以用2.5e2之类的科学计数法来表示。 复数复数的表示和数学上稍微有一些不同，在python中复数的虚部使用的是字母j而不是i。同时复数的实部和虚部都是浮点数类型。 表示时可以用a+bj的形式也可以用complex(a, b)。 表示复数的时候虚部和j不能分开，否则报错。如果虚部为$1$，仍然不能省略虚部，否则会报错。 类型转换只需要将类型名称作为函数名就可以实现数据类型之间的转换。如： 整数的转换使用int()函数。该函数的使用方法有两种： 对数字类型使用，则括号内只能接受整数或者浮点数，其中浮点数的转换规则是向原点靠近。如int(3.5) = 3, int(-3.1) = -3。括号内数字缺省时返回$0$。 对字符串使用，则括号内第一个参数是字符串，第二个参数是指定你要转换的字符串的进制。如int(&#39;23&#39;, 16) = 35。字符串必须要是符合该进制的，否则会报错。转换的结果是字符串在该进制下对应的十进制整数。 浮点数的转换使用float()函数，括号内可以接受数或者字符串，数不能为复数。 字符串也必须是可以正确转为浮点数的字符串，比如有多个小数点的就不能正常转换，会报错。字符串内最多包含一个+或者-，否则报错。符号和数字之间不能有空格，否则报错。 有一些特殊的字符串可以转换为一些特殊的浮点类型，如&#39;infinity&#39;，&#39;inf&#39;（不区分大小写），转换后就是inf。在前面加上一个减号可以变成负无穷。还有&#39;nan&#39;也会被转换成nan。 复数的转换使用complex(x[, y])可以生成一个复数。其中实部为x，而虚部为y（可缺省，此时虚部为0）。前一个参数可以为字符串，此时括号内只能有这一个参数，并且字符串中的复数必须是紧凑的，即数和符号间不能有空格，如1+2j，而不能是1 + 2j。 运算具体运算python中数的运算大体和其他编程语言相似，其中加，减，乘都没有什么区别，对于除法，python中/除法得到的总是一个浮点数，而要丢弃余数则需要用//。//除法得到的也不总是整数，这与被除数和除数的数据类型有关。如：1234567891011121314&gt;&gt;&gt; 15 // 43&gt;&gt;&gt; 15.0 // 43.0&gt;&gt;&gt; 15 // 4.03.0&gt;&gt;&gt; 15.0 // 4.03.0&gt;&gt;&gt; 15.2 // 3.44.0&gt;&gt;&gt; -15.2 // 3.4-5.0&gt;&gt;&gt; 15.0 // (-4.0)-4.0 可见//运算不仅丢弃了余数，取商的方向也是严格按照小于原来商的方向取的。 python中的乘方运算符时**，如：12345678&gt;&gt;&gt; 5 ** 225&gt;&gt;&gt; 5.0 ** 8390625.0&gt;&gt;&gt; 9 ** 0.53.0&gt;&gt;&gt; 9 ** -10.1111111111111111 不同的数混合处理时，会一并转换为浮点数。 使用%可以求得余数。如：12345678&gt;&gt;&gt; 5 % 32&gt;&gt;&gt; 5.0 % 1.60.19999999999999973&gt;&gt;&gt; 5.0 % (-1.6)-1.4000000000000004&gt;&gt;&gt; -5.0 % 1.61.4000000000000004 可以看出，//和%对于整除的理解是相同的。 赋值运算符除了最基本的=之外，其他和c++类似，如乘方a = a ** b可以简写为a **= b，加法a = a + b可以简写为a += b。需要注意的是，python中没有++，--之类的自增自减操作。只能通过+= 1和-= 1实现类似的自增自减操作。 运算优先级python中运算的优先级和正常的数学运算差别不大。都是乘方最先，乘除（含取余）其次，加减最后。事实上，python中有一点稍显不同，那就是当+和-是一元运算符时，两者的优先级位于乘方和乘除之间。 和数字操作有关的函数绝对值和绝对值相关的有abs(x)和fabs(x)两个函数。 abs(x)是内置函数，而fabs(x)是在math模块中定义的，两者的区别还在于fabs(x)适用于整数和浮点数，而abs(x)还适用于复数。复数的abs就是复数的模。 取整和取整相关的有ceil(x)和floor(x)两个函数。 ceil(x)是向上取整，floor(x)是向下取整。两者返回的都是整数。 两者都定义在math模块中。 指数和对数和指数与对数相关的函数有exp(x)，log(x)和log10(x)。 exp(x)返回$e^x$，log(x)返回$\ln x$，log10(x)返回$\lg x$。三者返回的都是浮点数。 三者都定义在math模块中。 求幂可以使用pow(x, y[, z])函数求$x^y \mod z$（如果省略$z$则只计算$x^y$，此时$x, y$可以为浮点数；而若要使用$z$则$x, y, z$必须均为整数）。 该函数为内建函数，可以不导入模块，直接调用。函数返回值类型与结果有关，结果是整数则返回值为整数，否则为浮点数。 实际上在math模块中也存在一个pow(x, y)函数，但该函数只接受2个参数（均可为浮点数），并且只返回浮点数。 求算术平方根使用math模块中的sqrt(x)求$x$的算术平方根。$x$需要是非负实数。 该函数作用不大。 分离整数和小数部分使用math模块中的modf(x)函数以二元组形式得到$x$的整数部分与小数部分，两部分的数值符号与$x$相同，整数部分以浮点型表示。如：12&gt;&gt;&gt; math.modf(123.45)(0.45000000000000284, 123.0) 四舍五入使用math模块中的round(x[, n])函数对浮点数进行四舍五入，其中$n$是四舍五入到哪一位，默认为0（个位）。返回值是浮点数。 应该说，该函数的效果并不理想，一是因为它在python2.x版本和python3.x版本中有着不同的实现，导致两个版本对于同一个数的处理结果可能不同；二是该函数因为受计算机浮点数表示精度的影响，可能会产生误差，如round(2.355, 2)会得到2.35的神奇结果。所以如果要追求精确性，就最好别用它。 三角函数math模块中定义了sin(x)，cos(x)，tan(x)，asin(x)，acos(x)，atan(x)等三角函数。 此外，还定义了degrees(x)和radians(x)这两个函数，分别用于弧度转角度和角度转弧度，如：1234&gt;&gt;&gt; math.degrees(math.pi/2)90.0&gt;&gt;&gt; math.radians(90.0)1.5707963267948966 与输出数有关的函数bin(x)，oct(x)和hex(x)分别可以输出int类型数的二进制，八进制，十六进制的表示。如：123456&gt;&gt;&gt; bin(123)'0b1111011'&gt;&gt;&gt; oct(123)'0o173'&gt;&gt;&gt; hex(123)'0x7b']]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（二） 变量]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-2%2F</url>
    <content type="text"><![CDATA[第二篇学习笔记，内容包含了Python变量使用和命名的要点。 变量的使用python是一个动态类型语言，它在创建一个变量的时候不需要事先声明变量的类型。如1message = 2 但是变量如果在定义的时候不赋一个值则会报错。同时变量的类型可以随时切换，如12message = 2message = 'abc' # 合法 可以一时间给多个变量赋值，如1a = b = c = 2 或者给多个变量一次性赋上不同的值，如1a, b, c = 1, 2, 3 变量的命名python中变量的命名原则和c++相似，必须满足以下条件： 变量名仅能包含数字，字母和下划线，不能含有空格，且不以数字开头。 变量名不能为关键字。如不能把list作为关键字。 变量的命名原则同样适于函数，类，模块的命名等。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（一） 基本语法]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-1%2F</url>
    <content type="text"><![CDATA[第一篇学习笔记，内容包含了Python的一些基本语法和基本内容。 缩进python用缩进表示一个代码块。一般的缩进都必须要是4个空格。缩进相同的一组语句构成一个代码块，我们称之代码组。复合语句中，冒号后面的缩进相同的一组语句构成一个代码块。不同的代码块之间有着不同的从属关系，这种从属关系对于理解代码逻辑非常必要。 多语句python用反斜杠支持多行语句，如下：12age = 1 + \2 在各种括号中的多行语句不需要用反斜杠。如列表中：12items = ['a', 'ab'] 在一行中使用多个语句可以像c系列语言一样用分号隔开。 交互界面python的命令行交互界面中，输入一个表达式可以返回一个结果，这个结果被储存在变量_中。应当在使用交互界面时将_视为一个只读的变量。在将交互界面当作一个计算器使用的时候可以将_看作是lastans之类的值。如果尝试改变_的值会导致_的值不再根据最后的运算结果而变化，如：123456789101112&gt;&gt;&gt; a = 1&gt;&gt;&gt; a1&gt;&gt;&gt; a + _2&gt;&gt;&gt; _ = 12&gt;&gt;&gt; a + _13&gt;&gt;&gt; a1&gt;&gt;&gt; a + _13 除非使用del _，否则这样的情况不会改变。 同时赋值使用如下格式可以执行同时赋值： var_1, var_2, var_3, ..., var_n = exp_1, exp_2, exp_3, ..., exp_n因此python中可以用非常简单的语法实现两个变量的交换。如：1a, b = b, a 逗号的使用python中不强制要求在某些地方，最后一个参数之后不能有逗号。因此print(1, 2,)是合法的。（事实上python自己在一些地方就是这么做的） 注释一般的注释的格式如下：1# 注释 多行注释使用三引号，用两对三个单引号或者两对三个双引号将所要注释的内容框起来即可。如：1234567891011'''注释11231233'''"""注释12344321""" 要用中文的话貌似要加上这两行在最顶上。因为python一般只支持ASCII码。（不过一般情况下用中文好像也没有出什么事情…?）12#!/usr/bin/python # -*- coding: utf-8 -*- 顺带一提，这两行代码中，第一行指定了该代码使用python解释器来运行，第二行指定了代码的编码格式。 pass语句这是个空语句，它只有占位子的作用，本身什么也不做。 寻求帮助使用help()函数获取相关类型或者函数的信息。对某个实例使用help()函数可以得到其所属类的相关信息。如：1234class A: passa = A()print(help(a)) 可以得到：12345678910Help on A in module __main__ object:class A(builtins.object) | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined)]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4699 Editor]]></title>
    <url>%2F2018%2F12%2F23%2Fhdu4699%2F</url>
    <content type="text"><![CDATA[题目链接 题解 本题的特殊性在于，四种操作均在光标位置发生，并且发生完操作之后光标至多移动一个位置。根据这种始终在序列中间某个指定位置进行修改的性质，可以使用“对顶栈”算法。————《算法竞赛进阶指南》 有这种思想这道题就很好做了。实际上题目中的“最大前缀和”和求栈中最小值有点像，也算是使用栈的一个提示？1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int Q, stf[1000005], tf, str[1000005], tr, st[1000005], t, sum = 0;int main()&#123; while(scanf("%d", &amp;Q) == 1)&#123; tf = tr = t = 0, sum = 0, st[0] = -2000000000; char ord[3]; int opr = 0; while(Q--)&#123; scanf("%s", ord); if(ord[0] == 'I')&#123; scanf("%d", &amp;opr); stf[++tf] = opr, t++, sum += opr; st[t] = max(st[t - 1], sum); &#125; if(ord[0] == 'D') t--, sum -= stf[tf--]; if(ord[0] == 'L' &amp;&amp; tf) sum -= stf[tf], str[++tr] = stf[tf--], t--; if(ord[0] == 'R' &amp;&amp; tr) &#123; stf[++tf] = str[tr--], t++, sum += stf[tf]; st[t] = max(st[t - 1], sum); &#125; if(ord[0] == 'Q') scanf("%d", &amp;opr), printf("%d\n", st[opr]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO18JAN Rental Service]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu4181%2F</url>
    <content type="text"><![CDATA[题目链接 题解贪心，把产奶量，商店给出的收购价和村民给的租金均降序排序，然后遍历每一种方案，把牛分成两部分，使得一部分产奶，一部分卖出，看哪一种总收益最大。代码稍微复杂，但思维难度不大。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Sp&#123; int req, p1;&#125;;struct cmp&#123; inline bool operator() (const Sp &amp;s1, const Sp &amp;s2)&#123; return s1.p1 &gt; s2.p1; &#125;&#125;;struct cmp2&#123; inline bool operator() (const int &amp;i1, const int &amp;i2)&#123; return i1 &gt; i2; &#125;&#125;;Sp sp[100005];int n, m, r, otp[100005], p2[100005];ll totp[100005] = &#123;0&#125;, tmon[100005] = &#123;0&#125;;ll tr[100005] = &#123;0&#125;;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;r); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;otp[i]); for(int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;sp[i].req, &amp;sp[i].p1); for(int i = 0; i &lt; r; ++i) scanf("%d", &amp;p2[i]); sort(sp, sp + m, cmp()); sort(p2, p2 + r, cmp2()); sort(otp, otp + n, cmp2()); totp[0] = 0, tmon[0] = 0; for(int i = 1; i &lt;= m; ++i) totp[i] = totp[i - 1] + sp[i - 1].req, tmon[i] = tmon[i - 1] + 1ll * sp[i - 1].p1 * sp[i - 1].req; tr[0] = 0; for(int i = 1; i &lt;= r; ++i) tr[i] = tr[i - 1] + 1ll * p2[i - 1]; ll ans = tr[min(n, r)], curotp = 0; for(int i = 0; i &lt; n; ++i)&#123; curotp += otp[i]; int ind = lower_bound(totp, totp + m + 1, curotp) - totp; ans = max(ans, tmon[ind - 1] + (curotp - totp[ind - 1]) * sp[ind - 1].p1 + tr[min(n - i - 1, r)]); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO18OPEN Lemonade Line]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu4379%2F</url>
    <content type="text"><![CDATA[题目链接 题解对w_i降序排序之后模拟即可。这是贪心。123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int n, w[100005];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;w[i]); sort(w, w + n); int cnt = 0; for(int i = n - 1; i &gt;= 0; --i)&#123; if(cnt &lt;= w[i]) cnt++; else break; &#125; printf("%d\n", cnt); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10JAN Tea Time]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu2978%2F</url>
    <content type="text"><![CDATA[题目链接 题解并查集模板（？）题。1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int fa[1005], rk[1005], n, m, q;void init()&#123; for(int i = 1; i &lt;= n; ++i) fa[i] = i, rk[i] = 1;&#125;int Find(int x)&#123; if(x == fa[x]) return x; return (fa[x] = Find(fa[x]));&#125;void joint(int x, int y)&#123; int xa = Find(x), ya = Find(y); if(xa == ya) return ; if(rk[xa] &gt; rk[ya]) fa[ya] = xa, rk[xa] += rk[ya]; else fa[xa] = ya, rk[ya] += rk[xa];&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); init(); int u, v; for(int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;u, &amp;v), joint(u, v); for(int i = 0; i &lt; q; ++i) scanf("%d%d", &amp;u, &amp;v), printf("%s\n", Find(u) == Find(v) ? "Y" : "N"); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1468 派对灯]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu1468%2F</url>
    <content type="text"><![CDATA[题目链接 题解和leetcode上面某题几乎一样。注意排序就行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt = 0, op[105] = &#123;0&#125;;int res[105], ans[10][105], tot = 0;int ori[10], b[2][10], c[3], to[10];void ssort()&#123; for(int i = 0; i &lt; tot; ++i) ori[i] = i; for(int i = n - 1; i &gt;= 0; --i)&#123; c[0] = c[1] = 0; for(int j = 0; j &lt; tot; ++j)&#123; int curbit = ans[ori[j]][i]; b[curbit][c[curbit]++] = ori[j]; &#125; c[1] += c[0]; for(int j = tot - 1; j &gt;= 0; --j)&#123; int curbit = ans[ori[j]][i]; to[--c[curbit]] = ori[j]; &#125; for(int j = 0; j &lt; tot; ++j) ori[j] = to[j]; &#125;&#125;bool judge()&#123; for(int i = 0; i &lt; n; ++i) if((op[i] == 1 &amp;&amp; res[i] == 0) || (op[i] == -1 &amp;&amp; res[i] == 1)) return false; memcpy(ans[tot], res, sizeof(res)), tot++; return true;&#125;inline void reset()&#123; fill(res, res + n, 1);&#125;void process(int x)&#123; if(x == 1)&#123; for(int i = 0; i &lt; n; ++i) res[i] ^= 1; &#125;else if(x == 2)&#123; for(int i = 0; i &lt; n; i += 2) res[i] ^= 1; &#125;else if(x == 3)&#123; for(int i = 1; i &lt; n; i += 2) res[i] ^= 1; &#125;else if(x == 4)&#123; for(int i = 0; i &lt; n; i += 3) res[i] ^= 1; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int t; while(scanf("%d", &amp;t), t &gt; 0) op[t - 1] = 1; while(scanf("%d", &amp;t), t &gt; 0)&#123; if(op[t - 1] == 1)&#123; printf("IMPOSSIBLE\n"); return 0; &#125; op[t - 1] = -1, cnt++; &#125; bool flag = false; if(m == 0)&#123; if(cnt &gt; 0) &#123; printf("IMPOSSIBLE\n"); return 0; &#125; else&#123; for(int i = 0; i &lt; n; ++i) printf("1"); putchar('\n'); return 0; &#125; &#125;else if(m &amp; 1)&#123; reset(); if(m &gt; 1) flag |= judge();//0 process(1), flag |= judge();//1 process(2), flag |= judge();//3 process(1), flag |= judge();//2 reset(), process(4), flag |= judge();//4 if(m &gt; 1)&#123; process(2), flag |= judge();//24 process(1), flag |= judge();//34 process(2), flag |= judge();//14 &#125; &#125;else&#123; reset(), flag |= judge();//0 process(1), flag |= judge();//1 process(2), flag |= judge();//3 process(4), flag |= judge();//34 process(1), flag |= judge();//24 process(3), flag |= judge();//14 reset(), process(2), flag |= judge();//2 if(m &gt; 2) reset(), process(4), flag |= judge();//4 &#125; if(!flag)&#123; printf("IMPOSSIBLE\n"); return 0; &#125; ssort(); for(int i = 0; i &lt; tot; ++i)&#123; for(int j = 0; j &lt; n; ++j) printf("%d", ans[ori[i]][j]); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 卷积变换]]></title>
    <url>%2F2018%2F12%2F17%2Ftemplate-fft%2F</url>
    <content type="text"><![CDATA[本文主要讨论三个算法：FFT，NTT和FWT。 基础知识卷积 在泛函分析中，卷积、叠积（convolution）、摺积或旋积，是通过两个函数$f$和$g$生成第三个函数的一种数学算子，表征函数$f$与经过翻转和平移的$g$的乘积函数所围成的曲边梯形的面积。如果将参加卷积的一个函数看作区间的指示函数，卷积还可以被看作是“移动平均”的推广。————维基百科 事实上，在这里我们主要讨论的是定义在数列上的卷积。最基本的一个问题是：给定两个长度有限的序列\left\{a_i\right\}, \left\{b_i\right\}，求出序列\left\{c_i\right\}，使得c_i = \sum_{j + k = i} a_j \oplus b_k，其中$\oplus$是某个满足交换律的二元运算。 复数单位根根据代数基本定理，复数方程$z^n = 1$有$n$个根，这些根互不相同，可以表示为$e^{\frac{2\pi k i}{n}} = \cos(\frac{2\pi k }{n})+i\sin(\frac{2\pi k }{n})\quad (k\in \lbrace 0, 1, \cdots, n- 1 \rbrace)$。一般记作w_n^k = e^{\frac{2\pi k i}{n}}。单位根具有一些很神奇的性质： w_n^0 = w_n^n = 1。 w_n^0, w_n^1, \cdots, w_n^{n - 1}各不相同。 w_{tn}^{tk} = w_n^k(t \ge 1), w_n^{k + \frac{n}{2}} = -w_n^k。这一个性质有着很强的几何意义。 w_n^{jk} = w_n^{jk \mod n}。 原根和阶FFT（快速傅里叶变换）基础：离散傅里叶变换]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hihocoder1384]]></title>
    <url>%2F2018%2F12%2F16%2Fhihocoder1384%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数论复习笔记-1]]></title>
    <url>%2F2018%2F12%2F12%2Fnumber-theory-1%2F</url>
    <content type="text"><![CDATA[（这里大概不会涉及代码） 同余关系算术基本定理表述对于任何一个大于$1$的正整数$n$，$n$都能被唯一分解为有限个质数的乘积，写作： n = p_1^{c_1} p_2^{c_2} \cdots p_m^{c_m}其中c_i \ge 1、p_i是质数$(\forall i)$，且p_1]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1019 Number Sequence]]></title>
    <url>%2F2018%2F12%2F12%2Fpoj1019%2F</url>
    <content type="text"><![CDATA[题目链接 题解二分出答案要求的数字出现在$1234\cdots n$里面的$n$的值，然后计算具体是这一串数里面的哪一个数的哪一位。后面这个子问题在leetcode 400上有。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;int s[10], cnt;unsigned int get(int t)&#123; int pst = 0, u = 9, res = 0, a1 = 0; for(int i = 1; ; ++i)&#123;//d = i a1 += i; int terms = min(u, t) - pst; res += terms * a1 + (terms * (terms - 1) / 2) * i; if(t &lt;= u) break; a1 += i * (u - pst - 1); pst = u, u = 10 * u + 9; &#125; return res;&#125; int solve(unsigned int n)&#123; int l = 1, r = 35000; while(l &lt; r)&#123; int mid = (l + r) &gt;&gt; 1; if(get(mid) &gt;= n) r = mid; else l = mid + 1; &#125; int gap = n - get(r - 1); if(gap &lt;= 9) return gap; int i = 1, u = 9; while(gap &gt; u)&#123; gap += u, u = u * 10 + 9, ++i; if(gap &lt;= i * u)&#123; int res = (gap + i - 1) / i; cnt = 0; while(res) s[cnt++] = res % 10, res /= 10; return s[cnt - 1 - ((gap + i - 1) % i)]; &#125; &#125;&#125;int main()&#123; int T; unsigned int n; scanf("%d", &amp;T); while(T--)&#123; scanf("%u", &amp;n); printf("%d\n", solve(n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uva756]]></title>
    <url>%2F2018%2F12%2F11%2Fuva756%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2134 单选错位]]></title>
    <url>%2F2018%2F12%2F11%2Fbzoj2134%2F</url>
    <content type="text"><![CDATA[题目地址 题解考虑每一道题对答案的贡献。容易发现当一道题的选项数目是$a$，而错填到这道题的答案所属的原来那道题目有$b$个选项时，这道题目对的概率是$\frac{1}{\max\left{a, b\right}}$（可以画格子图，看对角线来考虑）。然后这道题对的期望就是概率$\times 1$。所以对每一个题目都这么跑一遍就可以了。12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n, A, B, C, a1, a2, a3;int main()&#123; double ans = 0; scanf("%d%d%d%d%d", &amp;n, &amp;A, &amp;B, &amp;C, &amp;a1); a2 = a1; int pst = a2 % C + 1, real; for(int i = 2; i &lt;= n; ++i)&#123; a3 = ((long long)a2 * A + B) % 100000001; real = a3 % C + 1; ans += 1.0 / max(pst, real); pst = real, a2 = a3; &#125; real = a1 % C + 1; ans += 1.0 / max(pst, real); printf("%.3lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算的运用]]></title>
    <url>%2F2018%2F12%2F06%2Fbit-operation-applications%2F</url>
    <content type="text"><![CDATA[位运算可以用来做什么？ 位运算众所周知，常用的位运算有&amp;（与），|（或），^（异或），&lt;&lt;（左移），&gt;&gt;（右移），~（取反）几种。 位运算虽然简单，但是在应用上有很多技巧。 基础：位的访问和修改位的访问位的访问可以简单的使用一个移位操作和一个与操作来实现。下面的程序就演示了检测第$pos$位上是不是$1$：123bool getPos(unsigned int x, int pos)&#123; return (x &gt;&gt; pos) &amp; 1;&#125; 而要访问第$pos$位开始向后的连续$t$位，就要使用一个“遮罩”来捕获后面的那些位。使用与运算就可以做到这一点。如下面代码所示：123int getPosT(unsigned int x, int pos, int t)&#123; return (x &gt;&gt; pos) &amp; ((1u &lt;&lt; t) - 1);&#125; 位的修改要将第$pos$位修改为$1$可以使用或运算。如下面的演示程序：123unsigned int setPos(unsigned int x, int pos)&#123; return x | (1u &lt;&lt; pos);&#125; 要将第$pos$位修改为$0$可以将原数与一个只有$pos$位上是$0$，其余位均为$1$的数相与，如下程序所示。123unsigned int delPos(unsigned int x, int pos)&#123; return x &amp; ~(1u &lt;&lt; pos);&#125; 要将第$pos$位取反可以将原数与一个只有$pos$位上是$1$，其余位均为$1$的数相异或，如下程序所示。123unsigned int flipPos(unsigned int x, int pos)&#123; return x ^ (1u &lt;&lt; pos);&#125; 进阶：求某些特殊的值求最低位的bit这个是经典的lowbit方法。代码如下：123unsigned int lowbit(unsigned int x)&#123; return x &amp; (-x);&#125; 原理是补码为反码$+1$。 参考资料： 《回归本源————位运算及其应用》，2014年信息学奥林匹克国家集训队论文]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode近期做题 简要题解]]></title>
    <url>%2F2018%2F11%2F24%2Fleetcode-easy-normal%2F</url>
    <content type="text"><![CDATA[记录一点简要题解。个人认为以下题目中比较好的：11，19，84，96，137，138，189，229，240，258，260，264，290，324，326，368，400，438，448，453，456，458，459，478，479，633，754，877，932，939 1Hash Table 边存边找 2简单大数加法 3用类似于尺取法的方法统计字符，维护滑动窗口中字符的出现次数。另一个相对更好的方法是维护每一个字符的出现位置，这样就不需要在更新滑动窗口的时候（这时最后一个被纳入的字符出现重复）让前端的指针向后一步一步移动，而是可以直接让前端指针指向重复字符在窗口内出现位置的后一个位置。比如：当前窗口是 abcb，b 重复，就可以让头指针（指向 a）改为指向前一个 b 的后面一个位置，也就是 c。这样略去了前端指针不断后移的过程，从而减小了时间复杂度的常数因子。 5最差的是枚举子串暴力判断，$O(n^3)$；比较好的是枚举中间点暴力判断，$O(n^2)$；最好的是 Manacher，$O(n)$。 6模拟或者推公式。 7基本上和翻转字符串相同。特判负数和溢出。 8小模拟用 python 的正则表达式做法是真的厉害。。。 9用字符串。不用字符串可以考虑先特判负数，然后转化为翻转数字来做。官方给了一个更好的方法：只需要判断反转后一半是否相等即可。 11方法一排序，找周围比自己高的，进而找最远的。123456789101112131415161718class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ len1 = len(height) h = list(zip(height, range(0, len1))) h.sort(key = lambda x: x[0]) ans = 0 hd, tl = 0, len1 - 1 for i in h: hh, idx = i[0], i[1] ans = max(ans, max(idx - hd, tl - idx) * hh) height[idx] = -1 while hd &lt; tl and height[hd] == -1: hd += 1 while hd &lt; tl and height[tl] == -1: tl -= 1 return ans 方法二使用两个分别指向头和尾的指针，每次比较两个指针所指的木板的长度，将指向较小者的指针向中间地区移动，这样就可以保证能找到最大的解。这样做是线性的时间复杂度。123456789101112131415class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ len1 = len(height) i, j, ans = 0, len1 - 1, 0 while i &lt; j: ans = max(ans, min(height[i], height[j]) * (j - i)) if height[i] &lt; height[j]: i += 1 else: j -= 1 return ans 12模拟 13小模拟 14二分最长前缀长度。可以用startswith()。 15基本同18，不过简单很多 16暴力可以做，但是时间效率不行。应该是先排序然后用双指针。 17水 18折半搜索 19这题有点厉害。。。先用一个快指针跳$n$个点，然后慢指针从头开始，两个指针始终维护$n$的间距。快指针到末尾时慢指针到答案处。123456789101112131415class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == NULL) return NULL; ListNode *hhd = new ListNode(-1), *res = hhd; hhd-&gt;next = head; ListNode *fst = hhd; for (int i = 0; i &lt; n; ++i) fst = fst-&gt;next; while(fst-&gt;next != NULL) fst = fst-&gt;next, hhd = hhd-&gt;next; hhd-&gt;next = hhd-&gt;next-&gt;next; return res-&gt;next; &#125;&#125;; 20水栈。 21水归并 22水 DFS。模拟一个栈中匹配括号的过程，在 DFS 的时候记录栈中有多少个左括号就可以完成 DFS。 24加一个头节点即可 26可以用双指针法。 27遍历。 281str.find() 29倍增。-2147483648的情况非常不好做。 311next_permutation(nums.begin(), nums.end()); 33先二分找到旋转的地方，再普通二分。 34二分。等同于实现lower_bound()和upper_bound()。 35二分。基本等同于34题。 36模拟 38容易 39完全背包记录方案 40DFS 46简单全排列构造 47排序后递归全排列，或者直接next_permutation? 48水 49把元组或者正规化的字符串作为键其实可以，不过有一个神奇操作是用质数作为状态压缩的工具，把一个字符串映射成为一个数。实在是非常创新了。（虽然两个做法效率差不多） 501return x ** n 53我觉得$O(n)$更精妙来着… 54模拟 56按左端点从左到右排序，模拟即可。 58水 59和54题配套 60康拓展开 61先遍历一遍求出总长，再找到要切断的地方。 62水递推 63简单递推。 64DP 66水 671return bin(int(a, 2) + int(b, 2))[2: ] 69二分or函数。 70递推。斐波那契数列。 71超过 3 个点算文件夹名，惊了 73可以把每一个0提到每一行/列的第一个位置，这样就不用保存每一行/列是否有0出现了。 74类似于二分 75三指针问题，只要分别记录 0 区域的右边界，2 区域的左边界即可，剩下一个指针用来遍历数组。我一开始想的是只记录 2 区域的左边界，然后把 1 换成 2，在遍历结束后再加上去。。。这样不够好。 77基本的递归组合。 78基本的二进制数构造子集。 79大力 DFS 就行了。。。 80理论上任意指定的保留数目都可以实现。 81因为存在重复元素，所以无法在二分的时候判定重复元素是属于哪一部分。故不能直接套用原来的方法。如果打算在二分的时候去重就需要花费至多 $O(n)$ 的时间。既然如此，还不如直接扫一遍获知答案。。。 82水 83水 86用两个头节点，把原来的链表拆开之后按顺序连接到头节点上即可。不要想的太复杂。 88从尾部开始合并有序队列。 90先排序算出每一种数的个数，然后把答案的vector建出来，按照特定的顺序向里面添加一定数目的元素即可。有直接生成然后去重的偷懒做法，不提倡。 91水 DP 92这题做法比较多，我用的是维护链表$m-1, m, n+1$三个位置，然后根据各自位置判断链接方式的方法。 93简单枚举和剪枝 94, 144水迭代应该是指用栈记录上一次访问了什么，然后遇到这个节点更新，如果全部弄完了就出栈。 95递归的时候以包含所有可能的树结构的 vector 作为返回值即可。（有没有什么可以降低空间复杂度的方法？） 96经典问题。答案是Catalan数。 98中序遍历 100水 101递归遍历用两个参数 102BFS 103每一层按照奇偶性转一下 104水 105, 106模板 107把102的结果reverse即可。 108相当于构建一棵AVL树。只需要每次对半切分子序列即可。 109基本同108 110按照题意模拟即可。 112水 113水 114水 116对于一个根节点，令左儿子连接右儿子，右儿子连接根的next的左儿子。 117基本同116，不过找next要沿着next链跳，且要先向右走。或者，一个更好的方法是按层构建next，因为构建了一层next就可以在这层基础上把所有子节点的next构造出来。 118水 119利用组合数公式 120普通DP 121维护当前所遇到的最小数$mini$，然后从左向右扫，每遇到一个数就尝试更新答案和$mini$。 122简单DP 125正规化字符串之后直接判定。 129简单递推 130BFS 131把每一个前缀的答案记录一下。这个过程和记忆化有些类似。猜测这个题目用 python 会方便很多。 134跑一遍就行，如果从$i$跑不到$j$，那么从$i+1, i+2, …, j-1$也跑不到$j$。证明很简单。 136异或 137方法一基本做法是统计每一位的1数目，看看哪一位的次数模$3$余$1$，然后把这些位或起来。12345678910111213141516171819202122class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ ans, j, cnt1, cnt2 = 0, 1, 0, 0 for i in range(0, 32): for t in nums: if t &gt;= 0: if t &amp; j: cnt1 += 1 else: if (-t) &amp; j: cnt2 += 1 if cnt1 % 3 == 1: ans += j elif cnt2 % 3 == 1: ans += -j j &lt;&lt;= 1 cnt1, cnt2 = 0, 0 return ans 方法二对于这道题而言，我们寄希望于能找到一种方法，利用位运算，来实现三进制的无进位加法。换言之，有没有什么方法可以实现某些位上出现00-&gt;01-&gt;10-&gt;00的循环呢？答案是有的。因为是二进制，所以我们可以考虑用两个二进制数表示一个三进制的数。这里直接给出这种运算方法。手算可以发现它实现了b，a上同一位00-&gt;01-&gt;10-&gt;00的变化（因为我也不知道这是怎么想到的，代码来自中文leetcode本题评论区）事实上，利用逻辑运算规则可以构造出这样一个真值函数，来实现三进制的运算。1234567891011class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ a, b = 0, 0 for num in nums: b = ~a &amp; (b ^ num) a = ~b &amp; (a ^ num) return b 138一个非常不错的题目。一种优秀的做法是：先将每一个点都复制一份，连在其后方，新节点和旧节点交替链接。然后遍历新节点，新节点的随机指针指向的就是旧节点随即指针指向的next。然后将新节点连成新链表即可。这种方法最优秀的一点在于，通过构造这样一种结构，它避免了遍历节点的时候成环等情况，让更新随机指针更加方便。12345678910111213141516171819202122232425262728class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == NULL) return NULL; Node *tmp = head; while (tmp != NULL)&#123; Node *n = new Node(tmp-&gt;val, tmp-&gt;next, NULL); tmp-&gt;next = n, tmp = n-&gt;next; &#125; tmp = head; while (tmp != NULL)&#123; if (tmp-&gt;random != NULL) tmp-&gt;next-&gt;random = tmp-&gt;random-&gt;next; tmp = tmp-&gt;next-&gt;next; &#125; tmp = head; Node *ans = head-&gt;next; while (tmp-&gt;next-&gt;next != NULL)&#123; Node *p = tmp-&gt;next-&gt;next; tmp-&gt;next-&gt;next = p-&gt;next; tmp-&gt;next = p; tmp = p; &#125; tmp-&gt;next-&gt;next = NULL; tmp-&gt;next = NULL; return ans; &#125;&#125;; 139简单 DP 141Floyd判圈法 142不让用额外空间就还行，那就乱搞。。。不乱搞实际就是Floyd判圈法的一个推论。 147从头向后插入即可。 150水，但是用python小心python的神奇负数除法 1511return " ".join(reversed(s.split())) 153是 33 的第一步（找出旋转点） 155单调栈 160先求出两个表头的深度，然后把两个表头放到同一深度，再一起向前走。 162因为数组的两端都视为最低点，所以可以用二分来做。思想很简单：我们希望最后停在峰的位置。对于 $mid$，如果从 $mid$ 到 $mid+1$ 高度增加，那么说明至少峰不是 $mid$，令 $l:=mid+1$；否则说明至少 $r$ 右边不是峰，令 $r:=mid$。注意，这里我们似乎只考虑了只有一个峰的情况。但事实上，二分的每一步都是正确的，而最后得到的确实是峰的位置。（证明有时间可能会证一下） 165按照.切分列表之后按照项比较即可 166这题细节太多。。。（要素过多）基本思想还是判环，由抽屉原理不可能出现比分母还多种类的余数，所以用一个 Hash Table 记录余数（因为分母可以特大），用另外一个列表记录商。然后就是各种奇奇怪怪的边界情况。请考虑： 没有小数部分 分母为 INT_MIN 结果是负数 考虑完这三种情况差不多就能过了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: string fractionToDecimal(int numerator, int denominator) &#123; if (!numerator) return string("0"); string ans; int flag1 = 0, flag2 = 0; long long n = numerator, d = denominator; if (numerator &lt; 0) ++flag1, n = -n; if (denominator &lt; 0) ++flag2, d = -d; if (flag1 + flag2 == 1) ans.push_back('-'); if (n &gt;= d) ans += to_string(n / d), n %= d; else ans.push_back('0'); if (!n) return ans; long long g = __gcd(n, d); n /= g, d /= g; vector&lt;int&gt; val(1, 0); unordered_map&lt;int, int&gt; mp; int cnt = 0, cycle, shang, yushu; for(; n; n *= 10ll)&#123; shang = n / d, yushu = n % d; cout &lt;&lt; n &lt;&lt; " " &lt;&lt; d &lt;&lt; endl; val.push_back(shang), ++cnt; if(mp.count(yushu)) break; mp[yushu] = cnt; n %= d; &#125; ans.push_back('.'); if(!n)&#123; for (int i = 2; i &lt;= cnt; ++i) ans.push_back(val[i] + '0'); &#125;else&#123; cycle = mp[yushu] + 1; for(int i = 2; i &lt; cycle; ++i) ans.push_back(val[i] + '0'); ans.push_back('('); for(int i = cycle; i &lt;= cnt; ++i) ans.push_back(val[i] + '0'); ans.push_back(')'); &#125; return ans; &#125;&#125;; 167双指针 168特殊的进制问题，对于进位要特殊处理，或者每每次循环先让$n$自减1。 169摩尔投票法，经典问题。 17112for (int i = 0; i &lt; n; ++i) ans = ans * 26 + s[i] - 'A' + 1; 172统计这个阶乘中因子$2$和$5$的次数，取其较小者。但显然后者更少，所以只要统计后者。 178比较两个数字相连之后的字典序。 187压成20位的二进制数，然后bitset记录 189方法一根据$k$把原序列切分成两段，然后递归交换这两段。123456789101112131415161718192021222324252627class Solution: def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ len1 = len(nums) k %= len1 if k == 0 or len1 == 1: return a1, b1, a2, b2 = 0, len1 - 1 - k, len1 - k, len1 - 1 # 均以下标为准 while b2 - a2 != b1 - a1: if b2 - a2 &gt; b1 - a1: len2 = (b1 - a1 + 1) else: len2 = (b2 - a2 + 1) for i in range(0, len2): nums[a1 + i], nums[b2 - len2 + 1 + i] = nums[b2 - len2 + 1 + i], nums[a1 + i] if b2 - a2 &gt; b1 - a1: b2 -= len2 else: a1 += len2 len2 = b1 - a1 + 1 for i in range(0, len2): nums[a1 + i], nums[a2 + i] = nums[a2 + i], nums[a1 + i] 方法二采取类似于非旋转treap的方法，按照$k$把序列切分成为两段，然后分别逆序两段，再将一整段逆序就可以得到答案。123456789101112131415161718class Solution: def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ def rev(a, b): mid = (a + b) &gt;&gt; 1 for i in range(a, mid + 1): nums[i], nums[b + a - i] = nums[b + a - i], nums[i] len1 = len(nums) k %= len1 if k != 0: rev(0, len1 - k - 1) rev(len1 - k, len1 - 1) rev(0, len1 - 1) 方法三我猜是暴力移动…? 190用bin()，但也可以用位运算。 191位运算 198水DP 199利用二叉树前序遍历时，某一深度最后被访问的节点一定在本层最右这一性质。 200傻逼BFS 20112345678int rangeBitwiseAnd(int m, int n) &#123; int ans = 0, j = 1; while(m &amp;&amp; n)&#123; if((m &amp; 1) &amp;&amp; (n &amp; 1) &amp;&amp; m == n) ans |= j; m &gt;&gt;= 1, n &gt;&gt;= 1, j &lt;&lt;= 1; &#125; return ans;&#125; 不断考虑最低位。 202循环。 203水 204用埃氏筛，欧拉筛会被卡。 205用一个dict记录映射，一个set判断重复映射。 206把每一个节点往前面链 207其实就是判断整张图里面是否存在环。可以用 DFS 做，也可以做一次拓扑排序，然后判定是否所有顶点都进入了队列中。 208模板 209双指针，或者二分答案 210207 的升级版，做一次拓扑排序即可。 211Trie 树上套一个递归查询。好像也挺快的？ 213环形DP，考虑偷或者不偷第一家。 215nth_element() 216水 DFS 2171return len(set(nums)) &lt; len(nums) 219开一个dict记录一个数最后出现的位置，边遍历边更新。 220multiset水过，注意可恶的INT_MIN和INT_MAX。 221简单DP 222水 223简单容斥 225理论上每一次pop的时间复杂度都是$O(n)$（用来把栈顶放到队列的头），但可以通过多加几个缓冲队列来分摊一下时间复杂度。 226同非旋转treap。 227不是很懂为什么之前那个是困难，这个就是中等了原理都差不多 228水，但是注意溢出。。。 229神奇的摩尔投票法的扩展简单来说就是每次删除3个不同的数，这个使用计数器实现。然后检验剩下的两个候选数是不是真的满足条件（在原来的摩尔投票法中不需要，因为题目有这个条件）即可。12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int cx = 0, cy = 0, ax, ay; for (int i: nums)&#123; if(cx &amp;&amp; ax == i) cx++; else if(cy &amp;&amp; ay == i) cy++; else if(!cx) ax = i, cx = 1; else if(!cy) ay = i, cy = 1; else --cx, --cy; &#125; int n = nums.size(), cnt = 0; vector&lt;int&gt; ans; for (int i: nums) if(i == ax) cnt++; if(cnt &gt; n / 3) ans.push_back(ax); if(cy)&#123; cnt = 0; for (int i: nums) if(i == ay) cnt++; if(cnt &gt; n / 3) ans.push_back(ay); &#125; return ans; &#125;&#125;; 230在一般的平衡树中是通过记录子树的大小来实现的，但这里可以通过记录当前节点是中序遍历的第几个节点来实现。 231判断n == lowbit(n)。 232两个栈，一个用于反转，一个用于保存。先放进保存的栈里，如果要pop/peek，先检查反转栈里有没有，没有的话把保存栈里的全部pop进反转栈，然后输出即可。 234先用某种方法获取链表的中点，然后可以顺便反转了链表的前半部分，然后比对前后半部分即可。 235和下面的差不多，只是利用BST的特性可以判断具体该向哪一个方向走 236可以记录father然后向上爬，不过这样很麻烦。更快捷的做法是查找p和q在哪一个最深的子树当中，也就是对于每一个子树递归的去做。1234567891011class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL) return NULL; if(root == q || root == p) return root; TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q); if(l != NULL &amp;&amp; r != NULL) return root; //都有，那么自己就是LCA return l != NULL ? l: r; &#125;&#125;; 237由于题目中已经定位到了要删除的节点，所以按照传统方式删除是做不到的。要等价于“接管”后一个节点来做。12node-&gt;val = node-&gt;next-&gt;val;node-&gt;next = node-&gt;next-&gt;next; 238用对数。。。（并不）做两遍，从左乘和从右乘。 239经典单调队列 240最差劲的方法是对对角线二分，然后每次分成 3 个可能区域继续二分，这样做是 $O(n^{\log_2{3}})$ 的。（之前算错了复杂度）对其可以改进一下，先二分出某一行使得目标在数的大小上恰好处于这一行上面中间的数和这一行中间的数之间（形式化的说，若当前矩阵列的中间位置是 $mid$，那么要找到一个值 $row $ 满足 $\operatorname{matrix}[row- 1 ][mid]&lt;\text { target }&lt;\text {matrix}[\text {row}][m i d] $，前一个不等号始终不满足就取 $row$ 为第一行，后一个不等号始终不满足就取 $row$ 为最后一行的下一行 ），然后根据单调性可以发现答案一定不处于矩阵按这一行划分的左上部分和右下部分，分两个部分递归即可。还有一个更加优秀的办法：从矩阵的左下角开始，将当前格元素不断和目标比对，比目标小说明当前所在列可以舍去，比目标大说明当前所在行可以舍去。无论如何都要舍去一行或者一列，表明了该算法的时间复杂度是线性的。 241把表达式按照符号拆成两个部分，然后每一个部分分别计算可能的结果，在上一层合并起来。 242对字符串内字符排序后比较。也可以统计字符，比较各种字符数目。 257水 258观察可以发现答案和$n \mod 9$相关，实际也是。详细参见Digital Root1234567class Solution: def addDigits(self, num): """ :type num: int :rtype: int """ return (num - 1) % 9 + 1 if num != 0 else 0 260先把所有的数异或一遍，然后考虑结果的lowbit。这个bit必然存在于两个单独数的其中一个上，根据这个bit把这些数分成两个部分，分别异或一遍即可求出答案。 263看除掉所有$2, 3, 5$之后是不是$1$。注意条件是正整数。 264堆或者三指针。 即用一个序列记录所有丑数，然后对因子为2，3，5分别记录一个指针，这三个指针隐式的表示了三个单调队列的头节点。每次对这三个头节点取最小值更新即可。 注意一个数可能会出现在多个队列中，所以每一个头节点都要更新。 268根据列表长度判断$n$然后用$0+1+\cdots+n$减列表中数。 274排序贪心 275二分 278模板一样的二分 279DP。或者四平方定理。。。当且仅当$n=4^a(8b+7), a, b\in \mathbb{N}$的时候需要4个数。吃了没文化的亏。1234567891011121314151617181920212223class Solution &#123;public: int numSquares(int n) &#123; int tmp = n; while((tmp &amp; 3) == 0) tmp &gt;&gt;= 2; if(tmp % 8 == 7) return 4; int ssqrt = (int)floor(sqrt(n) + 0.5); if(ssqrt * ssqrt &gt; n) ssqrt--; if(ssqrt * ssqrt == n) return 1; int l = 1, r = ssqrt; while(l &lt; r)&#123; int res = l * l + r * r - n; if(res &gt; 0) r--; else if(res &lt; 0) l++; else return 2; &#125; if(2 * l * l == n) return 2; return 3; &#125;&#125;; 283看到$0$就删，末尾加回来。 284peek 之前复制一份自己，然后调用副本的 next。这是一种方法。 287不断使数归位，直到出现重复 290用两个dict同时记录原像和像。或者用一个dict记录双向。以下代码采用了前者。123456789101112131415161718class Solution: def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ domain, rng = &#123;&#125;, &#123;&#125; list1 = str.split() if len(list1) != len(pattern): return False for i, ch in enumerate(pattern): img, inv_img = rng.get(ch), domain.get(list1[i]) if img or inv_img: if img != list1[i] or inv_img != ch: return False domain[list1[i]] = ch rng[ch] = list1[i] return True 292观察发现$4 \mid n$时先手必败，其余情况下必胜。 299水 300LIS模板题。 303前缀和 304二维前缀和 306842 的退化版本 307树状数组 309对原来题目的DP方程稍作修改即可。 313n指针 315经典逆序对。 318用一个 int 来表示字母是否出现，然后 $O(n^2)$ 检查所有对即可。 319大力推公式1return int(n ** 0.5) 322大力DP吧，没什么好说的。。。 324先说明一个神奇的映射：对于$n$为奇数，$2i\mod n$可以实现把数组按下标的振动形式排序。如$0, 1, 2, 3, 4, 5, 6\rightarrow 0, 4, 1, 5, 2, 6, 3$。对于偶数的$n$，这个映射是$2i \mod {n-1}$，对于最后一个元素无效。这是以0为下标起始的形式，如果以1为开始那么就有统一的形式$2i+1 \mod {(n \text{ or } 1)}$。这样就可以先用nth_element找出中位数，然后12 326方法一循环。 方法二对数。1234567891011class Solution: def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n == 1: return True if n &lt;= 0 or n % 3 != 0: return False from math import log k = log(n) / log(3) return abs(k - round(k)) &lt; 1e-9 方法三如果不知道数据大小要用对数或者循环，知道的话判断$3^p \mod n$是否为$0$即可（因为$3$是质数），其中$\forall n, 3^p &gt; n$。1234567class Solution: def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ return n &gt; 0 and 1162261467 % n == 0 328模拟 331可以直接把问题转换为对叶子节点的验证。1234567891011class Solution: def isValidSerialization(self, preorder: str) -&gt; bool: lst = preorder.split(",") deg = 1 for idx, s in enumerate(lst): if deg == 0: return False deg += -1 if s == '#' else 1 return deg == 0 337简单树形DP 338递推 341用类似于前序遍历的方法即可。 342先判断是不是$2$的幂，再开方看看开不开得出。或者判断n &amp; 0x55555555 == n。 343只拆分成2或者3 344切片or函数。 345双指针法，类似快排。注意大小写。 347堆的经典应用之一——找前 $K$ 个最大元素的变形。用 Hash Table 来记录频率。时间复杂度是 $O(N\log K)$。 349set.intersection 350用Counter或者dict之类。 367循环or二分or看开方是不是整数。 368DP，先排序，这样只要保证前面的可以整除后面即可。这么做还是$O(n^2)$，如果拿双联通分量来做是不是也是这个事件复杂度？1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); sort(nums.begin(), nums.end()); vector&lt;int&gt; f(n, 1), bef(n, -1); int ans = 0, maxi = -1; for(int i = 0; i &lt; n; ++i)&#123; for (int j = i + 1; j &lt; n; ++j)&#123; if(nums[j] % nums[i]) continue; if(f[i] + 1 &gt; f[j]) f[j] = f[i] + 1, bef[j] = i; &#125; if(f[i] &gt; ans) ans = f[i], maxi = i; &#125; vector&lt;int&gt; aans; for (int i = 0, j = maxi; i &lt; ans; ++i, j = bef[j]) aans.push_back(nums[j]); return aans; &#125;&#125;; 371我用了+好像也没WA…? 372欧拉降幂公式 374水二分 383统计字符数，看看magazine中的字符够不够。 387统计字符数，找最靠前的只出现一次的字符。 389统计字符数，作差。 393字符串的解释方法是唯一的，所以只需要判定每一个字符是否符合要求即可。 397贪心，模4余3选择+1，模4余1选择-1。注意神奇的2147483647。 400方法一先找最高位然后一位一位向下找。推公式。1234567891011121314151617181920212223242526272829class Solution: def findNthDigit(self, n): """ :type n: int :rtype: int """ i, t, ten = 9, 1, 1 while n &gt; i * t: n -= i * t i *= 10 t += 1 ten *= 10 # 寻找所在数字的位数 ans = (1 + (n - 1) // (ten * t)) * ten n -= t * ten * (ans // ten - 1) ten //= 10 for j in range(t - 1, 0, -1): i = 0 while n &gt; (i + 1) * t * ten: i += 1 n -= i * t * ten ans += i * ten ten //= 10 for j in range(0, t - n): ans //= 10 return ans % 10 方法二可以在做完一层就补上前面一层缺少的位数，然后直接找到第$n$位属于哪一个数字。12345678910111213141516171819202122class Solution: def findNthDigit(self, n): """ :type n: int :rtype: int """ if n &lt; 10: return n i, p = 1, 9 while True: n += p p = p * 10 + 9 i += 1 if n &lt; i * p: return int(str((n + i - 1) // i)[(n + i - 1) % i]) """ 核心思想是补余。 寻找的顺序如下： 1 2 3 4 ... 9 -&gt; 01 02 03 ... 99 -&gt; 001 002 003 ... 999 所以n加的是p而不是i*p。只补上了前面的位数，与后面相齐。 """ 401大力枚举 405可以通过直接对 unsigned int 类型赋值来获取要转换的数。 409统计字符数，对于一种字符，如果有$2k+1$个就取$2k$个，否则全取。最后如果存在某种字符是奇数个就令其在中间，并且补上之前这种字符没取的那个。 412大水题 414维护第一，第二，第三大数。 415简单的高精度加法 416水DP 421Trie模板题 427常数谜之巨大 429简单BFS 430这是一个比较明显的递归结构，递归展开即可。 4341return len(s.split()) 437二重递归或者拿一个unordered_map统计。 438维护一个值$a$表示当前一个区间内有多少种字符数目和模板内该字符数目不同，然后移动更新$a$。类似滑动窗口。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findAnagrams(self, s, p): """ :type s: str :type p: str :rtype: List[int] """ def oord(x): return ord(x) - 97 list1, num = [0] * 26, 0 for i in p: idx = oord(i) list1[idx] += 1 if list1[idx] == 1: num += 1 list2, cnt = [0] * 26, 0 def calc(o, x): nonlocal cnt, list2 idx = oord(x) if list2[idx] == list1[idx]: cnt = cnt - 1 list2[idx] += o if list2[idx] == list1[idx]: cnt = cnt + 1 len1, len2, ans = len(p), len(s), [] if len1 &gt; len2: return ans for i in range(0, len1): calc(1, s[i]) if cnt == num: ans.append(0) for i in range(len1, len2): calc(-1, s[i - len1]) calc(1, s[i]) if cnt == num: ans.append(i - len1 + 1) return ans 441二分。 442基于和 448 相同的想法（这题完全就是 448 换了个说法吧） 443算出每一段相同字符的数目然后在原列表中加上去（用切片插入，否则报错）。本地修改也是可以的，稍微麻烦，可以参考下面的代码（来自这里）。12345678910111213class Solution(object): def compress(self, chars): anchor = write = 0 for read, c in enumerate(chars): if read + 1 == len(chars) or chars[read + 1] != c: chars[write] = chars[anchor] write += 1 if read &gt; anchor: for digit in str(read - anchor + 1): chars[write] = digit write += 1 anchor = read + 1 return write 445可以先记录链表的长度，然后反序保存高精度加法的结果（先不进位），然后再处理进位。 447暴力统计 448由于一个数只可能出现一或两次，一个性质成立：当第$i$个位置上的数不是$i$的时候，这个位置上的数就缺失了。所以构造一个“排序”：对每一个$i$，如果$i$位置上的数不是$i$，而是$k$，就将$i$与$k$位置的数交换，直到这两个要交换的数相同为止。可以看出这个算法是线性的，因为一次交换就会导致一个数回到原来的位置，而只有$n$个位置，所以至多交换$n$次。1234567891011121314151617class Solution: def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ len1 = len(nums) for i in range(0, len1): while nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] lst = [] for i in range(0, len(nums)): if nums[i] != i + 1: lst.append(i + 1) return lst 449其实和序列化和反序列化二叉树基本没什么区别，可能有一点区别在于可以只传输没有放置外部节点的前序遍历，然后利用搜索树性质获取中序遍历并且重建。后者在解码的时候理论上效率会差一点，因为要加上一个排序的过程。 450BST 基本操作 451基本同791 453$n-1$个元素同时增相当于剩下一个元素自己相对其他减，当每一个数相对大小相等就停止。因此可以统计所有元素的和$sum$和找出最小元素$mini$，那么$sum-mini$就是答案。这是所有非最小元素“减到”和最小元素相同的次数。123456789101112class Solution: def minMoves(self, nums): """ :type nums: List[int] :rtype: int """ sum, mini = 0, 3000000000 for i in nums: sum += i if i &lt; mini: mini = i return sum - mini * len(nums) 454先把两个数列组合起来，然后对其中一个做索引，另一个遍历一遍即可。 455排序之后贪心，尽量给完。 456考虑从右向左，找出一对逆序对，然后保证逆序对中较小的元素尽量大。这个过程可以用单调栈来实现。123456789101112131415class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 3) return false; stack&lt;int&gt; st; int maxi = INT_MIN, n = nums.size(); for (int i = n - 1; i &gt;= 0; --i)&#123; if (nums[i] &lt; maxi) return true; while (!st.empty() &amp;&amp; nums[i] &gt; st.top()) maxi = max(maxi, st.top()), st.pop(); st.push(nums[i]); &#125; return false; &#125;&#125;; 458本质是进制问题，或者状态空间之类的。可以归纳。12345678910111213class Solution(object): def poorPigs(self, buckets, minutesToDie, minutesToTest): """ :type buckets: int :type minutesToDie: int :type minutesToTest: int :rtype: int """ if buckets == 1: return 0 tot, ans = minutesToTest // minutesToDie, 1 while (tot + 1) ** ans &lt; 1.0 * buckets: ans += 1 return ans 459可以枚举总长度的倍数然后看子串是不是能拼出总串。更快的方法是看原串是否可以通过循环移位得到。具体写法是：1return s in (s + s)[1: -1] 461异或然后统计1的个数。 462中位数的应用 463BFS都不要 470并不是很懂这个题是怎么判定的，大概只要足够随机就行？ 474二维01背包 475排序后贪心or二分。 476利用反码=补码-1。 477每一位分别计算 478这题有两个方法：一个是在外切正方形里面做，不在圆内的点舍弃；或者用极坐标来做。但是极坐标在取半径的时候不能均匀取半径，否则靠近圆心的部分会更加密集一些。这个结论可以通过概率论来证明，不过可以直观地理解成：在等距离分布的情况下，由于外周的周长更大，所以外周上的点更加稀疏，进而靠近圆心的部分更加密集。可以证明，要想真正的均匀分布，半径的取值应该是 $r=R\sqrt {\text{random number}}$。 方法一（拒绝取样）1234567891011121314151617181920class Solution &#123;public: double r, x, y, pi; Solution(double radius, double x_center, double y_center) &#123; r = radius, x = x_center, y = y_center; srand(19722232); &#125; vector&lt;double&gt; randPoint() &#123; double a, b; for (; ; )&#123; a = (2.0 * rand() / RAND_MAX - 1.0) * r; b = (2.0 * rand() / RAND_MAX - 1.0) * r; if (a * a + b * b &gt; r * r) continue; else break; &#125; return vector&lt;double&gt;&#123;x + a, y + b&#125;; &#125;&#125;; 方法二（极坐标）12345678910111213141516class Solution &#123;public: double r, x, y, pi; Solution(double radius, double x_center, double y_center) &#123; r = radius, x = x_center, y = y_center; pi = 2.0 * acos(-1); srand(2131231); &#125; vector&lt;double&gt; randPoint() &#123; double a = r * sqrt(1.0 * rand() / RAND_MAX); double b = pi * rand() / RAND_MAX; double xx = a * cos(b), yy = a * sin(b); return vector&lt;double&gt;&#123;x + xx, y + yy&#125;; &#125;&#125;; 479伪·正解直接输出答案。12345678class Solution: def largestPalindrome(self, n): """ :type n: int :rtype: int """ ans = [9, 987, 123, 597, 677, 1218, 877, 475] return ans[n - 1] 正解（这种方法来自这里） 可以发现，当$n&gt;1$的时候最大的回文乘积都是偶数长度的（因为最高位都可以是$9$）。设最大的回文乘积为$U\times 10 ^ n + D = M\times L$。那么可以看出$U$和$D$是顺序恰好相反的两个数。设$M = 10^n - i$，$L = 10^n - j$，那么$M\times L = 10^{2n} - (i + j) \times 10^n + ij$。如果$i\times j &lt; 10^n$（这表明$i$和$j$可以很小，而这个结论适用于$n&gt;1$），那么可以得到$U = 10^n - (i + j)$，$D = i \times j$。这样我们设$a = i + j$，然后求出$U$，再根据$D = i \times (a - i)$解出整数$i$，解出来就成功了！实际上这还不是最优的。通过实验可以发现当$n$是偶数的时候有确定的解，其中$i = 1, j = 10^{\frac{n}{2}} +1$。所以只要对$n$为奇数的情况求解即可。1234567891011121314151617181920class Solution: def largestPalindrome(self, n): """ :type n: int :rtype: int """ if n == 1: return 9 p = 1 for i in range(0, n): p *= 10 if n &amp; 1 == 0: return (p - 1) * (p - int(p ** 0.5) + 1) % 1337 for a in range(2, p): u = p - a l = int(str(u)[: : -1]) if a ** 2 - 4 * l &gt;= 0: i = a + (a ** 2 - 4 * l) ** 0.5 if i // 2 == i / 2: return (u * p + l) % 1337 482字符串模拟。 485水 494水DP 496排序后从小到大，寻找每一个数$x$在原数组中右边的第一个元素，然后把$x$从原数组删去，如此反复。也可以维护一个递减的单调栈，从而得到答案。 498找规律 500水 501用三个变量分别维护当前统计元素、出现次数和最大出现次数。所以我真的不知道不用额外空间怎么做。。。这可能吗？ 503数组复制一遍，单调栈。节省空间的话可以不用复制 504简单进制转换 506水 507简单质因数分解。 509水 520简单模拟 521过于水 525把0变-1，寻找相同大小的前缀和。 530记录一下前驱就行了。 532排序后用指针 537水 538水 540按照元素出现位置二分 541水 542水BFS 543考察树的高度 551模拟 553第一个元素必然为分子，第二个元素必然为分母。其余的位置可以变。所以全部放在分子上。123456789class Solution: def optimalDivision(self, nums: List[int]) -&gt; str: if len(nums) == 1: return str(nums[0]) if len(nums) == 2: return str(nums[0]) + "/" + str(nums[1]) s = str(nums[0]) + "/(" for i in nums[1: -1]: s += str(i) + "/" s += str(nums[-1]) + ")" return s 556本质是求下一个排列 5571return " ".join([ss[: : -1] for ss in s.split()]) 559水 560利用 Hash Table 保存前缀和，扫一遍即可。 561排序 563水 565其实就是找置换的循环节 566模拟 567滑动窗口统计字符 575水 576水 DP 589, 590基本同二叉的情况 593正方形是菱形也是矩形，说明对角线相等并且四条边相等。依照这个对边排序计算即可。或者直接暴力枚举。 594直接使用 Hash Table 统计相邻元素。 598水 599枚举索引和，然后判定 606类似于树的括号表示方法 617简单的递归合并。速度有点慢？ 623水 628找最大的三个数和最小的两个数，取最大数和最小两数积与最大三数积更大者。 633方法一查表。12345678910111213141516class Solution: def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ list1 = [i * i for i in range(0, 65536)] i, j = 0, 65535 while 2 * i * i &lt;= c: while list1[j] &gt; c - i * i: j -= 1 if i * i + list1[j] == c: return True i += 1 return False 方法二双指针$l, r$，分别从$0$和$\sqrt{c}$向中间逼近。12345678910111213141516class Solution: def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ i, j = 0, int(c ** 0.5) + 1 while i &lt;= j: res = i * i + j * j if res == c: return True elif res &lt; c: i += 1 elif res &gt; c: j -= 1 return False 637水 638记忆化搜索 641水 647偷懒就用 $O(n^2)$ 的方法，或者用 Manacher 也可以。 650可以DP，但是效果很差劲。。。实际上根据DP方程可以发现产生的字符数目一定是某几个数的乘积。因此可以归纳得出：质数只能一个一个得到，然后两个质数的积的答案就是两个质数的和，质数的幂等同于多个质数相乘。所以做一次质因数分解即可。 654分治法找最大值 662用类似于完全二叉树的方式给节点编号来做。但这个题有一个非常变态的地方在于会出一些神奇数据，比如树直接退化成一条链，然后所有非叶子节点只有右子树。这样用 int 或者 long long 都会炸的很惨。这时要么用 unsigned long long 大力卡过去，要么用 Python 大力卡过去。但这些都是奇技淫巧。（等待正确做法，所以） 665小贪心 670小贪心 671其实就是求左右子树中最小的数（不和根相同）。。。写炸了。（不过性能好像还行） 672找规律。本质是异或操作的叠加。 673经典DP题，在原来DP数组的基础上加一个计数数组即可。时间复杂度$O(n^2)$。 674水 69312unsigned int res = (n ^ (n &gt;&gt; 1)) + 1u;return (res &amp; (res - 1)) == 0; 695傻逼BFS 701BST 基本操作 705拿 bitset 水过了，但总感觉不太好。。。 709大水题 713维护两个指针或者直接暴力向前取，只要保证把1跳过就行。 717因为是无前缀的编码所以可以直接扫一遍。更好的做法是发现最后两个相邻 0 之间必须有偶数个 1 才能满足条件。 718这是一个非常经典的问题：最长公共子串。当然，在这里因为数据量比较小，所以可以直接用 DP 做。当然还有万能的字符串 Hash。 720以长度为第一键值，字典序为第二键值对字符串排序，然后按不同长度暴力即可。 721并查集 725水 728一一判断。 738注意要改变的那一位是否是 1，有这个判断即可。 739单调栈的经典应用。 740排序后变成DP 746DP 747水题 754按奇偶性找规律，本质解方程。1234567891011121314151617181920class Solution: def reachNumber(self, target): """ :type target: int :rtype: int """ if target == 0: return 0 if target &lt; 0: target = -target l, r = 1, target while l &lt; r: mid = (l + r) &gt;&gt; 1 if target &lt;= mid * (mid + 1) // 2: r = mid else: l = mid + 1 return ((l + 1) &gt;&gt; 1) &lt;&lt; 1 | 1 if (((l + 1) &gt;&gt; 1) - target) &amp; 1 else l 762直接暴力就行了。 763贪心 766水 7711return sum([1 for c in S if c in J]) 777注意到操作前后非X字符的相对顺序不会变化，且R只能向右移动，L只能向左移动。模拟即可。 784枚举子集，可以用格雷码加速。 785水 787$O(NK)$ 最短路，这个是一个经典问题来着？只要做 $K$ 轮的松弛操作就行了。 790递推式 f[i] = f[i - 1] + f[i - 2] + 2\sum_{j = 1}^{i - 3} f[j]791自定义优先级即可 794先数一数每一种字符的数目。如果 X 比 O 多一个就保证后手不胜利，如果 X 和 O 一样多就保证先手不胜利，其他情况都是非法的。 795可以用单调栈做 796水 797大力 DFS 801不是很水的 DP 804set 去重 811简单的统计 812数据比较小，可以暴力。大的话凸包+旋转卡壳 813大力DP 814递归清除左右子树，如果发现自己成了 0 叶子就说明自己这棵子树全是 0，于是自我清除。 817用一个 bitset 将所有列表中的数记录下来，然后在链表上遍历一遍即可。 821这个，没什么好说的。。。每次处理两个相邻的 C 即可。 829手推公式，发现可以做到 $O(\sqrt{N})$。 832水 833一边扫描一边替换即可。 840简单模拟 841水 BFS 842暴力，注意前两个数可以比较小12345678910111213141516171819202122232425262728293031class Solution: def splitIntoFibonacci(self, S: str) -&gt; List[int]: l = len(S) lst = [] for i in range(1, (2 * l) // 3): for j in range(0, (i + 1) // 2): if S[0] == "0" and j + 1 != 1: break if S[j + 1] == "0" and i - j != 1: continue lst.append(int(S[0: j + 1])) lst.append(int(S[j + 1: i + 1])) cur = i + 1 flag = 1 while cur &lt; l: nxt = lst[-1] + lst[-2] ll = len(str(nxt)) if ll + cur &gt; l or int(S[cur: cur + ll]) != nxt or nxt &gt;= 2147483648: flag = 0 break lst.append(nxt) cur += ll if not flag: lst.clear() continue else: return lst return lst 849水 855一种做法的大致思想是：保存区间的左端点，和其对应长度的一半，用一个 set 来存，然后每次选出区间长度最大的那个，将数插入后一分为二；删除的时候将原来被分割开的两个区间合二为一。实际上好像有更优秀的做法。 859先判断长度是否完全相同，再判断是否存在这样两个字符。 860贪心 863如果这个树使用邻接表保存的话事情会方便很多，但是这里比较可惜，不是。所以可以用一个 Hash Table，先找到目标点，然后求出目标点的所有祖先到其的距离，然后再一次 DFS 算出所有点到其的距离。实际上修改一下应该是可以去掉 Hash Table 的。 865和 1123 差不多（我先做的 1123） 866打表方法不是很难。如果要做在线判断的话可以考虑先二分出起始位置然后枚举回文数。实际上有一个性质非常强的剪枝：偶数长度的回文数全都不是质数。因为它们全部可以被分解为形如 $1000…0001n$ 之和的形式，其中 $0$ 的个数是偶数个。而 $1000…0001 - 11 = 999…9990$，$9$ 的个数也是偶数个。所以必然被 11 整除。加上这个剪枝就能跑的很快了。没加上也无所谓，反正在判定质数的时候会很早被 11 毙掉。 867模拟 868水，可以看出python字符串很慢？ 869水 870排序后贪心：从 B 中最小的数开始，找 A 中第一个大于它的数，然后继续对 B 中次小的找对应的，以此类推。 872水 873方法一大力枚举，由于斐波那契数的增长速度是指数级别的，所以总序列长度大约是 $\log$ 级别的。所以总时间复杂度是 $O(n^2\log m)$。$m$ 可以看作是序列中的最大数。 874用数据结构（比如 Hash Table 或者是 Set）来保存所有的障碍点，然后直接模拟即可。 875二分 877DP或者数学。因为先手必然可以取走所有编号奇偶性相同的堆，而编号全为奇数的堆总和和编号全为偶数的堆总和中必然有一个相对更大的，因此先手必胜。1return True # 就是这么自信。 884用Counter 888只要找一组解就很简单 890保存字符之间的双射即可，对每一个单词做一遍。好像前面有非常类似的题目。 893按下标奇偶性拆分字符串，排序后重组，再用set去重。 896水，可以遍历两遍或一遍，这取决于写法。 905双指针交换或者新开两个数组。 908找最小值$+K$和最大值$-K$之间关系。 912？ 914最大公约数。 916先对 B 中每一个单词做一次字符统计，取 max 后再在 A 中统计。 917双指针 918用单调队列是非常睿智的做法。。。要么是中间的一段被选，要么是中间的一段不被选。二者择其一即可。 919模仿堆插入思路 921直接对右括号进行匹配，然后剩余的左括号和右括号数目和就是答案。 922水 925字符串分段，比较段长。 926水 929简单的字符串处理。 932构造层级结构。可以发现一个数列A_n保持了这个性质，那么对A_n的每一项加（或者减）去一个定值或者乘上一个非零数也会保持这样一个性质。从而构造递归结构：基础：$n=2$，答案是$1, 2$。向上：$n=2^k\rightarrow n=2^{k+1}$，$n=2^k$时答案是A_k，$n=2^{k+1}$时答案是2A_k-1和2A_k相连接。1234567891011class Solution: def beautifulArray(self, N): """ :type N: int :rtype: List[int] """ lst, len1 = [1], 1 while len1 &lt; N: lst = [(i &lt;&lt; 1) - 1 for i in lst] + [i &lt;&lt; 1 for i in lst] len1 &lt;&lt;= 1 return [i for i in lst if i &lt;= N] 933模拟 937注意字母排序指的是对每一个字形成的列表进行字典序排序。 938水 939暴力枚举矩阵的对角上两个点，然后查找能不能找到另外两个点。 941注意边界 942一种做法是求出相对高度数组。设第一个数的高度为$0$，维护当前最大上升量$up$和最大下降量$down$，遇到I则该位相对高度为$up$，并上升量$+1$，遇到D则该位相对高度为$down$，并下降量$-1$，如此可以保证每一位上的相对高度都不同，然后按照相对高度分配$0, 1, \cdots, n$即可。 944简单比较，注意这个题目中的有序指的是字母的ASCII码不递减。 946模拟出栈即可。 947按照在同一行或者同一列的关系将点连起来建图，一个连通块内的元素总可以被消去的只剩一个。所以只要找出联通块数目即可。这个可以用并查集维护。 949小模拟 957循环节 961用bitset大力弄过。或者考虑元素之间的关系，这$N$个数要么相邻，要么全部间隔为1。依照此原则判断。 970水 973K小堆 974记录余数方案数目 976经典题目，对边长排序，然后可以组成最大三角形的三条边在排序之后的数组里面一定是连续的。依照这个枚举判定即可。 977找到负数和非负数的分解，双指针即可。 985水 989普通高精度加法 993记录一下深度即可。 994水BFS 997判入度，出度即可。 1004类滑动窗口，注意$K=0$的神奇情况。 1006模拟 1008偷懒的做法是直接把 105 的方法搬过来，然而利用 BST 性质会更加简洁一些。 1009简单位运算 1013双指针 1015等价于寻找$t$使得$10^t\equiv 1 \pmod{9K}$，用欧拉定理，结合指数循环节即可。 1016最简单的方法是枚举子串，然后判断 1 到 N 之间的数是不是全占了。实际上没必要，因为 $[2^(k-1), 2^k-1]$ 这个区间中的数包含了所有 $[0, 2^(k-1))$ 的数（这里包含是指子串意义上的），所以我们可以只需要判断离 $N$ 最近的 $2^k$ 长度的区间，并上长度不满 $2^k$ 的以 $N$ 为右端点的区间即可。 1017求负的二进制。具体流程和求二进制基本相同，求出对-2的余数的绝对值，减掉这个绝对值然后除以-2，直到0为止。可以看出把-2替换为别的正整数就是求正进制表达的方法。 1018水 1021水 1022DFS 1033先对三个石头的位置排序，然后最大的移动次数就是最远-最近-2，最少的移动次数特判间距为1和间距为2的两个情况。 1037先判断三个点是否不同，然后再判断是否共线。 1038在中序遍历上跑一个前缀和，然后按照中序遍历把值赋回去。 1039其实就是一个简单的区间DP，但当初想得谜之复杂，就没做出来。。。实际上为了避免点之间的循环顺序，只需要考虑某一段点之间，第一个点和最后一个点相连的边对应的三角形。 1041能够走出圈的充要条件是末状态朝向不变和行动距离大于1。 1042水四染色 1043水DP 1071水 1091简单 BFS 1093简单统计 1103简单的找规律 1108水 1109借教室？ 1122把原本的对数排序改成对元组进行排序即可。 1123实际上不需要管什么叶子，只要管两个子树间高度的比较，然后分情况处理就行了。。。不知道为什么写的乱七八糟。 1124写了一个 $O(n\log n)$ 的水算法，发现这题居然可以用单调栈做。。。 1137水 1138小模拟 1139矩阵前缀和优化判断 1144要么只削减偶数位置的元素，要么只削减奇数位置的元素。 1145以 x 为根，判定三个子树中是否存在比另外两棵节点数都多的一棵，有的话 y 就能获胜，反之则不能。 1146可持久化数组（主席树）没有必要用那么高级的东西。每一个位置都用 Hash Table 来保存即可。所以说思维还是要开阔啊。。。12345678910111213141516171819202122232425class SnapshotArray &#123;public: vector&lt;map&lt;int, int&gt;&gt; arr; int cnt; SnapshotArray(int length) &#123; cnt = 0; for (int i = 0; i &lt; length; ++i) arr.push_back(map&lt;int, int&gt;()), arr[i][0] = 0; &#125; void set(int index, int val) &#123; arr[index][cnt] = val; &#125; int snap() &#123; int res = cnt++; return res; &#125; int get(int index, int snap_id) &#123; auto it = arr[index].upper_bound(snap_id); --it; return (*it).second; &#125;&#125;; 1150能用一行解决的最好就用一行。。。1return collections.Counter(nums).get(target, -1) &gt; (len(nums) // 2) 1151滑动窗口，找 0 最少那个。 1152这题特别麻烦。。。如果使用的是朴素的算法的话很容易写一大串。大概思路就是暴力，但怎么写是一个很有意思的问题。我最开始写的版本有接近 90 行，并且调试了很久，而后看了其他人的发现根本不需要这么复杂。。。下面给一个我修改过的大概的实例作为简短代码的参考。12 1154水 1155递推 1156有点麻烦，但基本思想还可以：考虑长度为 1 的单字符子串，如果两侧的单字符子串包含相同的字符，那就看看能不能从别的地方弄一个字符和它交换以将两侧连接起来。这里有一些边界情况的讨论。注意对于长度不为 1 的单字符子串也要考虑能不能将其端点旁的字符换成其包含的字符，这也是情况之一。上面这个做法是线性的。 1160模拟 1161统计 1162BFS]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode近期做题 简要题解]]></title>
    <url>%2F2018%2F11%2F24%2Fleetcode-easy-normal%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[记录一点简要题解。个人认为以下题目中比较好的：11，19，84，96，137，189，229，258，260，264，290，324，326，368，400，438，448，453，458，459，479，633，754，877，932，939 1水 2水 3统计字符，维护桶。 6模拟或者推公式。 7基本上和翻转字符串相同。特判负数和溢出。 8小模拟 9用字符串。 11方法一排序，找周围比自己高的，进而找最远的。123456789101112131415161718class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ len1 = len(height) h = list(zip(height, range(0, len1))) h.sort(key = lambda x: x[0]) ans = 0 hd, tl = 0, len1 - 1 for i in h: hh, idx = i[0], i[1] ans = max(ans, max(idx - hd, tl - idx) * hh) height[idx] = -1 while hd &lt; tl and height[hd] == -1: hd += 1 while hd &lt; tl and height[tl] == -1: tl -= 1 return ans 方法二使用两个分别指向头和尾的指针，每次比较两个指针所指的木板的长度，将指向较小者的指针向中间地区移动，这样就可以保证能找到最大的解。这样做是线性的时间复杂度。123456789101112131415class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ len1 = len(height) i, j, ans = 0, len1 - 1, 0 while i &lt; j: ans = max(ans, min(height[i], height[j]) * (j - i)) if height[i] &lt; height[j]: i += 1 else: j -= 1 return ans 12模拟 13小模拟 14二分最长前缀长度。可以用startswith()。 15基本同18，不过简单很多 16暴力可以做，但是时间效率不行。应该是先排序然后用双指针。 17水 18折半搜索 19这题有点厉害。。。先用一个快指针跳$n$个点，然后慢指针从头开始，两个指针始终维护$n$的间距。快指针到末尾时慢指针到答案处。123456789101112131415class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == NULL) return NULL; ListNode *hhd = new ListNode(-1), *res = hhd; hhd-&gt;next = head; ListNode *fst = hhd; for (int i = 0; i &lt; n; ++i) fst = fst-&gt;next; while(fst-&gt;next != NULL) fst = fst-&gt;next, hhd = hhd-&gt;next; hhd-&gt;next = hhd-&gt;next-&gt;next; return res-&gt;next; &#125;&#125;; 20水栈。 21水归并 22水DFS 24加一个头节点即可 26可以用双指针法。 27遍历。 281str.find() 29倍增。-2147483648的情况非常不好做。 311next_permutation(nums.begin(), nums.end()); 33先二分找到旋转的地方，再普通二分。 34二分。等同于实现lower_bound()和upper_bound()。 35二分。基本等同于34题。 36模拟 38容易 39完全背包记录方案 40DFS 46简单全排列构造 47排序后递归全排列，或者直接next_permutation? 48水 49把元组或者正规化的字符串作为键其实可以，不过有一个神奇操作是用质数作为状态压缩的工具，把一个字符串映射成为一个数。实在是非常创新了。（虽然两个做法效率差不多） 501return x ** n 53我觉得$O(n)$更精妙来着… 54模拟 56按左端点从左到右排序，模拟即可。 58水 59和54题配套 60康拓展开 61先遍历一遍求出总长，再找到要切断的地方。 62水递推 63简单递推。 64DP 66水 671return bin(int(a, 2) + int(b, 2))[2: ] 69二分or函数。 70递推。斐波那契数列。 73可以把每一个0提到每一行/列的第一个位置，这样就不用保存每一行/列是否有0出现了。 74类似于二分 77基本的递归组合。 78基本的二进制数构造子集。 80理论上任意指定的保留数目都可以实现。 82水 83水 88从尾部开始合并有序队列。 90先排序算出每一种数的个数，然后把答案的vector建出来，按照特定的顺序向里面添加一定数目的元素即可。有直接生成然后去重的偷懒做法，不提倡。 92这题做法比较多，我用的是维护链表$m-1, m, n+1$三个位置，然后根据各自位置判断链接方式的方法。 94, 144水迭代应该是指用栈记录上一次访问了什么，然后遇到这个节点更新，如果全部弄完了就出栈。 96经典问题。答案是Catalan数。 98中序遍历 100水 101递归遍历用两个参数 102BFS 103每一层按照奇偶性转一下 104水 105, 106模板 107把102的结果reverse即可。 108相当于构建一棵AVL树。只需要每次对半切分子序列即可。 109基本同108 110按照题意模拟即可。 112水 113水 114水 116对于一个根节点，令左儿子连接右儿子，右儿子连接根的next的左儿子。 117基本同116，不过找next要沿着next链跳，且要先向右走。或者，一个更好的方法是按层构建next，因为构建了一层next就可以在这层基础上把所有子节点的next构造出来。 118水 119利用组合数公式 120普通DP 121维护当前所遇到的最小数$mini$，然后从左向右扫，每遇到一个数就尝试更新答案和$mini$。 122简单DP 125正规化字符串之后直接判定。 129简单递推 130BFS 134跑一遍就行，如果从$i$跑不到$j$，那么从$i+1, i+2, …, j-1$也跑不到$j$。证明很简单。 136异或 137方法一基本做法是统计每一位的1数目，看看哪一位的次数模$3$余$1$，然后把这些位或起来。12345678910111213141516171819202122class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ ans, j, cnt1, cnt2 = 0, 1, 0, 0 for i in range(0, 32): for t in nums: if t &gt;= 0: if t &amp; j: cnt1 += 1 else: if (-t) &amp; j: cnt2 += 1 if cnt1 % 3 == 1: ans += j elif cnt2 % 3 == 1: ans += -j j &lt;&lt;= 1 cnt1, cnt2 = 0, 0 return ans 方法二对于这道题而言，我们寄希望于能找到一种方法，利用位运算，来实现三进制的无进位加法。换言之，有没有什么方法可以实现某些位上出现00-&gt;01-&gt;10-&gt;00的循环呢？答案是有的。因为是二进制，所以我们可以考虑用两个二进制数表示一个三进制的数。这里直接给出这种运算方法。手算可以发现它实现了b，a上同一位00-&gt;01-&gt;10-&gt;00的变化（因为我也不知道这是怎么想到的，代码来自中文leetcode本题评论区）事实上，利用逻辑运算规则可以构造出这样一个真值函数，来实现三进制的运算。1234567891011class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ a, b = 0, 0 for num in nums: b = ~a &amp; (b ^ num) a = ~b &amp; (a ^ num) return b 141Floyd判圈法 142不让用额外空间就还行，那就乱搞。。。不乱搞实际就是Floyd判圈法的一个推论。 150水，但是用python小心python的神奇负数除法 155单调栈 160先求出两个表头的深度，然后把两个表头放到同一深度，再一起向前走。 167双指针 168特殊的进制问题，对于进位要特殊处理，或者每每次循环先让$n$自减1。 169摩尔投票法，经典问题。 17112for (int i = 0; i &lt; n; ++i) ans = ans * 26 + s[i] - 'A' + 1; 172统计这个阶乘中因子$2$和$5$的次数，取其较小者。但显然后者更少，所以只要统计后者。 178比较两个数字相连之后的字典序。 187压成20位的二进制数，然后bitset记录 189方法一根据$k$把原序列切分成两段，然后递归交换这两段。123456789101112131415161718192021222324252627class Solution: def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ len1 = len(nums) k %= len1 if k == 0 or len1 == 1: return a1, b1, a2, b2 = 0, len1 - 1 - k, len1 - k, len1 - 1 # 均以下标为准 while b2 - a2 != b1 - a1: if b2 - a2 &gt; b1 - a1: len2 = (b1 - a1 + 1) else: len2 = (b2 - a2 + 1) for i in range(0, len2): nums[a1 + i], nums[b2 - len2 + 1 + i] = nums[b2 - len2 + 1 + i], nums[a1 + i] if b2 - a2 &gt; b1 - a1: b2 -= len2 else: a1 += len2 len2 = b1 - a1 + 1 for i in range(0, len2): nums[a1 + i], nums[a2 + i] = nums[a2 + i], nums[a1 + i] 方法二采取类似于非旋转treap的方法，按照$k$把序列切分成为两段，然后分别逆序两段，再将一整段逆序就可以得到答案。123456789101112131415161718class Solution: def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ def rev(a, b): mid = (a + b) &gt;&gt; 1 for i in range(a, mid + 1): nums[i], nums[b + a - i] = nums[b + a - i], nums[i] len1 = len(nums) k %= len1 if k != 0: rev(0, len1 - k - 1) rev(len1 - k, len1 - 1) rev(0, len1 - 1) 方法三我猜是暴力移动…? 190用bin()，但也可以用位运算。 191位运算 198水DP 200傻逼BFS 20112345678int rangeBitwiseAnd(int m, int n) &#123; int ans = 0, j = 1; while(m &amp;&amp; n)&#123; if((m &amp; 1) &amp;&amp; (n &amp; 1) &amp;&amp; m == n) ans |= j; m &gt;&gt;= 1, n &gt;&gt;= 1, j &lt;&lt;= 1; &#125; return ans;&#125; 不断考虑最低位。 202循环。 203水 204用埃氏筛，欧拉筛会被卡。 205用一个dict记录映射，一个set判断重复映射。 206把每一个节点往前面链 208模板 209双指针，或者二分答案 213环形DP，考虑偷或者不偷第一家。 215nth_element() 2171return len(set(nums)) &lt; len(nums) 219开一个dict记录一个数最后出现的位置，边遍历边更新。 220multiset水过，注意可恶的INT_MIN和INT_MAX。 221简单DP 222水 223简单容斥 225理论上每一次pop的时间复杂度都是$O(n)$（用来把栈顶放到队列的头），但可以通过多加几个缓冲队列来分摊一下时间复杂度。 226同非旋转treap。 227不是很懂为什么之前那个是困难，这个就是中等了原理都差不多 229神奇的摩尔投票法的扩展简单来说就是每次删除3个不同的数，这个使用计数器实现。然后检验剩下的两个候选数是不是真的满足条件（在原来的摩尔投票法中不需要，因为题目有这个条件）即可。12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int cx = 0, cy = 0, ax, ay; for (int i: nums)&#123; if(cx &amp;&amp; ax == i) cx++; else if(cy &amp;&amp; ay == i) cy++; else if(!cx) ax = i, cx = 1; else if(!cy) ay = i, cy = 1; else --cx, --cy; &#125; int n = nums.size(), cnt = 0; vector&lt;int&gt; ans; for (int i: nums) if(i == ax) cnt++; if(cnt &gt; n / 3) ans.push_back(ax); if(cy)&#123; cnt = 0; for (int i: nums) if(i == ay) cnt++; if(cnt &gt; n / 3) ans.push_back(ay); &#125; return ans; &#125;&#125;; 231判断n == lowbit(n)。 232两个栈，一个用于反转，一个用于保存。先放进保存的栈里，如果要pop/peek，先检查反转栈里有没有，没有的话把保存栈里的全部pop进反转栈，然后输出即可。 234先用某种方法获取链表的中点，然后可以顺便反转了链表的前半部分，然后比对前后半部分即可。 235和下面的差不多，只是利用BST的特性可以判断具体该向哪一个方向走 236可以记录father然后向上爬，不过这样很麻烦。更快捷的做法是查找p和q在哪一个最深的子树当中，也就是对于每一个子树递归的去做。1234567891011class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL) return NULL; if(root == q || root == p) return root; TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q); if(l != NULL &amp;&amp; r != NULL) return root; //都有，那么自己就是LCA return l != NULL ? l: r; &#125;&#125;; 237由于题目中已经定位到了要删除的节点，所以按照传统方式删除是做不到的。要等价于“接管”后一个节点来做。12node-&gt;val = node-&gt;next-&gt;val;node-&gt;next = node-&gt;next-&gt;next; 238用对数。。。（并不）做两遍，从左乘和从右乘。 239经典单调队列 242对字符串内字符排序后比较。也可以统计字符，比较各种字符数目。 257水 258观察可以发现答案和$n \mod 9$相关，实际也是。详细参见Digital Root1234567class Solution: def addDigits(self, num): """ :type num: int :rtype: int """ return (num - 1) % 9 + 1 if num != 0 else 0 260先把所有的数异或一遍，然后考虑结果的lowbit。这个bit必然存在于两个单独数的其中一个上，根据这个bit把这些数分成两个部分，分别异或一遍即可求出答案。 263看除掉所有$2, 3, 5$之后是不是$1$。注意条件是正整数。 264堆或者三指针。 即用一个序列记录所有丑数，然后对因子为2，3，5分别记录一个指针，这三个指针隐式的表示了三个单调队列的头节点。每次对这三个头节点取最小值更新即可。 注意一个数可能会出现在多个队列中，所以每一个头节点都要更新。 268根据列表长度判断$n$然后用$0+1+\cdots+n$减列表中数。 274排序贪心 275二分 278模板一样的二分 279DP。或者四平方定理。。。当且仅当$n=4^a(8b+7), a, b\in \mathbb{N}$的时候需要4个数。吃了没文化的亏。1234567891011121314151617181920212223class Solution &#123;public: int numSquares(int n) &#123; int tmp = n; while((tmp &amp; 3) == 0) tmp &gt;&gt;= 2; if(tmp % 8 == 7) return 4; int ssqrt = (int)floor(sqrt(n) + 0.5); if(ssqrt * ssqrt &gt; n) ssqrt--; if(ssqrt * ssqrt == n) return 1; int l = 1, r = ssqrt; while(l &lt; r)&#123; int res = l * l + r * r - n; if(res &gt; 0) r--; else if(res &lt; 0) l++; else return 2; &#125; if(2 * l * l == n) return 2; return 3; &#125;&#125;; 283看到$0$就删，末尾加回来。 287不断使数归位，直到出现重复 290用两个dict同时记录原像和像。或者用一个dict记录双向。以下代码采用了前者。123456789101112131415161718class Solution: def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ domain, rng = &#123;&#125;, &#123;&#125; list1 = str.split() if len(list1) != len(pattern): return False for i, ch in enumerate(pattern): img, inv_img = rng.get(ch), domain.get(list1[i]) if img or inv_img: if img != list1[i] or inv_img != ch: return False domain[list1[i]] = ch rng[ch] = list1[i] return True 292观察发现$4 \mid n$时先手必败，其余情况下必胜。 300LIS模板题。 303前缀和 304二维前缀和 307树状数组 309对原来题目的DP方程稍作修改即可。 313n指针 315经典逆序对。 319大力推公式1return int(n ** 0.5) 322大力DP吧，没什么好说的。。。 324先说明一个神奇的映射：对于$n$为奇数，$2i\mod n$可以实现把数组按下标的振动形式排序。如$0, 1, 2, 3, 4, 5, 6\rightarrow 0, 4, 1, 5, 2, 6, 3$。对于偶数的$n$，这个映射是$2i \mod {n-1}$，对于最后一个元素无效。这是以0为下标起始的形式，如果以1为开始那么就有统一的形式$2i+1 \mod {(n \text{ or } 1)}$。这样就可以先用nth_element找出中位数，然后12 326方法一循环。 方法二对数。1234567891011class Solution: def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n == 1: return True if n &lt;= 0 or n % 3 != 0: return False from math import log k = log(n) / log(3) return abs(k - round(k)) &lt; 1e-9 方法三如果不知道数据大小要用对数或者循环，知道的话判断$3^p \mod n$是否为$0$即可（因为$3$是质数），其中$\forall n, 3^p &gt; n$。1234567class Solution: def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ return n &gt; 0 and 1162261467 % n == 0 328模拟 337简单树形DP 338递推 342先判断是不是$2$的幂，再开方看看开不开得出。或者判断n &amp; 0x55555555 == n。 343只拆分成2或者3 344切片or函数。 345双指针法，类似快排。注意大小写。 349set.intersection 350用Counter或者dict之类。 367循环or二分or看开方是不是整数。 368DP，先排序，这样只要保证前面的可以整除后面即可。这么做还是$O(n^2)$，如果拿双联通分量来做是不是也是这个事件复杂度？1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); sort(nums.begin(), nums.end()); vector&lt;int&gt; f(n, 1), bef(n, -1); int ans = 0, maxi = -1; for(int i = 0; i &lt; n; ++i)&#123; for (int j = i + 1; j &lt; n; ++j)&#123; if(nums[j] % nums[i]) continue; if(f[i] + 1 &gt; f[j]) f[j] = f[i] + 1, bef[j] = i; &#125; if(f[i] &gt; ans) ans = f[i], maxi = i; &#125; vector&lt;int&gt; aans; for (int i = 0, j = maxi; i &lt; ans; ++i, j = bef[j]) aans.push_back(nums[j]); return aans; &#125;&#125;; 371我用了+好像也没WA…? 372欧拉降幂公式 374水二分 383统计字符数，看看magazine中的字符够不够。 387统计字符数，找最靠前的只出现一次的字符。 389统计字符数，作差。 397贪心，模4余3选择+1，模4余1选择-1。注意神奇的2147483647。 400方法一先找最高位然后一位一位向下找。推公式。1234567891011121314151617181920212223242526272829class Solution: def findNthDigit(self, n): """ :type n: int :rtype: int """ i, t, ten = 9, 1, 1 while n &gt; i * t: n -= i * t i *= 10 t += 1 ten *= 10 # 寻找所在数字的位数 ans = (1 + (n - 1) // (ten * t)) * ten n -= t * ten * (ans // ten - 1) ten //= 10 for j in range(t - 1, 0, -1): i = 0 while n &gt; (i + 1) * t * ten: i += 1 n -= i * t * ten ans += i * ten ten //= 10 for j in range(0, t - n): ans //= 10 return ans % 10 方法二可以在做完一层就补上前面一层缺少的位数，然后直接找到第$n$位属于哪一个数字。12345678910111213141516171819202122class Solution: def findNthDigit(self, n): """ :type n: int :rtype: int """ if n &lt; 10: return n i, p = 1, 9 while True: n += p p = p * 10 + 9 i += 1 if n &lt; i * p: return int(str((n + i - 1) // i)[(n + i - 1) % i]) """ 核心思想是补余。 寻找的顺序如下： 1 2 3 4 ... 9 -&gt; 01 02 03 ... 99 -&gt; 001 002 003 ... 999 所以n加的是p而不是i*p。只补上了前面的位数，与后面相齐。 """ 401大力枚举 409统计字符数，对于一种字符，如果有$2k+1$个就取$2k$个，否则全取。最后如果存在某种字符是奇数个就令其在中间，并且补上之前这种字符没取的那个。 412大水题 414维护第一，第二，第三大数。 415简单的高精度加法 416水DP 421Trie模板题 427常数谜之巨大 429简单BFS 4341return len(s.split()) 437二重递归或者拿一个unordered_map统计。 438维护一个值$a$表示当前一个区间内有多少种字符数目和模板内该字符数目不同，然后移动更新$a$。类似滑动窗口。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findAnagrams(self, s, p): """ :type s: str :type p: str :rtype: List[int] """ def oord(x): return ord(x) - 97 list1, num = [0] * 26, 0 for i in p: idx = oord(i) list1[idx] += 1 if list1[idx] == 1: num += 1 list2, cnt = [0] * 26, 0 def calc(o, x): nonlocal cnt, list2 idx = oord(x) if list2[idx] == list1[idx]: cnt = cnt - 1 list2[idx] += o if list2[idx] == list1[idx]: cnt = cnt + 1 len1, len2, ans = len(p), len(s), [] if len1 &gt; len2: return ans for i in range(0, len1): calc(1, s[i]) if cnt == num: ans.append(0) for i in range(len1, len2): calc(-1, s[i - len1]) calc(1, s[i]) if cnt == num: ans.append(i - len1 + 1) return ans 441二分。 443算出每一段相同字符的数目然后在原列表中加上去（用切片插入，否则报错）。本地修改也是可以的，稍微麻烦，可以参考下面的代码（来自这里）。12345678910111213class Solution(object): def compress(self, chars): anchor = write = 0 for read, c in enumerate(chars): if read + 1 == len(chars) or chars[read + 1] != c: chars[write] = chars[anchor] write += 1 if read &gt; anchor: for digit in str(read - anchor + 1): chars[write] = digit write += 1 anchor = read + 1 return write 445可以先记录链表的长度，然后反序保存高精度加法的结果（先不进位），然后再处理进位。 447暴力统计 448由于一个数只可能出现一或两次，一个性质成立：当第$i$个位置上的数不是$i$的时候，这个位置上的数就缺失了。所以构造一个“排序”：对每一个$i$，如果$i$位置上的数不是$i$，而是$k$，就将$i$与$k$位置的数交换，直到这两个要交换的数相同为止。可以看出这个算法是线性的，因为一次交换就会导致一个数回到原来的位置，而只有$n$个位置，所以至多交换$n$次。1234567891011121314151617class Solution: def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ len1 = len(nums) for i in range(0, len1): while nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] lst = [] for i in range(0, len(nums)): if nums[i] != i + 1: lst.append(i + 1) return lst 451基本同791 453$n-1$个元素同时增相当于剩下一个元素自己相对其他减，当每一个数相对大小相等就停止。因此可以统计所有元素的和$sum$和找出最小元素$mini$，那么$sum-mini$就是答案。这是所有非最小元素“减到”和最小元素相同的次数。123456789101112class Solution: def minMoves(self, nums): """ :type nums: List[int] :rtype: int """ sum, mini = 0, 3000000000 for i in nums: sum += i if i &lt; mini: mini = i return sum - mini * len(nums) 454先把两个数列组合起来，然后对其中一个做索引，另一个遍历一遍即可。 455排序之后贪心，尽量给完。 458本质是进制问题，或者状态空间之类的。可以归纳。12345678910111213class Solution(object): def poorPigs(self, buckets, minutesToDie, minutesToTest): """ :type buckets: int :type minutesToDie: int :type minutesToTest: int :rtype: int """ if buckets == 1: return 0 tot, ans = minutesToTest // minutesToDie, 1 while (tot + 1) ** ans &lt; 1.0 * buckets: ans += 1 return ans 459可以枚举总长度的倍数然后看子串是不是能拼出总串。更快的方法是看原串是否可以通过循环移位得到。具体写法是：1return s in (s + s)[1: -1] 461异或然后统计1的个数。 462中位数的应用 463BFS都不要 470并不是很懂这个题是怎么判定的，大概只要足够随机就行？ 474二维01背包 475排序后贪心or二分。 476利用反码=补码-1。 477每一位分别计算 479伪·正解直接输出答案。12345678class Solution: def largestPalindrome(self, n): """ :type n: int :rtype: int """ ans = [9, 987, 123, 597, 677, 1218, 877, 475] return ans[n - 1] 正解（这种方法来自这里） 可以发现，当$n&gt;1$的时候最大的回文乘积都是偶数长度的（因为最高位都可以是$9$）。设最大的回文乘积为$U\times 10 ^ n + D = M\times L$。那么可以看出$U$和$D$是顺序恰好相反的两个数。设$M = 10^n - i$，$L = 10^n - j$，那么$M\times L = 10^{2n} - (i + j) \times 10^n + ij$。如果$i\times j &lt; 10^n$（这表明$i$和$j$可以很小，而这个结论适用于$n&gt;1$），那么可以得到$U = 10^n - (i + j)$，$D = i \times j$。这样我们设$a = i + j$，然后求出$U$，再根据$D = i \times (a - i)$解出整数$i$，解出来就成功了！实际上这还不是最优的。通过实验可以发现当$n$是偶数的时候有确定的解，其中$i = 1, j = 10^{\frac{n}{2}} +1$。所以只要对$n$为奇数的情况求解即可。1234567891011121314151617181920class Solution: def largestPalindrome(self, n): """ :type n: int :rtype: int """ if n == 1: return 9 p = 1 for i in range(0, n): p *= 10 if n &amp; 1 == 0: return (p - 1) * (p - int(p ** 0.5) + 1) % 1337 for a in range(2, p): u = p - a l = int(str(u)[: : -1]) if a ** 2 - 4 * l &gt;= 0: i = a + (a ** 2 - 4 * l) ** 0.5 if i // 2 == i / 2: return (u * p + l) % 1337 482字符串模拟。 485水 494水DP 496排序后从小到大，寻找每一个数$x$在原数组中右边的第一个元素，然后把$x$从原数组删去，如此反复。也可以维护一个递减的单调栈，从而得到答案。 498找规律 500水 503数组复制一遍，单调栈。节省空间的话可以不用复制 504简单进制转换 507简单质因数分解。 509水 520简单模拟 525把0变-1，寻找相同大小的前缀和。 532排序后用指针 540按照元素出现位置二分 542水BFS 553第一个元素必然为分子，第二个元素必然为分母。其余的位置可以变。所以全部放在分子上。123456789class Solution: def optimalDivision(self, nums: List[int]) -&gt; str: if len(nums) == 1: return str(nums[0]) if len(nums) == 2: return str(nums[0]) + "/" + str(nums[1]) s = str(nums[0]) + "/(" for i in nums[1: -1]: s += str(i) + "/" s += str(nums[-1]) + ")" return s 559水 561排序 589, 590基本同二叉的情况 617简单的递归合并。速度有点慢？ 628找最大的三个数和最小的两个数，取最大数和最小两数积与最大三数积更大者。 633方法一查表。12345678910111213141516class Solution: def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ list1 = [i * i for i in range(0, 65536)] i, j = 0, 65535 while 2 * i * i &lt;= c: while list1[j] &gt; c - i * i: j -= 1 if i * i + list1[j] == c: return True i += 1 return False 方法二双指针$l, r$，分别从$0$和$\sqrt{c}$向中间逼近。12345678910111213141516class Solution: def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ i, j = 0, int(c ** 0.5) + 1 while i &lt;= j: res = i * i + j * j if res == c: return True elif res &lt; c: i += 1 elif res &gt; c: j -= 1 return False 650可以DP，但是效果很差劲。。。实际上根据DP方程可以发现产生的字符数目一定是某几个数的乘积。因此可以归纳得出：质数只能一个一个得到，然后两个质数的积的答案就是两个质数的和，质数的幂等同于多个质数相乘。所以做一次质因数分解即可。 654分治法找最大值 665小贪心 670小贪心 671其实就是求左右子树中最小的数（不和根相同）。。。写炸了。（不过性能好像还行） 672找规律。本质是异或操作的叠加。 673经典DP题，在原来DP数组的基础上加一个计数数组即可。时间复杂度$O(n^2)$。 674水 69312unsigned int res = (n ^ (n &gt;&gt; 1)) + 1u;return (res &amp; (res - 1)) == 0; 695傻逼BFS 709大水题 713维护两个指针或者直接暴力向前取，只要保证把1跳过就行。 728一一判断。 740排序后变成DP 746DP 747水题 754按奇偶性找规律，本质解方程。1234567891011121314151617181920class Solution: def reachNumber(self, target): """ :type target: int :rtype: int """ if target == 0: return 0 if target &lt; 0: target = -target l, r = 1, target while l &lt; r: mid = (l + r) &gt;&gt; 1 if target &lt;= mid * (mid + 1) // 2: r = mid else: l = mid + 1 return ((l + 1) &gt;&gt; 1) &lt;&lt; 1 | 1 if (((l + 1) &gt;&gt; 1) - target) &amp; 1 else l 763贪心 7711return sum([1 for c in S if c in J]) 777注意到操作前后非X字符的相对顺序不会变化，且R只能向右移动，L只能向左移动。模拟即可。 785水 791自定义优先级即可 797大力DFS 812数据比较小，可以暴力。大的话凸包+旋转卡壳 813大力DP 829手推公式，发现可以做到$O(\sqrt{N})$。 840简单模拟 842暴力，注意前两个数可以比较小 849水 859先判断长度是否完全相同，再判断是否存在这样两个字符。 867模拟 868水，可以看出python字符串很慢？ 877DP或者数学。因为先手必然可以取走所有编号奇偶性相同的堆，而编号全为奇数的堆总和和编号全为偶数的堆总和中必然有一个相对更大的，因此先手必胜。1return True # 就是这么自信。 884用Counter 888只要找一组解就很简单 893按下标奇偶性拆分字符串，排序后重组，再用set去重。 896水，可以遍历两遍或一遍，这取决于写法。 905双指针交换或者新开两个数组。 908找最小值$+K$和最大值$-K$之间关系。 912？ 914最大公约数。 917双指针 918用单调队列是非常睿智的做法。。。要么是中间的一段被选，要么是中间的一段不被选。二者择其一即可。 921直接对右括号进行匹配，然后剩余的左括号和右括号数目和就是答案。 922水 925字符串分段，比较段长。 926水 932构造层级结构。可以发现一个数列A_n保持了这个性质，那么对A_n的每一项加（或者减）去一个定值或者乘上一个非零数也会保持这样一个性质。从而构造递归结构：基础：$n=2$，答案是$1, 2$。向上：$n=2^k\rightarrow n=2^{k+1}$，$n=2^k$时答案是A_k，$n=2^{k+1}$时答案是2A_k-1和2A_k相连接。1234567891011class Solution: def beautifulArray(self, N): """ :type N: int :rtype: List[int] """ lst, len1 = [1], 1 while len1 &lt; N: lst = [(i &lt;&lt; 1) - 1 for i in lst] + [i &lt;&lt; 1 for i in lst] len1 &lt;&lt;= 1 return [i for i in lst if i &lt;= N] 933模拟 937注意字母排序指的是对每一个字形成的列表进行字典序排序。 939暴力枚举矩阵的对角上两个点，然后查找能不能找到另外两个点。 941注意边界 942一种做法是求出相对高度数组。设第一个数的高度为$0$，维护当前最大上升量$up$和最大下降量$down$，遇到I则该位相对高度为$up$，并上升量$+1$，遇到D则该位相对高度为$down$，并下降量$-1$，如此可以保证每一位上的相对高度都不同，然后按照相对高度分配$0, 1, \cdots, n$即可。 944简单比较，注意这个题目中的有序指的是字母的ASCII码不递减。 946模拟出栈即可。 949小模拟 961用bitset大力弄过。或者考虑元素之间的关系，这$N$个数要么相邻，要么全部间隔为1。依照此原则判断。 970水 973K小堆 974记录余数方案数目 976经典题目，对边长排序，然后可以组成最大三角形的三条边在排序之后的数组里面一定是连续的。依照这个枚举判定即可。 977找到负数和非负数的分解，双指针即可。 985水 989普通高精度加法 993记录一下深度即可。 994水BFS 997判入度，出度即可。 1004类滑动窗口，注意$K=0$的神奇情况。 1006模拟 1009简单位运算 1013双指针 1015等价于寻找$t$使得$10^t\equiv 1 \pmod{9K}$，用欧拉定理，结合指数循环节即可。 1017求负的二进制。具体流程和求二进制基本相同，求出对-2的余数的绝对值，减掉这个绝对值然后除以-2，直到0为止。可以看出把-2替换为别的正整数就是求正进制表达的方法。 1018水 1022DFS 1033先对三个石头的位置排序，然后最大的移动次数就是最远-最近-2，最少的移动次数特判间距为1和间距为2的两个情况。 1037先判断三个点是否不同，然后再判断是否共线。 1038在中序遍历上跑一个前缀和，然后按照中序遍历把值赋回去。 1039其实就是一个简单的区间DP，但当初想得谜之复杂，就没做出来。。。实际上为了避免点之间的循环顺序，只需要考虑某一段点之间，第一个点和最后一个点相连的边对应的三角形。 1041能够走出圈的充要条件是末状态朝向不变和行动距离大于1。 1042水四染色 1043水DP 1071水]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板 生成树]]></title>
    <url>%2F2018%2F11%2F15%2Ftemplate-spanning-tree%2F</url>
    <content type="text"><![CDATA[本文主要讨论生成树相关的算法。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU1686 Oulipo]]></title>
    <url>%2F2018%2F11%2F12%2Fhdu1686%2F</url>
    <content type="text"><![CDATA[题目链接 题解KMP模板题…1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;void build_fail(char *pat, int len, int *fail)&#123; fail[0] = -1; for(int i = 1, j = -1; i &lt; len; ++i)&#123; while(j &gt; -1 &amp;&amp; pat[i] != pat[j + 1]) j = fail[j]; if(pat[i] == pat[j + 1]) fail[i] = ++j; else fail[i] = -1; &#125;&#125;int KMP_match(char *text, int l1, char *pat, int l2, int *fail)&#123; int cnt = 0; for(int i = 0, j = -1; i &lt; l1; ++i)&#123; while(j &gt; -1 &amp;&amp; text[i] != pat[j + 1]) j = fail[j]; if(text[i] == pat[j + 1]) j++; if(j == l2 - 1) j = fail[j], cnt++; &#125; return cnt;&#125;int n, m, fail[10005] = &#123;0&#125;;char a[10005], b[1000005];int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%s%s", a, b); m = strlen(a), n = strlen(b); build_fail(a, m, fail); printf("%d\n", KMP_match(b, n, a, m, fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1711 Number Sequence]]></title>
    <url>%2F2018%2F11%2F12%2Fhdu1711%2F</url>
    <content type="text"><![CDATA[题目链接 题解对数字序列做一次KMP即可。12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;void build_fail(int *pat, int len, int *fail)&#123; fail[0] = -1; for(int i = 1, j = -1; i &lt; len; ++i)&#123; while(j &gt; -1 &amp;&amp; pat[i] != pat[j + 1]) j = fail[j]; if(pat[i] == pat[j + 1]) fail[i] = ++j; else fail[i] = -1; &#125;&#125;int KMP_match(int *text, int l1, int *pat, int l2, int *fail)&#123; for(int i = 0, j = -1; i &lt; l1; ++i)&#123; while(j &gt; -1 &amp;&amp; text[i] != pat[j + 1]) j = fail[j]; if(text[i] == pat[j + 1]) j++; if(j == l2 - 1) return i - l2 + 2; &#125; return -1;&#125;int n, m, a[1000005], b[10005], fail[10005] = &#123;0&#125;;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; m; ++i) scanf("%d", &amp;b[i]); build_fail(b, m, fail); printf("%d\n", KMP_match(a, n, b, m, fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 字符串]]></title>
    <url>%2F2018%2F11%2F11%2Ftemplate-string%2F</url>
    <content type="text"><![CDATA[字符串相关算法的模板。 KMP算法KMP算法的核心是后缀配对前缀，从而可以在配对失败的时候不用总是从头开始，而是从可以成功匹配的某一个前缀开始继续匹配。 KMP算法的匹配方式非常容易，但是需要预处理出一个next（或称fail）数组，表示匹配失败的时候跳转的位置。 若$m$是模板的长度，$n$是文本串的长度，那么时间复杂度：$O(m+n)$，空间复杂度：$O(m)$。123456789101112131415161718192021222324//构建fail数组void build_fail(char *pat, int len, int *fail)&#123; fail[0] = -1; for(int i = 1, j = -1; i &lt; len; ++i)&#123; while(j &gt; -1 &amp;&amp; pat[i] != pat[j + 1])//j+1表示当前模板串内要匹配的前缀的字符 j = fail[j]; if(pat[i] == pat[j + 1]) fail[i] = ++j; else fail[i] = -1; &#125;&#125;//匹配过程void KMP_match(char *text, int l1, char *pat, int l2, int *fail)&#123; for(int i = 0, j = -1; i &lt; l1; ++i)&#123; while(j &gt; -1 &amp;&amp; text[i] != pat[j + 1]) j = fail[j]; if(text[i] == pat[j + 1]) j++; if(j == l2 - 1)&#123; //do something... 因为你已经匹配到了。 &#125; &#125;&#125; 扩展KMP算法扩展KMP算法用于解决这样的问题：给定两个字符串$S$和$T$（长度分别为$n$和$m$），下标从$0$开始，定义$extend[i]$等$S[i…n-1]$与$T$的最长相同前缀的长度，求出所有的$extend[i]$。 解决这个问题需要引入一个额外的数组：$next[0…m-1]$，其中$next[i]$表示$T[i…m-1]$和$T$的最长公共前缀的长度。这个数组的用途先不说明，先直接考虑$extend$的求解过程。 假设$extend[0…i-1]$已经解决完成，那么现在考虑求出$extend[i]$。令$p = \max_\limits{1\le j &lt;i} {j + extend[j]}$，即为之前在$S$中已经匹配完成的最右边界。设$a$为取这个最大值的$j$，那么按照题目要求，有$T[0…p-a) = S[a…p)$。之后按照两种情况进行讨论： 如果$p - i &gt; next[i - a]$，那么由于$next$中保存的都是最长的长度，$extend[i]$不可能超过$next[i-a]$，故此时令$extend[i] = next[i - a]$。 如果$p - i = next[i - a]$，那么只能保证$S[i…p)$这一部分是$T$的前缀，这个时候需要暴力匹配。此时可以看出，在$extend[i]$被求出来之后，$p$和$a$的值都会被更新。 如果$p - i &lt; next[i - a]$，那么在2的基础上追加了$T[0…p-i]=T[i-a…p-a]$的条件，即得到$S[p] \neq T[p-a] \implies S[p]\neq T[p-i]$，此时令$extend[i] = p - i$即可。 这样我们就得到了$extend$数组的求解过程。而求解$next$数组的过程就是对$T$求$extend$的过程。 由于$p$是不降的，所以在匹配的时候最多会遍历一次$S$和$T$串，因此算法的时间复杂度是$O(m+n)$。 可以说这个算法虽然被称为扩展KMP算法，但内核思想却和manacher算法相近，都是利用了在特定情况下的重复信息。12]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板 线性基]]></title>
    <url>%2F2018%2F11%2F08%2Ftemplate-linear-basis%2F</url>
    <content type="text"><![CDATA[对线性基的一些认识。与线性代数不同的是，在这里，我们一般只研究异或这一运算。 概念]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 511 (Div. 2) 题解]]></title>
    <url>%2F2018%2F09%2F22%2Fcontest-cf1047%2F</url>
    <content type="text"><![CDATA[人傻题不会.jpg A题目链接 分类讨论。可以分成$(a, a, b)$的形式，但是实际上还是分成$(1, 1, n-2)$或者$(1, 2, n-3)$更快。我是很蠢的选了前者。12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int k = n / 3, p = n - k - k; if(k % 3 == 0) &#123; if(p % 3 == 1) k++, p -= 2; else k--, p += 2; &#125;else if(p % 3 == 0) &#123; if(k % 3 == 1) k++, p -= 2; else k--, p += 2; &#125; printf("%d %d %d\n", k, k, p); return 0;&#125; B题目链接 观察可以发现，直线方程可以写成$y=-x+d$。而直线过点的时候可以保证答案最小，所以只要计算所有点中横纵坐标和的最大值即可。12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int n, ans = 0;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)&#123; int x, y; scanf("%d%d", &amp;x, &amp;y); ans = max(ans, x + y); &#125; printf("%d\n", ans); return 0;&#125; C题目链接 先求出这个GCD，然后： 方法一对每一个数除掉GCD，这样新的GCD就变成了$1$。我们只要让去掉一些数之后GCD大于$1$即可。可以枚举小于等于N=\sqrt{\max \left\{a_n\right\} }的质数，然后对每一个数判断是不是这个质数的倍数。保证尽量多的数是某一个质数的倍数即可。本质上是做质因数分解。这么做会超时。 方法二在方法一的基础上变换思路，考虑所有大于GCD的数，利用埃氏筛法求出其倍数的个数，和答案比较。 方法三在方法一的基础上用线性筛优化质因数分解的过程。 在这一题中我们可以看出筛法和质因数分解之间的紧密联系，这对于某一类的数论题目很有启发意义。以下代码基于方法二。1234567891011121314151617181920212223242526272829303132#pragma G++ optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;int n, maxi = 0, mk[15000005] = &#123;0&#125;;bool vd[15000005] = &#123;0&#125;;int gcd(int x, int y)&#123; return (!y) ? x : gcd(y, x % y);&#125;int main()&#123; int g; scanf("%d%d", &amp;n, &amp;g); maxi = g, mk[g]++; for(int i = 2; i &lt;= n; ++i) &#123; int t; scanf("%d", &amp;t); if(g != 1) g = gcd(t, g); maxi = max(maxi, t); mk[t]++; &#125; int ans = n; for(int i = g + 1; i &lt;= maxi; ++i)&#123; if(!vd[i])&#123; int cnt = 0; for(int j = i; j &lt;= maxi; j += i) vd[j] = 1, cnt += mk[j]; ans = min(ans, n - cnt); &#125; &#125; if(ans == n) printf("-1\n"); else printf("%d\n", ans); return 0;&#125; D题目链接 可以发现在格子处于一定大小，如$1\times 6$和$2\times 4$$的时候是可以做到基本填满的。所以我们就可以把整个棋盘切成多个小格，用这些小格的答案作为基去凑出整个棋盘的答案。我用的$7\times 7$以下所有格子的答案作为基，用这个应该就够了。12]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块学习记录]]></title>
    <url>%2F2018%2F09%2F15%2Fwriting%2Fbuildblock%2F</url>
    <content type="text"><![CDATA[本文主要记录了我做题时对分块算法的一些感觉。分块在处理一些奇奇怪怪的区间处理问题时常常十分有用。 普通线性分块——以区间加法为例问题1：给出一个长度为$N$的序列，共有$M$个操作，操作为区间加法或者区间求和。 考虑将序列分成$T$块，每一块长均为$S = \frac{N}{T}$，然后处理一系列的操作。对于区间加法，我们分两种情况： 若目标区间长度不足一个块，则对区间内每一个元素进行暴力修改。 若区间跨了多个块，那么对区间内的所有完整的块进行遍历，依次打上加法标记；对于区间端点所在的两个块，只对其中在区间内的元素进行暴力修改，换言之，对左右两端两个不完整的块进行暴力修改。对于区间求和，同样分两种情况： 若目标区间长度不足一个块，则对区间内每一个元素进行暴力统计。 若区间跨了多个块，那么对区间内的所有完整的块进行遍历，依次累加上它们的和；对于区间端点所在的两个块，只对其中在区间内的元素进行暴力统计，换言之，对左右两端两个不完整的块进行暴力统计。 这么做的时间复杂度是$O(M(S+T))$。根据均值不等式，当$S=T=\sqrt{N}$时括号内的值最小。因此选择的块数和块长都为$\sqrt{N}$时可以做到理论上的时间复杂度最优。打标记的做法和线段树相似，因此扩展到区间乘法，区间赋值的时候可以依照线段树的规则进行扩展，原理则基本相同。事实上，这种分块方式是最常见的。有时会根据具体的算法调整块的大小已达到理论最优时间复杂度。 特殊线性分块1——使用特殊方法（数据结构）维护块问题2：题目链接 考虑分块，发现区间加法虽然好做，但是求区间有多少个满足条件的人是不好办的，只有序列有序的时候才可以用二分这样时间复杂度稍低的方法求出答案，但在执行了区间加法后有序性就有可能被破坏。继续观察可以发现，分块后区间加法导致有序性被破坏的情况只有“区间加法没有覆盖完整的一块”这一种情况。因此事先对每一个块内部排序，区间加法除按照之前所述方法进行外，还要对不完整的块打上一个“有序性破坏”的标记。区间查询时，对有序性存在的完整块直接二分出答案，对有序性被破坏的完整块先排序再求解，对不完整的块暴力统计。因为一个区间加法最多导致2个块的有序性被破坏，所以排序的总次数为$O(\sqrt{N} + Q)$，总时间复杂度为$O(n\log n + q \sqrt{N} \log n)$。 在这类问题中，某些操作不能使用打标记之类的简单，普适的方法去解决时，就可以考虑用其他一些高明的方法（在本题中表现为排序，有时也表现为用数据结构维护块）——毕竟分块本身就算的上是一种相当高明的暴力方法嘛。（当然，要看数据规模） 特殊线性分块2——块状链表和暴力重构问题3：题目链接 这个题目像是NOI2003 文本编辑器的弱化。事实上这个题目是可以用块状链表实现的，但因为这里是分块的讲解，所以还是考虑分块。由于本题的操作比较简单，就只有插入，所以可以直接用一个链表来模拟。将链表分成$O(\sqrt {N})$段，每一段都保存段的长度（因为段会因为插入而变长）和段的开头，在理想情况下可以利用长度在$O(\sqrt {N})$时间内找到插入的位置并且完成插入。询问同理。这样总时间复杂度就是$O(N\sqrt {N})$。但是数据经过特殊构造后可以形成一个段特别长的情况，此时分块链表退化成为普通链表，时间复杂度最坏会达到$O(N^2)$。为了避免这种情况，需要在插入达到一定次数之后及时对链表进行重构，即重新分块。令插入次数的限制为$O(\sqrt {N})$，因为重构花费的时间是$O(n)$，而每次重构之后插入的时间复杂度都会恢复为原来水平，因此重构+插入+询问的总时间复杂度就是$O(N\sqrt {N})$。 这类问题一般有着大量的插入和删除操作，对应的是链表这样能够快速执行插入和删除的链状结构，因此使用有着分块思想的块状链表可以快速准确的完成这些操作。同时当操作简单时直接对所有的块进行重构也是一个不错的选择。 特殊线性分块3——以区间众数为例特殊线性分块4——带修改分块]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国家集训队2009 小Z的袜子]]></title>
    <url>%2F2018%2F09%2F15%2Fluogu1494%2F</url>
    <content type="text"><![CDATA[题目链接 题解莫队算法的一个典型应用。对所有询问的左端点所在块的编号排序，块内对右端点排序，然后按顺序处理所有询问。由于$(l, r)$的情况可以在$O(1)$的情况下转移到$(l, r + 1), (l, r - 1), (l - 1, r), (l + 1, r)$的情况，因此根据一定的复杂度分析，该算法的时间复杂度是$O(n \sqrt{n})$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1e9using namespace std;typedef long long ll;struct Q&#123; ll l,r,sqi,id;&#125;;bool cmp(Q u,Q v)&#123; if(u.sqi==v.sqi)return u.r&lt;v.r; return u.sqi&lt;v.sqi;&#125;Q query[50005];ll a[50005],ans[50005][2],n,m,size;ll cnt[50005]=&#123;0&#125;,tot=0;ll sqr(ll t)&#123;return t*t;&#125; void update(ll o,ll id)&#123; tot-=sqr(cnt[a[id]]), cnt[a[id]]+=o, tot+=sqr(cnt[a[id]]);&#125;ll gcd(ll a,ll b)&#123; return (!b)?a:gcd(b,a%b);&#125;void init()&#123; ll i,j; scanf("%lld%lld",&amp;n,&amp;m); for(size=1;size*size&lt;n;size++); for(i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(i=1;i&lt;=m;i++) scanf("%lld%lld",&amp;query[i].l,&amp;query[i].r), query[i].sqi=(query[i].l-1)/size, query[i].id=i; sort(query+1,query+m+1,cmp);&#125;void solve()&#123; ll L=1,R=0,_l,_r,_id,fz,fm,p; for(int i=1;i&lt;=m;i++)&#123; _l=query[i].l,_r=query[i].r; _id=query[i].id; for(;R&lt;_r;R++) update(1,R+1); for(;R&gt;_r;R--) update(-1,R); for(;L&lt;_l;L++) update(-1,L); for(;L&gt;_l;L--) update(1,L-1); if(_l==_r)&#123; ans[_id][0]=0,ans[_id][1]=1; continue; &#125; fz=tot-(_r-_l+1),fm=(_r-_l+1)*(_r-_l); p=gcd(fm,fz); fz/=p,fm/=p; ans[_id][0]=fz,ans[_id][1]=fm; &#125; for(int i=1;i&lt;=m;i++) printf("%lld/%lld\n",ans[i][0],ans[i][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 教主的魔法]]></title>
    <url>%2F2018%2F09%2F15%2Fluogu2801%2F</url>
    <content type="text"><![CDATA[题目链接 题解分块。先分块，然后对每一个块内排序。修改时对于处于一个块内的暴力修改后重新排序，对于处于不同块的把最左最右两个不完整的块暴力修改，然后对中间的块打标记。查询时对整个块直接二分查询，对不完整的块就暴力查询。时间复杂度：$O(Q\sqrt{N} \log N)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,h[1000005],bid[1000005],siz;//偷懒的做法。int t[1005][1005],add[1005],vis[1005],S[1005]=&#123;0&#125;; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int query(int L,int R,int C)&#123; int ans=0; for(;bid[L]==bid[L-1];L++) if(h[L]&gt;=C-add[bid[L]])ans++; for(;bid[R]==bid[R+1];R--) if(h[R]&gt;=C-add[bid[R]])ans++; for(int i=bid[L];i&lt;=bid[R];i++)&#123; if(vis[i])&#123; for(int j=0;bid[L]==i;L++) t[i][j++]=h[L]; sort(t[i],t[i]+S[i]); ans+=(t[i]+S[i])-lower_bound(t[i],t[i]+S[i],C-add[i]); vis[i]=0; &#125;else ans+=(t[i]+S[i])-lower_bound(t[i],t[i]+S[i],C-add[i]); &#125; return ans;&#125;void update(int L,int R,int W)&#123; for(;bid[L]==bid[L-1];L++)h[L]+=W; vis[bid[L-1]]=1; for(;bid[R]==bid[R+1];R--)h[R]+=W; vis[bid[R+1]]=1; for(int i=bid[L];i&lt;=bid[R];i++) add[i]+=W;&#125;void init()&#123; n=read(),m=read(); for(siz=1;siz*siz&lt;n;siz++); for(int i=1;i&lt;=n;i++) h[i]=read(), bid[i]=(i-1)/siz+1, S[bid[i]]++; bid[n+1]=siz+1;&#125;void solve()&#123; int x,y,z; char ord[3]; fill(vis+1,vis+siz+1,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%s%d%d%d",ord,&amp;x,&amp;y,&amp;z); if(ord[0]=='A') printf("%d\n",query(x,y,z)); else update(x,y,z); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨氏矩阵和勾长公式]]></title>
    <url>%2F2018%2F09%2F11%2Fyoung-tableau%2F</url>
    <content type="text"><![CDATA[本文讨论杨氏矩阵以及和其密切相关的勾长公式。 杨氏矩阵]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ2279 Mr. Young's Picture Permutations]]></title>
    <url>%2F2018%2F09%2F11%2Fpoj2279%2F</url>
    <content type="text"><![CDATA[题目链接 题解容易发现最高的人只能站在最左上角，然后后面的人从高到低必须要站在已经有的人的附近，不然就不合法。以此为依据，以人数为阶段，每一排的人数为状态转移即可。可以使用队列保证状态转移顺序正确。事实上这个题考的是一个叫做杨氏矩阵的数据结构，另外一篇文章里会介绍。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef unsigned int ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int k, n[6], g;ll f[32][32][32][32][32];int que[500000][5], l, r, cur[6];bool vis[32][32][32][32][32];void init()&#123; g = 0; for(int i = 0; i &lt; k; ++i) n[i] = read(), g += n[i]; for(int i = k; i &lt; 5; ++i) n[i] = 0; sort(n, n + 5); reverse(n, n + 5);&#125;void solve()&#123; memset(vis, 0, sizeof(vis)); f[0][0][0][0][0] = 1; vis[0][0][0][0][0] = true; l = 0, r = 1; for(int i = 0; i &lt; 5; ++i) que[0][i] = 0; ll ans = 0; while(r - l)&#123; int sum = 0; for(int i = 0; i &lt; 5; ++i) cur[i] = que[l][i], sum += cur[i]; l++; if(sum == g)&#123; ans += f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]]; continue; &#125; for(int i = 0; i &lt; k; ++i)&#123; if(cur[i] &lt; n[i] &amp;&amp; (i == 0 || cur[i - 1] &gt; cur[i]))&#123; int addi = f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]]; cur[i]++; if(!vis[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]])&#123; f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] = 0; for(int j = 0; j &lt; k; ++j) que[r][j] = cur[j]; for(int j = k; j &lt; 5; ++j) que[r][j] = 0; r++; vis[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] = 1; &#125; f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] += addi; cur[i]--; &#125; &#125; &#125; printf("%u\n", ans);&#125;int main()&#123; while(k = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1434]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu1434%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[luogu2909]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2909%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[AHOI2005 矿藏编码]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2539%2F</url>
    <content type="text"><![CDATA[题目链接 题解标准的递归定义。按照递归定义处理即可。答案很大，要用int128或者double。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef __int128 ll;int n;ll ans = 0;void init()&#123; scanf("%d", &amp;n);&#125;void get(ll d)&#123; int p; scanf("%1d", &amp;p); if(p == 0) ans += d * d; else if(p == 2)&#123; for(int i = 0; i &lt; 4; ++i) get(d &gt;&gt; 1); &#125;&#125;void solve()&#123; ll a = 1; for(int i = 1; i &lt;= n; ++i) a *= 2ll; get(a); int num[50], len = 0; while(ans) num[++len] = ans % 10, ans /= 10; for(int i = len; i &gt;= 1; --i) printf("%d", num[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2005 位图]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2335%2F</url>
    <content type="text"><![CDATA[题目链接 题解从每一个白块周围扩展即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, mp[155][155], ans[155][155];int que[22505][2], r, l;int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;;void init()&#123; n = read(), m = read(); memset(ans, -1, sizeof(ans)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) mp[i][j] = read(); r = l = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j)&#123; if(mp[i][j]) ans[i][j] = 0; else&#123; for(int k = 0; k &lt; 4; ++k)&#123; int ex = i + dx[k], ey = j + dy[k]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; mp[ex][ey])&#123; que[r][0] = i, que[r++][1] = j; ans[i][j] = 1; break; &#125; &#125; &#125; &#125;&#125;void solve()&#123; while(r - l)&#123; int cx = que[l][0], cy = que[l++][1]; for(int i = 0; i &lt; 4; ++i)&#123; int ex = cx + dx[i], ey = cy + dy[i]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; ans[ex][ey] &lt; 0)&#123; ans[ex][ey] = ans[cx][cy] + 1; que[r][0] = ex, que[r++][1] = ey; &#125; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m - 1; ++j) printf("%d ", ans[i][j]); printf("%d\n", ans[i][m - 1]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06FEB Stall Reservations]]></title>
    <url>%2F2018%2F09%2F02%2Fluogu2859%2F</url>
    <content type="text"><![CDATA[题目链接 题解线段覆盖类型的题目。先对端点排序，然后从左到右扫描，对线段依次分配。用一个堆来管理空出来的牛棚。当端点重合时先分配再释放。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;struct Q&#123; int id, x;&#125;;struct cmp&#123; bool operator ()(const Q&amp; q1, const Q&amp; q2)&#123; return q1.x &lt; q2.x; &#125;&#125;;int n, l[50005], r[50005], ans[50005] = &#123;0&#125;;Q q[100005];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) l[i] = read(), r[i] = read(), q[i &lt;&lt; 1].id = q[i &lt;&lt; 1 | 1].id = i, q[i &lt;&lt; 1].x = l[i], q[i &lt;&lt; 1 | 1].x = r[i]; sort(q, q + n + n, cmp());&#125;void solve()&#123; int ans_ = 0; for(int i = 0; i &lt; n + n; )&#123; int j; for(j = i; j &lt; n + n &amp;&amp; q[j].x == q[i].x; ++j) if(!ans[q[j].id]) &#123; if(pq.empty()) ans_++, ans[q[j].id] = -ans_; else ans[q[j].id] = -pq.top(), pq.pop(); &#125; for(j = i; j &lt; n + n &amp;&amp; q[j].x == q[i].x; ++j)&#123; if(ans[q[j].id] &lt; 0) ans[q[j].id] = -ans[q[j].id]; else pq.push(ans[q[j].id]); &#125; i = j; &#125; printf("%d\n", ans_); for(int i = 0; i &lt; n; ++i) printf("%d\n", ans[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09DEC Selfish Grazing]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu2970%2F</url>
    <content type="text"><![CDATA[题目链接 题解贪心入门题。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[50005];int main()&#123; int n,i,j,u,v,ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d%d",&amp;u,&amp;v), p[i].first=v,p[i].second=u; sort(p,p+n); ans++,u=p[0].second,v=p[0].first; for(i=1;i&lt;n;)&#123; while(i&lt;n&amp;&amp;p[i].second&lt;v) i++; if(i==n)break; ans++,u=p[i].second,v=p[i].first; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17FEB Why Did the Cow Cross the Road II S]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu3662%2F</url>
    <content type="text"><![CDATA[题目链接 题解记录每一个长为$k$的一段中有几个坏灯，找出答案。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;bool vis[100005] = &#123;0&#125;;int n, k, b;void init()&#123; scanf("%d%d%d", &amp;n, &amp;k, &amp;b); for(int i = 0; i &lt; b; ++i)&#123; int t; scanf("%d", &amp;t); vis[t] = true; &#125;&#125;void solve()&#123; int cnt = 0, ans = n; for(int i = 1; i &lt;= k; ++i) if(vis[i]) cnt++; for(int i = k; i &lt;= n; ++i)&#123; ans = min(ans, cnt); if(!ans) break; if(vis[i - k + 1]) cnt--; if(vis[i + 1]) cnt++; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12NOV Clumsy Cows]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu3056%2F</url>
    <content type="text"><![CDATA[题目链接 题解先把能配对的配掉，然后因为剩下的长度一定是偶数，所以可以根据左边)的数目和右边(的数目判断答案。当两者均为偶数时两边各改一半即可，均为奇数则分割处的)(要改成()，之后就转化为偶数的情况。123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[100005];void init()&#123; scanf("%s", s);&#125;void solve()&#123; int l = 0, r = 0, len = strlen(s); for(int i = 0; i &lt; len; ++i)&#123; if(s[i] == '(') l++; else&#123; if(l) l--; else r++; &#125; &#125; printf("%d\n", ((l + 1) &gt;&gt; 1) + ((r + 1) &gt;&gt; 1));&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08JAN Cow Contest]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu2419%2F</url>
    <content type="text"><![CDATA[题目链接 题解用Floyd算法补全胜负关系，然后如果能够确定一个牛对所有其他牛的胜负关系就认为名次可确认。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, d[105][105];void init()&#123; memset(d, -1, sizeof(d)); n = read(), m = read(); for(int i = 0; i &lt; m; ++i)&#123; int u = read(), v = read(); d[u][v] = 1, d[v][u] = 0; &#125; for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) if(d[i][k] != -1 &amp;&amp; d[k][j] != -1 &amp;&amp; d[i][k] == d[k][j]) d[i][j] = d[i][k];&#125;void solve()&#123; int ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; int w = 0, f = 0; for(int j = 1; j &lt;= n; ++j) if(d[i][j] == 1) w++; else if(d[i][j] == 0) f++; if(w + f == n - 1) ans++; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1574]]></title>
    <url>%2F2018%2F08%2F31%2Fluogu1574%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[POJ2689 Prime Distance]]></title>
    <url>%2F2018%2F08%2F31%2Fpoj2689%2F</url>
    <content type="text"><![CDATA[题目链接 题解区间筛质数模板题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;unsigned int L, R, prime[35005], cnt = 0;bool vis1[70005] = &#123;0&#125;, vis2[1000005] = &#123;0&#125;;void getP()&#123; vis1[1] = true; for(int i = 2; i &lt;= 65536; ++i) if(!vis1[i])&#123; for(int j = i + i; j &lt;= 65536; j += i) vis1[j] = true; prime[++cnt] = i; &#125;&#125;void init()&#123; if(L &lt;= 1) L = 2; for(int i = 1; i &lt;= cnt; ++i)&#123; unsigned int p = prime[i]; if(R &lt; p) break; for(unsigned int j = max((L - 1 + p) / p, 2u); j &lt;= R / p; ++j) vis2[j * p - L] = 1; &#125;&#125;void solve()&#123; unsigned int lst = 0, mind = 1000001, maxd = 0; pair&lt;int, int&gt; ans1, ans2; for(unsigned int i = L; i &lt;= (unsigned int)R; ++i)&#123; if(!vis2[i - L])&#123; if(lst &gt; 0)&#123; if(i - lst &lt; mind)&#123; mind = i - lst; ans1.first = lst, ans1.second = i; &#125; if(i - lst &gt; maxd)&#123; maxd = i - lst; ans2.first = lst, ans2.second = i; &#125; &#125; lst = i; &#125; &#125; if(!maxd) printf("There are no adjacent primes.\n"); else printf("%d,%d are closest, %d,%d are most distant.\n", ans1.first, ans1.second, ans2.first, ans2.second); memset(vis2, 0, sizeof(vis2));&#125;int main()&#123; getP(); while(scanf("%d%d", &amp;L, &amp;R) == 2)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2005 午餐]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2577%2F</url>
    <content type="text"><![CDATA[题目链接 题解按时间DP。如果只有一个窗口那就是贪心了，按照吃饭时间从大到小排即可。两个窗口就DP，设$f[i][j]$表示前$i$个人在窗口1花了$j$时间打饭，最短的用餐时间。这样的话就可以转移了。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;pair&lt;int,int&gt; P[205];int n,A[205],B[205],f[205][40005],sum[205];int cmp(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b)&#123; return a.second&gt;b.second;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)P[i].first=read(),P[i].second=read(); sort(P+1,P+n+1,cmp); for(int i=1;i&lt;=n;i++)A[i]=P[i].first,B[i]=P[i].second; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+A[i];&#125;void solve()&#123; memset(f,0x3f,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;=sum[i-1];j++)&#123;//只有这段时间有意义 f[i][j]=min(f[i][j],max(f[i-1][j],sum[i-1]-j+A[i]+B[i])); f[i][j+A[i]]=min(f[i][j+A[i]],max(f[i-1][j],j+A[i]+B[i])); &#125; &#125; int ans=INF; for(int i=0;i&lt;=sum[n];i++)ans=min(ans,f[n][i]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI2016初中组 迷宫]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2778%2F</url>
    <content type="text"><![CDATA[题目链接 题解大部分人是用几何性质去枚举的。标算貌似用了线性求LCA，常数很大的样子。我是暴力建树，然后用了类似于LCA的方法求最长公共路径，然后再求不同的路。本质上可能是一样的，不过我这个居然更快？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,x_1,x_2,y_1,y_2,par[8005],son[8005],bro[8005];int cx,cy,rec[2][8005],tot[2]=&#123;0&#125;;struct C&#123; int id,x,y,r; bool operator&lt;(C c)&#123; return r&gt;c.r; &#125;&#125;;C cir[8005];void dfs(int id,int o)&#123; int dx,dy,dr; for(int i=son[id];i!=-1;i=bro[i])&#123; dx=cir[i-1].x,dy=cir[i-1].y,dr=cir[i-1].r; if((cx-dx)*(cx-dx)+(cy-dy)*(cy-dy)&lt;=dr*dr)&#123; rec[o][tot[o]++]=id; dfs(i,o); return ; &#125; &#125; rec[o][tot[o]++]=id; return ;&#125;void insert_(int cur,int id)&#123; int dx,dy,dr; for(int i=son[cur];i!=-1;i=bro[i])&#123; dx=cir[i-1].x,dy=cir[i-1].y,dr=cir[i-1].r; if((cx-dx)*(cx-dx)+(cy-dy)*(cy-dy)&lt;=dr*dr)&#123; insert_(i,id); return ; &#125; &#125; par[id]=cur,bro[id]=son[cur], son[cur]=id;&#125;void init()&#123; memset(son,-1,sizeof(son)); memset(par,-1,sizeof(par)); memset(bro,-1,sizeof(bro)); int i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d%d%d",&amp;cir[i].x,&amp;cir[i].y,&amp;cir[i].r); sort(cir,cir+n); scanf("%d",&amp;m); //建树 for(i=0;i&lt;n;i++) cx=cir[i].x,cy=cir[i].y, insert_(0,i+1);&#125;void solve()&#123; int i,j,lim,ans; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d",&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); tot[0]=tot[1]=0; cx=x_1,cy=y_1,dfs(0,0); cx=x_2,cy=y_2,dfs(0,1); lim=min(tot[0],tot[1]); for(j=0;j&lt;lim;j++) if(rec[0][j]!=rec[1][j])break; ans=tot[0]+tot[1]-2*j; printf("%d\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI2009 中国象棋]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2051%2F</url>
    <content type="text"><![CDATA[题目链接 题解不好形容的DP。设$f(i,j,k)$表示当前在第$i$行，有$j$列没炮，$k$列$1$个炮。就可以愉快的转移了。转移的时候注意系数。（也就是组合数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define Mod 9999973llusing namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll n,m,f[105][105][105]=&#123;0&#125;;//f(i,j,k) 第i行 j列0个 k列1个 void init()&#123; n=read(),m=read(); f[1][m][0]=1,f[1][m-1][1]=m; if(m!=1)f[1][m-2][2]=m*(m-1)/2;&#125;void solve()&#123; for(int i=2;i&lt;=n;i++) for(ll j=0;j&lt;=m;j++) for(ll k=0;k+j&lt;=m;k++)&#123; f[i][j][k]+=f[i-1][j][k]; if(k&gt;=2)f[i][j][k]+=f[i-1][j+2][k-2]*(j+2)*(j+1)/2; if(j+1&lt;=m)f[i][j][k]+=f[i-1][j+1][k]*(j+1)*k; if(k+2&lt;=m)f[i][j][k]+=f[i-1][j][k+2]*(k+2)*(k+1)/2; if(k&gt;=1)f[i][j][k]+=f[i-1][j+1][k-1]*(j+1); if(k+1&lt;=m)f[i][j][k]+=f[i-1][j][k+1]*(k+1); f[i][j][k]%=Mod; &#125; ll ans=0; for(int j=0;j&lt;=m;j++) for(int k=0;k+j&lt;=m;k++) ans=(ans+f[n][j][k])%Mod; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1984]]></title>
    <url>%2F2018%2F08%2F30%2Fwriting%2Fluogu1984%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[USACO13JAN Painting the Fence]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2205%2F</url>
    <content type="text"><![CDATA[题目地址 题解对线段左右端点坐标排序，模拟加入和删除线段，同时维护线段覆盖层数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;bool in[100005] = &#123;0&#125;;int n, k, ans = 0;pair&lt;int, int&gt; p[200005];void init()&#123; n = read(), k = read(); char ord[3]; for(int i = 0, cur = 0; i &lt; n; ++i)&#123; int st; scanf("%d%s", &amp;st, ord); if(ord[0] == 'R') p[i &lt;&lt; 1].first = cur, p[i &lt;&lt; 1 | 1].first = cur + st, cur += st; if(ord[0] == 'L') p[i &lt;&lt; 1].first = cur, p[i &lt;&lt; 1 | 1].first = cur - st, cur -= st; p[i &lt;&lt; 1].second = p[i &lt;&lt; 1 | 1].second = i; &#125; sort(p, p + n + n);&#125;void solve()&#123; int cnt = 1, lst = p[0].first; in[p[0].second] = 1; for(int i = 1; i &lt; n + n; ++i)&#123; int id = p[i].second; if(cnt &gt;= k) ans += p[i].first - lst; if(!in[id]) in[id] = 1, cnt++; else in[id] = 0, cnt--; lst = p[i].first; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI2009 中位数]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu1627%2F</url>
    <content type="text"><![CDATA[题目链接 题解设$b$所在位置是$k$，那么对于$k$及$b$左边的所有位置求一个$d[i]$，表示$i$到$k-1$有几个小于$b$的数。那么对于$k$及其右边的位置$j$我们定义$d[j]$为$k+1$到$j$有几个小于$b$的数，这样对于一个$j$我们想要找到所有的$i$，使得 d[j]+d[i]=j-k-d[j]+k-i-d[i]整理为 2d[j]-j=-i-2d[i]用map实现。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;map&lt;int, int&gt; mp;int n, a[100005], b, k, ans = 0;void init()&#123; n = read(), b = read(); for(int i = 1; i &lt;= n; ++i)&#123; a[i] = read(); if(a[i] == b) k = i; &#125;&#125;void solve()&#123; int cnt = 0; for(int i = k; i &gt;= 1; --i)&#123; if(a[i] &lt; b) cnt++; mp[0 - i - 2 * cnt]++; &#125; cnt = 0; for(int i = k; i &lt;= n; ++i)&#123; if(a[i] &lt; b) cnt++; ans += mp[2 * cnt - i]; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHOI2002 百事世界杯之旅]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu1291%2F</url>
    <content type="text"><![CDATA[题目地址 题解]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3917 异或序列]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu3917%2F</url>
    <content type="text"><![CDATA[题目链接 题解考虑每一位的贡献，发现每一个数包括它自己在内，向左不断异或得到的$1$的个数是可以递推的，而这个数这一位的贡献次数就等于它左边的数的个数$+1$，于是就可以做了。某种意义上的前缀和。事实上可以当作前缀和来做。一般这种奇怪的位运算题都要分别考虑贡献1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll sum = 0;int n, a[100005], cntl[100005];void init()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read();&#125;void solve()&#123; cntl[0] = 0; for(int i = 1, j = 0; j &lt; 30; i &lt;&lt;= 1, ++j)&#123; for(int k = 1; k &lt;= n; ++k) if(a[k] &amp; i) cntl[k] = k - cntl[k - 1], sum += 1ll * i * cntl[k]; else cntl[k] = cntl[k - 1], sum += 1ll * i * cntl[k]; &#125; printf("%lld\n", sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2016 食物链]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu3183%2F</url>
    <content type="text"><![CDATA[题目链接 题解拓扑排序即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;typedef struct&#123; int v,_next; &#125;Edge; Edge edge[200005];int cnt=0,at[100005],ru[100005]=&#123;0&#125;,V,E,ans[100005]=&#123;0&#125;;int q[100005],f=0,r=0;void addedge(int _u,int _v)&#123; edge[cnt].v=_v, ru[_v]++, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; void init()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,u,v; memset(at,-1,sizeof(at)); for(i=0;i&lt;E;i++) scanf("%d%d",&amp;u,&amp;v), addedge(u-1,v-1);&#125;void solve()&#123; int Ans=0; for(int i=0;i&lt;V;i++) if(!ru[i]&amp;&amp;at[i]!=-1) ans[i]=1,q[r++]=i; while(r-f)&#123; int h=q[f++],i,_v; for(i=at[h];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v; ru[_v]--; ans[_v]+=ans[h]; if(!ru[_v]) q[r++]=_v; &#125; &#125; for(int i=0;i&lt;V;i++) if(at[i]==-1) Ans+=ans[i]; printf("%d\n",Ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1724 Ellipse]]></title>
    <url>%2F2018%2F08%2F30%2Fhdu1724%2F</url>
    <content type="text"><![CDATA[题目链接 题解可以直接用数值积分，也可以查积分表。 (\frac {x}{2}\sqrt{a^2 - x ^2}+\frac {a^2}{2}\arcsin {\frac{x}{a}})' = \sqrt{a^2 - x^2}123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std; double a, b, L, R;void init()&#123; scanf("%lf%lf%lf%lf", &amp;a, &amp;b, &amp;L, &amp;R);&#125;double FF(double x)&#123; return b * (x * sqrt(a * a - x * x) / 2 + a * a * asin(x / a) / 2) / a;&#125;void solve()&#123; if(L &lt; -a) L = -a; if(R &gt; a) R = a; printf("%.3lf\n", (FF(R) - FF(L)) * 2);&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3908 异或之和]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu3908%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一对每一位统计这一位上有多少个1。1234567891011121314151617181920212223#include &lt;iostream&gt;#define INF 2000000000using namespace std;typedef unsigned long long ll;ll n;void init()&#123; cin &gt;&gt; n;&#125;void solve()&#123; ll t = n, ans = 0; for(ll c = 1; ; c &lt;&lt;= 1)&#123; ll cnt = c * ((t / c + 1) &gt;&gt; 1) + (t % c) * ((t / c + 1) &amp; 1); if(cnt &amp; 1) ans |= c; if(t &gt; c) t -= c; else break; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; 方法二两个相邻（从0,1开始）的数异或必然为1。所以统计一下即可。如果$n$是偶数只要在$n$是奇数的情况上异或即可。]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2388 阶乘之乘]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu2388%2F</url>
    <content type="text"><![CDATA[题目链接 题解可以知道阶乘$n!$中因子$p$的次数是 \sum_{k = 1} \lfloor \frac{n}{p^k}\rfloor而末尾$0$的个数就要看因子$10$的次数，而$10$的次数要看$2$和$5$的次数。因为本题中容易看出$2$的次数远大于$5$的次数，所以只要算出后者即可。这里我用了一点等差数列的技巧。。。123456789101112131415161718192021#include &lt;cstdio&gt;#define INF 2000000000using namespace std;typedef long long ll;ll n;void init()&#123; scanf("%lld", &amp;n);&#125;void solve()&#123; ll n5 = 0; for(ll i = 5; i &lt;= n; i *= 5)&#123; ll clos = (n % i == i - 1) ? n : (n - (n + 1) % i); n5 += ((clos + 1) / i - 1) * (clos + 1) / 2 + (n - clos) * (clos + 1) / i; &#125; printf("%lld\n", n5);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 高精度整数]]></title>
    <url>%2F2018%2F08%2F29%2Ftemplate-biginteger%2F</url>
    <content type="text"><![CDATA[高精度整数运算的模板。为了节省空间，此处不将运算封装成为一个类。 字符串变为高精度数高精度整数用的比较多的是将大数变成一个万进制数，用一个数组储存。数组的第一位为万进制数的长度。1234567891011int ten[] = &#123;1, 10, 100, 1000&#125;;inline void clearZero(int *bi)&#123; while(bi[0] &amp;&amp; !bi[bi[0]]) --bi[0];&#125;void build(char *src, int *dst)&#123; int len = strlen(src); dst[0] = (len - 1) / 4 + 1; for(int i = len - 1, j = 0; i &gt;= 0; --i, ++j) dst[(j &gt;&gt; 2) + 1] = (src[i] - '0') * ten[j &amp; 3]; clearZero(dst);&#125; 高精度比较和字符串比大小差不多。1234567891011121314151617181920//前者小于后者？bool cmp1(int *s1, int *s2)&#123; if(s1[0] != s2[0]) return s1[0] &lt; s2[0]; for(int i = s1[0]; i &gt;= 1; --i) if(s1[i] != s2[i]) return s1[i] &lt; s2[i]; return false;&#125;//小于等于bool cmp2(int *s1, int *s2)&#123; if(s1[0] != s2[0]) return s1[0] &lt; s2[0]; for(int i = s1[0]; i &gt;= 1; --i) if(s1[i] != s2[i]) return s1[i] &lt; s2[i]; return true;&#125;//等于bool cmp3(int *s1, int *s2)&#123; for(int i = 0; i &lt;= s1[0]; ++i) if(s1[i] != s2[i]) return false; return true;&#125; 高精度加法从最低位开始加，一直加到更大数的最高位。1234567void add(int *s1, int *s2, int *dst)&#123; int len = max(s1[0], s2[0]), x = 0; dst[0] = len; for(int i = 1; i &lt;= len; ++i) x += s1[i] + s2[i], dst[i] = x % 10000, x /= 10000; if(x &gt; 0) dst[++dst[0]] = x;&#125; 如果不支持不停的memset那就改写成这样：123456789101112void add(int *s1, int *s2, int *dst)&#123; int len1 = max(s1[0], s2[0]), len2 = s1[0] + s2[0] - len1, x = 0; dst[0] = len1; int *smax; if(s1[0] == len1) smax = s1; else smax = s2; for(int i = 1; i &lt;= len2; ++i) x += s1[i] + s2[i], dst[i] = x % 10000, x /= 10000; for(int i = len2 + 1; i &lt;= len1; ++i) x += smax[i], dst[i] = x % 10000, x /= 10000; if(x &gt; 0) dst[++dst[0]] = x;&#125; 高精度减法默认为$a-b$，因为负数不太好实现。 高精度乘法乘一个小于10000的数乘一个大数高精度左移直接执行对该数乘上2。 高精度幂高精度除法高精度开方高精度GCD直接使用Stein算法。void gcd(int s1, int s2, int *dst){ dst[0] = dst[1] = 1;}]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BJWC2008 雷涛的小猫]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu1107%2F</url>
    <content type="text"><![CDATA[题目链接 题解水DP记录每一层的最大值用于优化转移。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, h, d, dp[2005][2005] = &#123;0&#125;, maxi[2005] = &#123;0&#125;, cnt[2005][2005] = &#123;0&#125;;void init()&#123; n = read(), h = read(), d = read(); for(int i = 0; i &lt; n; ++i)&#123; int ni = read(); for(int j = 0; j &lt; ni; ++j) cnt[i][read()]++; &#125;&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i) dp[i][h] = cnt[i][h], maxi[h] = max(maxi[h], cnt[i][h]); for(int i = h - 1; i &gt;= 0; --i) for(int j = 0; j &lt; n; ++j)&#123; dp[j][i] = dp[j][i + 1]; if(h - i &gt;= d) dp[j][i] = max(dp[j][i], maxi[i + d]); dp[j][i] += cnt[j][i]; maxi[i] = max(maxi[i], dp[j][i]); &#125; printf("%d\n", maxi[0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数降幂定理]]></title>
    <url>%2F2018%2F08%2F28%2Fproblem-eulerjiangmi%2F</url>
    <content type="text"><![CDATA[问题证明： a^x \equiv a^{x\mod \phi(c) + \phi(c)} \pmod c \quad (x\ge \phi(c))求解容易知道，数列$a^0, a^1, a^2, …, a^x,…$一定有一段长度不超过$c$的循环节。设这段循环节从$r$开始，长度为$l$，那么$a^r \equiv a^{r+l} \pmod c$。而定理中有一个$\mod \phi(c)$，这提示我们考虑循环的性质。根据定理，我们不妨猜想$\phi(c)$就是一个循环节的长度的倍数，即$l\mid \phi(c)$，并且从数列的前$\phi(c)$项中的某一项开始就已经开始循环了。首先对于$r$有2个性质： 数列前$r$项和后面所有项分别处于两个不同的集合中。因为如果两个集合相交，那么说明可以改变$r$的大小使得两个集合不相交，这样就不符合循环从$r$开始。 前$r$项没有重复的项。因为如果有，说明循环在$r$之前就已经开始，这也不符合$r$的定义。 对于$\gcd(a, c) = 1$的情况，由于欧拉定理，该式子显然成立。对于其他更为平凡的情况，则有： $a$是质数，则$a\mid c$。则设$c=ka^e$，则$\phi(c)=\phi(k) \times a^{e-1}\times (a-1)$。则$a^{\phi(k)} \equiv 1 \pmod k$，则$a^{\phi(c)} \equiv 1 \pmod k$。令$a^{\phi(c)}=sk + 1$，则$a^{\phi(c)+e}=ska^e+a^e=sc+a^e$，即$a^{e+\phi(c)} \equiv a^e \pmod c$。因此可知$r\le e$。易证$\phi(c)\ge e$。（考虑构造不等式） $a$是质数的幂，则设$a=p^e$，$c=kp^w$。则$\phi(c)=\phi(k)\times p^{w-1}\times (p-1)$。则$p^{\phi(k)} \equiv 1 \pmod k$，则$p^{\phi(c) \frac{e}{\gcd(e, \phi(c))}} \equiv 1 \pmod k$。令$l’ = \frac{\phi(c)}{\gcd(e, \phi(c))}$,$p^{e l’}=sk+1$，则$p^{(l’+w)e }=a^{w+l’}=skp^{ew}+p^{ew}=sp^{(e-1)w}c+a^w$，即$a^{w+l’} \equiv a^w \pmod c$。因此可知$r\le w$，$l’\mid \phi(c)$，即$\phi(c)$可以构成一个周期。同样，易证$\phi(c)\ge w$。（考虑构造不等式） $a$是2个质数的幂的积，则设a=p_1^{e_1} p_2^{e_2}，那么由2可得p_1^{e_1 (w_1+\phi(c))} \equiv p_1^{e_1 w_1}\pmod c,p_2^{e_2 (w_2+\phi(c))} \equiv p_2^{e_2 w_2} \pmod c。对前一个式子两边乘以p_1^{e_1 w_2}，对后一个式子两边乘上p_2^{e_2 w_1}，将两个式子合并就有a^{w_1+w_2+\phi(c)} \equiv a^{w_1+w_2} \pmod c。同样，令c=kp_1^{w_1}p_2^{w_2}，就有\phi(c)=\phi(k)\times p_1^{w_1 - 1} \times (p_1 - 1) \times p_2^{w_2 - 1} \times (p_2 - 1)，因此利用上式即可证明w_1 + w_2 \le \phi(c)。 $a$为多个质数的幂的积，则依照3进行即可。 由此就完成了证明。（如果证错了请和我说！） 参考资料]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTSC2014 企鹅QQ]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4503%2F</url>
    <content type="text"><![CDATA[题目链接 题解裸hash的命中率太低了。还是要开unsigned long long，而且要搞2个模数。反正大概就是枚举删去哪一位，然后排序找不同。千万不要用传统的Hash，会疯狂wa。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define INF 2000000000#define P 390791ull#define P_ 323591ullusing namespace std;typedef unsigned long long ll;int n,L,S,ans=0,cnt[11179120]=&#123;0&#125;;ll hsh[11179120]=&#123;0&#125;,ppow1[306],ppow2[306],H[30005],T[30005];bool vis[11179120]=&#123;0&#125;;char Str[30005][205];ll Hash(char *s)&#123; ll resa=0,resb=0; //给某一个特殊位置赋值0 for(int i=0;i&lt;L;i++) resa=P*resa+s[i],resb=P_*resb+s[i]; resa+=resb; return resa;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),L=read(),S=read(); ppow1[0]=ppow2[0]=1; for(int i=1;i&lt;=L;i++) ppow1[i]=ppow1[i-1]*P,ppow2[i]=ppow2[i-1]*P_;&#125;void solve()&#123; int tmp; ll valu; for(int i=1;i&lt;=n;i++) scanf("%s",Str[i]), H[i]=Hash(Str[i]); for(int j=0;j&lt;L;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; valu=H[i],valu-=Str[i][j]*ppow1[L-j-1], valu-=Str[i][j]*ppow2[L-j-1]; T[i]=valu; &#125; sort(T+1,T+n+1); int cur=1; for(int i=2;i&lt;=n;i++)&#123; if(T[i]==T[i-1])ans+=cur,cur++; else cur=1; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>CTSC</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3884 上帝与集合的正确用法]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4139%2F</url>
    <content type="text"><![CDATA[题目链接 题解直接上欧拉定理降幂公式。 a^x \equiv a^{x\mod \phi(c) + \phi(c)} \pmod c \quad (x\ge \phi(c))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll P,phi[10000005]=&#123;0&#125;;ll Pow(ll a,ll b,ll c)&#123; a%=c; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll getphi(ll N)&#123; ll res=N,t=N; for(ll i=2;i*i&lt;=N;i++)&#123; if(t%i==0)&#123; while(t%i==0)t/=i; res/=i,res*=(i-1); &#125; if(t==1)break; &#125; if(t!=1)res/=t,res*=(t-1); return res;&#125;ll dfs(ll p)&#123; if(p==1)return 0; //S=2^S=2^S mod phi P，what is S? if(!phi[p])phi[p]=getphi(p); return (Pow(2,dfs(phi[p])+phi[p],p));&#125;void init()&#123; phi[1]=1;&#125;void solve()&#123; int T=read(); while(T--)&#123; P=read(),printf("%lld\n",dfs(P)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2429 GCD & LCM Inverse]]></title>
    <url>%2F2018%2F08%2F28%2Fpoj2429%2F</url>
    <content type="text"><![CDATA[题目地址 题解找质因子用Miller-Rabin和Pollard-Rho实现，然后求解的时候考虑对勾函数，当$a$和$b$越接近$\sqrt{ab}$时$a+b$越小。就做完了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;ll g, l, prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;ll dd[55], ans = -1;int e1[55] = &#123;0&#125;, e2[55] = &#123;0&#125;, cnt = 0;double lev, dis;ll gcd(ll a, ll b)&#123; return (!b) ? a : gcd(b, a % b);&#125;ll mul(ll a, ll b, ll M)&#123; ll res = 0; while(b)&#123; if(b &amp; 1ll) &#123; res += a; if(res &gt;= M) res -= M; &#125; a &lt;&lt;= 1, b &gt;&gt;= 1; if(a &gt;= M) a -= M; &#125; return res;&#125;ll modpow(ll a, ll b, ll M)&#123; a %= M; ll res = 1; while(b)&#123; if(b &amp; 1ll) res = mul(res, a, M); a = mul(a, a, M), b &gt;&gt;= 1; &#125; return res;&#125;bool witness(ll a, ll n, ll t, ll u)&#123; ll x = modpow(a, u, n); for(ll i = 1; i &lt;= t; ++i)&#123; ll xx = mul(x, x, n); if(xx == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return true; x = xx; &#125; if(x != 1) return true; return false;&#125;bool miller_rabin(ll n)&#123; for(int i = 0; i &lt; 10; ++i)&#123; if(n == prime[i]) return true; else if(n % prime[i] == 0) return false; &#125; ll t, u; for(t = 1; ; ++t) if((n - 1) % (1 &lt;&lt; t) == 0) break; u = (n - 1) / (1 &lt;&lt; t); for(int i = 0; i &lt; 10; ++i) if(witness(rand() % (n - 1) + 1, n, t, u)) return false; return true;&#125;ll rho(ll n, ll c)&#123; ll x = modpow(rand(), rand(), n), y = x, d = 1; int k = 2; for(int i = 1; d == 1; ++i)&#123; x = mul(x, x, n) + c; if(x &gt;= n) x -= n; if(x &gt; y) d = gcd(x - y, n); else d = gcd(y - x, n); if(i == k) y = x, k &lt;&lt;= 1; &#125; return d;&#125;ll Pollard(ll n)&#123; ll d = n; while(d == n) d = rho(n, rand() % (n - 1) + 1); return d;&#125;void addFac(ll &amp;x, ll d, int *e)&#123; int cur; for(cur = 0; cur &lt; cnt; ++cur) if(dd[cur] == d) break; dd[cur] = d; do&#123; x /= d, e[cur]++; &#125;while(x % d == 0); if(cur == cnt) cnt++;&#125;void getFac(ll x, int *e)&#123; if(!miller_rabin(x))&#123; ll d = Pollard(x); getFac(d, e), getFac(x / d, e); &#125;else&#123; addFac(x, x, e); &#125;&#125;void dfs(int ind, ll x)&#123; if(ind == cnt)&#123; if(1.0 * x &gt; lev &amp;&amp; ans &gt; x) ans = x; return ; &#125; ll res = 1; for(int i = 0; i &lt; e2[ind]; ++i) res *= dd[ind]; dfs(ind + 1, x * res); for(int i = e2[ind]; i &lt; e1[ind]; ++i) res *= dd[ind]; dfs(ind + 1, x * res);&#125;void init()&#123; srand(122144);&#125;void solve()&#123; cnt = 0; memset(dd, 0, sizeof(dd)); memset(e1, 0, sizeof(e1)); memset(e2, 0, sizeof(e2)); if(g == l) cout &lt;&lt; g &lt;&lt; " " &lt;&lt; l &lt;&lt; endl; else&#123; getFac(l, e1); if(g != 1) getFac(g, e2); lev = sqrt(1.0 * l * g); ans = l, dfs(0, 1); cout &lt;&lt; (l / ans) * g &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl; &#125;&#125;int main()&#123; while(scanf("%lld %lld", &amp;g, &amp;l) == 2)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2006 狼抓兔子]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4001%2F</url>
    <content type="text"><![CDATA[题目链接 题解平面图最小割转对偶图最短路裸题。数组要开大！开大！开大！要特判！特判！特判！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; struct Edge&#123; int v,cost,_next; &#125;; Edge edge[7000005];int cnt=0,at[2000005],n,m,S,T,sq,d[2010005];int que[7000005];bool in[2000005]=&#123;0&#125;;int id(int i,int j)&#123;return (i-1)*(m-1)+j;&#125;void addedge(int _u,int _v,int _cost)&#123; edge[++cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt; edge[++cnt].v=_u, edge[cnt].cost=_cost, edge[cnt]._next=at[_v], at[_v]=cnt;&#125; void spfa_bfs()&#123; fill(d+1,d+sq*2+10000,INF); int i,_u,_v,_co,r=0,f=0,qc=0; d[S]=0,que[r++]=S,in[S]=1,qc++; while(qc&amp;&amp;qc&lt;=7000000)&#123; _u=que[f],in[_u]=0; f=(f==7000000)?0:f+1; qc--; for(i=at[_u];i;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r]=_v; r=(r==7000000)?0:r+1; qc++; &#125; &#125; &#125; &#125;&#125;void init()&#123; n=read(),m=read(),sq=(n-1)*(m-1); if(n==1||m==1)&#123; int ans=INF,c; for(int i=1;i&lt;=m+n-2;i++) c=read(),ans=min(ans,c); printf("%d\n",ans); return ; &#125; S=2*sq+1,T=2*sq+2; int u,v,c; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++)&#123; c=read(); if(i==1)addedge(id(i,j),T,c); else if(i==n)addedge(id(i-1,j)+sq,S,c); else addedge(id(i-1,j)+sq,id(i,j),c); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++)&#123; c=read(); if(j==1)addedge(id(i,j)+sq,S,c); else if(j==m)addedge(id(i,j-1),T,c); else addedge(id(i,j-1),id(i,j)+sq,c); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++)&#123; c=read(); addedge(id(i,j),id(i,j)+sq,c); &#125; spfa_bfs(); printf("%d\n",d[T]);&#125;void solve()&#123; &#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最小割</tag>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判圈问题]]></title>
    <url>%2F2018%2F08%2F28%2Fwriting%2Fproblem-findcycle%2F</url>
    <content type="text"><![CDATA[这里讨论主流的判圈算法。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（3）]]></title>
    <url>%2F2018%2F08%2F28%2Fwriting%2Ftemplate-math-3%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于数值，高精度计算相关的问题。 积分计算自适应Simpson方法Romberg方法]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018多校第一场 题解]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Fcontest-2018multischool%2F</url>
    <content type="text"><![CDATA[题目链接 A一个很神奇的数学题…我个人只会观察，发现当$n=3k$时可以利用均值不等式直接输出最大值，$n=4k$时答案就是$2k^3$，其他的手算了几个，估计没有，就直接$-1$。居然对了。这是为什么呢？题解里面只写了一个等式，我看不太懂 1=\frac{1}{2}+\frac{1}{3}+\frac{1}{6}=\frac{1}{3}+\frac{1}{3}+\frac{1}{3}=\frac{1}{2}+\frac{1}{4}+\frac{1}{4}12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll n;void init()&#123; n = read();&#125;void solve()&#123; if(n % 3 == 0) n /= 3, printf("%lld\n", n * n * n); else if(n % 4 == 0) n &gt;&gt;= 2, printf("%lld\n", n * n * n * 2ll); else printf("-1\n");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; B首先先把可以匹配的弄掉，最后剩一堆$pair(a, b)$，表示该字符串有$a$个’)’，$b$个’(‘。然后贪心，用一种迷之方法排序。。。排序的中心要求是让)少(多的在前面，)多(少的在后面，由前者过渡到后者。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef pair&lt;int, int&gt; pp;int n, st[100005], top, ans;pp p[100005];char s[100005];void init()&#123; ans = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", s); int r = 0, l = 0, len = strlen(s); top = 0; for(int j = 0; j &lt; len; ++j)&#123; if(s[j] == ')')&#123; if(top &amp;&amp; st[top - 1] == '(') top--, l--, ans += 2; else st[top++] = ')', r++; &#125;else st[top++] = '(', l++; &#125; p[i].first = r, p[i].second = l; &#125;&#125;bool cmp(const pp&amp; p1, const pp&amp; p2)&#123; if(!p1.first) return 1; if(!p2.first) return 0; int f1 = p1.first - p1.second, f2 = p2.first - p2.second; if(f1 * f2 &lt;= 0) return f1 &lt; f2; if(f1 &lt; 0) return p1.first &lt;= p2.first; return p1.second &gt;= p2.second;&#125;void solve()&#123; sort(p, p + n, cmp); int l = p[0].first, r = p[0].second; for(int i = 1; i &lt; n; ++i)&#123; int ll = p[i].first, rr = p[i].second; ans += min(r, ll) * 2; if(r &gt; ll) r = r - ll + rr; else l = ll - r + l, r = rr; &#125; printf("%d\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; C]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2559]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Fpoj2559%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（1）]]></title>
    <url>%2F2018%2F08%2F26%2Ftemplate-math-1%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于快速幂和快速乘，与质数相关的问题。 快速幂对于$a^b$，把$b$展开成为二进制形式，然后按位乘，同时让$a$反复平方。时间复杂度：$O(\log n)$12345678int modpow(int a, int b, int M)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (res * a) % M; a = (a * a) % M, b &gt;&gt;= 1; &#125; return res;&#125; 特化版本：123456789101112131415161718//模数比较大，但是平方不会爆long long时int modpow(int a, int b, int M)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = 1ll * res * a % M; a = 1ll * a * a % M, b &gt;&gt;= 1; &#125; return res;&#125;//模数很大，很容易爆long long时ll modpow(ll a, ll b, ll M)&#123; ll res = 1; while(b)&#123; if(b &amp; 1) res = fstmul(res, a, M); a = fstmul(a, a, M), b &gt;&gt;= 1; &#125; return res;&#125; 快速乘实现一当$a\times b \mod M$可能超过当前类型限制时，可以将$b$展开成为二进制，然后根据乘法分配律让$a$按位乘，即可避免溢出。时间复杂度：$O(\log n)$12345678int fstmul(int a, int b, int M)&#123; int res = 0; while(b)&#123; if(b &amp; 1) res = (res + a) % M; a &lt;&lt;= 1, a %= M, b &gt;&gt;= 1; &#125; return res;&#125; 特化版本：12345678910111213//模数很大时ll fstmul(ll a, ll b, ll M)&#123; ll res = 0; while(b)&#123; if(b &amp; 1) &#123; res += a; if(res &gt;= M) res -= M; &#125; a &lt;&lt;= 1, b &gt;&gt;= 1; if(a &gt;= M) a -= M; &#125; return res;&#125; 实现二因为$a\times b \mod M = a\times b - \lfloor \frac{a\times b}{M} \rfloor \times M$，因此可以用(long) double来存$\frac{a\times b}{M}$，然后再化成整数去乘$M$，再算出对应的结果。时间复杂度：$O(1)$123456int fstmul_2(int a, int b, int M)&#123; int c = (double)a * b / M; int res = a * b - c * M; //此时res由于溢出，可能为负数 if(res &lt; 0) res += M; return res;&#125; 特化版本：1234567//模数是long long级别ll fstmul_2(ll a, ll b, ll M)&#123; ll c = (long double)a * b / M; ll res = a * b - c * M; //此时res由于溢出，可能为负数 if(res &lt; 0) res += M; return res;&#125; 素数定理\pi(x) \sim \frac{N}{\ln N}可以用这个定理估计一定范围内的素数个数。 质数判断试除法一个数$N$为合数，那么一定有一个数$T$，使得$T|N,2\le T \le \sqrt{N}$。根据这个可以用时间复杂度$O(\sqrt n)$判断质数。123456bool isP(int x)&#123; if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125; 特化版本：1234567//x比较大，long long级别bool isP(ll x)&#123; if(x &lt;= 1ll) return false; for(ll i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125; Miller-Rabin算法由费马小定理，当$p$为一个质数，对于$gcd(a, p) = 1$，有$a^{p - 1} \equiv 1 \pmod p$。反过来说，当我们知道有$gcd(a, p) = 1$，并且$a^{p - 1} \equiv 1 \pmod p$时，那么$p$就有可能是质数。理论上，要认定一个数$p$为一个质数，我们可以用所有小于它的和它互质的数$a$做一个判定，即判断是否有$a^{p - 1} \equiv 1 \pmod p$。如果全部成立，那么$p$几乎就是一个质数。可惜的是，存在这样的合数——卡迈克尔数(Carmicheal Number)。因此，必须要做出一些改进，使得判定更为准确。下面先直接给出Miller-Rabin算法的代码：123456789101112131415161718192021bool witness(int a, int n, int t, int u)&#123; int x = modpow(a, u, n); for(int i = 0; i &lt; t; ++i)&#123; int xx = (x * x) % n; if(xx == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return true; x = xx; &#125; if(x != 1) return true; return false;&#125;bool isP_miller_rabin(int n, int times)&#123;//执行times次 int t = 1, u; while((n - 1) % (2 &lt;&lt; t) == 0) t++; u = (n - 1) / (1 &lt;&lt; t); while(times--)&#123; int a = rand() % (n - 1) + 1; if(witness(a, n, t, u)) return false; &#125; return true;&#125; 该算法的另一个理论基础是二次探测定理：若$x^2 \equiv 1\pmod p$，$p$为质数，那么$x\equiv 1 \pmod p$或者$x \equiv -1 \pmod p$。这是因为上式可以化成$(x+1)(x-1)\equiv 0 \pmod p$，而$p$是一个质数，由质数的锐利性质可得。当$p$为质数时，令$p-1= 2^tu$，那么对于序列$a^u, a^{2u}, a^{2^2u}, …, a^{2^tu}$，由于最后一项一定为$1$，那么必然有以下条件中的一个： $a^u \equiv 1 \pmod p$ $\exists i \in \lbrace 0, 1, 2, … , t-1\rbrace, a^{2^iu} \equiv -1 \pmod p$ 若这两个性质都不符合，那么就能够确认$p$是合数。可以证明，这样的$a$占了$1$到$p-1$的$75\%$左右，因此做$T$次判断，失误率近似在$4^{-T}$。要取得更加优秀的结果，可以先根据质数表，看看几个小质数是不是程序中$n$的因子，然后再进行Miller-Rabin验证。特化版本：12 求质数埃氏筛法基于“合数一定有一个大于$1$，小于自身的质因数”的想法，可以直接从$2$向$N$扫描，遇到没有被标记的数就认为它是质数，然后把它的倍数全部标记。这样没有被标记的数就全部都是质数了。由于遇到一个质数$p$的时候小于$p^2$的$p$的倍数已经全部被标记了，所以可以直接从$p^2$开始进行筛除。时间复杂度：$O(n\log \log n)$。（小于$n$的质数的倒数和约为$\log \log n$，参见此处）1234567void getP(int N)&#123; for(int i = 2; i &lt;= N; ++i) if(!vis[i])&#123; for(int j = i * i; j &lt;= N; j += i) vis[j] = 1; &#125;&#125; 区间筛法要筛出$[L, R]$上面的质数，只需要筛出所有$[2, \sqrt{R}]$上面的质数即可，因为$[L, R]$上面的合数必然有一个位于$[2, \sqrt{R}]$上面的质因子。 时间复杂度：$O(N \log \log N)$（基于埃氏筛法）123456789void getP(int L, int R)&#123; if(L &lt;= 1) L = 2; for(int i = 1; i &lt;= cnt; ++i)&#123; unsigned int p = prime[i]; if(R &lt; p) break; for(unsigned int j = max((L - 1 + p) / p, 2u); j &lt;= R / p; ++j)//这里取j的初始值是为了保证能取道区间内所有p的倍数 vis2[j * p - L] = 1; &#125;&#125; 欧拉筛法也称线性筛法。观察上面的埃氏筛法程序容易发现，一个数常常会被多个质数筛掉，这样会影响效率。如果一个数只会被筛一次，那么就可以做到线性的时间复杂度。考虑每一个数的最小质因数$mindiv[i]$，从$2$到$N$扫描。如果一个数未被访问过，那就把它加入质数里面。然后对于当前的数，利用所有小于或者等于$mindiv[i]$的质数$p$，标记$mindiv[i]\times p$为合数，同时置其最小质因数为$p$。这样每一个合数就都被它的最小质因数筛掉了。时间复杂度：$O(n)$1234567891011121314// 本代码未显式保存mindivint prime[N &gt;&gt; 1], tot = 0;bool vis[N];void getP(int N)&#123; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i]) prime[tot++] = i; for(int j = 0; j &lt; tot; ++j)&#123; if(i * prime[j] &gt; N) break; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; //这一步起到的是让p不大于最小质因数 &#125; &#125;&#125; 质因数分解算术基本定理对于任何一个大于$1$的正整数$n$，$n$都能被唯一分解为有限个质数的乘积，写作： n = p_1^{c_1} p_2^{c_2} \cdots p_m^{c_m}其中c_i \ge 1、p_i是质数$(\forall i)$，且p_1]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（2）]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Ftemplate-math-2%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于模相关的问题。 求$\gcd$欧几里得算法（辗转相除法）辗转相除法基于GCD递归定理： \gcd(a, b) = \gcd(b, a\mod b)该定理可以用反证法进行证明，也可以通过证明左右两数分别被对方整除证明。此处不列出证法。123int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125; Stein算法该算法相对欧几里得算法而言，在计算机上实现的效率更高，尤其是对于一些大数的计算。该算法的步骤也非常简单，即为以下式子： \gcd(a, b) = \begin{cases} 2\gcd(\frac {a}{2}, \frac{b}{2}) \quad & \text{if }a, b \text{ are even } \\ \gcd(\frac{a}{2}, b) \quad & \text{if }a \text{ is even and }b \text{ is odd } \\ \gcd(\frac{\left| a- b\right|}{2}, b)\quad & \text{if }a, b \text{ are odd } \end{cases}以上式子的正确性可以用同余式的性质证明，此处不给出。1234567891011int gcd(int a, int b)&#123; if(!b) return a; if(!a) return b; if(a &amp; 1)&#123; if(b &amp; 1) return gcd(b, abs(a - b) &gt;&gt; 1); else return gcd(a, b &gt;&gt; 1); &#125;else&#123; if(b &amp; 1) return gcd(a &gt;&gt; 1, b); else return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; &#125;&#125; 扩展欧几里得扩展欧几里得可以用来求解线性同余方程组。 123456789int extgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b)&#123; x = 1, y = 0; return a; &#125; int d = extgcd(b, a % b, y, x); y -= x * (a / b); return d;&#125; 欧拉函数欧拉定理欧拉定理叙述如下： 欧拉定理降幂公式 解线性同余方程组中国剩余定理中国剩余定理（CRT）可以用来求解线性同余方程组。它的描述如下：有$n$个线性同余方程组： \begin{cases} x \equiv a_1 \pmod {m_1} \\ x \equiv a_2 \pmod {m_2} \\ \vdots \\ x \equiv a_n \pmod {m_n} \\ \end{cases}其中m_1, m_2, \cdots, m_n两两互质，那么存在唯一的一个$x$在模M = \Pi_{i = 1}^{n} m_i使得上述方程组成立。证明如下：首先构造一个这样的$x$证明存在性。令M_i为除m_i外所有m_j的积，那么\gcd(M_i, m_i)=1。解b_i \dot M_i \equiv 1 \pmod {m_i}。然后令x=\sum_{i = 1}^{n} a_i \dot b_i \dot M_i，则这个$x$就是答案。（容易验证这一点）然后再证明唯一性。假设存在另一个不同的解$y$，那么$x-y$同时是m_i(\forall i)的倍数。因为m_i两两互质。所以$x-y$是$M$的倍数。所以$x\equiv y \pmod M$。矛盾。这样就可以利用这个构造性算法构造出这个问题的解了：123456789101112int CRT(int m[], int a[], int n)&#123; int M = 1, x = 0; for(int i = 0; i &lt; n; ++i) M *= m[i]; for(int i = 0; i &lt; n; ++i)&#123; int Mi = M / m[i], b, q; extgcd(Mi, m[i], b, q); Mi = ((Mi * a[i]) % M) * b % M; x = (x + Mi) % M; &#125; return (x + M) % M;&#125; 扩展中国剩余定理当$m_i$不两两互质怎么办？依然可以求出线性同余方程组的解。 先考虑只有两个方程的情况。假如只有这样两个方程： \begin{cases} x\equiv b_1 \pmod {m_1} \\ ax\equiv b_2 \pmod {m_2} \end{cases}写$x=b_1+tm_1$，带入第二个方程得$m_1 a t\equiv b_2 - ab_1 \pmod {m_2}$。解出$t$，如$t\equiv c \pmod {m_2}$，就可以得到$t=c+dm_2$，带入，从而$x\equiv b_1+cm_1 \pmod {m_1m_2}$。这样就可以依次解开第三，四，……个方程。 实际上为了防止爆数据类型，完全可以把$\pmod {m_1m_2}$改写为$\pmod {lcm(m_1, m_2)}$。下面的代码就是这么做的。123456789101112131415ll extCRT(ll b[], ll m[], int n)&#123; ll M = m[1], ans = b[1], x, y; for(int i = 2; i &lt;= n; ++i)&#123; ll d = extgcd(M, m[i], x, y), a_ = (b[i] - ans) % m[i]; if(a_ &lt; 0) a_ += m[i]; if(a_ % d) return -1; x = fstmul(x, a_ / d, m[i] / d); if(x &lt; 0) x += m[i] / d; ll MM = M; M /= d, M *= m[i]; ans = (ans + fstmul(x, MM, M)) % M; if(ans &lt; 0) ans += M; &#125; return ans;&#125; 组合数取模卢卡斯定理一句话描述卢卡斯定理，就是： \tbinom{n}{m} \equiv \tbinom{\lfloor \frac{n}{p} \rfloor}{\lfloor \frac{m}{p} \rfloor} \tbinom{n \mod p}{m \mod p} \pmod p其中$p$是质数。容易发现卢卡斯定理的表达式里面有一个递归结构，所以可以把它做成递归的。123ll Lucas(ll n, ll m)&#123; return (!m) ? 1 : C(n % p, m % p) * Lucas(n / p, m / p) % p;&#125; 扩展卢卡斯定理如果要取模的数$p$不是质数怎么办？可以考虑将$p$进行质因数分解，分解成$\prod p^e$的形式，算出组合数对每一个$p^e$取模的值，然后用中国剩余定理合并即可。方便起见，记$P=p^e$。那么问题就是怎么求$\tbinom{n}{m} \mod P$。先考虑$n!, m!, (n-m)!$各自含因子$p$的次数。设三者分别含$p$的次数是e_1, e_2, e_3，那么只有当e_1-e_2-e_3]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NOI1997-2002 题解]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fnoi1997-2002%2F</url>
    <content type="text"><![CDATA[包含了NOI1997-2002六年部分题目的题解。 NOI1997D1T2 最优乘车题目链接 单源最短路问题。考输入。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='\n'||c==EOF)return -1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;bool mp[505][505]=&#123;0&#125;;int n,m,q[5005],f=0,r=0,d[505];void solve()&#123; q[r++]=0,d[0]=-1; int h,v; while(r-f)&#123; h=q[f++]; for(v=0;v&lt;n;v++) if(mp[h][v]&amp;&amp;d[v]&gt;d[h]+1)d[v]=d[h]+1,q[r++]=v; &#125;&#125;int main()&#123; m=read(),read();n=read(),read(); fill(d,d+n,10000000); int i,j,u,v; for(i=0;i&lt;m;i++)&#123; j=0;while((v=read())&gt;0)q[j++]=v; for(u=0;u&lt;j;u++) for(v=u+1;v&lt;j;v++) mp[q[u]-1][q[v]-1]=1; &#125; solve(); if(d[n-1]&gt;=1000000)printf("NO\n"); else printf("%d\n",d[n-1]); return 0;&#125; NOI1998D1T1 个人所得税题目链接 模拟即可。开数组存每个员工每个月的收入，最后再计算；遇到单个的就直接计算。本题读入很神奇，需注意。还有就是负数的处理问题，应交税的部分不能为负。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int m,money[50005][20]=&#123;0&#125;;char typ[10],tim[10],PAY[]="PAY",INC[]="INCOME";double ans=0,pay_l[]=&#123;0,500,2000,5000,20000,40000,60000,80000,100000,999999999&#125;,inc_l[]=&#123;0,20000,50000,999999999&#125;;void init()&#123; scanf("%d",&amp;m);&#125;double Count_pay(int pr)&#123; double left=max(0,pr-800),_ans=0; for(int i=1;i&lt;=9;i++) if(left&lt;pay_l[i])&#123; _ans+=i*0.05*(left-pay_l[i-1]); break; &#125;else _ans+=i*0.05*(pay_l[i]-pay_l[i-1]); return _ans;&#125;double Count_income(int pr)&#123; double left,_ans=0; left=(pr&gt;4000)?(pr*0.8):(max(0,pr-800)); for(int i=1;i&lt;=3;i++)&#123; if(left&lt;inc_l[i])&#123; _ans+=(i+1)*0.1*(left-inc_l[i-1]); break; &#125;else _ans+=(i+1)*0.1*(inc_l[i]-inc_l[i-1]); &#125; return _ans;&#125;void solve()&#123; int id,pr,mon; for(;;)&#123; scanf("%s",typ); if(typ[0]=='#')break; scanf("%d%s%d",&amp;id,tim,&amp;pr); if(!strcmp(PAY,typ))&#123; if(tim[1]=='/')mon=tim[0]-'0'; else mon=10*(tim[0]-'0')+tim[1]-'0'; money[id][mon]+=pr; &#125;else&#123; ans+=Count_income(pr); &#125; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=12;j++) if(money[i][j]) ans+=Count_pay(money[i][j]); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; NOI2000D1T1 瓷片项链题目链接 二次函数。12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int v,v0;int main()&#123; if((v%v0==0&amp;&amp;v%(v0+v0))||v==0) printf("0\n"); else &#123; double a=v,b=v0,ans,d=v/(v0+v0); if(ceil(d)-d&gt;d-floor(d)) ans=floor(d); else ans=ceil(d); printf("%d\n",(int)ans); &#125; return 0;&#125; D1T3 古城之谜题目链接 这题怎么想的。。。看了byvoid的题解还是有点晕晕乎乎。要先对给出的形式进行简化。 句子：是名词、动词短语交替出现的，且开头必定为名词短语。名词短语：相当于任意多个副词+名词。动词短语：相当于任意多个副词+动词。 考虑刻画状态，字母要算进去，当前词性要算进去，还要考虑最少的句子数和单词数。所以设$f(i,j,k)$表示前$i$个字母，最后一个单词词性为$j$，组成$k$个句子的最小单词数量。$j$有$3$种，用$0,1,2$表示名，动，副。但是还要考虑到副词的链接问题。所以加一种情况：$j=3$，表明是副词，并且前面最近的非副词是动词。$j=2$时前面最近的非副词是名词。然后就大力转移即可。直接开数组会MLE，但是可以发现$k$的转移来源只会是$k$和$k-1$，所以用滚动数组压掉这一维。匹配串我用的是hash，大概不会被卡掉…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000#define Mod 10000007ullusing namespace std;typedef unsigned long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,len,f[5005][4][2],maxl=0;char word[1005][25],tex[50005];ll hsh[50005],Pow[50005];bool t1[10000007],t2[10000007],t3[10000007];ll getHash(int i,int j)&#123; return hsh[j]-(hsh[i-1]*Pow[j-i+1]);&#125; void init()&#123; n=read(); int l;ll Hash; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",word[i]); l=strlen(word[i]),Hash=0,maxl=max(maxl,l-2); for(int j=2;j&lt;l;j++) Hash=Hash*137ull+(ll)word[i][j]+157ull; if(word[i][0]=='n')t1[Hash%Mod]=1; if(word[i][0]=='v')t2[Hash%Mod]=1; if(word[i][0]=='a')t3[Hash%Mod]=1; &#125; scanf("%s",tex+1); len=strlen(tex+1)-1,hsh[0]=0,Pow[0]=1; for(int i=1;i&lt;=len;i++) hsh[i]=hsh[i-1]*137ull+(ll)tex[i]+157ull,Pow[i]=Pow[i-1]*137ull;&#125;void solve()&#123; memset(f,0x3f,sizeof(f)); f[0][0][0]=0; int B,B_,ans1,ans2; ll tmp; for(int k=1;k&lt;=len;k++)&#123; B=(k&amp;1),B_=B^1; for(int i=1;i&lt;=len;i++)&#123; f[i][0][B]=f[i][1][B]=f[i][2][B]=f[i][3][B]=0x3f3f3f3f; for(int t=i;t&gt;i-maxl&amp;&amp;t&gt;=1;t--)&#123; tmp=getHash(t,i)%Mod; if(t1[tmp])&#123; int &amp;T=f[i][0][B]; T=min(T,min(f[t-1][1][B]+1,f[t-1][3][B]+1)); T=min(T,min(f[t-1][0][B_]+1,f[t-1][1][B_]+1)); &#125; if(t2[tmp])&#123; int &amp;T=f[i][1][B]; T=min(T,min(f[t-1][0][B]+1,f[t-1][2][B]+1)); &#125; if(t3[tmp])&#123; int &amp;T=f[i][2][B]; T=min(T,min(f[t-1][0][B]+1,f[t-1][2][B]+1)); T=min(T,f[t-1][0][B_]+1); int &amp;T2=f[i][3][B]; T2=min(T2,min(f[t-1][1][B]+1,f[t-1][3][B]+1)); T2=min(T2,min(f[t-1][0][B_]+1,f[t-1][1][B_]+1)); &#125; &#125; &#125; if(f[len][0][B]&lt;INF||f[len][1][B]&lt;INF)&#123; ans1=k,ans2=min(f[len][0][B],f[len][1][B]); break; &#125; &#125; printf("%d\n%d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T1 单词查找树题目链接 trie树模板题？123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int trie[100005][29]=&#123;0&#125;;char wd[1005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void solve()&#123; int ans=1,p; char *s; while(~scanf("%s",wd))&#123; p=1; for(s=wd;*s;s++)&#123; if(!trie[p][*s-'A']) trie[p][*s-'A']=++ans; p=trie[p][*s-'A']; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; solve(); return 0;&#125; D2T2 青蛙过河题目链接 设$f(h,k)$为答案。则显然的是$f(0,k)=k+1$。我们加一个石墩，那么可以先把最上面一波青蛙送到新加的上面去，然后把下面那一拨送到对岸，再把石墩上的送走。所以$f(1,k)=2f(0,k)$。再加一个。我们又把一波青蛙送到其中一个石墩上，然后问题变成了$f(1,k)$的形式，所以$f(2,k)=2f(1,k)$。换言之，加一个石墩，送青蛙的能力就增强一倍。所以$f(h,k)=2^h (k+1)$。12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll h,k;void init()&#123; scanf("%lld%lld",&amp;h,&amp;k);&#125;void solve()&#123; printf("%lld\n",(k+1)*(1&lt;&lt;h));&#125;int main()&#123; init(); solve(); return 0;&#125; D2T3 算符破译NOI2001D1T1 食物链题目链接 设$a,2a,3a$分别表示$a$属于$A,B,C$。则对于1，判断$a$与$2b$和$a$与$3b$是否在同一集合对于2，判断$a$吃不吃自己与$b$吃不吃$a$即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int rank[150010],parent[150010],t,ans=0,k,n,x,y;int same(int a,int b),find(int a);void init(int n),joint(int x,int y);void init(int n)&#123; int i;for(i=1;i&lt;=n;i++)&#123; parent[i]=i; rank[i]=0; &#125;&#125;void joint(int x,int y)&#123; int a=find(x),b=find(y); if(a==b)return; if(rank[a]&lt;rank[b])&#123; parent[a]=b; &#125;else&#123; parent[b]=a; if(rank[a]==rank[b])rank[a]++; &#125;&#125;int find(int a)&#123; if(parent[a]==a)return a; else return (parent[a]=find(parent[a]));&#125;int same(int a,int b)&#123;return find(a)==find(b);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k);int i; init(n*3);for(i=0;i&lt;k;i++)&#123; scanf("%d%d%d",&amp;t,&amp;x,&amp;y); if(x&gt;n||y&gt;n||x&lt;1||y&lt;1)ans++; else&#123; if(t==1)&#123; if(same(x,y+n)||same(x,y+2*n))ans++; else &#123;joint(x,y);joint(x+n,y+n);joint(x+n*2,y+n*2);&#125; &#125;else&#123; if(same(x,y+2*n)||same(x,y))ans++; else&#123; joint(x,y+n);joint(x+n,y+2*n);joint(x+n*2,y); &#125; &#125; &#125; &#125;printf("%d\n",ans); return 0;&#125; D1T2 反正切函数的应用题目链接 $O(\sqrt n)$乱搞。利用$(a-b)(a-c)=a^2+1$12345678910111213141516#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned int uint;uint a,ans=4000000000u,d;int main()&#123; scanf("%u",&amp;a); d=a*a+1; for(uint i=1;i*i&lt;=d;i++) if(d%i==0)ans=min(ans,a+a+i+d/i); printf("%u\n",ans); return 0;&#125; D1T3 聪明的打字员题目链接 标准的广搜。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char vis[1000000][6]=&#123;0&#125;;int S,T,ans[1000005][6],ten[10];queue&lt;int&gt; q1,q2;//000000-999999int ptoi(int *L)&#123; int res=0; for(int i=0;i&lt;6;i++)res=res*10+L[i]; return res;&#125;void itop(int *L,int x)&#123; for(int i=5;i&gt;=0;i--)L[i]=x%10,x/=10;&#125;void init()&#123; S=read(),T=read(); memset(ans,0x3f,sizeof(ans)); ans[S][0]=0; ten[5]=1; for(int i=4;i&gt;=0;i--)ten[i]=ten[i+1]*10;&#125;void solve()&#123; vis[S][0]=1,q1.push(S),q2.push(0); int h,pos,permu[10],Ans=INF,now,to; while(!q1.empty())&#123; h=q1.front(),q1.pop(),pos=q2.front(),q2.pop(); if(h==T)break; now=ans[h][pos],itop(permu,h); if(pos&amp;&amp;!vis[h][pos-1])//left vis[h][pos-1]=1,ans[h][pos-1]=now+1, q1.push(h),q2.push(pos-1); if(pos!=5&amp;&amp;!vis[h][pos+1])//right vis[h][pos+1]=1,ans[h][pos+1]=now+1, q1.push(h),q2.push(pos+1); if(permu[pos]!=9)&#123;//up to=h+ten[pos]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(permu[pos])&#123;//down to=h-ten[pos]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(pos&amp;&amp;permu[0]!=permu[pos])&#123; to=h-permu[0]*ten[0]-permu[pos]*ten[pos]+permu[0]*ten[pos]+permu[pos]*ten[0]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(pos!=5&amp;&amp;permu[5]!=permu[pos])&#123; to=h-permu[5]*ten[5]-permu[pos]*ten[pos]+permu[5]*ten[pos]+permu[pos]*ten[5]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; &#125; for(int i=0;i&lt;6;i++)Ans=min(Ans,ans[T][i]); printf("%d\n",Ans);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T1 炮兵阵地题目链接 标准的状压DP。 D2T2 方程的解数题目链接 meet in the middle。拆成两半，$O(M^3)$枚举+核对。用map会MLE，干脆hash。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define P 4000037using namespace std;typedef long long ll;int n,m;ll k[15],p[15],ppow[155][40]=&#123;0&#125;,half,ans=0;ll LIM=2147483647;int hsh[4000060],cnt[4000060];bool vis[4000060]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;k[i],&amp;p[i]); for(ll i=1;i&lt;=m;i++)&#123; ppow[i][0]=1; ll lim=1; for(int j=1;j&lt;=35;j++)&#123; lim*=i; if(lim&gt;=LIM)break; ppow[i][j]=ppow[i][j-1]*i; &#125; &#125;&#125;int locate(int val)&#123; int q=abs(val); for(q%=P;vis[q]&amp;&amp;hsh[q]!=val;q=(q==P-1)?0:q+1); return q;&#125;void build(int at,ll val)&#123; if(at&gt;half)&#123; int loc=locate((int)val); cnt[loc]++,hsh[loc]=(int)val,vis[loc]=1; return ; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!ppow[i][p[at]])break; ll lim=val+ppow[i][p[at]]*k[at]; if(lim&gt;=LIM||lim&lt;=-LIM)break;//爆了 build(at+1,lim); &#125;&#125;void Search(int at,ll val)&#123; if(at==n+1)&#123; int _val=(int)(-val); int loc=locate(_val); if(hsh[loc]==_val)ans+=cnt[loc]; return ; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!ppow[i][p[at]])break; ll lim=val+ppow[i][p[at]]*k[at]; if(lim&gt;=LIM||lim&lt;=-LIM)break;//爆了 Search(at+1,lim); &#125;&#125;void solve()&#123; half=n/2; build(1,0); Search(half+1,0); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T3 陨石的秘密题目链接可以发现SS表达式的定义是递归形式的，而且SS表达式形成了一个树形结构（有深度，还有儿子）。设$f(i,j,k,d)$为$i$对大括号，$j$对中括号，$k$对小括号，树深度$&lt;=d$的方案总数。对于同一层而言，决策有： 分出一支，深度变大。 同一层上增加。对于第一种情况，我们再加一个状态：设$g(i,j,k,d)$为$i$对大括号，$j$对中括号，$k$对小括号，树深度$\le d$，且表达式构成一棵树的方案总数。他从$f$转移而来，决策是给$f$加一个根。这样就可以转移了。初始：$f(0,0,0,0…D)=1$。答案：f(L_1,L_2,L_3,D)-f(L_1,L_2,L_3,D-1)（相当于容斥）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define Mod 11380using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int l1,l2,l3,D,f[11][11][11][31]=&#123;0&#125;,g[11][11][11][31]=&#123;0&#125;;char vis1[11][11][11][31]=&#123;0&#125;,vis2[11][11][11][31]=&#123;0&#125;;int dp_g(int a,int b,int c,int d);int dp_f(int a,int b,int c,int d);int dp_g(int a,int b,int c,int d)&#123; if(vis2[a][b][c][d])return g[a][b][c][d]; int t=0; if(!a&amp;&amp;!b&amp;&amp;c&gt;=1)(t+=dp_f(a,b,c-1,d-1))%=Mod; if(!a&amp;&amp;b&gt;=1)(t+=dp_f(a,b-1,c,d-1))%=Mod; if(a&gt;=1)(t+=dp_f(a-1,b,c,d-1))%=Mod; vis2[a][b][c][d]=1; return (g[a][b][c][d]=t);&#125;int dp_f(int a,int b,int c,int d)&#123; if(vis1[a][b][c][d])return f[a][b][c][d]; int t=0; for(int i=0;i&lt;=a;i++) for(int j=0;j&lt;=b;j++) for(int k=0;k&lt;=c;k++) if(i||j||k)(t+=dp_g(i,j,k,d)*dp_f(a-i,b-j,c-k,d))%=Mod; vis1[a][b][c][d]=1; return (f[a][b][c][d]=t);&#125;void init()&#123; l1=read(),l2=read(),l3=read(),D=read(); for(int i=0;i&lt;=D;i++) vis1[0][0][0][i]=1,f[0][0][0][i]=1, vis2[0][0][0][i]=1,g[0][0][0][i]=0;&#125;void solve()&#123; printf("%d\n",(dp_f(l1,l2,l3,D)-dp_f(l1,l2,l3,D-1)+Mod)%Mod);&#125;int main()&#123; init(); solve(); return 0;&#125; NOI2002D1T2 调皮的小孩（题目暂缺） 显然你最多只能问一个人$2$遍。显然你问裁判同样问题$2$次他就会自爆。那就分类讨论。先随便找个人，然后对其他人问他是不是0队的。 $N$个人Yes$M$个No，那么这个人就有可能是0队的。（1）$N\neq M$，他就是0队的。（2）$N=M$，让他问1队的任意一个人是不是1队的$2$次，答案一样这个人就是0队的，反之就是裁判。 $N+1$个人No$M-1$个人Yes，那么这个人是1队的，去另外$N+1$个人问他是不是1队的即可。 $N$个人No$M$个人Yes，$N\neq M$他就是裁判，$N=M$就套用1的解决方法。]]></content>
      <categories>
        <category>NOI题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>其他DP</tag>
        <tag>递推</tag>
        <tag>枚举</tag>
        <tag>模拟</tag>
        <tag>并查集</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2440 完全平方数]]></title>
    <url>%2F2018%2F08%2F25%2Fbzoj2440%2F</url>
    <content type="text"><![CDATA[题目链接 题解我觉得这题比较简单= =对于这种难以直接求解的问题一般采用二分解决。先二分一个答案$x$，然后看$[1,x]$间有多少个这样的数。直接算算不出，由于是完全平方数，考虑补集转化，求是完全平方数倍数的个数。有重叠，考虑容斥。答案就是$n-$只有一个质因子的平方数倍数个数$+$有$2$个质因子的$-$有$3$个质因子的…但是质因子太多，会TLE。我们知道容斥和莫比乌斯函数有关，所以利用莫比乌斯函数优化。这样答案就是 \sum_{i = 1}^{\sqrt{x}}\mu(i)\times \lfloor \frac{x}{i^2}\rfloor二分范围？观察样例，猜测不会超过2k_i。。。话说这个题 二分有点奇怪 改了一下改成这样才能过？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int mu[100005];int prime[100005],tot=0,n,k;bool vis[100005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int judge(int x)&#123; int res=0,l=(int)sqrt(x); for(int i=1;i*i&lt;=x;i++)&#123; res+=mu[i]*(x/(i*i)); &#125; return res;&#125;void init()&#123; mu[1]=1,vis[1]=1; for(int i=2;i&lt;=100000;i++)&#123; if(!vis[i]) mu[i]=-1,prime[tot++]=i; for(int j=0;j&lt;tot;j++)&#123; ll t=i;t*=(ll)prime[j]; if(t&gt;100000)break; vis[i*prime[j]]=1,mu[i*prime[j]]=-mu[i]; if(i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; &#125; &#125;&#125;void solve()&#123; n=read(); while(n--)&#123; k=read(); int L=1,R=2*k,M; while(R-L)&#123; M=L+(R-L)/2; if(judge(M)&gt;=k)R=M; else L=M+1; &#125; printf("%d\n",L); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3614]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fpoj3614%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 506 (Div. 3) 题解]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fcontest-cf1029%2F</url>
    <content type="text"><![CDATA[A题目链接 观察样例可以发现，只要找到最长的和后缀相同的前缀，然后重复该前缀$k$次，再输出剩下的即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, k;char s[105];void init()&#123; n = read(), k = read(); scanf("%s", s);&#125;void solve()&#123; int st; for(st = 1; st &lt; n; st++)&#123; int flag = 1; for(int j = 0; j &lt; n - st; ++j) if(s[st + j] != s[j])&#123; flag = 0; break; &#125; if(flag) break; &#125; if(st == n)&#123; for(int i = 0; i &lt; k; ++i) printf("%s", s); &#125;else&#123; for(int i = 0; i &lt; k; ++i) for(int j = 0; j &lt; st; ++j) putchar(s[j]); for(int i = st; i &lt; n; ++i) putchar(s[i]); &#125; printf("\n");&#125;int main()&#123; init(); solve(); return 0;&#125; B题目链接 C题目链接]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4317]]></title>
    <url>%2F2018%2F08%2F24%2Fwriting%2Fluogu4317%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 438D The Child and Sequence]]></title>
    <url>%2F2018%2F08%2F24%2Fcf438d%2F</url>
    <content type="text"><![CDATA[题目链接 题解第一次写这种靠数学分析来找特定规律的题目…观察区间取模的问题，我们可以发现一个数最多会被取模log_2 n次。（因为一次取模至少会缩小一半，和启发式合并相似）所以没什么顾虑，暴力做就是了。操作一用lazytag解决，操作二的话维护区间内最大值及其下标，每次暴力找最大的，如果大于模数就单点修改。操作三就是单点修改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll seg[400005]=&#123;0&#125;,tag[400005]=&#123;0&#125;,_v,sum[400005],loc[400005];int _a,_b,m,n,siz;pair&lt;int,ll&gt; Nulll;void maintain(int id)&#123; if(seg[id&lt;&lt;1]&gt;seg[id&lt;&lt;1|1]) seg[id]=seg[id&lt;&lt;1],loc[id]=loc[id&lt;&lt;1]; else seg[id]=seg[id&lt;&lt;1|1],loc[id]=loc[id&lt;&lt;1|1]; sum[id]=sum[id&lt;&lt;1]+sum[id&lt;&lt;1|1];&#125;void build_seg()&#123; for(siz=1;siz&lt;n;siz&lt;&lt;=1); int i; for(i=siz;i&lt;siz+n;i++) scanf("%lld",&amp;seg[i]), tag[i]=0,sum[i]=seg[i],loc[i]=i-siz+1; //seg最大值，sum和，tag标记，loc最大值位置 for(;i&lt;(siz&lt;&lt;1);i++) seg[i]=sum[i]=tag[i]=loc[i]=0; for(i=siz-1;i&gt;=1;i--) maintain(i);&#125;void pushdown(int id,ll len)&#123; if(!tag[id])return ; seg[id&lt;&lt;1]+=tag[id],seg[id&lt;&lt;1|1]+=tag[id]; tag[id&lt;&lt;1]+=tag[id],tag[id&lt;&lt;1|1]+=tag[id]; sum[id&lt;&lt;1]+=tag[id]*(len&gt;&gt;1),sum[id&lt;&lt;1|1]+=tag[id]*(len&gt;&gt;1); tag[id]=0;&#125;void update(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(l&gt;=_a&amp;&amp;r&lt;=_b)&#123; seg[id]+=_v,tag[id]+=_v,sum[id]+=(r-l+1)*_v; return ; &#125; pushdown(id,(ll)(r-l+1)); update(id&lt;&lt;1,l,(l+r)&gt;&gt;1); update(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); maintain(id);&#125;pair&lt;int,ll&gt; query_p(int id,int l,int r)&#123; //查询区间最大值 pair&lt;int,ll&gt; P,p1; P.first=P.second=-1; if(l&gt;_b||r&lt;_a)return Nulll; if(l&gt;=_a&amp;&amp;r&lt;=_b)&#123; P.first=loc[id],P.second=seg[id]; return P; &#125; pushdown(id,(ll)(r-l+1)); p1=query_p(id&lt;&lt;1,l,(l+r)&gt;&gt;1); if(p1.second&gt;P.second)P=p1; p1=query_p(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); if(p1.second&gt;P.second)P=p1; return P; &#125;ll query(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return 0; if(l&gt;=_a&amp;&amp;r&lt;=_b)return sum[id]; pushdown(id,(ll)(r-l+1)); return query(id&lt;&lt;1,l,(l+r)&gt;&gt;1)+query(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r);&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); build_seg(); Nulll.first=-1,Nulll.second=-1; &#125;void solve()&#123; for(int i=0;i&lt;m;i++)&#123; int typ,_c,_d; scanf("%d",&amp;typ); if(typ==1) scanf("%d%d",&amp;_a,&amp;_b), printf("%lld\n",query(1,1,siz)); else if(typ==2)&#123; scanf("%d%d%lld",&amp;_c,&amp;_d,&amp;_v); ll Mod=_v; pair&lt;int,ll&gt; P; for(;;)&#123; _a=_c,_b=_d; P=query_p(1,1,siz); if(P.second&lt;Mod)break; _a=_b=P.first,_v=P.second%Mod-P.second; update(1,1,siz); &#125; //for(int i=0;i&lt;5;i++) // _a=_b=i+1, // printf("%lld ",query(1,1,siz)); //printf("\n"); &#125;else&#123; scanf("%d%lld",&amp;_a,&amp;_v), _b=_a,_v-=query(1,1,siz),update(1,1,siz); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 670C Cinema]]></title>
    <url>%2F2018%2F08%2F24%2Fcf670c%2F</url>
    <content type="text"><![CDATA[题目链接 题解对于每一个影片分别统计一下看的很满意的人和比较满意的人数，维护答案即可。数据很大，需要离散化一下。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[200005], b[200005], c[200005];void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) a[i] = read(); m = read(); for(int i = 0; i &lt; m; ++i) b[i] = read(); for(int i = 0; i &lt; m; ++i) c[i] = read();&#125;void solve()&#123; sort(a, a + n); int max1 = 0, max2 = 0, ans = 1; for(int i = 0; i &lt; m; ++i)&#123; int r1 = upper_bound(a, a + n, b[i]) - lower_bound(a, a + n, b[i]); int r2 = upper_bound(a, a + n, c[i]) - lower_bound(a, a + n, c[i]); if(r1 &gt; max1) max1 = r1, max2 = r2, ans = i + 1; else if(r1 == max1 &amp;&amp; r2 &gt; max2) max2 = r2, ans = i + 1; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 405C Unusual Product]]></title>
    <url>%2F2018%2F08%2F24%2Fcf405c%2F</url>
    <content type="text"><![CDATA[题目链接 题解因为觉得这是一道出的很好的模拟题，所以拿过来了。上文中提到的flip操作其实就是取反。暴力做法是$O(nq)$的，挂。看数据，考虑有没有什么接近线性的做法：我们将整个结果展开。比如这么一个方阵： \begin{bmatrix} a_1 & b _1 & c_1 \\ a_2 & b_2 & c_2 \\ a_3 & b_3 & c_3 \end{bmatrix}他的unusual square 就是a_1^2 + b_2^2 + c_3^2 + 2(a_2b_1+a_3c_1+b_3c_2)由于是在模$2$的环境下进行，这个式子后半部分都是没有用的东西。所以只要时时刻刻维护前面平方项的和即可。然而…每一次操作都必然改变一项且仅改变一个平方项，使之从0变1或从1变0.所以做法就是 读入时不保留矩阵，只算平方项 更新时只要知道它更新了即可，然后把平方和异或1。这个算法的复杂度就是$O(n^2+q)-O(1)$的。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,sum=0,lg[1005],q,jc;//保留对角线只是我无聊...int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;((i==j)?lg[i]:jc)); for(int i=0;i&lt;n;i++) sum^=lg[i];&#125;void solve()&#123; scanf("%d",&amp;q); int op; for(int i=0;i&lt;q;i++)&#123; scanf("%d",&amp;op); if(op==3)printf("%d",sum); else scanf("%d",&amp;jc),sum^=1; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 813C The Tag Game]]></title>
    <url>%2F2018%2F08%2F24%2Fcf813c%2F</url>
    <content type="text"><![CDATA[题目链接 题解显然这是一个追逐的局面。Alice的棋追着Bob的跑。要保证时间拖得最长，就必须使得Bob逃离的越远。算出AB两个棋子到这棵树上每一个其他点的时间t_A和t_B，然后dfs，看B棋子能到达哪一个点使得t_A>t_B且t_A最大。答案就是最大的这个2t_A。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,x,at[200005],to[400005],_next[400005],cnt=0;int ldis[200005]=&#123;0&#125;,rdis[200005]=&#123;0&#125;,ans=0;bool vis[200005]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;x); int u,v; memset(at,-1,sizeof(at)); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v); u--,v--; to[cnt]=v,_next[cnt]=at[u],at[u]=cnt++; to[cnt]=u,_next[cnt]=at[v],at[v]=cnt++; &#125;&#125;void dfs(int cur,int *dis)&#123; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]]) vis[to[i]]=1, dis[to[i]]=dis[cur]+1, dfs(to[i],dis); &#125;&#125;void dfs2(int cur)&#123; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]]&amp;&amp;ldis[to[i]]&gt;rdis[to[i]]) vis[to[i]]=1,dfs2(to[i]); &#125; ans=max(ans,ldis[cur]);&#125;void solve()&#123; vis[0]=1,dfs(0,ldis); memset(vis,0,sizeof(vis)); vis[x-1]=1,dfs(x-1,rdis); memset(vis,0,sizeof(vis)); dfs2(x-1); printf("%d\n",ans*2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 二分法和三分法]]></title>
    <url>%2F2018%2F08%2F24%2Fwriting%2Ftemplate-bi-or-trinary%2F</url>
    <content type="text"><![CDATA[简单的算法有时候也要仔细考量。 二分整数域上的二分二分很好写，但总是有一些坑，容易写的TLE或者是要额外判断。我个人推荐（也是某本书上给出的）的一种写法是：版本A:12345while (r - l)&#123; int mid = (r + l + 1) &gt;&gt; 1; if(judge(mid)) l = mid; else r = mid - 1;&#125; 版本B:12345while (r - l)&#123; int mid = (r + l) &gt;&gt; 1; if(judge(mid)) r = mid; else l = mid + 1;&#125; 这种写法的好处是最后$l$和$r$会回到一个数上面去，就不用担心后续特判的操作。两种版本都是正确的，只是使用的对象不一样。考虑好可行域的划分问题即可。（一般我都是用$[4,5]$这个区间当例子来考虑的）还有一点就是：这两个版本的二分对于负数域也是行得通的。因为一般右移都是算术右移，实现的是向下取整，所以可以正常工作。（不妨考虑$[-3,-2]$）从代码也可以看出版本A更接近左边，版本B更接近右边。 实数域上的二分比起整数域上的二分，实数域由于没有向哪里取整的问题，所以更加容易实现。只需要用一个$eps$判断是否足够接近即可。12345while (r - l &gt; eps)&#123; double mid = (r + l) / 2; if(judge(mid)) r = mid; else l = mid;&#125; 或者可以迭代一定次数，获得一个相对更高的精度。12345for(int i = 0; i &lt; 100; ++i)&#123; double mid = (r + l) / 2; if(judge(mid)) r = mid; else l = mid;&#125; STLlower_bound和upper_bound已经是广为人知了。 参考资料 《算法竞赛进阶指南》]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Tallest Cow]]></title>
    <url>%2F2018%2F08%2F24%2Fluogu2879%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果不存在任何大小关系，不妨认为所有牛的高度都达到了最高。存在大小关系，就不妨一步一步满足。由于最小的单位是1，就让两个牛之间的高度相对两边少1，这样就在满足尽量高的前提下满足了限制条件。这一步可以用区间减法或者差分实现。需要注意的是可能两个牛的关系会重复出现，此时需要去重。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, id, h, m, hi[10005] = &#123;0&#125;;pair&lt;int, int&gt; p[10005];void init()&#123; n = read(), id = read(), h = read(), m = read(); for(int i = 0; i &lt; m; ++i)&#123; p[i].first = read(), p[i].second = read(); if(p[i].first &gt; p[i].second) swap(p[i].first, p[i].second); &#125; sort(p, p + m); m = unique(p, p + m) - p;&#125;void solve()&#123; for(int i = 0; i &lt; m; ++i)&#123; int l = p[i].first, r = p[i].second; hi[l + 1]--, hi[r]++; &#125; int sum = 0; for(int i = 1; i &lt;= n; ++i) sum += hi[i], printf("%d\n", h + sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1458 Sumdiv]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj1845%2F</url>
    <content type="text"><![CDATA[题目地址 题解分治法求解等比数列和的一个运用。每次把数列分成两半，就可以做到$O(logn)$了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int a, b, sum = 1;int poww(int d, int e)&#123; int res = 1; while(e)&#123; if(e &amp; 1) res = (res * d) % 9901; d = (d * d) % 9901; e &gt;&gt;= 1; &#125; return res;&#125;int f(int p, int c)&#123; if(c == 0) return 1; if(c == 1) return (1 + p) % 9901; if(c &amp; 1) return f(p, c &gt;&gt; 1) * (1 + poww(p, (c + 1) &gt;&gt; 1)) % 9901; else return ((f(p, c &gt;&gt; 1) + 9900) * (1 + poww(p, c &gt;&gt; 1)) + 1) % 9901;&#125;void init()&#123; a = read(), b = read();&#125;void solve()&#123; int t = a; for(int i = 2; i * i &lt;= a; ++i)&#123; if(t % i == 0)&#123; int cc = 0; do&#123; t /= i, cc++; &#125;while(t % i == 0); sum = sum * f(i % 9901, cc * b) % 9901; &#125; if(t == 1) break; &#125; if(t != 1) sum = sum * f(t % 9901, b) % 9901; printf("%d\n", sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2018 Best Cow Fences]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj2018%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题精度高的一批…总之想到直接求解比较困难，联想到这样平均值的题目一般要用上二分，所以二分一个最大平均值，然后根据判定条件来就行了。 C(S):\exists l, r ,r - l \ge F,sum[r]-rS\ge sum[l] - lS12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, L, a[100005], sum[100005], maxi = 0;void init()&#123; n = read(), L = read(); sum[0] = 0; for(int i = 1; i &lt;= n; ++i) a[i] = read(), maxi = max(maxi, a[i]), sum[i] = sum[i - 1] + a[i];&#125;bool judge(double x)&#123; double mini = 0; for(int i = L; i &lt;= n; ++i)&#123; double cur = 1.0 * sum[i] - i * x; if(cur &gt; mini || abs(cur - mini) &lt; 1e-5) return true; mini = min(mini, 1.0 * sum[i + 1 - L] - (i + 1 - L) * x); &#125; return false;&#125;void solve()&#123; double l = 1.0 * sum[n] / n, r = 1.0 * maxi; for(int i = 0; i &lt; 60; ++i)&#123; double mid = (l + r) / 2; if(judge(mid)) l = mid; else r = mid; &#125; printf("%d\n", (int)(1000 * l));&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1958 Strange Towers of Hanoi]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj1958%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$f(i)$为$i$个盘子时候的情况，那么当把$j$个盘子移到另一个柱子上，然后将剩下的用3根柱子汉诺塔形式移动，再将$j$个移回去时，就可以推导出$f(i)$的表达式： f(i) = \min \limits_{1 \le j < i}\left\{2 f(j) + d(i - j) \right\}其中$d(i)$为3根柱子汉诺塔中有$i$个盘子的步数。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll d[15], f[15] = &#123;0&#125;;void init()&#123; d[1] = 1, f[1] = 1; for(int i = 2; i &lt;= 12; ++i) d[i] = d[i - 1] &lt;&lt; 1 | 1;&#125;void solve()&#123; printf("1\n"); for(int i = 2; i &lt;= 12; ++i)&#123; f[i] = INF; for(int j = 1; j &lt; i; ++j) f[i] = min(f[i], (f[j] &lt;&lt; 1) + d[i - j]); printf("%lld\n", f[i]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2893 M × N Puzzle]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj2893%2F</url>
    <content type="text"><![CDATA[题目地址 题解将这个拼图展开，可以发现：0左右移动不改变序列的逆序对数，上下移动改变的逆序对数和列数的奇偶性相反。因此当列数是奇数时可以直接根据原序列逆序对数是不是偶数判断，列数是偶数时由于0上下移动引起对数的变化的奇偶性只和它始态行和终态行之间的距离有关，因此只需判断原序列逆序对数和这个距离的奇偶性是否相同即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[1000005], b[1000005], dis;ll ans;void init()&#123; int cnt = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j)&#123; a[cnt++] = read(); if(a[cnt - 1] == 0) cnt--, dis = n - 1 - i; &#125;&#125;void Merge(int ls, int rs, int re)&#123; int lp = ls, rp = rs, tp = ls; while(lp &lt; rs &amp;&amp; rp &lt; re)&#123; if(a[lp] &lt;= a[rp]) b[tp++] = a[lp++]; else b[tp++] = a[rp++], ans += 1ll * (rs - lp); &#125; while(lp &lt; rs) b[tp++] = a[lp++]; while(rp &lt; re) b[tp++] = a[rp++]; memcpy(a + ls, b + ls, sizeof(int) * (re - ls));&#125;void ms(int l, int r)&#123; int len = r - l, mid = (r + l) &gt;&gt; 1; if(len == 1) return ; ms(l, mid), ms(mid, r); Merge(l, mid, r);&#125;void solve()&#123; ans = 0; ms(0, n * m - 1); if(m &amp; 1) printf("%s\n", (ans % 2) ? "NO" : "YES"); else printf("%s\n", (ans % 2 == dis % 2) ? "YES" : "NO");&#125;int main()&#123; while(n = read(), m = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1995 Raising Modulo Numbers]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj1995%2F</url>
    <content type="text"><![CDATA[题目地址 题解快速幂。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int poww(int a, int b, int m)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (res * a) % m; a = (a * a) % m; b &gt;&gt;= 1; &#125; return res;&#125;int m, h, dd[45005], ex[45005];void init()&#123; m = read(), h = read(); for(int i = 0; i &lt; h; ++i) dd[i] = read(), ex[i] = read();&#125;void solve()&#123; int sum = 0; for(int i = 0; i &lt; h; ++i) sum = (sum + poww(dd[i] % m, ex[i], m)) % m; printf("%d\n", sum);&#125;int main()&#123; int T = read(); while(T--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3784 Running Median]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj3784%2F</url>
    <content type="text"><![CDATA[题目地址 题解对顶堆技巧。就是把序列拆成两个部分，使得要维护的特定的数恰好处于被堆分割的部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq1;priority_queue&lt;int&gt; pq2;int n;void init()&#123; int snum = read(); n = read(); printf("%d %d\n", snum, (n + 1) &gt;&gt; 1);&#125;void solve()&#123; if(n == 1)&#123; printf("%d", read()); return ; &#125; int hd = read(), cnt = 2; printf("%d ", hd); pq2.push(hd); for(int i = 2; i &lt;= n; ++i)&#123; hd = read(); if(hd &lt;= pq2.top()) pq2.push(hd); else pq1.push(hd); if(i &amp; 1)&#123; while(pq2.size() &gt; pq1.size() + 1) pq1.push(pq2.top()), pq2.pop(); while(pq2.size() &lt; pq1.size() + 1) pq2.push(pq1.top()), pq1.pop(); printf("%d", pq2.top()); if(cnt == 10 &amp;&amp; i != n) cnt = 0, printf("\n"); else if(i != n) printf(" "); cnt++; &#125; &#125; while(!pq1.empty()) pq1.pop(); while(!pq2.empty()) pq2.pop();&#125;int main()&#123; int T = read(); for(int i = 1; i &lt;= T; ++i)&#123; init(); solve(); if(i != T) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2299 Ultra-QuickSort]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[题目地址 题解逆序对。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[500005], b[500005];ll ans;void init()&#123; for(int i = 0; i &lt; n; ++i) a[i] = read();&#125;void Merge(int ls, int rs, int re)&#123; int lp = ls, rp = rs, tp = ls; while(lp &lt; rs &amp;&amp; rp &lt; re)&#123; if(a[lp] &lt;= a[rp]) b[tp++] = a[lp++]; else b[tp++] = a[rp++], ans += 1ll * (rs - lp); &#125; while(lp &lt; rs) b[tp++] = a[lp++]; while(rp &lt; re) b[tp++] = a[rp++]; memcpy(a + ls, b + ls, sizeof(int) * (re - ls));&#125;void ms(int l, int r)&#123; int len = r - l, mid = (r + l) &gt;&gt; 1; if(len == 1) return ; ms(l, mid), ms(mid, r); Merge(l, mid, r);&#125;void solve()&#123; ans = 0; ms(0, n); printf("%lld\n", ans);&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3468 A Simple Problem with Integers]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[题目地址 题解线段树水题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long ll;ll sum[400005],add[400005]=&#123;0&#125;,mul[400005]=&#123;0&#125;,_v;int n,size,_a,_b,m;void pushdown(int id,int len)&#123; if(id&gt;=size||!add[id])return ; sum[id&lt;&lt;1]+=add[id]*(ll)(len&gt;&gt;1); sum[id&lt;&lt;1|1]+=add[id]*(ll)(len&gt;&gt;1); add[id&lt;&lt;1]+=add[id]; add[id&lt;&lt;1|1]+=add[id]; add[id]=0;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); int i; for(size=1;size&lt;n;size&lt;&lt;=1); for(i=size;i-size&lt;n;i++) scanf("%lld",&amp;sum[i]); for(;i&lt;(size&lt;&lt;1);i++)sum[i]=0; for(i=size-1;i&gt;=1;i--) sum[i]=sum[i&lt;&lt;1]+sum[i&lt;&lt;1|1];&#125;void update(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(_a&lt;=l&amp;&amp;r&lt;=_b)&#123; sum[id]+=_v*(ll)(r-l+1),add[id]+=_v; return ; &#125; pushdown(id,r-l+1); update(id&lt;&lt;1,l,(l+r)&gt;&gt;1); update(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); sum[id]=sum[id&lt;&lt;1]+sum[id&lt;&lt;1|1];&#125;ll query(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return 0ll; if(_a&lt;=l&amp;&amp;r&lt;=_b)return sum[id]; pushdown(id,r-l+1); return query(id&lt;&lt;1,l,(l+r)&gt;&gt;1)+query(id&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;void solve()&#123; int i,j,o,u,v; char ord[3]; for(i=0;i&lt;m;i++)&#123; scanf("%s%d%d",ord,&amp;_a,&amp;_b); if(ord[0]=='C') scanf("%lld",&amp;_v), update(1,1,size); else printf("%lld\n",query(1,1,size)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第九章]]></title>
    <url>%2F2018%2F08%2F23%2Faoapc-chapter9%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第九章部分习题的整合。 例9-1 UVa1025 A Spy in the Metro题目链接 每一个时刻都有3个决策：在当前车站等一下，从向左开的车上下车，从向右开的车上下车。由于“坐在车上”这个状态不好表示，因此相应的替换为后两个状态。由于要表示当前时刻和当前车站，因此用$dp(i, j)$表示当前在$i$时刻，$j$车站，最少的在车站的时间。这样的话整个dp的时间复杂度为$O(nT)$。注意越界！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, T, m1, m2;int dp[255][55], t[55];bool has[255][55][2];void init()&#123; T = read(); t[0] = t[n] = 0; for(int i = 1; i &lt; n; ++i) t[i] = read(); memset(has, 0, sizeof(has)); m1 = read(); for(int i = 0; i &lt; m1; ++i) &#123; int tt = read(); for(int j = 1; j &lt;= n; ++j)&#123; if(tt &gt; T) break; has[tt][j][0] = 1, tt += t[j]; &#125; &#125; m2 = read(); for(int i = 0; i &lt; m2; ++i) &#123; int tt = read(); for(int j = n; j &gt;= 1; --j)&#123; if(tt &gt; T) break; has[tt][j][1] = 1, tt += t[j - 1]; &#125; &#125;&#125;void solve()&#123; memset(dp, 0x3f, sizeof(dp)); dp[0][1] = 0; for(int i = 1; i &lt;= T; ++i) for(int j = 1; j &lt;= n; ++j)&#123; int&amp; d = dp[i][j]; d = dp[i - 1][j] + 1; if(j &gt; 1 &amp;&amp; has[i][j][0] &amp;&amp; i &gt;= t[j - 1]) d = min(d, dp[i - t[j - 1]][j - 1]); if(j &lt; n &amp;&amp; has[i][j][1] &amp;&amp; i &gt;= t[j]) d = min(d, dp[i - t[j]][j + 1]); &#125; if(dp[T][n] &gt; T) printf("impossible\n"); else printf("%d\n", dp[T][n]);&#125;int main()&#123; int kase = 1; while(n = read())&#123; printf("Case Number %d: ", kase++); init(); solve(); &#125; return 0;&#125; 例9-2 UVa437 The Tower of Babylon题目链接 一个扩展性的矩阵嵌套问题？我设计的状态是$dp(i, j, id)$表示塔的第$i$块砖为第$j$个方块，并且高的编号为$id$时塔的最高高度。这样由于每一次转移只需要枚举之前一次放上去的方块，就可以判断是否合法。由于至多需要$2n$层，每一层的决策数都为$O(n)$，故总的时间复杂度为$O(n^2)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int dp[63][33][3], n, ord[33][3];void init()&#123; int x[3]; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; 3; ++j) x[j] = read(); sort(x, x + 3); for(int j = 0; j &lt; 3; ++j) ord[i][j] = x[2 - j]; &#125;&#125;void solve()&#123; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; 3; ++j) dp[1][i][j] = ord[i][j]; int ans = 0; for(int i = 2; ; ++i)&#123; int flag = 0; for(int j = 0; j &lt; n; ++j) for(int k = 0; k &lt; 3; ++k)&#123; int &amp;d = dp[i][j][k]; int a, b; if(k == 0) a = ord[j][1], b = ord[j][2]; if(k == 1) a = ord[j][0], b = ord[j][2]; if(k == 2) a = ord[j][0], b = ord[j][1]; for(int jj = 0; jj &lt; n; ++jj) for(int kk = 0; kk &lt; 3; ++kk)&#123; if(!dp[i - 1][jj][kk]) continue; int aa, bb; if(kk == 0) aa = ord[jj][1], bb = ord[jj][2]; if(kk == 1) aa = ord[jj][0], bb = ord[jj][2]; if(kk == 2) aa = ord[jj][0], bb = ord[jj][1]; if(aa &gt; a &amp;&amp; bb &gt; b) d = max(d, dp[i - 1][jj][kk] + ord[j][k]), ans = max(ans, d), flag = 1; &#125; &#125; if(!flag) break; &#125; printf("%d\n", ans);&#125;int main()&#123; int kase = 1; while(n = read())&#123; printf("Case %d: maximum height = ", kase++); init(); solve(); &#125; return 0;&#125; 例9-5 UVa12563 Jin Ge Jin Qu hao题目链接 先对前$t-1$秒跑一个背包，然后再检查一下最多的方案和对应的时间，并且加上劲歌金曲即可。原因是因为劲歌金曲唱了一定比不唱好，所以$t$要减掉一。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, t, len[55], dp[10005];void init()&#123; n = read(), t = read(); for(int i = 0; i &lt; n; ++i) len[i] = read();&#125;void solve()&#123; memset(dp, -1, sizeof(dp)); dp[0] = 0; t--; for(int i = 0; i &lt; n; ++i) for(int j = t; j &gt;= len[i]; --j) if(dp[j - len[i]] &gt;= 0) dp[j] = max(dp[j], dp[j - len[i]] + 1); int ans = -1, maxi; for(int i = t; i &gt;= 0; --i) if(dp[i] &gt; ans) ans = dp[i], maxi = i; printf("%d %d\n", ans + 1, maxi + 678);&#125;int main()&#123; int T = read(); for(int i = 1; i &lt;= T; ++i)&#123; printf("Case %d: ", i); init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第八章]]></title>
    <url>%2F2018%2F08%2F23%2Faoapc-chapter8%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第八章部分习题的整合。 例8-1 UVa120 Stacks of Flapjacks题目链接 显然，直接把对应的数放到它应该在的地方的排序方式是最快的。所以可以先对整个序列排一个序，然后从底向上判断某个位置上的数是否是排序后对应的数，不是的话就先把该数翻到最顶上，然后再翻到对应位置。这么做就是最快的排序方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[10005];int st[10005], n, p[10005], cur;int read()&#123; int x = 0; char c = s[cur]; while(c &lt; '0' || c &gt; '9')&#123; if(c == '\n' || c == EOF) return 0; c = s[++cur]; &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = s[++cur]; return x; &#125;void init()&#123; cur = n = 0; while(st[n] = read()) p[n] = st[n], n++; sort(p, p + n);&#125;void solve()&#123; for(int i = 0; i &lt; n - 1; ++i) printf("%d ", st[i]); printf("%d\n", st[n - 1]); for(int i = n - 1; i &gt; 0; --i)&#123; if(p[i] == st[i]) continue; int j; for(j = i - 1; st[j] != p[i]; --j) ; if(j) reverse(st, st + j + 1), printf("%d ", n - j); reverse(st, st + i + 1), printf("%d ", n - i); &#125; printf("0\n");&#125;int main()&#123; while(fgets(s, 10000, stdin) != NULL)&#123; init(); solve(); &#125; return 0;&#125; 例8-3 UVa1152 4 Values whose Sum is 0题目链接 这题神烦，哈希表几乎不可能过得了。所以还是直接排序后二分比较快。即所谓中途相遇法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[4005], b[4005], c[4005], d[4005];int q[16000005];ll ans;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) a[i] = read(), b[i] = read(), c[i] = -read(), d[i] = -read(); int cnt = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) q[cnt++] = c[i] + d[j]; sort(q, q + cnt);&#125;void solve()&#123; ans = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) ans += upper_bound(q, q + n * n, a[i] + b[j]) - lower_bound(q, q + n * n, a[i] + b[j]); printf("%lld\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); if(T &gt; 0) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001-2005 题解]]></title>
    <url>%2F2018%2F08%2F23%2Fnoip2001-2005%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2001-2005题目的题解。 NOIP2001普及T1 数的计算题目地址 \mathcal dp\left(i\right) = 1+ \sum_{j=1}^{\lfloor i/2\rfloor} dp\left(j\right) (i>1) \\ dp\left(1\right) = 11234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;typedef long long ll;int dp[1005]=&#123;0&#125;,n;int main()&#123; dp[2]=2,dp[1]=1; scanf("%d",&amp;n); int i,j; for(i=3;i&lt;=n;i++)&#123; for(j=i/2;j&gt;=1;j--) dp[i]+=dp[j]; dp[i]++; &#125; printf("%d\n",dp[n]); return 0;&#125; 普及T2 最大公约数与最小公倍数问题题目地址 我们知道$\mathcal x_0$必须是$\mathcal y_0$的约数。所以记$\mathcal t=\frac{y_0}{x_0}$，则$\mathcal 2^u$（$\mathcal u$为$\mathcal t$不同质因子的个数）即为答案。（集合划分）很巧妙的数学方法。爆搜会TLE来着。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int isP(int a)&#123;for(int i=2;i*i&lt;=a;i++)if(a%i==0)return 0;return 1;&#125;int main()&#123; int x0,y0,i,ans=1; scanf("%d%d",&amp;x0,&amp;y0); if(y0%x0)&#123;printf("0\n");return 0;&#125; for(i=2,y0/=x0;i&lt;=y0;i++) if(y0%i==0&amp;&amp;isP(i))ans&lt;&lt;=1; printf("%d\n",ans); return 0;&#125; 普及T3 求先序排列题目链接 由后序得根，然后中序的两半继续分治。递归建立一颗树。具体过程是，在中序中找到根，然后由于左右子树分别在其左右，故可以再为左右子树建树。如果到了树为空的情况就返回。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s1[30], s2[30];int root, lc[250], rc[250];int get(int il, int ir, int pl, int pr)&#123; if(ir - il &lt; 0) return 0; int id = s2[pr], i; for(i = il; i &lt;= ir; ++i) if(s1[i] == id) break; int len = i - il; lc[id] = get(il, i - 1, pl, pl + len - 1); rc[id] = get(i + 1, ir, pl + len, pr - 1); return id;&#125;void getP(int id)&#123; printf("%c", id); if(lc[id]) getP(lc[id]); if(rc[id]) getP(rc[id]);&#125;void solve()&#123; int len = strlen(s1); root = get(0, len - 1, 0, len - 1); getP(root);&#125;int main()&#123; scanf("%s%s", s1, s2); solve(); return 0;&#125; 普及T4 装箱问题题目地址 一个简单的背包问题。不过稍微要做一些处理，只要考虑状态的合法性即可。初始合法的状态就是箱子为空，随后按照01背包扩展到其他状态。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int V, n, f[20005] = &#123;0&#125;, v[35];void init()&#123; V = read(), n = read(); for(int i = 0; i &lt; n; ++i) v[i] = read();&#125;void solve()&#123; f[0] = 1; for(int i = 0; i &lt; n; ++i) for(int j = V; j &gt;= v[i]; --j) f[j] |= f[j - v[i]]; int ans; for(ans = V; !f[ans]; --ans) ; printf("%d\n", V - ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 一元三次方程求解题目地址 有4种方法： 暴力，按$0.01$步长枚举 二分，按照单调性求解 数学公式 导数 这里用的是二分，感觉还不错。1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef double D;D a,b,c,d,t1,t2,epi=0.01;D get(D k)&#123; return k*a*k*k+b*k*k+c*k+d;&#125;D C(int ll,int rr)&#123; D tmp,mid,l=(D)ll,r=(D)rr; int i=(get(l)&gt;get(r))?1:0; for(;;)&#123; mid=(l+r)/2.0; tmp=get(mid); if(r-l&lt;epi&amp;&amp;r-l&gt;-epi)break; if(tmp&gt;0)&#123; if(i)l=mid; else r=mid; &#125;else&#123; if(i)r=mid; else l=mid; &#125; &#125; printf("%.2lf ",mid);&#125;int main()&#123; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); int i;for(i=-100;i&lt;=100;i++)&#123; t1=(D)i,t2=t1+0.99; t1=get(t1),t2=get(t2); if(t1*t2&lt;0)C(i,i+1); else if(t1&lt;epi&amp;&amp;t1&gt;-epi)printf("%.2lf ",(D)i); &#125; return 0; &#125; 提高T2 数的划分题目地址 一个经典的递推问题。 方法一我的方法是设$f(n, m, k)$为数$n$划分为$k$个小于或等于$m$的数的方法数。那么有 f(n, m, k) = f(n, m - 1, k) + f(n - m, m, k - 1)这么做是$O(n ^2 k)$的。1234567891011121314#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int f[205][7]=&#123;0&#125;,n,k;int main()&#123; f[0][0]=1; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) for(int p=1;p&lt;=n;p++) if(p-i&gt;=0)f[p][j]+=f[p-i][j-1]; printf("%d\n",f[n][k]); return 0;&#125; 方法二设$f(n, k)$为题意所求，那么： 划分里面有$1$，那么包含$f(n - 1, k - 1)$&gt; 划分里面没有$1$，那么给划分里面所有的数添上一个$1$，即包含$f(n - k, k)$。因此得到f(n, k) = f(n - 1, k - 1) + f(n - k, k)时间复杂度$O(nk)$。 提高T3 统计单词个数题目地址 提高T4 Car的旅行路线题目地址 非常简单的最短路，非常难的建图。出发地和到达地每个机场间道路权值设为0即可。建图就是暴力用勾股求矩形顶点。在下面的代码中，我将顶点拆成了4个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#define rep(e) for(e=0;e&lt;4;e++)using namespace std;typedef double db;int T,s,t,A,B,rec[405][2],pr[105],vis[405];db ds[405][405],d[405][405],l[405];db dis(int a,int b)&#123; return (rec[a][0]-rec[b][0])*(rec[a][0]-rec[b][0])+ (rec[a][1]-rec[b][1])*(rec[a][1]-rec[b][1]);&#125;bool eq(db a,db b)&#123;return a-b&gt;(-1e-6)&amp;&amp;a-b&lt;(1e-6);&#125;void make(int i)&#123; db q1=dis(i,i+2),q2=dis(i,i+1),q3=dis(i+1,i+2); if(eq(q1+q2,q3))rec[i+3][0]=rec[i+2][0]+rec[i+1][0]-rec[i][0], rec[i+3][1]=rec[i+2][1]+rec[i+1][1]-rec[i][1]; else if(eq(q2+q3,q1))rec[i+3][0]=rec[i+2][0]+rec[i][0]-rec[i+1][0], rec[i+3][1]=rec[i+2][1]+rec[i][1]-rec[i+1][1]; else if(eq(q1+q3,q2))rec[i+3][0]=rec[i+1][0]+rec[i][0]-rec[i+2][0], rec[i+3][1]=rec[i+1][1]+rec[i][1]-rec[i+2][1];&#125;void dijkstra()&#123; int at,i=A&lt;&lt;2,j;db lst; fill(l,l+s,1e10); fill(vis,vis+s,0); l[i]=l[i+1]=l[i+2]=l[i+3]=0.0; for(i=0;i&lt;s;i++)&#123; for(lst=1e10,j=0;j&lt;s;j++) if(!vis[j]&amp;&amp;l[j]&lt;lst)at=j,lst=l[j]; vis[at]=1; for(j=0;j&lt;s;j++) l[j]=min(l[at]+d[at][j],l[j]); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v;db price; while(T--)&#123; scanf("%d%d%d%d",&amp;s,&amp;t,&amp;A,&amp;B); A--,B--,s&lt;&lt;=2; for(i=0;i&lt;s;i+=4)&#123; scanf("%d%d%d%d%d%d%d",&amp;rec[i][0],&amp;rec[i][1],&amp; rec[i+1][0],&amp;rec[i+1][1],&amp;rec[i+2][0],&amp; rec[i+2][1],&amp;pr[i]),make(i); if(i/4==A||i/4==B)pr[i]=0; &#125; for(i=0;i&lt;s;i+=4)&#123; for(j=0;j&lt;s;j+=4)&#123; price=(i!=j)?t:pr[i]; rep(u)rep(v) ds[i+u][j+v]=sqrt(dis(i+u,j+v)), d[i+u][j+v]=price*ds[i+u][j+v]; &#125; &#125; dijkstra(); printf("%.1lf\n",l[B&lt;&lt;2]); &#125; return 0;&#125; NOIP2002普及T2 选数题目地址 用DFS构造出所有的组合即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,x[24],ans=0;bool isPrime(int t)&#123; if(t&amp;1)&#123; if(t==1)return false; else&#123; for(int i=3;i*i&lt;=t;i+=2) if(t%i==0)return false; return true; &#125; &#125;else return t==2;&#125;void dfs(int index,int used,int sum)&#123; sum+=x[index]; if(used==k)&#123; if(isPrime(sum))ans++; return ; &#125; for(int i=index+1;i&lt;=n-k+used;i++) dfs(i,used+1,sum);&#125;void init()&#123; n=read(),k=read(); for(int i=0;i&lt;n;i++) x[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;=n-k;i++) dfs(i,1,0); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; NOIP2003提高T1 神经网络题目地址 拓扑排序。按照题意模拟即可。注意，只有一个神经元的情况要特判。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int mp[105][105],c[105]=&#123;0&#125;,u[105],V,E,d[105]=&#123;0&#125;;int que[105],f=0,r=0,vis[105]=&#123;0&#125;,mat[105][105]=&#123;0&#125;;void topo()&#123; int du[105]=&#123;0&#125;,i,j,o=0; for(i=1;i&lt;=V;i++)&#123; for(j=1;j&lt;=V;j++) if(mat[j][i])du[i]++,d[j]++; if(!du[i])vis[i]=1,que[r++]=i; &#125; while(r-f)&#123; i=que[f++]; if(du[i])c[i]-=u[i]; if(c[i]&gt;0)&#123; for(j=1;j&lt;=V;j++) if(mat[i][j])&#123; c[j]+=mp[i][j]*c[i]; if(!vis[j]) vis[j]=1,que[r++]=j; &#125; &#125; &#125; for(i=1;i&lt;=V;i++) if(!d[i]&amp;&amp;c[i]&gt;0) o=1,printf("%d %d\n",i,c[i]); if(!o)printf("NULL\n");&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,_u,v,_c; for(i=1;i&lt;=V;i++) scanf("%d%d",&amp;c[i],&amp;u[i]); for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;_u,&amp;v,&amp;_c), mat[_u][v]=1, mp[_u][v]=_c; if(V==1&amp;&amp;c[1]&gt;0) printf("%d %d\n",1,c[1]); else topo(); return 0;&#125; NOIP2004提高T1 津津的储蓄计划题目地址 模拟神题。123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int saved = 0, cur = 0;int main()&#123; int flag = 1; for(int i = 1; i &lt;= 12; ++i)&#123; cur += 300; int curm; scanf("%d", &amp;curm); if(curm &gt; cur)&#123; printf("-%d\n", i), flag = 0; break; &#125; cur -= curm; saved += cur - (cur % 100); cur %= 100; &#125; if(flag) printf("%d\n", cur + saved * 6 / 5); return 0;&#125; NOIP2005提高T4 等价表达式题目地址 表达式求值。然而数据可以很大，直接比较答案和原式的做法不大现实。所以我们可以采用NOIP2014解方程的做法，把$a$带入一个数，再模一个质数，看结果是不是相同的。实际上为了保证准确性是可以模多个质数的，但这题数据很水，就没有这么做。最好还是多模几个质数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define A 1189using namespace std;int stack[2][10005],top[2]=&#123;0&#125;,pro[300],lim,targ,M=10009;char _exp[10000];int poww(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125; return res; &#125;void opr()&#123; int a1,a2,b; a2=stack[0][--top[0]], a1=stack[0][--top[0]], b=stack[1][--top[1]]; if(b=='+')stack[0][top[0]++]=(a1+a2)%M; if(b=='-')stack[0][top[0]++]=(a1-a2+M)%M; if(b=='*')stack[0][top[0]++]=(a1*a2)%M; if(b=='^')stack[0][top[0]++]=poww(a1,a2);&#125;void calc()&#123; int i,j,t=-1,cnt=0; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='a') stack[0][top[0]++]=A; else if(isdigit(_exp[i]))&#123; if(t&lt;0)t=_exp[i]-'0'; else t=t*10+_exp[i]-'0'; &#125;else if(_exp[i]!=' ')&#123; if(t!=-1) stack[0][top[0]++]=t, t=-1; if(_exp[i]=='(') stack[1][top[1]++]='(',cnt++; else if(_exp[i]==')')&#123; if(!cnt)continue; while(stack[1][top[1]-1]!='(') opr(); top[1]--,cnt--; &#125;else&#123; while(top[1]&amp;&amp;stack[1][top[1]-1]!='('&amp;&amp; pro[stack[1][top[1]-1]]&gt;=pro[_exp[i]]) opr(); stack[1][top[1]++]=_exp[i]; &#125; &#125; &#125;&#125;void init()&#123; pro['+']=pro['-']=1, pro['*']=2, pro['^']=3; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; calc(); targ=stack[0][0];&#125;void solve()&#123; int m,i; fgets(_exp,99,stdin); sscanf(_exp,"%d",&amp;m); for(i=0;i&lt;m;i++)&#123; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; top[0]=top[1]=0; memset(stack,0,sizeof(stack)); calc(); if(stack[0][0]==targ) printf("%c",'A'+i); &#125; printf("\n");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>背包DP</tag>
        <tag>递推</tag>
        <tag>DFS</tag>
        <tag>二分</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>树形结构</tag>
        <tag>栈</tag>
        <tag>最短路</tag>
        <tag>非完美算法</tag>
        <tag>拓扑排序</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1996-2000 题解]]></title>
    <url>%2F2018%2F08%2F21%2Fnoip1996-2000%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP1996-2001部分题目的题解。 NOIP1996提高T3 挖地雷题目地址 题目已经帮你拓扑排序完了，直接转移就可以。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,V,mp[25][25]=&#123;0&#125;,m[25],dp[25]=&#123;0&#125;,pre[25],ans[25],maxi=0,at;int main()&#123; scanf("%d",&amp;n); int i,j; fill(pre,pre+n,-1);//记录路径 for(i=0;i&lt;n;i++) scanf("%d",&amp;m[i]); for(i=0;i&lt;n-1;i++) for(j=i+1;j&lt;n;j++) scanf("%d",&amp;mp[i][j]); dp[0]=maxi=m[0],at=0; for(i=1;i&lt;n;i++)&#123; for(j=i-1;j&gt;=0;j--) if(mp[j][i]&amp;&amp;dp[j]&gt;=dp[i]) dp[i]=dp[j],pre[i]=j; dp[i]+=m[i]; if(dp[i]&gt;maxi) maxi=dp[i],at=i; &#125; for(j=0,i=at;i!=-1;i=pre[i]) ans[j++]=i+1; for(i=j-1;i&gt;=0;i--)&#123; printf("%d",ans[i]); if(i)printf(" "); &#125; printf("\n%d\n",maxi); return 0;&#125; 提高T4 砝码称重题目地址 用了完全背包，但是数据很弱，好像没有必要。可以暴力枚举。123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int f[1005]=&#123;0&#125;,n,v[6],ans=0;void packX(int vv)&#123;//二进制枚举版本 int p=1,vi=vv,j; while(n&gt;=p)&#123; for(j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); n-=p,p&lt;&lt;=1,vi&lt;&lt;=1; &#125; if(n)&#123; for(vi=n*vv,j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); &#125;&#125;int main()&#123; v[0]=1,v[1]=2,v[2]=3,v[3]=5,v[4]=10,v[5]=20; f[0]=1; for(int i=0;i&lt;6;i++)&#123; scanf("%d",&amp;n); if(n)packX(v[i]); &#125; for(int i=1;i&lt;=1000;i++) ans+=f[i]; printf("Total=%d\n",ans); return 0;&#125; NOIP1997普及T1 棋盘题目地址 自己推一下就行了。长方形（含正方形）个数为 \frac {nm(n+1)(m+1) }{4}正方形个数为 \mathcal \sum_{i=1}^m {i \left( n-m+i \right) \left( m \le n \right)}1234567891011121314#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll n,m,a1=0,a2=0;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(n&lt;m)swap(n,m); a1=m*n*(n+1)*(m+1)/4; for(int i=1;i&lt;=m;i++) a2+=(n-m+i)*i; printf("%lld %lld\n",a2,a1-a2); return 0; &#125; 普及T2 三角形题目地址 暴力枚举即可。用了全排列。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int ans=0,p,rec[20],now[20]=&#123;1,2,3,4,5,6,7,8,9&#125;;void cmp()&#123; if(!ans||memcmp(now,rec,sizeof(int)*9)&lt;0) memcpy(rec,now,sizeof(rec)); ans++;&#125;int ok()&#123; return ((now[0]&lt;now[5]&amp;&amp;now[5]&lt;now[8]) &amp;&amp;(now[1]&lt;now[3]&amp;&amp;now[6]&lt;now[7]&amp;&amp;now[2]&lt;now[4]) &amp;&amp;(now[0]+now[1]+now[3]+now[5]==p) &amp;&amp;(now[6]+now[7]+now[8]+now[5]==p) &amp;&amp;(now[0]+now[2]+now[4]+now[8]==p));&#125;int main()&#123; scanf("%d",&amp;p); do&#123; if(ok())cmp(); &#125;while(next_permutation(now,now+9)); if(!ans)&#123; printf("NO\n"); return 0; &#125; printf("%d\n",ans); printf("%d\n%d %d\n%d %d\n%d %d %d %d\n",rec[0], rec[1],rec[2],rec[3],rec[4],rec[5],rec[6], rec[7],rec[8]); return 0; &#125; 普及T3 街道题目地址 就是非常正常的DP。递推式 \mathcal dp(i,j) = dp(i-1,j)+dp(i,j-1)之后再用一个简单的高精度就可以了。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll M=1000000000000000,dp[55][55][2]=&#123;0&#125;,n,m,x1,x2,y1,y2,ok=1;void add(ll u1,ll v1,ll u2,ll v2)&#123; ll a=dp[u1][v1][0]+dp[u2][v2][0]; dp[u2][v2][0]=a%M,a/=M; a+=dp[u1][v1][1]+dp[u2][v2][1]; dp[u2][v2][1]=a%M;//简单的高精度&#125;void solve()&#123; dp[1][1][0]=1; for(ll i=1;i&lt;=n;i++) for(ll j=1;j&lt;=m;j++) if((ok&amp;&amp;(i&lt;x1||i&gt;x2||j&lt;y1||j&gt;y2))||(!ok)) add(i-1,j,i,j), add(i,j-1,i,j); //递推过程 dp[n][m][1]%=100000; if(dp[n][m][1]&gt;0)printf("%lld%015lld\n",dp[n][m][1],dp[n][m][0]); else printf("%lld\n",dp[n][m][0]);&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(!x1&amp;&amp;!x2&amp;&amp;!y1&amp;&amp;!y2)ok=0; else&#123; if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); &#125; solve(); return 0;&#125; 提高T1 棋盘问题2（待考察？）题目地址 本题我只想出来了一种比较简单的搜索方法。。。实际上原题数据很小，基本上各种搜索方法都可以过，但是当$N = 10$的时候就很难卡过去了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,sqr,mat[15][15]=&#123;0&#125;,dx[]=&#123;0,0,-1,1&#125;,dy[]=&#123;-1,1,0,0&#125;,ans=0;bool isprime[205]=&#123;0&#125;,used[105]=&#123;0&#125;;void dfs(int x,int y)&#123; if(ans)return ; for(int i=2;!ans&amp;&amp;i&lt;=sqr;i++)&#123; if(!used[i]&amp;&amp;(!x||isprime[i+mat[x-1][y]])&amp;&amp;(!y||isprime[i+mat[x][y-1]]))&#123; mat[x][y]=i,used[i]=1; if(x==y)&#123; if(x==n-1)&#123;ans=1;return;&#125; else dfs(x,y+1); &#125;else if(y==n-1)dfs(x+1,x); else if(x==n-1)dfs(y+1,y+1); else if(y&gt;x)dfs(x,y+1); else if(x&gt;y)dfs(x+1,y); if(!ans)mat[x][y]=0,used[i]=0; &#125; &#125;&#125;void init()&#123; n=read(); sqr=n*n; for(int i=3;i&lt;=200;i+=2)&#123; isprime[i]=1; for(int j=3;j*j&lt;=i;j+=2) if(i%j==0)&#123; isprime[i]=0;break; &#125; &#125;&#125;void solve()&#123; mat[0][0]=1,used[1]=1; dfs(0,1); if(!ans)printf("NO\n"); else&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n-1;j++) printf("%d ",mat[i][j]); printf("%d\n",mat[i][n-1]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; NOIP1998普及T1 寻找三位数题目地址 很简单的枚举。只要从101枚举到333即可，然后记录每一位。可以采用特殊策略优化，比如当前数字必须不是5的倍数。1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char k[10];int main()&#123; int a,b,c,d,fl,i; for(a=101;a&lt;=333;a++)&#123; if(a%5==0)continue; memset(k,0,sizeof(k)); fl=1,b=a,c=a*2,d=a*3; k[b%10]++,k[c%10]++,k[d%10]++; k[(b/10)%10]++,k[(c/10)%10]++,k[(d/10)%10]++; k[b/100]++,k[c/100]++,k[d/100]++; for(i=1;i&lt;=9;i++) if(k[i]!=1) fl=0; if(fl)printf("%d %d %d\n",b,c,d); &#125; return 0;&#125; 普及T2 阶乘之和题目地址 高精度乘法+加法水过。12 普及T3 幂次方题目地址 递归计算即可。12 提高T1 火车站题目地址 设第二站上的人数是$p$，则：容易看出每一站上下车的人都等于$fib[i]a+fib[j]p$，其中$i$和$j$为相邻正整数。那么只需要算出最终车上的人等于多少$a$加多少$p$，解出$p$，然后带入第$x$站的数据即可。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int a,n,m,x,fib[25],xs1[25],xs2[25];void init()&#123; a=read(),n=read(),m=read(),x=read(); fib[0]=0,fib[1]=1; for(int i=2;i&lt;=24;i++) fib[i]=fib[i-1]+fib[i-2];&#125;void solve()&#123; xs1[1]=xs1[2]=1,xs2[1]=xs2[2]=0; for(int i=3;i&lt;n;i++) xs1[i]=xs1[i-1]+fib[i-2]-fib[i-3], xs2[i]=xs2[i-1]+fib[i-1]-fib[i-2]; printf("%d\n",xs1[x]*a+xs2[x]*(m-xs1[n-1]*a)/xs2[n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T2 拼数题目地址 NOIP1999普及T1 Cantor表题目地址 找规律，分奇偶讨论，最后$ \mathcal O(1)$计算。12345678#include &lt;cstdio&gt;using namespace std;int main()&#123; int n,i;scanf("%d",&amp;n); for(i=1;n&gt;(i*i+i)/2;i++); if(i%2==0)n=i*i+1-n; printf("%d/%d\n",i+(i*i-i)/2+1-n,n-(i*i-i)/2);&#125; 普及T2 回文数题目地址 套用高精度加法模板即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n, s1[1005], s2[1005];char s[1005];void init()&#123; scanf("%d%s", &amp;n, &amp;s);&#125;bool judge(int len)&#123; for(int i = 1; i &lt;= (len &gt;&gt; 1); ++i) if(s1[i] != s1[len - i + 1]) return false; return true;&#125;void add()&#123; memset(s2, 0, sizeof(s2)); int x = 0; s2[0] = s1[0]; for(int i = 1; i &lt;= s1[0]; ++i)&#123; x += s1[i] + s1[s1[0] - i + 1]; s2[i] = x % n; x /= n; &#125; if(x &gt; 0) s2[++s2[0]] = x;&#125;void solve()&#123; int len = strlen(s); s1[0] = len; for(int i = len - 1; i &gt;= 0; --i)&#123; if(isdigit(s[i])) s1[len - i] = s[i] - '0'; else s1[len - i] = s[i] - 'A' + 10; &#125; int flag = 0; for(int i = 0; i &lt;= 30; ++i)&#123; if(judge(s1[0]))&#123; flag = 1; printf("STEP=%d\n", i); break; &#125; add(); memcpy(s1, s2, sizeof(s2)); &#125; if(!flag) printf("Impossible!");&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 导弹拦截题目地址 先求最长不上升子序列，再求最长上升子序列。（Dilworth定理，最长链和最长反链）或者因为数据小，贪心的做法也能接受。所以我无聊的写了三个版本： $O(nlogn)$动态规划123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int high[50],tot=0,ans=0,dp[50]=&#123;0&#125;,tmp; int main()&#123; int i,j; while(scanf("%d",&amp;high[tot])==1)tot++; for(i=0;i&lt;tot;i++)&#123; for(tmp=1,j=0;j&lt;i;j++)&#123; if(high[j]&gt;=high[i])tmp=max(tmp,dp[j]+1); &#125;dp[i]=tmp; &#125;for(i=0;i&lt;tot;i++)ans=max(ans,dp[i]); fill(dp,dp+tot,0x7FFFFFFF);for(i=0;i&lt;tot;i++) *lower_bound(dp,dp+tot,high[i])=high[i]; tmp=lower_bound(dp,dp+tot,0x7FFFFFFF)-dp; printf("%d\n%d\n",ans,tmp); return 0; &#125; $O(n^2)$动态规划12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dat[55],n;int dp(int o)&#123; int dpp[55],ans=1; fill(dpp,dpp+n,1); for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++) if(o&amp;&amp;dat[j]&lt;=dat[i])dpp[i]=max(dpp[i],dpp[j]+1); else if(dat[j]&lt;dat[i])dpp[i]=max(dpp[i],dpp[j]+1); ans=max(ans,dpp[i]); &#125;return ans;&#125;int main()&#123; n=0;while(~scanf("%d",&amp;dat[n]))n++; reverse(dat,dat+n); printf("%d\n",dp(1)); reverse(dat,dat+n); printf("%d\n",dp(0)); return 0;&#125; $O(n^2)$贪心123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int h[25],low[25],n=0,ans,f[25];int main()&#123; int i,j,t; while(~scanf("%d",&amp;h[n]))n++; for(f[0]=1,ans=i=1;i&lt;n;i++)&#123; f[i]=1; for(j=0;j&lt;i;j++) if(h[j]&gt;=h[i])f[i]=max(f[i],f[j]+1); ans=max(ans,f[i]); &#125; printf("%d\n",ans); for(low[0]=h[0],ans=0,i=1;i&lt;n;i++)&#123; for(j=0;j&lt;=ans;j++) if(low[j]&gt;=h[i])&#123;low[j]=h[i];break;&#125; if(j&gt;ans)low[++ans]=h[i]; &#125; printf("%d\n",ans+1); return 0;&#125; 普及/提高T3 旅行家的预算题目地址 尽量选最便宜的，如果油满了就换次便宜的，这样递归（循环下去）。最后油全满了就No solution。这里使用了优先队列来取最优值。只是懒得手写堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;typedef double db;typedef struct&#123; int id;db count,dis,pri;&#125;Pp;bool operator&lt;(Pp a,Pp b)&#123;return a.pri&gt;b.pri;&#125;Pp dat[105];int n;db ans=0,C,D,per;priority_queue&lt;Pp&gt; pq;void solve()&#123; pq.push(dat[0]); int i,j,k; Pp tmp; for(i=1;i&lt;=n;i++)&#123; db need=(dat[i].dis-dat[i-1].dis)/per,mini; for(;!pq.empty();)&#123; tmp=pq.top(); for(mini=need,j=tmp.id;j&lt;i;j++) mini=min(C-dat[j].count,mini); for(j=tmp.id;j&lt;i;j++) dat[j].count+=mini; ans+=mini*tmp.pri; if(mini&lt;need) need-=mini,pq.pop(); else break; &#125; if(pq.empty())&#123;ans=-1;return ;&#125; pq.push(dat[i]); &#125; &#125;int main()&#123; int i,j; scanf("%lf%lf%lf%lf%d",&amp;D,&amp;C,&amp;per,&amp;dat[0].pri,&amp;n); for(i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;dat[i].dis,&amp;dat[i].pri); dat[0].dis=0; for(n++,i=0;i&lt;=n;i++) dat[i].count=0,dat[i].id=i; dat[n].dis=D; solve(); if(ans&lt;0)printf("No Solution\n"); else printf("%.2lf\n",ans); return 0;&#125; 提高T4 邮票面值设计题目链接]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>背包DP</tag>
        <tag>枚举</tag>
        <tag>贪心</tag>
        <tag>线性DP</tag>
        <tag>堆</tag>
        <tag>图上DP</tag>
        <tag>生成函数</tag>
        <tag>棋盘DP</tag>
        <tag>部分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2006 题解]]></title>
    <url>%2F2018%2F08%2F21%2Fnoip2006%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2006八道题目的题解。 普及T1 明明的随机数题目链接 排序去重即可。 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n;vector&lt;int&gt; v;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; int j; scanf("%d",&amp;j); v.push_back(j); &#125; sort(v.begin(),v.end()); vector&lt;int&gt;::iterator it=unique(v.begin(),v.end()); printf("%d\n",it-v.begin()); for(int i=0;i&lt;it-v.begin();i++) printf("%d ",v[i]); return 0; &#125; 普及T2 开心的金明题目链接 最基本的01背包。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int V, n, f[30005] = &#123;0&#125;, v[30], w[30];void init()&#123; V = read(), n = read(); for(int i = 0; i &lt; n; ++i) v[i] = read(), w[i] = read();&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i) for(int j = V; j &gt;= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + w[i] * v[i]); printf("%d\n", f[V]);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T3 Jam的计数法题目链接 自己手写一个生成下一个组合的函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int s, t, l;char p[30];void init()&#123; s = read() - 1, t = read() - 1, l = read(); scanf("%s", p); for(int i = 0; i &lt; l; ++i) p[i] -= 'a';&#125;bool getC()&#123; int cur = l - 1; while(cur &gt;= 0 &amp;&amp; p[cur] == t - l + 1 + cur) cur--; if(cur == -1) return false; p[cur]++, cur++; while(cur &lt; l) p[cur] = p[cur - 1] + 1, cur++; for(int i = 0; i &lt; l; ++i) putchar(p[i] + 'a'); putchar('\n'); return true;&#125;void solve()&#123; for(int i = 0; i &lt; 5; ++i) if(!getC()) break;&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 数列题目链接 容易证明 \forall b \in \mathbb{N}^*, k^b>\sum_{i=0}^{b-1} k^i令(N)_{10}=(a_na_{n-1}...a_1a_0)_2可以推出 \sum_{i=0}^n a_i \cdot k^i随着$N$递增。而$N$从$1$开始增加，因此该数列的第$N$项即为上式。12345678910111213141516#include &lt;cstdio&gt;int n,k,m=0,s=0;int p(int w)&#123; int res=1; for(int i=1;i&lt;=w;i++)res*=n; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); while(k)&#123; if(k&amp;1)s+=p(m); m++,k&gt;&gt;=1; &#125; printf("%d\n",s); return 0;&#125; 提高T1 能量项链题目链接 和石子合并差不多。由于是环状，所以需要把原来的项链复制一遍。很经典的区间DP。123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[205][205]=&#123;0&#125;,n,dat[205][2];int main()&#123; scanf("%d",&amp;n); n&lt;&lt;=1; int _n=n; for(int i=0;i&lt;_n;i++) scanf("%d",&amp;dat[i][0]), dat[i+_n][0]=dat[i][0]; dat[n-1][1]=dat[0][0]; for(int i=0;i&lt;n-1;i++) dat[i][1]=dat[i+1][0]; for(int i=1;i&lt;_n;i++)//i:length for(int j=0;j+i&lt;n;j++) for(int k=j;k&lt;i+j;k++) dp[j][i+j]=max(dp[j][j+i],dp[j][k]+dp[k+1][i+j]+ dat[j][0]*dat[k][1]*dat[i+j][1]); int ans=dp[0][_n-1]; for(int i=1;i&lt;_n;i++) ans=max(ans,dp[i][i+_n-1]); printf("%d\n",ans); return 0;&#125; 提高T2 金明的预算方案题目链接 一个很不寻常的背包DP。由于有附件的存在，我们需要将购买不同的附件相分开。即将购买0到多个附件分别作为不同的决策考虑。由于附件数不超过2个，所以我们购买某一个主件和其附件的时候至多只有4种决策：只购买主件，或者买主件和两个附件中的一个，或者主附件全买。这样的话就归化成了一个普通的01背包问题。1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int dp[32005]=&#123;0&#125;,n,W,w[62][5]=&#123;0&#125;,v[62][5]=&#123;0&#125;;int main()&#123; scanf("%d%d", &amp;W, &amp;n); for(int i = 1; i &lt;= n; ++i)&#123; int j, p, k; scanf("%d%d%d", &amp;j, &amp;p, &amp;k); if(k)&#123; if(w[k][0] &gt; 1) w[k][3] += j, w[k][4] += j, w[k][0] += 2, v[k][3] += p * j, v[k][4] += p * j; else w[k][2] += j, w[k][3] += j, w[k][0]++, v[k][3] += p * j, v[k][2] += p * j; &#125;else&#123; w[i][0]++, w[i][1] += j, w[i][2] += j, w[i][3] += j, w[i][4] += j; v[i][3] += p * j, v[i][4] += p * j, v[i][1] = p * j, v[i][2] += p * j; &#125; &#125; for(int i = 1; i &lt;= n; ++i) if(w[i][0]) for(int j = W; j &gt;= w[i][1]; --j) for(int k = 1; k &lt;= w[i][0]; ++k) if(j - w[i][k] &gt;= 0) dp[j] = max(dp[j], dp[j - w[i][k]] + v[i][k]); printf("%d\n", dp[W]); return 0;&#125; 提高T3 作业调度方案题目链接 模拟即可…千万不要考虑什么奇奇怪怪的优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int gid,_id,p[2]; &#125;Move;Move move[405],*pt[25][25];int mac[25][455]=&#123;0&#125;,cnt[25]=&#123;0&#125;,m,n;int ok(int id,int l,int r)&#123; for(int i=l;i&lt;=r;i++) if(mac[id][i])return i; for(int i=l;i&lt;=r;i++) mac[id][i]=1; return 0;&#125; int solve()&#123; int i,j,k,u,v,id,ans=0; fill(cnt,cnt+24,1); for(i=1;i&lt;=m*n;i++)&#123; u=move[i].p[0],v=move[i].p[1], id=move[i].gid; for(j=cnt[id];;)&#123; k=ok(u,j,j+v-1); if(!k)&#123;cnt[id]=j+v;break;&#125; else j=k+1; &#125; &#125; for(i=1;i&lt;=n;i++) ans=max(ans,cnt[i]); return ans-1;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int i,j,k; for(i=1;i&lt;=m*n;i++) scanf("%d",&amp;j), move[i].gid=j, move[i]._id=++cnt[j], pt[j][cnt[j]]=&amp;move[i]; for(k=0;k&lt;2;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) scanf("%d",&amp;pt[i][j]-&gt;p[k]); printf("%d\n",solve()); return 0;&#125; 提高T4 $2^k$进制数题目地址 组合数问题。数码递增视为一个组合。这样一个数，数码只有$\mathcal 2^k-1$个，故长度至多为$\mathcal 2^k-1$。因此当$\mathcal w \ge \left(2^k-1\right) \times k $的时候，多出的那部分没有意义。此时令$\mathcal w = \left(2^k-1\right) \times k $。对于一个$\mathcal w$，一个$\mathcal 2^k$进制数除去最高位至多有$\mathcal \lfloor \frac {w}{k} \rfloor$位。考虑$\mathcal 2$到$\mathcal \lfloor \frac {w}{k} \rfloor$位，由于数码有$\mathcal 2^k-1$个，故此部分答案为 \mathcal \sum_{i=2}^{ \lfloor \frac {w}{k} \rfloor} C_{2^k-1}^{i}考虑最高位，由于最高位可能的最大数我们可以算出，设其为$\mathcal u$，则 \mathcal u=2^{w \mod k}-1最高位已经确定，剩下的只有$\mathcal \lfloor \frac {w}{k} \rfloor$个数字要选，备选的数字有$\mathcal 2^k-1-o \left( 1\le o \le u\right)$个，故此部分答案为 \mathcal \sum_{o=1}^u C_{2^k-1-o}^{\lfloor \frac {w}{k} \rfloor}两部分相加即为本题答案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define p 10000using namespace std;int c[520][25],ans[56]=&#123;0&#125;,k,w,k1,k2;void mul(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=1;i&lt;=s1[0];i++) x+=s1[i]*s2,to[i]=x%p,x/=p; for(;x&gt;0;)to[++to[0]]=x%p,x/=p; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void add(int s1[],int s2[])&#123; s2[0]=max(s1[0],s2[0]); int x=0; for(int i=1;i&lt;=s2[0];i++) x+=s1[i]+s2[i],s2[i]=x%p,x/=p; for(;x!=0;)s2[++s2[0]]=x%p,x/=p;&#125;void divide(int s1[],int s2)&#123; int x=0; for(int i=s1[0];i&gt;=1;i--)&#123; x=x*p+s1[i],s1[i]=x/s2,x%=s2; &#125; for(;s1[0]&gt;1&amp;&amp;s1[s1[0]]==0;)s1[0]--;&#125;void C(int m,int n)&#123; c[0][0]=c[0][1]=1; for(int i=1;i&lt;=m;i++) mul(c[i-1],n-i+1,c[i]),divide(c[i],i);&#125;int output(int big[])&#123; printf("%d",big[big[0]]); for(int i=big[0]-1;i&gt;=1;i--) printf("%04d",big[i]); printf("\n");&#125;int main()&#123; scanf("%d%d",&amp;k,&amp;w); k1=1&lt;&lt;k; if(w&gt;k*(k1-1))w=k*(k1-1); C(w/k,k1-1); for(int i=2;i&lt;=w/k;i++)add(c[i],ans); k2=1&lt;&lt;(w%k); for(int i=1;i&lt;k2;i++) C(w/k,k1-1-i),add(c[w/k],ans); output(ans); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>背包DP</tag>
        <tag>模拟</tag>
        <tag>区间DP</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hanoi]]></title>
    <url>%2F2018%2F08%2F21%2Fwriting%2FHanoi%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP2007 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2007%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2007八道题目的题解。 普及T1 奖学金题目链接 按照题意排序即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;struct Stu&#123; int all, chi, id;&#125;;struct cmp&#123; inline bool operator()(const Stu&amp; s1, const Stu&amp; s2)&#123; if(s1.all != s2.all)return s1.all &gt; s2.all; if(s1.chi != s2.chi)return s1.chi &gt; s2.chi; return s1.id &lt; s2.id; &#125;&#125;;Stu s[505];int n;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) s[i].id = i + 1, s[i].all = s[i].chi = read(), s[i].all += read() + read(); sort(s, s + n, cmp());&#125;void solve()&#123; for(int i = 0; i &lt; 5; ++i) printf("%d %d\n", s[i].id, s[i].all);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T2 纪念品分组题目链接 排序后大的尽量和小的组合，无法组合则直接退出。123456789101112131415#include &lt;cstdio&gt;#include &lt;algorithm&gt;int limit,n,k[30005],ans=0;int main()&#123; scanf("%d%d",&amp;limit,&amp;n); int i,at,o=0; for(i=0;i&lt;n;i++)scanf("%d",&amp;k[i]); std::sort(k,k+n); for(i=0;i&lt;n;i++)&#123; for(o=0,at=n-1;at&gt;i;at--) if(k[at]&lt;=limit-k[i])&#123;o=1;break;&#125; if(o)&#123;ans+=n-at;n=at;&#125;else&#123;ans+=n-i;break;&#125; &#125;printf("%d\n",ans); return 0;&#125; 普及T3 守望者的逃离题目链接 方法一分类讨论。。尽量采取最优的策略。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;int m, s, t, ts, lim;int get()&#123; if((10 - m) % 4) return (10 - m) / 4 + 1; return (10 - m) / 4;&#125;int main()&#123; scanf("%d%d%d", &amp;m, &amp;s, &amp;t); for(int i = t, ts = s; i &gt; 0; )&#123; if(ts &lt;= 0) break; if(m &gt;= 10) m -= 10, ts -= 60, i--; else&#123; if(ts &lt;= 17) i--, ts=0;//跑一下就跑的到 else&#123; if((lim = get()) &lt; 3)&#123; if(i &gt;= lim + 1)&#123; if(ts &lt;= 34)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else i = i - (lim + 1), ts -= 60, m -= 10, m += lim * 4; &#125;else &#123; if(ts &lt;= i * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else ts -= i * 17, i = 0;//尽量跑 &#125; &#125;else&#123; if(i &gt;= 7)&#123; if(ts &lt;= 7 * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else i -= 7, ts -= 120; &#125;else &#123; if(ts &lt;= i * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else ts -= i * 17, i = 0;//尽量跑 &#125; &#125; &#125; &#125; if(ts &gt; 0) printf("No\n%d\n", s - ts); else printf("Yes\n%d\n", t - i); return 0; &#125; 方法二我们将法术和跑步分开来，跑一遍DP。一开始只有法术，然后修改决策为跑步。（来自洛谷上的神奇方法）该方法之所以成立，就在于恢复完全是为了放出法术，而和跑步无关。因此可以将两者视为不同的决策。12345678910111213141516171819int dp[300005];void solve()&#123; int m = read(), s = read(), T = read(); dp[0] = 0; for(int i = 1; i &lt;= T; ++i)&#123; if(m &gt;= 10) dp[i] = dp[i - 1] + 60, m -= 10; else dp[i] = dp[i - 1], m += 4; &#125; for(int i = 1; i &lt;= T; ++i)&#123; dp[i] = max(dp[i], dp[i - 1] + 17); if(dp[i] &gt;= s)&#123; printf("Yes\n%d\n", i); break; &#125; &#125; printf("No\n%d\n", dp[T]);&#125; 普及T4 Hanoi双塔问题题目链接 可以证明最短的次数一定是原汉诺塔问题的答案的两倍。（因为最优情况下就是每一次要移动2个同样大小的盘子）所以…加个高精度就完了。 提高T1 统计数字题目链接 模拟即可。123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; int n,k[200005],tot=1,last;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;k[i]); sort(k,k+n); last=k[0]; for(int i=1;i&lt;n;i++)&#123; if(last!=k[i]) printf("%d %d\n",last,tot),tot=1,last=k[i]; else tot++; &#125; printf("%d %d\n",last,tot); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第七章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter7%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第七章部分习题的整合。 例7-1 UVa725 Division题目链接 直接枚举除数即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, cnt[20];void solve()&#123; int flag = 0; for(int i = 1234; ; ++i)&#123; int j = i * n; if(j &lt; 10000 &amp;&amp; i &lt; 10000) continue; int tot = 0; while(j) cnt[tot++] = j % 10, j /= 10; j = i; while(j) cnt[tot++] = j % 10, j /= 10; if(i &lt; 10000)cnt[tot++] = 0; if(tot &gt; 10)break; sort(cnt, cnt + 10); for(j = 0; j &lt; 10; ++j) if(cnt[j] != j) break; if(j == 10) printf("%d / %05d = %d\n", i * n, i, n), flag = 1; &#125; if(!flag) printf("There are no solutions for %d.\n", n);&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(); if(!n)break; if(T &gt; 1)printf("\n"); solve(); &#125; return 0;&#125; 例7-2 UVa11059 Maximum Product题目链接 枚举两端即可。数据比较小，直接用long long。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;ll seq[50];void init()&#123; for(int i = 0; i &lt; n; ++i) seq[i] = read();&#125;void solve()&#123; ll ans = 0; for(int i = 0; i &lt; n; ++i) for(int j = i; j &lt; n; ++j)&#123; ll st = 1; for(int k = i; k &lt;= j; ++k) st *= seq[k]; ans = max(ans, st); &#125; printf("%lld.\n\n", ans);&#125;int main()&#123; int T = 0; while(scanf("%d", &amp;n) == 1)&#123; T++; printf("Case #%d: The maximum product is ", T); init(); solve(); &#125; return 0;&#125; 例7-3 UVa10976 Fractions Again?!题目链接 由于$x \ge y$可以发现$\frac{1}{x} \le \frac{1}{y}$。故$y$的下限为$k+1$，上限为$2k$。将$y$从$k+1$开始枚举到$2k$即可。12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, ans[10005][2], cnt;void solve()&#123; cnt = 0; for(int i = n + 1; i &lt;= n + n; ++i)&#123; int fz = i - n, fm = n * i; if(fm % fz == 0) ans[cnt][0] = fm / fz, ans[cnt++][1] = i; &#125; printf("%d\n", cnt); for(int i = 0; i &lt; cnt; ++i) printf("1/%d = 1/%d + 1/%d\n", n, ans[i][0], ans[i][1]);&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; solve(); &#125; return 0;&#125; 例7-4 UVa524 Prime Ring Problem题目链接 直接DFS即可。回溯法的入门型题目。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, ring[20];bool isnt[50] = &#123;0&#125;, vis[20] = &#123;0&#125;;void init()&#123; isnt[1] = 1; for(int i = 2; i &lt;= 32; ++i) if(!isnt[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 32; j += i) isnt[j] = 1; &#125;&#125;void dfs(int index, int cur)&#123; ring[cur] = index; if(cur == n)&#123; if(!isnt[ring[1] + index])&#123; for(int i = 1; i &lt; n; ++i) printf("%d ", ring[i]); printf("%d\n", ring[n]); &#125; return ; &#125; vis[index] = 1; for(int i = 2; i &lt;= n; ++i) if(!vis[i] &amp;&amp; !isnt[i + ring[cur]]) dfs(i, cur + 1); vis[index] = 0;&#125;void solve()&#123; dfs(1, 1);&#125;int main()&#123; init(); int T = 1; while(scanf("%d", &amp;n) == 1)&#123; if(T &gt; 1)printf("\n"); printf("Case %d:\n", T); solve(); T++; &#125; return 0;&#125; 例7-6 UVa140 Bandwidth题目链接 枚举全排列，然后模拟即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005];bool mat[50][50], vis[50];int p[10], n, b[10], ansp[10];void init()&#123; memset(mat, 0, sizeof(mat)); memset(vis, 0, sizeof(vis)); for(int i = 0; isalpha(s[i]); ++i)&#123; int cur = s[i++] - 'A'; vis[cur] = 1; for(i++; isalpha(s[i]); ++i)&#123; int to = s[i] - 'A'; mat[cur][to] = mat[to][cur] = 1; vis[to] = 1; &#125; &#125;&#125;void solve()&#123; n = 0; for(int i = 0; i &lt; 26; ++i) if(vis[i]) p[n++] = i; int ans = INF; do&#123; int cur = 0; memset(b, 0, sizeof(b)); for(int i = 0; i &lt; n; ++i)&#123; for(int j = i - 1; j &gt;= 0; --j) if(mat[p[i]][p[j]]) b[i] = max(b[i], i - j); for(int j = i + 1; j &lt; n; ++j) if(mat[p[i]][p[j]]) b[i] = max(b[i], j - i); cur = max(cur, b[i]); if(cur &gt;= ans) break; &#125; if(cur &lt; ans)&#123; memcpy(ansp, p, sizeof(p)); ans = cur; &#125; &#125;while(next_permutation(p, p + n)); for(int i = 0; i &lt; n; ++i) printf("%c ", ansp[i] + 'A'); printf("-&gt; %d\n", ans);&#125;int main()&#123; for(; ; )&#123; scanf("%s", s); if(s[0] == '#')break; init(); solve(); memset(s, 0, sizeof(s)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第六章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter6%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第六章部分习题的整合。 例6-2 UVa514 Rails题目链接 用栈模拟即可。对于要求顺序的第$i$项，只有$2$种可能： 它不在栈里，那么把它前面的全部入栈。 它在栈里，那么除非它在栈顶，不然不可能满足此顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, permu[1005], st[1005], top, in[1005];void solve()&#123; top = 0; memset(in, 0, sizeof(in)); int cur = 1, ans = 1; for(int i = 1; i &lt;= n; ++i)&#123; if(!in[permu[i]])&#123; for(; cur &lt; permu[i]; ++cur) st[top++] = cur, in[cur] = 1; cur++; &#125;else&#123; if(st[top - 1] == permu[i]) top--, in[permu[i]] = 0; else&#123; ans = 0; break; &#125; &#125; &#125; printf("%s\n", ans ? "Yes" : "No");&#125;void init()&#123; for(; ; )&#123; if(permu[1] = read())&#123; for(int i = 2; i &lt;= n; ++i) permu[i] = read(); solve(); &#125;else &#123; printf("\n"); break ; &#125; &#125;&#125;int main()&#123; for(; ; )&#123; n = read(); if(!n)break ; init(); &#125; return 0;&#125; 例6-4 UVa11988 Broken Keyboard (a.k.a. Beiju Text)题目链接 直接用链表模拟即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[5000005];int cur, nxt[5000005], lst;void solve()&#123; cur = lst = 0; nxt[0] = -1; int len = strlen(s + 1); for(int i = 1; i &lt;= len; ++i)&#123; if(s[i] == '[')&#123; cur = 0; &#125;else if(s[i] == ']')&#123; cur = lst; &#125;else&#123; nxt[i] = nxt[cur]; nxt[cur] = i; cur = i; if(nxt[cur] == -1) lst = cur; &#125; &#125; for(int i = nxt[0]; i != -1; i = nxt[i]) putchar(s[i]); putchar('\n');&#125;int main()&#123; while(scanf("%s", s + 1) == 1) solve(); return 0;&#125; 例6-6 UVa679 Dropping Balls题目链接 可以根据奇偶判断一个球在一个节点应该是向左还是向右走，同时算出有多少个球走到了下一个节点。这样的话就可以递归计算。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int d, id, ans;void init()&#123; d = read(), id = read();&#125;void get(int curd, int curi, int curp)&#123; if(curd == d)&#123; ans = curp; return ; &#125; if(curi &amp; 1) get(curd + 1, curi / 2 + 1, curp &lt;&lt; 1); else get(curd + 1, curi / 2, curp &lt;&lt; 1 | 1);&#125;void solve()&#123; get(1, id, 1); printf("%d\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; scanf("%d", &amp;T); return 0;&#125; 例6-8 UVa548 Tree题目链接 根据中序遍历和后序遍历构造树即可。细节有一点多。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[2000005];int cur, p1[10005], p2[10005], n;int lc[10005], rc[10005], key[10005], mini[10005], ans;int read()&#123; int x = 0; char c = s[cur]; while(c &lt; '0' || c &gt; '9')&#123; if(c == '\n' || c == EOF) return -1; c = s[++cur]; &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = s[++cur]; return x; &#125;void init()&#123; n = 0; for(cur = 0; ; ++n)&#123; p1[n] = read(); if(p1[n] &lt; 0) break; &#125; fgets(s, 2000000, stdin); cur = 0; for(int i = 0; i &lt; n; ++i) p2[i] = read();&#125;int get(int il, int ir, int pl, int pr)&#123; if(ir - il &lt; 0) return 0; int i, id = p2[pr]; for(i = il; i &lt;= ir; ++i) if(p1[i] == id) break; int len = i - il; lc[id] = get(il, i - 1, pl, pl + len - 1); rc[id] = get(i + 1, ir, pl + len, pr - 1); key[id] = id; if(lc[id] &amp;&amp; rc[id])&#123; if(key[lc[id]] &gt; key[rc[id]]) key[id] += key[rc[id]], mini[id] = mini[rc[id]]; else if(key[lc[id]] &lt; key[rc[id]]) key[id] += key[lc[id]], mini[id] = mini[lc[id]]; else key[id] += key[rc[id]], mini[id] = mini[rc[id]], mini[id] = min(mini[lc[id]], mini[rc[id]]); &#125;else if(lc[id]) key[id] += key[lc[id]], mini[id] = mini[lc[id]]; else if(rc[id]) key[id] += key[rc[id]], mini[id] = mini[rc[id]]; else mini[id] = id; return id;&#125;void solve()&#123; int root = get(0, n - 1, 0, n - 1); printf("%d\n", mini[root]);&#125;int main()&#123; while(fgets(s, 2000000, stdin) != NULL)&#123; init(); solve(); &#125; return 0;&#125; 例6-9 UVa839 Not so Mobile题目链接 按照递归顺序生成整个天平即可。例题给出的代码中get函数的返回值是天平是否平衡，这里我稍微做了一些调整。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int ans = 1;int get()&#123; int wl = read(), dl = read(), wr = read(), dr = read(); if(!wl) wl = get(); if(!wr) wr = get(); if(wl * dl != wr * dr) ans = 0; return wl + wr;&#125;void solve()&#123; ans = 1; get(); printf("%s\n", ans ? "YES" : "NO");&#125;int main()&#123; int T = read(); while(T--)&#123; solve(); if(T &gt; 0) printf("\n"); &#125; return 0;&#125; 例6-10 UVa699 The Falling Leaves题目链接 也是利用递归构造出整个树的结构。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int root, lc[100005], rc[100005];int cntl[100005], cntr[100005], maxl, maxr;void build(int id, int pos)&#123; if(pos &gt;= 0) cntr[pos] += id, maxr = max(maxr, pos); else cntl[-pos] += id, maxl = min(maxl, pos); lc[id] = read(); if(lc[id] &gt; 0) build(lc[id], pos - 1); rc[id] = read(); if(rc[id] &gt; 0) build(rc[id], pos + 1);&#125;void solve()&#123; memset(cntl, 0, sizeof(cntl)); memset(cntr, 0, sizeof(cntr)); maxl = maxr = 0; build(root, 0);&#125;int main()&#123; int T = 1; while((root = read()) != -1)&#123; solve(); printf("Case %d:\n", T); for(int i = -maxl; i &gt;= 1; --i) printf("%d ", cntl[i]); for(int i = 0; i &lt; maxr; ++i) printf("%d ", cntr[i]); printf("%d\n\n", cntr[maxr]); T++; &#125; return 0;&#125; 例6-13 UVa1103 Ancient Messages题目链接 搜索联通块即可。这里用了一点技巧：先把所有符号外围的白色填充掉，然后再对符号框架部分搜索。在搜索框架时发现了没有访问过的白色块就说明这个符号有洞，用这种方法统计出洞的个数即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m;int dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;, lis[] = &#123;'W', 'A', 'K', 'J', 'S', 'D'&#125;;int dat[205][205], tot, cnt;bool vis[205][205];char ans[1005];void init()&#123; memset(dat, 0, sizeof(dat)); for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; int d; scanf("%1x", &amp;d); if(d &amp; 8)dat[i][j &lt;&lt; 2] = 1; if(d &amp; 4)dat[i][j &lt;&lt; 2 | 1] = 1; if(d &amp; 2)dat[i][j &lt;&lt; 2 | 2] = 1; if(d &amp; 1)dat[i][j &lt;&lt; 2 | 3] = 1; &#125; &#125; m &lt;&lt;= 2;&#125;void dfs(int cx, int cy, int o)&#123;//o代表当前填充的是框架还是白色块 vis[cx][cy] = 1; for(int i = 0; i &lt; 4; ++i)&#123; int ex = cx + dx[i], ey = cy + dy[i]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; !vis[ex][ey])&#123; if(o)&#123; if(!dat[ex][ey]) dat[ex][ey] = ++tot, dfs(ex, ey, 0); else if(dat[ex][ey] == 1) dfs(ex, ey, 1); &#125;else if(!dat[ex][ey]) dat[ex][ey] = tot, dfs(ex, ey, 0); &#125; &#125;&#125;void solve()&#123; memset(vis, 0, sizeof(vis)); tot = 2, cnt = 0; for(int i = 0; i &lt; n; ++i)&#123; if(!vis[i][0] &amp;&amp; !dat[i][0]) dfs(i, 0, 0); if(!vis[i][m - 1] &amp;&amp; !dat[i][m - 1]) dfs(i, m - 1, 0); &#125; for(int i = 0; i &lt; m; ++i)&#123; if(!vis[0][i] &amp;&amp; !dat[0][i]) dfs(0, i, 0); if(!vis[n - 1][i] &amp;&amp; !dat[n - 1][i]) dfs(n - 1, i, 0); &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; if(!vis[i][j] &amp;&amp; dat[i][j] == 1)&#123; int his = tot; dfs(i, j, 1); ans[cnt++] = lis[tot - his]; &#125; &#125; &#125; sort(ans, ans + cnt); ans[cnt] = '\0'; printf("%s\n", ans);&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), m = read(); if(!n &amp;&amp; !m) break; printf("Case %d: ", T); init(); solve(); &#125; return 0;&#125; 例6-15 UVa10305 Ordering Tasks题目链接 直接拓扑排序即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, du[105];int que[105], f, r, lis[105];bool e[105][105];void init()&#123; memset(du, 0, sizeof(du)); for(int i = 0; i &lt; m; ++i)&#123; int u = read(), v = read(); du[v]++; e[u][v] = 1; &#125;&#125;void solve()&#123; f = r = 0; for(int i = 1; i &lt;= n; ++i) if(!du[i]) que[r++] = i; int cnt = 0; while(r - f)&#123; int cur = que[f++]; lis[cnt++] = cur; for(int i = 1; i &lt;= n; ++i) if(e[cur][i])&#123; du[i]--; if(!du[i]) que[r++] = i; &#125; &#125; for(int i = 0; i &lt; n - 1; ++i) printf("%d ", lis[i]); printf("%d\n", lis[n - 1]); memset(e, 0, sizeof(e));&#125;int main()&#123; for(; ; ) &#123; n = read(), m = read(); if (!n &amp;&amp; !m) break; init(); solve(); &#125; return 0;&#125; 6-1 UVa673 Parentheses Balance题目链接 括号序列的匹配。。用栈模拟即可。我一开始没看清题，以为只要能配对即可，结果疯狂WA。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005];int st[10005], top;void init()&#123; fgets(s, 1000, stdin);&#125;void solve()&#123; int len = strlen(s), flag = 1; top = 0; for(int i = 0; i &lt; len; ++i)&#123; if(s[i] == '(' || s[i] == '[') st[top++] = s[i]; else if(s[i] == ')')&#123; if(top &amp;&amp; st[top - 1] == '(') top--; else&#123; flag = 0; break; &#125; &#125;else if(s[i] == ']')&#123; if(top &amp;&amp; st[top - 1] == '[') top--; else&#123; flag = 0; break; &#125; &#125; &#125; if(top) flag = 0; printf("%s\n", flag ? "Yes" : "No");&#125;int main()&#123; fgets(s, 1000, stdin); int T; sscanf(s, "%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 6-3 UVa536 Tree Recovery题目链接 和根据后序和中序求先序一样。只要知道先序的根在开头，后序的根在末尾即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s1[30], s2[30];int root, lc[250], rc[250];int get(int pl, int pr, int il, int ir)&#123; if(ir - il &lt; 0) return 0; int id = s1[pl], i; for(i = il; i &lt;= ir; ++i) if(s2[i] == id) break; int len = i - il; lc[id] = get(pl + 1, pl + len, il, i - 1); rc[id] = get(pl + len + 1, pr, i + 1, ir); return id;&#125;void getP(int id)&#123; if(lc[id]) getP(lc[id]); if(rc[id]) getP(rc[id]); printf("%c", id);&#125;void solve()&#123; int len = strlen(s1); root = get(0, len - 1, 0, len - 1); getP(root); printf("\n");&#125;int main()&#123; while(scanf("%s%s", s1, s2) == 2) solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>树形结构</tag>
        <tag>栈</tag>
        <tag>链表</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第五章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter5%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第五章部分习题的整合。 例5-1 UVa10474 Where is the Marble?题目链接 排序后二分查找即可。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, q, st[10005];void init()&#123; for(int i = 0; i &lt; n; ++i) st[i] = read(); sort(st, st + n);&#125;void solve()&#123; int x; for(int i = 0; i &lt; q; ++i)&#123; x = read(); int index = lower_bound(st, st + n, x) - st; if(st[index] == x) printf("%d found at %d\n", x, index + 1); else printf("%d not found\n", x); &#125;&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), q = read(); if(!n &amp;&amp; !q)break ; printf("CASE# %d:\n", T); init(); solve(); &#125; return 0;&#125; 例5-5 UVa12096 The SetStack Computer题目链接 将集合映射成数，然后进行操作。非常好的练习STL的题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef set&lt;int&gt; Set;map&lt;Set, int&gt; mp;int n, stack[10005], top, tot;Set st[2005];int getID(Set *s)&#123; if(!mp.count(*s))&#123; mp[*s] = tot, tot++; return tot - 1; &#125; return mp[*s];&#125;void push()&#123; stack[top++] = 0;&#125;void dup()&#123; stack[top] = stack[top - 1]; top++;&#125;void _union()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss; set_union(st[xa].begin(), st[xa].end(), st[xb].begin(), st[xb].end(), inserter(ss, ss.begin())); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void _inter()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss; set_intersection(st[xa].begin(), st[xa].end(), st[xb].begin(), st[xb].end(), inserter(ss, ss.begin())); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void add()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss = st[xb]; ss.insert(xa); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void init()&#123; n = read(); top = tot = 1; mp.clear(); Set s; mp[s] = 0, st[0] = s;&#125;void solve()&#123; char opr[12]; for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", opr); if(opr[0] == 'P')push(); if(opr[0] == 'D')dup(); if(opr[0] == 'U')_union(); if(opr[0] == 'I')_inter(); if(opr[0] == 'A')add(); printf("%d\n", st[stack[top - 1]].size()); &#125; printf("***\n");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 例5-7 UVa136 Ugly Numbers题目链接 用一个堆，每次取出最小的丑数，然后生成新的丑数。本题在其他地方有多个变种，故不在此贴出代码。答案：859963392 例5-8 UVa1592 Database题目链接 先对每一个字符串进行处理，将字符串映射为数后枚举c_1,c_2，然后从上到下扫描每一行，对同一行的两个格子打包成一个pair，然后再对pair进行映射，映射为当前的行号。之后即可判断是否有符合条件的r_1,r_2。和集合栈计算机那道题有异曲同工之妙。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, tab[10005][11];char s[110];map&lt;string, int&gt; mp1;map&lt;pair&lt;int, int&gt;, int&gt; mp2;void init()&#123; mp1.clear(); int tots = 0; for(int i = 0; i &lt; n; ++i)&#123; fgets(s, 99, stdin); int len = strlen(s); for(; isspace(s[len - 1]); --len) s[len - 1] = '\0'; for(int j = 0, k = 0, l = 0; j &lt; len; j = k, ++l)&#123; while(s[j] != ',' &amp;&amp; s[j] != '\0') ++j; s[j] = '\0'; string ss(s + k); if(!mp1.count(ss)) tab[i][l] = mp1[ss] = ++tots; else tab[i][l] = mp1[ss]; k = j + 1; &#125; &#125;&#125;void solve()&#123; int r1, r2, c1, c2; for(int i = 0; i &lt; m - 1; ++i) for(int j = i + 1; j &lt; m; ++j)&#123; mp2.clear(); for(int k = 0; k &lt; n; ++k)&#123; pair&lt;int,int&gt; pp(tab[k][i], tab[k][j]); if(!mp2.count(pp)) mp2[pp] = k + 1; else&#123; r1 = mp2[pp], r2 = k + 1, c1 = i + 1, c2 = j + 1; goto printans; &#125; &#125; &#125; printf("YES\n"); return ; printans: printf("NO\n%d %d\n%d %d\n", r1, r2, c1, c2);&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; m = read(); init(); solve(); &#125; return 0;&#125; 例5-12 UVa221 Urban Elevations题目链接 类似于扫描？对每一个建筑物左右两端的$x$坐标构成的序列排序去重，然后由于每两个$x$坐标之间的建筑物只会有一段，故使用一个数组保存坐标x_i右边这一段的高度。然后对建筑物从前往后（即按照$y$坐标升序）判断是否可见即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;double eps = 1e-5, xx[2005], zz[2005];struct City&#123; double x, y, lx, lz; int id, vis;&#125;;struct cmp&#123; inline bool operator()(const City&amp; c1, const City&amp; c2)&#123; if(c1.y - c2.y &lt; eps &amp;&amp; c1.y - c2.y &gt; -eps)return c1.x &lt; c2.x; return c1.y &lt; c2.y; &#125;&#125;;int n, len;City c[1005];void init()&#123; double tmp; for(int i = 0; i &lt; n; ++i) scanf("%lf%lf%lf%lf%lf", &amp;c[i].x, &amp;c[i].y, &amp;c[i].lx, &amp;tmp, &amp;c[i].lz), c[i].id = i + 1, c[i].vis = 0, xx[i &lt;&lt; 1] = c[i].x, xx[i &lt;&lt; 1 | 1] = c[i].x + c[i].lx; sort(c, c + n, cmp()); sort(xx, xx + n + n); len = unique(xx, xx + n + n) - xx; fill(zz, zz + len, 0.0);&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; int flag = 0, st = lower_bound(xx, xx + len, c[i].x) - xx; for(int j = st; xx[j] &lt; c[i].x + c[i].lx; ++j) if(c[i].lz &gt; zz[j]) flag = 1, zz[j] = c[i].lz; if(flag) c[i].vis = 1; &#125; for(int i = 0; i &lt; n; ++i) swap(c[i].x, c[i].y); sort(c, c + n, cmp()); int f = 0; for(int i = 0; i &lt; n; ++i) if(c[i].vis)&#123; if(f)printf(" "); printf("%d", c[i].id); if(!f)f = 1; &#125; printf("\n");&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(); if(!n)break ; else if(T &gt; 1)printf("\n"); printf("For map #%d, the visible buildings are numbered as follows:\n", T); init(); solve(); &#125; return 0;&#125; 5-2 UVa1594 Ducci Sequence题目链接直接模拟1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, d[20], dd[20];void init()&#123; n = read();&#125;void solve()&#123; bool ans = 0; for(int i = 0; i &lt; n; ++i) d[i] = read(); for(int i = 0; i &lt; 1001; ++i)&#123; int flag = 1; for(int j = 0; j &lt; n; ++j) if(d[j])&#123; flag = 0; break; &#125; if(flag)&#123; ans = 1; break; &#125;else &#123; for(int j = 0; j &lt; n - 1; ++j) dd[j] = abs(d[j] - d[j + 1]); dd[n - 1] = abs(d[n - 1] - d[0]); memcpy(d, dd, sizeof(d)); &#125; &#125; printf("%s\n", ans ? "ZERO" : "LOOP");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-3 UVa10935 Throwing cards away I题目链接 用队列模拟即可123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, que[505], l, r;void init()&#123; for(int i = 0; i &lt; n; ++i) que[i] = i + 1; l = 0, r = n;&#125;void solve()&#123; printf("Discarded cards:"); while(r - l &gt; 1)&#123; int a = que[l++]; printf(" %d", a); if(r - l &gt;= 2)printf(","); int b = que[l++]; que[r++] = b; &#125; printf("\nRemaining card: %d\n", que[l]);&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125; 5-4 UVa10763 Foreign Exchange题目链接 用multiset模拟即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;pair&lt;int, int&gt; p[500005];multiset&lt;pair&lt;int, int&gt; &gt; s;void init()&#123; for(int i = 0; i &lt; n; i++) p[i].first = read(), p[i].second = read();&#125;void solve()&#123; if(n &amp; 1)printf("NO\n"); else&#123; for(int i = 0; i &lt; n; ++i)&#123; pair&lt;int, int&gt; pp; pp.first = p[i].second, pp.second = p[i].first; if(!s.count(pp)) s.insert(p[i]); else s.erase(s.find(pp)); &#125; if(s.empty())printf("YES\n"); else printf("NO\n"); s.clear(); &#125;&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125; 5-5 UVa10391 Compound Words题目链接 用string类提供的各种方法即可。从每个词开始向下遍历，看看下面的词是不是以自己为前缀。如果不是就停止遍历，如果是那就看以自己为前缀的那个词的后缀是不是一个词（用set判断）。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;string&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;string s[120005];bool vis[120005] = &#123;0&#125;;int n;set&lt;string&gt; ss;void init()&#123; n = 0; while(cin &gt;&gt; s[n]) n++, ss.insert(s[n - 1]);&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; if(s[j].find(s[i]) == 0)&#123; string suff(s[j], s[i].length()); if(ss.count(suff)) vis[j] = 1; &#125;else break; &#125; &#125; for(int i = 0; i &lt; n; ++i) if(vis[i])cout &lt;&lt; s[i] &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; 5-6 UVa1595 Symmetry题目链接 先判断是否有这么一条竖线可以使得点的左右分布对称，再看是不是完全对称。方法很多，我采用了一个比较简单的写法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;pair&lt;int, int&gt; p[1005];void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) p[i].first = read(), p[i].second = read(); sort(p, p + n);&#125;void solve()&#123; int flag = 1, half; if(n &amp; 1) half = p[n &gt;&gt; 1].first &lt;&lt; 1; else half = p[(n &gt;&gt; 1) - 1].first + p[n &gt;&gt; 1].first ; for(int i = 0; i &lt; (n &gt;&gt; 1); ++i) if(p[n - i - 1].first + p[i].first != half)&#123; flag = 0; break; &#125; if(flag)&#123; for(int i = (n &gt;&gt; 1); i &lt; n; ++i) p[i].second = -p[i].second; sort(p + (n &gt;&gt; 1), p + n); for(int i = (n &gt;&gt; 1); i &lt; n; ++i) if(p[i].second + p[n - i - 1].second != 0 &amp;&amp; p[i].first * 2 != half)&#123; flag = 0; break; &#125; &#125; printf("%s\n", flag ? "YES" : "NO");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-7 UVa12100 Printer Queue题目链接 用一个队列模拟即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int pcnt[11], n, m;int que[10005][2], l, r;void init()&#123; n = read(), m = read(); memset(pcnt, 0, sizeof(pcnt)); for(int i = 0; i &lt; n; ++i) que[i][1] = i, pcnt[que[i][0] = read()]++; l = 0, r = n;&#125;void solve()&#123; int t; for(t = 1; r &gt; l; t++)&#123; for(; ; )&#123; int cur = que[l][0], flag = 0; for(int i = cur + 1; i &lt; 10; ++i) if(pcnt[i])&#123; flag = 1; break; &#125; if(flag) que[r][0] = cur, que[r++][1] = que[l][1], l++; else break; &#125; if(que[l][1] == m)break; pcnt[que[l][0]]--, l++; &#125; printf("%d\n", t);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-9 UVa1596 Bug Hunt题目链接 很神奇的模拟题。注意细节即可。在bug里找bug其乐无穷12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005][85];int line;struct Arr&#123; int size; map&lt;int, int&gt; mp;&#125;;Arr arr[130];int getVal(int id, int st)&#123; if(isalpha(s[id][st + 1]))&#123; int _val = getVal(id, st + 2); char c = s[id][st + 1]; if(_val &lt; 0 || arr[c].size &lt; 0 || _val &gt;= arr[c].size || !arr[c].mp.count(_val)) return -1; else return arr[c].mp[_val]; &#125;else&#123; int x = 0; for(st++; s[id][st] != ']'; ++st) x = x * 10 + s[id][st] - '0'; return x; &#125;&#125;bool getInitalized(int id)&#123; char c = s[id][0]; arr[c].mp.clear(); int val = getVal(id, 1); if(val &lt; 0)return false; arr[c].size = val; //printf("%d\n", val); return true;&#125;void solve()&#123; for(int i = 0; i &lt; 127; ++i) arr[i].size = -1; int ans; for(ans = 0; ans &lt; line; ++ans)&#123; char *sp = strchr(s[ans], '='); if(sp != NULL)&#123; int index = getVal(ans, 1); char c = s[ans][0]; if(index &lt; 0 || arr[c].size &lt; 0 || index &gt;= arr[c].size) break; else&#123; if(isalpha(*(sp + 1)))&#123; char cc = *(sp + 1); int x = getVal(ans, sp - s[ans] + 2); if(x &lt; 0 || arr[cc].size &lt; 0 || x &gt;= arr[cc].size || !arr[cc].mp.count(x)) break; else arr[c].mp[index] = arr[cc].mp[x]; &#125;else&#123; int x = 0; for(int st = sp - s[ans] + 1; isdigit(s[ans][st]); ++st) x = x * 10 + s[ans][st] - '0'; arr[c].mp[index] = x; &#125; &#125; &#125;else&#123; if(!getInitalized(ans)) break ; &#125; &#125; printf("%d\n", ans == line ? 0 : (ans + 1));&#125;int main()&#123; for(; ; )&#123; line = 0; for(; ; )&#123; fgets(s[line], 82, stdin); if(s[line][0] == '.') break; line++; &#125; if(!line)break; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>模拟</tag>
        <tag>离散化</tag>
        <tag>栈</tag>
        <tag>STL</tag>
        <tag>堆</tag>
        <tag>字符串</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第四章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter4%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第四章部分习题的整合。 例4-2 UVa489 Hangman Judge题目链接 模拟即可。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; #include &lt;math.h&gt; char b1[27]=&#123;0&#125;,n1[100005],n2[100005];int n=-1,solve(),res,lim1,i;int solve()&#123; int chance=6,all=0; lim1=strlen(n1); for(i=0;i&lt;lim1;i++)&#123; if(!b1[n1[i]-'a'])&#123; b1[n1[i]-'a']++;all++; &#125; &#125; lim1=strlen(n2); for(i=0;i&lt;lim1;i++)&#123; if(b1[n2[i]-'a'])&#123; b1[n2[i]-'a']--;all--; if(all==0&amp;&amp;(chance&gt;=0))return 1; &#125; else chance--; &#125; if(chance&lt;0)return -1; if(all&gt;0)return 0;&#125;int main()&#123; for(scanf("%d",&amp;n);n!=-1;n=-1,scanf("%d",&amp;n))&#123; scanf("%s%s",n1,n2); res=solve(); printf("Round %d\n",n); if(res==1)printf("You win.\n"); if(res==0)printf("You chickened out.\n"); if(res==-1)printf("You lose.\n"); memset(b1,0,sizeof(b1)); &#125; return 0; &#125; 例4-3 UVa133 The Dole Queue题目链接 按照题意模拟即可。1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;int p[25], n, k, m;int main()&#123; for(n = 0,scanf("%d%d%d", &amp;n, &amp;k, &amp;m); n != 0; n = 0,scanf("%d%d%d", &amp;n, &amp;k, &amp;m))&#123; for(int i = 1; i &lt;= n; ++i) p[i] = i; for(int l = 0, tmp = n, r = n + 1; tmp; )&#123; int s = k % tmp; if(!s)s = tmp; for(; s; )&#123; ++l; if(l &gt; n)l = 1; if(p[l])s--; &#125; s = m % tmp; if(!s)s = tmp; for(; s; )&#123; --r; if(r &lt; 1)r = n; if(p[r])s--; &#125; if(l != r) printf("%3d%3d", p[l], p[r]), tmp -= 2; else printf("%3d", p[l]), tmp--; p[l] = p[r] = 0; if(tmp)putchar(','); &#125; putchar('\n'); &#125; return 0;&#125; 4-1 UVa1589 Xiangqi题目链接 长的模拟注意当开始就将帅碰头的时候，不能认为黑方必胜。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,bx,by,loc[10][3],puz[15][15];//g 0 c 1 h 2 r 3int dx[]=&#123;-1,0,0,1&#125;,dy[]=&#123;0,1,-1,0&#125;;int ddx[]=&#123;-2,-2,-1,1,-1,1,2,2&#125;,ddy[]=&#123;-1,1,2,2,-2,-2,-1,1&#125;;bool ask(int cx,int cy)&#123; for(int i=0;i&lt;n;i++)&#123; int kx=loc[i][1],ky=loc[i][2]; if(kx==cx&amp;&amp;cy==ky)continue; if(loc[i][0]==0)&#123; int flag=1; if(cy!=ky)continue; for(int j=cx+1;j&lt;kx;j++) if(puz[j][cy])&#123; flag=0;break; &#125; if(flag)return true; &#125;else if(loc[i][0]==1)&#123; int cnt=0; if(cx==kx)&#123; for(int j=min(cy,ky)+1;j&lt;max(cy,ky);j++) if(puz[cx][j])cnt++; &#125;else if(cy==ky)&#123; for(int j=min(cx,kx)+1;j&lt;max(cx,kx);j++) if(puz[j][cy])cnt++; &#125; if(cnt==1)return true; &#125;else if(loc[i][0]==2)&#123; for(int j=0;j&lt;8;j++)&#123; int ccx=kx+ddx[j],ccy=ky+ddy[j]; if(ccx==cx&amp;&amp;ccy==cy&amp;&amp;!puz[kx+dx[j&gt;&gt;1]][ky+dy[j&gt;&gt;1]]) return true; &#125; &#125;else&#123; int flag=1; if(cx==kx)&#123; for(int j=min(cy,ky)+1;j&lt;max(cy,ky);j++) if(puz[cx][j])&#123; flag=0;break; &#125; &#125;else if(cy==ky)&#123; for(int j=min(cx,kx)+1;j&lt;max(cx,kx);j++) if(puz[j][cy])&#123; flag=0;break; &#125; &#125;else flag=0; if(flag)return true; &#125; &#125; return false;&#125;void init()&#123; memset(puz,0,sizeof(puz)); bx=read(),by=read(); char s[3]; for(int i=0;i&lt;n;i++)&#123; scanf("%s%d%d",s,&amp;loc[i][1],&amp;loc[i][2]); if(s[0]=='G')loc[i][0]=0; if(s[0]=='C')loc[i][0]=1; if(s[0]=='H')loc[i][0]=2; if(s[0]=='R')loc[i][0]=3; puz[loc[i][1]][loc[i][2]]=1; &#125;&#125;void solve()&#123; int ans=1; for(int i=0;i&lt;4;i++)&#123; int cx=bx+dx[i],cy=by+dy[i]; if(!cx||cx&gt;3||cy&lt;4||cy&gt;6)continue; puz[cx][cy]=1; if(!ask(cx,cy))&#123; ans=0;break; &#125; puz[cx][cy]=0; &#125; if(!ans)printf("NO\n"); else printf("YES\n");&#125;int main()&#123; while(n=read())&#123; init(); solve(); &#125; return 0;&#125; 4-4 UVa253 Cube painting题目链接 让第一个骰子不断向左/向上翻转，直到所有视图均被翻出位置。若此时所有翻出的可能的视图中没有第二个骰子的视图则认为两个骰子不等价。反之等价。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool vis[1000];char s[15];int h2,k1[]=&#123;4,0,2,3,5,1&#125;,k2[]=&#123;0,2,4,1,3,5&#125;;int cg(char c)&#123; if(c=='r')return 0; if(c=='g')return 1; if(c=='b')return 2;&#125;void dfs(int hs)&#123; int bs[7],hh1=0,hh2=0; for(int i=5;i&gt;=0;i--)bs[i]=hs%3,hs/=3; for(int i=0;i&lt;6;i++)hh1=hh1*3+bs[k1[i]]; for(int i=0;i&lt;6;i++)hh2=hh2*3+bs[k2[i]]; if(!vis[hh1])vis[hh1]=1,dfs(hh1); if(!vis[hh2])vis[hh2]=1,dfs(hh2);&#125;void init()&#123; memset(vis,0,sizeof(vis)); int h1=0;h2=0; for(int i=0;i&lt;6;i++)h1=h1*3+cg(s[i]); for(int i=6;i&lt;12;i++)h2=h2*3+cg(s[i]); vis[h1]=1; dfs(h1);&#125;void solve()&#123; if(vis[h2])printf("TRUE\n"); else printf("FALSE\n");&#125;int main()&#123; while(scanf("%s",s)==1)&#123; init(); solve(); &#125; return 0;&#125; 4-5 UVa1590 IP Networks题目链接 模拟即可熟悉位运算的好题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef unsigned int u_int;u_int ip[1005] = &#123;0&#125;;int m;void init()&#123; memset(ip, 0, sizeof(ip)); for(int i = 0; i &lt; m; ++i) for(int j = 3; j &gt;= 0; --j)&#123; u_int t = read(); ip[i] += (t &lt;&lt; (j * 8)); &#125;&#125;void solve()&#123; int n = 0, i; for(; n &lt;= 31; ++n)&#123; u_int pp = ~((1 &lt;&lt; n) - 1); for(i = 1; i &lt; m; ++i) if((pp &amp; ip[i]) != (pp &amp; ip[i - 1]))break ; if(i == m)break ; &#125; u_int ans = ~((1 &lt;&lt; n) - 1), t = 0xff000000; ip[0] &amp;= ans; for(int j = 3; j &gt;= 0; --j) printf("%u%s", (ip[0] &amp; t) &gt;&gt; (j * 8), j ? "." : "\n"), t &gt;&gt;= 8; t = 0xff000000; for(int j = 3; j &gt;= 0; --j) printf("%u%s", (ans &amp; t) &gt;&gt; (j * 8), j ? "." : "\n"), t &gt;&gt;= 8;&#125;int main()&#123; while(scanf("%d", &amp;m) == 1)&#123; init(); solve(); &#125; return 0;&#125; 4-7 UVa509 RAID!题目链接 模拟…即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int d, s, b, val, seq[100005];char data[7][6500];void init()&#123; char ord[3]; s = read(), b = read(); scanf("%s", ord); val = (ord[0] == 'E' ? 0 : 1); for(int i = 0; i &lt; d; ++i) scanf("%s", data[i]);&#125;void solve()&#123; int cur = 0, tot = 0; for(int i = 0; i &lt; b; ++i)&#123; for(int j = 0; j &lt; s; ++j)&#123; //当前的校验块在磁盘号为cur int c = 0, cnt = 0, id; for(int k = 0; k &lt; d; ++k)&#123; if(data[k][i * s + j] == 'x') cnt++, id = k;//坏的在id处 else c ^= (data[k][i * s + j] - '0'); &#125; if(cnt &gt;= 2) goto failed; else if(cnt == 1) data[id][i * s + j] = (c ^ val) + '0'; else&#123; if(c != val)//校验错误 goto failed; &#125; &#125; for(int j = 0; j &lt; d; ++j)&#123; if(j == cur)continue ; for(int k = 0; k &lt; s; ++k)&#123; if(data[j][i * s + k] - '0') seq[tot &gt;&gt; 2] += (1 &lt;&lt; (3 - (tot % 4))); tot++; &#125; &#125; cur = (cur + 1) % d; &#125; printf("valid, contents are: "); while(tot % 4)tot++; tot &gt;&gt;= 2; for(int i = 0; i &lt; tot; ++i)&#123; if(seq[i] &lt; 10)printf("%d", seq[i]); else putchar(seq[i] - 10 + 'A'); &#125; printf("\n"); return ; failed: printf("invalid.\n");&#125;int main()&#123; for(int T = 1; ; ++T)&#123; d = read(); if(!d)break ; printf("Disk set %d is ", T); init(); solve(); memset(seq, 0, sizeof(seq)); &#125; return 0;&#125; 4-9 Uva1591 Data Mining（待补充） 4-10 UVa815 Flooded!题目链接 先对高度排一个序，然后从最下方向上面淹即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m;double h[905], V;void init()&#123; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) h[i * m + j] = read(); V = read(), V /= 100.0; sort(h, h + n * m); h[n * m] = 100000000;&#125;void solve()&#123; double tot = 0.0, ans1, ans2; int i; for(i = 1; i &lt;= n * m; ++i)&#123; tot += h[i - 1]; if(V &lt; i * h[i] - tot) break; &#125; ans1 = (V + tot) / (double)i, ans2 = 100.0 * i / (n * m); printf("Water level is %.2lf meters.\n%.2lf percent of the region is under water.\n\n", ans1, ans2); &#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), m = read(); if(!n &amp;&amp; !m)break ; printf("Region %d\n", T); init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第三章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter3%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第三章部分习题的整合。 例3-1 TEX Quotes题目链接 简单模拟123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void init()&#123; &#125;void solve()&#123; char c; int flag=0; while((c=getchar())!=EOF)&#123; if(c!='"')putchar(c); else&#123; if(flag)putchar('\''),putchar('\''),flag=0; else putchar('`'),putchar('`'),flag=1; &#125; &#125;&#125;int main()&#123;、 init(); solve(); return 0;&#125; 例3-2 UVa10082 WERTYU题目链接 模拟12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[]="`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./'";void init()&#123; &#125;void solve()&#123; char c; while((c=getchar())!=EOF)&#123; int ind; if(isspace(c))putchar(c); else&#123; for(ind=0;s[ind]!=c;ind++); putchar(s[ind-1]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-3 UVa401 Palindromes题目链接 常量数组技巧！123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char rev_al[]="A 3 HIL JM O 2TUVWXY5",rev_num[]="1SE Z 8 ";char ask(char c)&#123; if(isalpha(c))return rev_al[c-'A']; if(isdigit(c))return rev_num[c-'1'];&#125;void init()&#123; &#125;void solve()&#123; char s[30]; while(scanf("%s",s)==1)&#123; int len=strlen(s),f1=1,f2=1; for(int i=0;i&lt;(len+1)/2;i++) if(s[i]!=s[len-i-1])&#123;f1=0;break;&#125; for(int i=0;i&lt;(len+1)/2;i++) if(s[len-i-1]!=ask(s[i]))&#123;f2=0;break;&#125; if(f1&amp;&amp;f2)printf("%s -- is a mirrored palindrome.\n",s); if((!f1)&amp;&amp;f2)printf("%s -- is a mirrored string.\n",s); if(f1&amp;&amp;(!f2))printf("%s -- is a regular palindrome.\n",s); if((!f1)&amp;&amp;(!f2))printf("%s -- is not a palindrome.\n",s); putchar('\n'); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-4 UVa340 Master-Mind Hints题目链接 模拟123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,numa[1005],numb[1005],co[10],ca[10],cb[10];void init()&#123; memset(co,0,sizeof(co)); for(int i=0;i&lt;n;i++) numa[i]=read(),co[numa[i]]++;&#125;void solve()&#123; for(;;)&#123; memset(cb,0,sizeof(cb)); memcpy(ca,co,sizeof(co)); int ans1=0,ans2=0; for(int i=0;i&lt;n;i++)&#123; numb[i]=read(),cb[numb[i]]++; if(numa[i]==numb[i])ans1++,ca[numa[i]]--,cb[numb[i]]--; &#125; if(!numb[0])break; for(int i=1;i&lt;=9;i++) ans2+=min(ca[i],cb[i]); printf(" (%d,%d)\n",ans1,ans2); &#125;&#125;int main()&#123; for(int T=1;;T++)&#123; n=read(); if(!n)break; printf("Game %d:\n",T); init(); solve(); &#125; return 0;&#125; 例3-5 UVa1583 Digit Generator题目链接 模拟123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int tab[100005]=&#123;0&#125;;void init()&#123; for(int i=1;i&lt;=100000;i++)&#123; int tmp=i,tot=i; while(tmp)tot+=tmp%10,tmp/=10; if(tot&lt;=100000&amp;&amp;!tab[tot])tab[tot]=i; &#125;&#125;void solve()&#123; for(int n=read();n;n--)printf("%d\n",tab[read()]);&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-6 UVa1584 Circular Sequence题目链接 模拟12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[1005];int len;void init()&#123; scanf("%s",s); len=strlen(s),memcpy(s+len,s,sizeof(char)*len);&#125;void solve()&#123; int ans=0; for(int t=1;t&lt;len;t++)&#123; int flag=1; for(int j=0;j&lt;len;j++) if(s[t+j]&lt;s[ans+j])&#123;flag=0;break;&#125; else if(s[t+j]&gt;s[ans+j])break; if(!flag)ans=t; &#125; for(int i=0;i&lt;len;i++) putchar(s[i+ans]); putchar('\n');&#125;int main()&#123; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-1 UVa1585 Score题目链接 模拟123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[100];void init()&#123; scanf("%s",s);&#125;void solve()&#123; int len=strlen(s),tot=0,sc=0; for(int i=0;i&lt;len;i++)&#123; if(s[i]=='O')tot++,sc+=tot; else tot=0; &#125; printf("%d\n",sc);&#125;int main()&#123; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-2 UVa1586 Score题目链接 模拟123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[100];double mass[26];void init()&#123; scanf("%s",s);&#125;void solve()&#123; double ans=0.0; int len=strlen(s),tot=0,ind=0; for(int i=0;i&lt;len;i++)&#123; if(isalpha(s[i]))&#123; if(ind&amp;&amp;!tot)tot=1; ans+=tot*mass[ind],tot=0,ind=s[i]-'A'; &#125;else tot=tot*10+s[i]-'0'; &#125; if(ind&amp;&amp;!tot)tot=1; ans+=tot*mass[ind]; printf("%.3lf\n",ans);&#125;int main()&#123; mass[0]=0; mass[2]=12.010,mass[7]=1.008,mass[14]=16.000,mass[13]=14.010; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-3 UVa1225 Digit Counting题目链接 模拟1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int T,tab[10005]=&#123;0&#125;,ans[22][11],cnt[11]=&#123;0&#125;,maxn=0;void init()&#123; T=read(); for(int i=0;i&lt;T;i++)&#123; int t=read(); tab[t]=i+1,maxn=max(maxn,t); &#125;&#125;void solve()&#123; for(int i=1;i&lt;=maxn;i++)&#123; int tmp=i; while(tmp)cnt[tmp%10]++,tmp/=10; if(tab[i])&#123; int ind=tab[i]; for(int j=0;j&lt;10;j++)ans[ind][j]=cnt[j]; &#125; &#125; for(int i=1;i&lt;=T;i++)&#123; for(int j=0;j&lt;9;j++)printf("%d ",ans[i][j]); printf("%d\n",ans[i][9]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 3-4 UVA455 Periodic Strings题目链接 这题有多种做法，这里选的是最容易想到的一种。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[1005];int main()&#123; int N=read(),flag=0; while(N--)&#123; scanf("%s",s); int len=strlen(s),ans=len; for(int i=1;i&lt;len;i++) if(len%i==0)&#123; int fl=1; for(int j=i;j&lt;len;j++) if(s[j]!=s[j%i])&#123;fl=0;break;&#125; if(fl)&#123;ans=i;break;&#125; &#125; if(!flag)flag=1; else putchar('\n'); printf("%d\n",ans); &#125;; return 0;&#125; 3-5 UVa227 Puzzle题目链接 这题神坑 有可能拼图里面有字母Z 最后一行的空行不能有，不然无限WA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char puz[7][7],list[100005],tmp[100005];int len,x,y;bool readPuzzle()&#123; char c[10]; for(int i=0;i&lt;5;i++)&#123; fgets(c,10,stdin); if(c[0]=='Z'&amp;&amp;strlen(c)&lt;5)return false; for(int j=0;j&lt;5;j++) if(isalpha(c[j]))puz[i][j]=c[j]; else if(c[j]==' ')puz[(x=i)][(y=j)]=c[j]; &#125; return true;&#125;bool move(int id)&#123; if(list[id]=='A')&#123; if(!x)return false; swap(puz[x-1][y],puz[x][y]),x--; return true; &#125; if(list[id]=='B')&#123; if(x==4)return false; swap(puz[x+1][y],puz[x][y]),x++; return true; &#125; if(list[id]=='L')&#123; if(!y)return false; swap(puz[x][y],puz[x][y-1]),y--; return true; &#125; if(list[id]=='R')&#123; if(y==4)return false; swap(puz[x][y+1],puz[x][y]),y++; return true; &#125; return false;&#125;void solve()&#123; int flag=1; for(int _flag=1;_flag;)&#123; fgets(list,100000,stdin); int len=strlen(list); for(int i=0;i&lt;len;i++)&#123; //printf("%c",list[i]); if(isalpha(list[i]))&#123; if(!move(i)&amp;&amp;flag)&#123; printf("This puzzle has no final configuration.\n"); flag=0; &#125; &#125;else if(list[i]=='0')&#123; _flag=0; break; &#125;else if(!isspace(list[i]))&#123; if(flag) printf("This puzzle has no final configuration.\n"),flag=0; &#125; &#125; &#125; if(flag)&#123; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;4;j++) printf("%c ",puz[i][j]); printf("%c\n",puz[i][4]); &#125; &#125;&#125;int main()&#123; int T=1; while(readPuzzle())&#123; if(T!=1)putchar('\n'); printf("Puzzle #%d:\n",T++); solve(); memset(puz,0,sizeof(puz)); &#125; return 0;&#125; 3-8 UVa202 Repeating Decimals题目链接 模拟只要除出来了一样的余数就停止因为除数不是很大，所以余数不算多，可以完成12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int m,n,vis[3005]=&#123;0&#125;,lis[3105];void init()&#123; printf("%d/%d = %d.",m,n,m/n); m%=n;&#125;void solve()&#123; int ans=1,pace=1; memset(vis,0,sizeof(vis)); for(;m;pace++)&#123; if(vis[m])break; vis[m]=pace,m*=10; lis[pace]=m/n,m%=n; &#125; if(!m)&#123; for(int i=1;i&lt;pace;i++) printf("%d",lis[i]); printf("(0)\n"); &#125;else &#123; for(int i=1;i&lt;vis[m];i++) printf("%d",lis[i]); printf("("); if(pace&lt;=50)&#123; for(int i=vis[m];i&lt;pace;i++) printf("%d",lis[i]); printf(")\n"); &#125;else&#123; for(int i=vis[m];i&lt;=50;i++) printf("%d",lis[i]); printf("...)\n"); &#125; ans=pace-vis[m]; &#125; printf(" %d = number of digits in repeating cycle\n\n",ans);&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)==2)&#123; init(); solve(); &#125; return 0;&#125; 3-10 UVa1587 Box题目链接保证构成一个长方体需要： 有3组相同的面 有3组长宽高 判断即可。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;pair&lt;int,int&gt; p[7];int a[19];void init()&#123; for(int i=1;i&lt;6;i++) scanf("%d%d",&amp;p[i].first,&amp;p[i].second); for(int i=0;i&lt;6;i++)&#123; if(p[i].first&lt;p[i].second) swap(p[i].first,p[i].second); a[i&lt;&lt;1]=p[i].first,a[i&lt;&lt;1|1]=p[i].second; &#125; sort(a,a+12); sort(p,p+6);&#125;void solve()&#123; int ans=1; for(int i=0;i&lt;6;i+=2) if(p[i].first!=p[i+1].first||p[i].second!=p[i+1].second)&#123; ans=0;break; &#125; for(int i=0;i&lt;12;i+=4) if(a[i]!=a[i+1]||a[i]!=a[i+2]||a[i]!=a[i+3])&#123; ans=0;break; &#125; if(!ans)printf("IM"); printf("POSSIBLE\n");&#125;int main()&#123; while(scanf("%d%d",&amp;p[0].first,&amp;p[0].second)==2)&#123; init(); solve(); &#125; return 0;&#125; 3-12 UVa11809 Floating-Point Numbers题目链接 数字都很大，用数字的对数比较。事先对不同M和E打个表，然后比即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;double tab[11][50],eps=1e-6;//M Evoid init()&#123; double t=0.5,u=0.5; for(int i=0;i&lt;=9;i++)&#123; for(int j=1;j&lt;=30;j++)&#123; double k=(double)((1&lt;&lt;j)-1); tab[i][j]=k*log(2.0)+log(t); &#125; u*=0.5,t+=u; &#125;&#125;void solve()&#123; char s[50]; while(scanf("%s",s)==1)&#123; if(strlen(s)==3)break; s[17]=' '; double t,u,g; sscanf(s,"%lf%lf",&amp;t,&amp;u); g=u*log(10.0)+log(t); for(int i=0;i&lt;=9;i++) for(int j=1;j&lt;=30;j++) if(g-tab[i][j]&lt;eps&amp;&amp;g-tab[i][j]&gt;-eps)&#123; printf("%d %d\n",i,j); break; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fwriting%2Fnoip2017%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2017十道题目的题解。 提高D1T1 小凯的疑惑题目链接 和USACO上的麦香牛块差不多，套上公式即可。最大的数即为$ab-a-b$。12345678910111213141516#include &lt;iostream&gt;#define INF 2000000000using namespace std;typedef unsigned long long ll;ll s, t;void init()&#123; cin &gt;&gt; s &gt;&gt; t;&#125;void solve()&#123; cout &lt;&lt; s * t - s - t &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2010%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2010八道题目的题解。 普及T1 数字统计题目地址 某一道普及的弱化版。模拟即可。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int l,r,ans=0;int main()&#123; scanf("%d%d",&amp;l,&amp;r); for(int i=l;i&lt;=r;i++)&#123; int t=i; while(t)ans+=(t%10==2),t/=10; &#125; printf("%d\n",ans); return 0;&#125; 普及T2 接水问题题目地址 模拟即可。可以用堆加速，但我的代码里没用。不用堆的时间复杂度是$O(nm)$，用的话是$O(nlogm)$。12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int n,m,at[105],w[10005],f=0,ans=0; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d",&amp;at[i]); for(int i=m;i&lt;n;i++) scanf("%d",&amp;w[i-m]); for(;;)&#123; int mini=INF; for(int i=0;i&lt;m;i++) if(at[i]&gt;0&amp;&amp;at[i]&lt;mini)mini=at[i]; if(mini==INF)break; ans+=mini; for(int i=0;i&lt;m;i++) if(at[i]&gt;0)&#123; at[i]-=mini; if(!at[i])&#123; if(f!=n-m)at[i]=w[f++]; else at[i]=-1; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 普及T3 导弹拦截题目地址 此题致敬了11年前的那道经典题目。我们希望这个工作半径最小，直觉上就要让这两个系统都被充分利用。也就是让第一套拦截一部分，第二套拦截另一部分。我们先对所有导弹到第一套系统的距离从近到远排一个序，企图把这个序列切成$2$份，将前半部分给第一个系统，将后半部分（远的）给第二个系统。枚举切开的部位，找到第二套系统应该有的工作半径，也就是分配给第二套系统的最远导弹到他的距离。这里用各种方法实现，我用的是对所有导弹到第二套系统的距离从远到近排一个序，然后用一个指针扫的方法。综上，解决本题的时间复杂度为$O(nlogn)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int id,dis;&#125;Mis;Mis mis[200005];bool operator&lt;(Mis a,Mis b)&#123;return a.dis&lt;b.dis;&#125;int p1[2],p2[2],n,at;//p1 x p2 ybool vis[100005]=&#123;0&#125;;int ask()&#123;//找第二套应该有的工作半径 while(vis[mis[at].id]&amp;&amp;at&lt;2*n) at++; if(at==2*n)return 0; else return mis[at].dis;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;p1[0],&amp;p2[0],&amp;p1[1],&amp;p2[1],&amp;n); int i,j,l1,l2,ans=2000000000; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;l1,&amp;l2), mis[i].dis=(p1[0]-l1)*(p1[0]-l1)+ (p2[0]-l2)*(p2[0]-l2), mis[i+n].dis=-(p1[1]-l1)*(p1[1]-l1)- (p2[1]-l2)*(p2[1]-l2), mis[i].id=mis[i+n].id=i; sort(mis,mis+n), sort(mis+n,mis+n+n), at=n; ans=min(ans,-ask());//全部分配给第二套 for(i=0;i&lt;n;i++) vis[mis[i].id]=1, ans=min(ans,(mis[i].dis-ask())); printf("%d\n",ans); return 0;&#125; 普及T4 三国游戏题目地址 这个人肯定不会输给电脑。因为计算机的选将是完全根据这个人的选法来的，也就是说，这个人自己是一定有把握选中更好的策略的。然后具体选法，非常简单：最大的一定被拆，所以我们矮子里拔高个儿，选默契值排第二且是所有第二中最高的一对将。这样就做完了。时间复杂度：$O(n^2)$。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,mat[505][505]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) scanf("%d",&amp;mat[i][j]), mat[j][i]=mat[i][j];&#125;void solve()&#123; int max1=0,max2=0,ans=0; for(int i=0;i&lt;n;i++)&#123; max1=max2=0; for(int j=0;j&lt;n;j++)&#123; if(mat[i][j]&gt;max1)max2=max1,max1=mat[i][j]; else if(mat[i][j]&gt;max2)max2=mat[i][j]; &#125; ans=max(ans,max2); &#125; printf("1\n%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 机器翻译题目地址 用队列模拟即可。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool vis[1005];int w,m,n,que[100005],f=0,r=0;void init()&#123; m=read(),n=read();&#125;void solve()&#123; int ans=0; while(n--)&#123; w=read(); if(!vis[w])&#123; vis[w]=1,que[r++]=w,ans++; if(r-f==m+1)vis[que[f++]]=0; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T2 乌龟棋题目地址 按卡片数$DP$即可。只要知道每一种卡片的使用情况就可以推知当前所处位置，从而进行状态转移。设$f(i,j,k,l)$表示用了$i$张$1$，$j$张$2$，$k$张$3$，$l$张$4$的最大得分，则状态转移方程容易导出。1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define dis(a,b,c,d) score[1+a+(b&lt;&lt;1)+(d&lt;&lt;2)+(c&lt;&lt;2)-c]#define fep(a,b) for(a=0;a&lt;=cnt[b];a++)using namespace std;int dp[41][41][41][41]=&#123;0&#125;,n,m,cnt[4]=&#123;0&#125;,score[353];int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v,d; for(i=1;i&lt;=n;i++) scanf("%d",&amp;score[i]); for(i=0;i&lt;m;i++) scanf("%d",&amp;j),cnt[j-1]++; dp[0][0][0][0]=score[1]; fep(i,0)fep(j,1)fep(u,2)fep(v,3)&#123; d=dis(i,j,u,v); if(i)dp[i][j][u][v]=max(dp[i-1][j][u][v]+d,dp[i][j][u][v]); if(j)dp[i][j][u][v]=max(dp[i][j-1][u][v]+d,dp[i][j][u][v]); if(u)dp[i][j][u][v]=max(dp[i][j][u-1][v]+d,dp[i][j][u][v]); if(v)dp[i][j][u][v]=max(dp[i][j][u][v-1]+d,dp[i][j][u][v]); &#125; printf("%d\n",dp[cnt[0]][cnt[1]][cnt[2]][cnt[3]]); return 0;&#125; 提高T3 关押罪犯（待考察）题目地址 贪心。将仇恨值从大到小排序，从仇恨最大的一对人开始处理起。记录每一个人的“对手”，看作是这个人和“对手”必须处在不同监狱。如果两人所处监狱相同那就表示分配到此为止，输出答案。然后分类讨论，假设两人都还没有对手就互相记为对手，表示两人不会在一个监狱；只有一个人有对手，那就另一个人把这个人记为对手，并且把这个人的对手收为己方（用并查集实现）；两个人都有，那就收各自的对手为己方。讨论完之后，处理下一对罪犯，如此反复。这样就可以在$O(mlogm)$的时间复杂度内解决这个问题。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int parent[20005],riv[20005]=&#123;0&#125;,m,n,re[100005][3];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;&#125;void init(int k)&#123; for(int i=1;i&lt;=k;i++)parent[i]=i;&#125;int Find(int a)&#123; if(parent[a]==a)return a; return (parent[a]=Find(parent[a]));&#125;void joint(int x,int y)&#123; int a=Find(x),b=Find(y); if(a==b)return; parent[b]=a;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(n);int i,k1,k2,t1,t2; for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;re[i][1],&amp;re[i][2],&amp;re[i][0]); qsort(re,m,sizeof(re[0]),cmp); for(i=0;i&lt;m;i++)&#123; t1=re[i][1],t2=re[i][2]; if(Find(t1)==Find(t2))break; if(riv[t2]&amp;&amp;!riv[t1])swap(t1,t2); if(!riv[t2])&#123; if(!riv[t1])riv[t1]=t2,riv[t2]=t1; else riv[t2]=t1,joint(t2,riv[t1]); &#125;else joint(t2,riv[t1]),joint(t1,riv[t2]); &#125; if(i==m)printf("0\n"); else printf("%d\n",re[i][0]); return 0;&#125; 提高T4 引水入城题目地址 先搜索，搜出每一个出水站能最多支援几个国家。然后会发现每一个国家能支援到的国家一定是一段一段存在的。如果不是，那么会形成一些国家无法被到达的局面，就输出$0$，然后统计。否则对每段区间排序后贪心选择即可。可以用一些手段加速，如对在第一行的国家，只选取相对周围的国家更高一些的国家来搜索，因为这个国家肯定可以向两侧扩展。时间复杂度：$O(nm)$（近似）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;bool dp[505][505],able[505][505]=&#123;0&#125;;int n,m,h[505][505],par[505],res,ans,dx[]=&#123;-1,0,0,1&#125;,dy[]=&#123;0,-1,1,0&#125;;int stack[250005][2],top=0;void dfs(int x,int y)&#123; int nx,ny,i; stack[top][0]=x,stack[top++][1]=y; while(top)&#123; x=stack[--top][0],y=stack[top][1]; for(i=0;i&lt;4;i++)&#123; nx=x+dx[i],ny=y+dy[i]; if(nx&gt;=0&amp;&amp;ny&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&lt;m&amp;&amp; h[nx][ny]&lt;h[x][y]&amp;&amp;!dp[nx][ny]) dp[nx][ny]=1,stack[top][0]=nx,stack[top++][1]=ny; &#125; &#125;&#125;void _solve()&#123; int i,j,p,k,rec[505][2],tot=0,l,r; for(ans=1,i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; p=par[i-1],k=0; while(k&lt;m&amp;&amp;!able[p][k])k++; rec[tot][0]=k; if(tot&amp;&amp;rec[tot-1][0]==k)tot--; while(k&lt;m&amp;&amp;able[p][k])k++; rec[tot++][1]=k-1; if(k-1&lt;rec[tot-1][0])tot--; j=i-1; &#125; for(l=rec[0][0],r=rec[0][1],i=1;i&lt;tot;i++)&#123; while(i&lt;tot&amp;&amp;rec[i][0]&lt;=r+1)i++; if(r==m-1)break; i--,r=rec[i][1],ans++; &#125;&#125;void solve()&#123; int i,j,k; for(i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; memset(dp,0,sizeof(dp)); dp[0][par[i-1]]=1,dfs(0,par[i-1]); memcpy(able[par[i-1]],dp[n-1],sizeof(bool)*m); j=i-1; &#125; bool cnt[505]=&#123;0&#125;; for(k=i=0;i&lt;m;i++) for(j=0;j&lt;m;j++) if(able[par[i]][j]&amp;&amp;!cnt[j])cnt[j]=1,k++; res=(k==m)?1:0; if(res)_solve(); else ans=m-k; printf("%d\n%d\n",res,ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,maxi,lst; for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++) scanf("%d",&amp;h[i][j]); for(i=0;i&lt;m;i++)&#123; while(i&lt;m-1&amp;&amp;h[0][i+1]&gt;h[0][i])i++; for(j=i-1;j&gt;=0&amp;&amp;h[0][j]&lt;h[0][j+1];j--) par[j]=i; par[i]=i; for(j=i+1;j&lt;m&amp;&amp;h[0][j]&lt;h[0][j-1];j++) par[j]=i; while(i&lt;m-1&amp;&amp;h[0][i+1]&lt;h[0][i])i++; &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>堆</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2009%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2009八道题目的题解。 普及T1 多项式输出题目地址 只要读懂了题就不难了。模拟即可，代码可能有点长。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int n,xs;int main()&#123; scanf("%d",&amp;n); for(int i=n;i&gt;=0;i--)&#123; scanf("%d",&amp;xs); if(xs!=0)&#123; if(i==n)&#123; if(abs(xs)==1)&#123; if(xs==-1)putchar('-'); &#125;else printf("%d",xs); &#125;else if(i==1)&#123; if(xs==1)printf("+x"); else if(xs==-1)printf("-x"); else printf("%+dx",xs); continue; &#125;else if(i==0)&#123; printf("%+d",xs); break; &#125;else &#123; if(xs==1)printf("+"); else if(xs==-1)printf("-"); else printf("%+d",xs); &#125; printf("x^%d",i); &#125; &#125; printf("\n"); return 0;&#125; 普及T2 分数线划定题目地址 根据题目描述来模拟和排序即可。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[10005];bool cmp(const P &amp;pa,const P &amp;pb)&#123; return pa.first&gt;pb.first||(pa.first==pb.first&amp;&amp;pa.second&lt;pb.second);&#125;int n,m,lim;int main()&#123; scanf("%d%d",&amp;n,&amp;m); lim=m*150/100; for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;p[i].second,&amp;p[i].first); sort(p,p+n,cmp); int sc=p[lim-1].first,extra=0; for(int i=lim;i&lt;n;i++) if(p[i].first==sc)extra++; else break; printf("%d %d\n",sc,lim+extra); for(int i=0;i&lt;lim+extra;i++) printf("%d %d\n",p[i].second,p[i].first); return 0; &#125; 普及T3 细胞分裂题目地址 题意：找出某一个数$S_i$，使得$\mathcal S_i^T=M={m_1}^{m_2}$，且$T$最小。考虑$S_i$的唯一分解，只要使得每一个质因数对应的次数都能超过$M$的唯一分解中这个质因数对应的次数即可。这样就可以算出对应的时间$T$来。由于一个数的质因数个数大约是$O(logn)$级别的，使用以上算法的时间复杂度约为$O(nlogm_1)$。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll m1,m2,ans=-1,lis[10][2],a,tot,p,k;int n,t=0;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;m1,&amp;m2); ll e=m1; for(ll b=2;b&lt;=m1;b++) if(e%b==0)&#123; lis[t++][0]=b,lis[t-1][1]=0; while(e%b==0) lis[t-1][1]++,e/=b; lis[t-1][1]*=m2; &#125; for(int i=0;i&lt;n;i++)&#123; tot=0; scanf("%lld",&amp;a); int j; for(j=0;j&lt;t;j++) if(a%lis[j][0]==0)&#123; p=0; while(a%lis[j][0]==0) p++,a/=lis[j][0]; k=lis[j][1]/p; if(lis[j][1]%p)k++;tot=max(tot,k); &#125;else break; if(j!=t)continue; ans=(ans&lt;0)?tot:(ans&gt;tot?tot:ans); &#125; printf("%lld\n",ans); return 0; &#125; 普及T4 道路游戏题目地址 方法一这是一道比较难的DP。状态的表示比较难想，我个人一开始给出的转移方程是：设$f(i,j,k)$表示当前在$i$工厂，$j$时间，$k$状态时的最大金币量，其中$k=0$表示当前机器人刚刚走出了第一步，$k=1$表示当前机器人走出了$2$到$p$步，并且已经被回收。这样状态转移方程就很好写，$f(i,j,0)$就从上一秒的$f(i-1,j-1,1)$里面找最大值，$f(i,j,1)$就枚举一下步数。这么做的时间复杂度是$O(nmp)$的。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005][1005][2]=&#123;0&#125;,m[1005][1005],n,t,p,cost[1005];int deque[4005][2],f=0,r=0,R;void in(int o,int at)&#123; while(r&gt;f&amp;&amp;o&gt;deque[r-1][0]) r--; deque[r][0]=o,deque[r++][1]=at;&#125;int out(int at)&#123; if(deque[f][1]==(at+R-p)%n) f++; return deque[f][0];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;t,&amp;p); int i,j,m2=0,m3=0,k,l,ans=0,sum; R=1000*n; for(i=0;i&lt;n;i++) for(j=0;j&lt;t;j++) scanf("%d",&amp;m[i][j]); for(i=0;i&lt;n;i++) scanf("%d",&amp;cost[i]); for(i=1;i&lt;=t;i++)&#123;//[f,r] for(j=0;j&lt;n;j++)&#123; dp[i][j][1]=m2; if(!j)dp[i][j][1]+=m[n-1][i-1]-cost[n-1]; else dp[i][j][1]+=m[j-1][i-1]-cost[j-1]; for(k=(j-1+n)%n,l=1,sum=0;l&lt;p;l++,k=(k-1+n)%n) if(i-l&gt;0) sum+=m[k][i-l], dp[i][j][0]=max(dp[i][j][0],dp[i-l][k][1]+sum); else break; m3=max(m3,max(dp[i][j][0],dp[i][j][1])); &#125; m2=m3,m3=0; &#125; for(i=0;i&lt;n;i++) ans=max(ans,max(dp[t][i][0],dp[t][i][1])); printf("%d\n",ans); return 0;&#125; 但是居然过了！我就没留意这道题了（其实我都写了单调队列但没用上）今天想了一下，发现没必要那么麻烦，很多地方可以优化。 方法二设$f(i,j)$为机器人走到$i$工厂，$j$时间所能收集的最大金币量。那么 f(i,j)=\max \limits_{i\le k \le p} \left\{ \max \limits_{1\le s\le n}\left\{f(s,j-k) \right\} +sum(i-1,j)-sum(i-k-1,j-k)-cost[i-k]\right\}其中 sum(i,j)=sum(i-1,j-1)+coin[i][j]那么提出$sum(i,j)$就可以发现括号里的量只与$k$有关，就用单调队列。而$sum$是可以前后递推出来的。所以，解决本题的时间复杂度就优化为了$O(nm)$。其实你如果读上面的题解读得仔细的话就会发现我没有讲到一个东西，那就是单调队列该怎么用。本题的优化方式十分特殊，由于$sum$是斜方格形进行求和的（$i-k,j-k \rightarrow i,j$），所以单调队列的下标也要随着$i$改变而改变。具体可以看代码。 完了么？没有。很多题解都会被洛谷上的Extra Test卡掉，虽然我也不知道这数据怎么出的但反正很厉害。（提示：其实读懂了题就不会被坑）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,p,coin[2005][1005],sum[1005][1005],cost[2005];int Deque[1005][1005][2],f[1005],r[1005],maxi[1005];int dp[1005][1005];void init()&#123; n=read(),m=read(),p=read(); for(int i=0;i&lt;n;i++) for(int j=1;j&lt;=m;j++) coin[i][j]=coin[i+n][j]=read(); for(int i=0;i&lt;n;i++)cost[i]=cost[i+n]=read();&#125;void inque(int x,int val,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;val&gt;Deque[x][r[x]-1][0])r[x]--; Deque[x][r[x]][0]=val,Deque[x][r[x]++][1]=k;&#125;int outque(int x,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;k-Deque[x][f[x]][1]&gt;p)f[x]++; return Deque[x][f[x]][0];&#125;void solve()&#123; for(int i=0;i&lt;n;i++)inque(i,-cost[i],0); int R=1000*n; //R：当前单调队列的偏移量 for(int j=1;j&lt;=m;j++)&#123; R--; sum[n-1][j]=sum[n-2][j-1]+coin[n-1][j]; sum[0][j]=sum[n-1][j-1]+coin[0][j]; dp[0][j]=outque(R%n,j)+sum[n-1][j]; maxi[j]=dp[0][j]; for(int i=1;i&lt;n;i++)&#123; sum[i][j]=sum[i-1][j-1]+coin[i][j]; dp[i][j]=outque((i+R)%n,j)+sum[i-1][j]; maxi[j]=max(maxi[j],dp[i][j]); &#125; inque(R%n,maxi[j]-cost[0]-sum[n-1][j],j); for(int i=1;i&lt;n;i++) inque((i+R)%n,maxi[j]-cost[i]-sum[i-1][j],j); &#125; //以上把0单独处理了 printf("%d\n",maxi[m]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 潜伏者题目地址 稍微麻烦的模拟。只要注意及时停止即可。12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;char f[27],sec[105],ori[105],s[105];int flag=1,vis[27];int main()&#123; scanf("%s%s%s",sec,ori,s); int l1=strlen(sec),l2=strlen(s); if(l1&lt;26)&#123; flag=0;goto end; &#125;//不够26个字母 for(int i=0;i&lt;l1;i++)&#123; if(f[sec[i]-'A']&amp;&amp;ori[i]!=f[sec[i]-'A'])&#123; flag=0;goto end; &#125;//没对上 f[sec[i]-'A']=ori[i],vis[sec[i]-'A']=1; &#125; for(int i=0;i&lt;26;i++) if(!vis[i]||!f[i])&#123; flag=0;goto end; &#125;//禁止没有得对 for(int i=0;i&lt;26;i++)vis[f[i]-'A']++; for(int i=0;i&lt;26;i++) if(vis[i]&gt;2)&#123; flag=0;goto end; &#125;//禁止一对多 end: if(!flag)printf("Failed\n"); else &#123; for(int i=0;i&lt;l2;i++) printf("%c",f[s[i]-'A']); printf("\n"); &#125; return 0;&#125; 提高T2 Hankson的趣味题题目地址 一道奇怪的数学题。（理论上这题爆搜比正解快，数据好像不是很好）考虑唯一分解和$GCD$，$LCM$的关系。设对于一个质数$p$，其为b_1的一个因数。那么：设k_{a_0},k_{a_1},k_{b_0},k_{b_1},k_x为a_0,a_1,b_0,b_1,x中$p$的次数。则：因为k_{a_1}=\min\{k_{a_0},k_x\},k_{b_1}=\max\{k_{b_0},k_x\}，若k_{a_0}>k_{a_1}那么k_x=k_{a_1}；若k_{a_0}=k_{a_1}，那么k_x\ge k_{a_1}.若k_{b_0}]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>搜索</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>单调队列</tag>
        <tag>字符串</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2011%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2011十道题目的题解。 普及T1 数字反转题目地址 模拟123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;char num[15];int main()&#123; scanf("%s",num); int f=(num[0]=='-'),len=strlen(num),cur=0; reverse(num,num+len); while(num[cur]=='0')cur++; if(f)putchar('-'); if(!num[cur]||num[cur]=='-')printf("0\n"); else&#123; while(isdigit(num[cur]))putchar(num[cur]),cur++; &#125; return 0;&#125; 普及T2 统计单词数题目地址 本题不需要使用字符串匹配的高级算法，模拟即可。注意单词必须完全匹配，即匹配时两个单词长度要一样。123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;char w[20],s[1000005];int ans1=-1,ans2=0,l1,l2;bool judge(int t)&#123; for(int i=0;i&lt;l1;i++) if(w[i]!=s[t+i])return 0; if(t+l1==l2||s[t+l1]==' ')return 1; return 0;&#125;int main()&#123; scanf("%s",w); while(getchar()!='\n'); fgets(s,1000003,stdin); l1=strlen(w),l2=strlen(s); for(int i=0;i&lt;l1;i++)if(isupper(w[i]))w[i]+='a'-'A'; for(int i=0;i&lt;l2;i++)if(isupper(s[i]))s[i]+='a'-'A'; for(int i=0;i&lt;l2;i++) if(s[i]!=' '&amp;&amp;(!i||s[i-1]==' ')&amp;&amp;i+l1-1&lt;l2) if(judge(i))&#123; if(ans1&lt;0)ans1=i; ans2++; &#125; if(ans1&lt;0)printf("%d\n",ans1); else printf("%d %d\n",ans2,ans1); return 0;&#125; 普及T3 瑞士轮题目地址 模拟+归并。直接模拟的话是$O(nqlogn)$的时间复杂度，会超时。发现每次比完赛之后赢的人和输的人各自的相对排名不变，所以将胜者和败者归并起来，时间复杂度为$O(nq)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[200005],pp[200005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,r,q,w[200005],q1[200005],q2[200005],r1,r2;//q1胜者 q2败者 void Merge()&#123; int tot=0,lb=1,rb=1; while(lb&lt;=r1&amp;&amp;rb&lt;=r2)&#123; int L=q1[lb],R=q2[rb]; if(p[L]&lt;p[R])pp[++tot]=p[L],lb++; else pp[++tot]=p[R],rb++; &#125; while(lb&lt;=r1)pp[++tot]=p[q1[lb]],lb++; while(rb&lt;=r2)pp[++tot]=p[q2[rb]],rb++; memcpy(p+1,pp+1,sizeof(P)*n);&#125;void init()&#123; n=read()&lt;&lt;1,r=read(),q=read(); for(int i=1;i&lt;=n;i++) p[i].first=-read(),p[i].second=i; for(int i=1;i&lt;=n;i++)w[i]=read(); sort(p+1,p+n+1); &#125;void solve()&#123; while(r--)&#123; r1=r2=0; for(int i=1;i&lt;=n;i+=2)&#123; q1[++r1]=i,q2[++r2]=i+1; if(w[p[i].second]&lt;w[p[i+1].second]) swap(q1[r1],q2[r2]),p[i+1].first--; else p[i].first--; &#125; Merge(); &#125; printf("%d\n",p[q].second);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 表达式的值题目地址 $DP$。实际上那两个运算就是与和或，所以直接用栈来模拟一下运算过程即可。按运算数来$DP$，记录一下当前编号为$id$的运算数取$0$和$1$时的方案数，这样做法就比较显然了，在模拟的时候计数即可。时间复杂度为$O(n)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;int s1[100005][2]=&#123;0&#125;,s2[100005]=&#123;0&#125;,t1=0,t2=0,pro[300],lim,M=10007;char _exp[100005];void opr()&#123; int a1,a2,b1,b2,o; a1=s1[--t1][0],a2=s1[t1][1], b1=s1[--t1][0],b2=s1[t1][1], o=s2[--t2]; if(o=='+') s1[t1][0]=(a1*b1)%M, s1[t1++][1]=(a1*b2+a2*b1+a2*b2)%M; if(o=='*')&#123; s1[t1][1]=(a2*b2)%M, s1[t1++][0]=(a1*b1+a1*b2+a2*b1)%M; &#125;&#125;void calc()&#123; int i,j; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='(') s2[t2++]='('; else if(_exp[i]==')')&#123; while(s2[t2-1]!='(') opr(); t2--; &#125;else&#123; if(_exp[i-1]!=')') s1[t1][0]=1, s1[t1++][1]=1; while(t2&amp;&amp;s2[t2-1]!='('&amp;&amp; pro[s2[t2-1]]&gt;=pro[_exp[i]]) opr(); s2[t2++]=_exp[i]; if(_exp[i+1]==')') s1[t1][0]=1, s1[t1++][1]=1; &#125; &#125;&#125;void init()&#123; pro['+']=1,pro['*']=2; scanf("%d%s",&amp;lim,&amp;_exp[1]); lim++; _exp[0]='('; _exp[lim++]=')';&#125;void solve()&#123; calc(); printf("%d\n",s1[0][0]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 铺地毯题目地址 模拟即可。注意判断矩形和无解条件。1234567891011121314#include &lt;bits/stdc++.h&gt;int x[10002],y[10002],l[10002],w[10002],n,dx,dy;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d%d%d",&amp;x[i],&amp;y[i],&amp;l[i],&amp;w[i]); scanf("%d%d",&amp;dx,&amp;dy); int at=-1; for(int i=0;i&lt;n;i++) if((dx&lt;=x[i]+l[i]&amp;&amp;dx&gt;=x[i])&amp;&amp;(dy&lt;=y[i]+w[i]&amp;&amp;dy&gt;=y[i])) at=i+1; printf("%d\n",at); return 0;&#125; 提高D1T2 选择客栈（待考察）题目地址 直接枚举是$O(n^2)$的，不够优秀。考虑这么一种做法：我们分颜色考虑，对于一种颜色$col$，用某个数据结构按距离从大到小存一 下客栈的编号（其实从小到大还是从大到小不重要），然后按顺序枚举每一个客栈，统计一下它的贡献。（也就是有几种方案，他被住下了）贡献怎么算呢？我们画个图 $cur$表示我们找到的离当前枚举到的客栈最近的合法（指最低消费$\le p$）客栈的编号，那么由乘法原理，这个时候$cur$左边的颜色为$col$的客栈数乘上右边颜色为$col$的客栈数就是可行的贡献。诶，刚才不是说算每一个客栈的贡献么？对的。这里由于$cur$右边的$col$颜色客栈之间没有合法客栈，所以把右边的一起算。这里还有一个问题：如果$cur$的颜色是$col$怎么办？如果$cur$右边的客栈全被统计过了，就把他划分到右边，否则划分到左边，这样可以保证正确性。计算完后继续看下一个客栈，这里有一个优化：如果客栈编号大于$cur$就直接跳过，因为他的贡献算过了。综上，使用以上算法的时间复杂度为$O(nk)$。由于数据的原因，实际时间复杂度远小于该值。本题还存在一个时间复杂度仅为$O(n)$的算法，可根据以上算法优化而来，各位不妨自行思考。提示：如果我们边读入数据，边动态更新$cur$会怎么样呢？123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,p,col[200005],cost[200005];int at[55],id[200005],nex[200005],cnt=0,tot[55];void init()&#123; n=read(),k=read(),p=read(); for(int i=1;i&lt;=n;i++)&#123; col[i]=read(),cost[i]=read(); id[++cnt]=i,nex[cnt]=at[col[i]],at[col[i]]=cnt,tot[col[i]]++; &#125; //链式前向星 &#125;void solve()&#123; int ans=0; for(int i=0;i&lt;k;i++)&#123; if(!at[i])continue ; int lf=tot[i],cur=id[at[i]]+1; //lf 左端 rt 右端 for(int j=at[i];j;j=nex[j])&#123; if(id[j]&gt;cur)continue;//优化，该客栈被统计过就跳过 int rt=0;//一开始cur右边没被统计过的客栈数是0 for(cur=id[j];cur&amp;&amp;cost[cur]&gt;p;cur--)//更新cur if(col[cur]==i)rt++,lf--;//遇到一个客栈在cur右边 if(!cur)break;//找不到这样的合法客栈 if(col[cur]==i&amp;&amp;!rt)rt=1,lf--;//对应右边无客栈被统计的情况 ans+=rt*lf;//计算贡献 &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T3 Mayan游戏题目地址 本题模拟的成分远大于搜索。由于步数已经确定，所以只要采用最简单的$DFS$即可求出结果。当然，我们需要一些必要的剪枝和优化： 列表内容最优化剪枝：按照$x,y$的顺序遍历方块，保证第一个找到的可行方案一定是最优方案。 最优化剪枝：只有当左边是空的时候才左移，否则等价于左边的右移。 最优化剪枝：不移动同色方块。 可行性剪枝：有某种方块个数$\le 2$直接退出，因为不可能消除。 程序上的优化：用$2$个队列处理事件，一个处理掉落，一个处理消除。这样就可以跑的非常快了。理论上还可以加一个估价的优化，就是通过同色方块的连接情况判断至少还要走几步，但实际上以上的优化已经足够了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//交换2个方块后要处理影响//1.掉落 2.消除 //可行性剪枝：同颜色&lt;=2个退出//设置一个掉落队列和一个事件队列//事件队列检查是否有可以消除的方块，有的话就把最上面一层得上一个加入掉落队列 //在掉落队列里检查上方是否有方块，有的话将上方的方块下降后全部加入事件队列 //两者需要交替进行。int pz[10][5][7];int n,ans[10][3],movement[10][3],cnt[11],flag=0;int dque[10005][2],dr,df;//掉落队列 int eque[10005][2],er,ef;//事件队列 int visx[10],visy[10],vis[5][7];void solve_clear(int cur)&#123; int dx,dy,col,len; for(int i=0;i&lt;5;i++)visx[i]=0; for(int i=0;i&lt;7;i++)visy[i]=0; memset(vis,0,sizeof(vis)); while(er&gt;ef)&#123; dx=eque[ef][0],dy=eque[ef++][1]; if(!visx[dx])&#123;//同一个x visx[dx]=1; col=pz[cur][dx][0],len=1; for(int i=1;i&lt;7;i++)&#123; if(pz[cur][dx][i]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[dx][j]=1; &#125; col=pz[cur][dx][i],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=6;7-j&lt;=len;j--)vis[dx][j]=1; &#125; &#125; if(!visy[dy])&#123; visy[dy]=1; col=pz[cur][0][dy],len=1; for(int i=1;i&lt;5;i++)&#123; if(pz[cur][i][dy]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[j][dy]=1; &#125; col=pz[cur][i][dy],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=4;5-j&lt;=len;j--)vis[j][dy]=1; &#125; &#125; &#125; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) if(vis[i][j])&#123; pz[cur][i][j]=0; if(j!=6) dque[dr][0]=i,dque[dr++][1]=j+1; &#125; &#125;void solve_drop(int cur)&#123; int dx,dy,des; while(dr&gt;df)&#123; dx=dque[df][0],dy=dque[df++][1]; for(des=dy-1;des&gt;=0&amp;&amp;!pz[cur][dx][des];des--); des++; for(int i=dy;i&lt;7;i++) if(pz[cur][dx][i]) pz[cur][dx][des++]=pz[cur][dx][i], eque[er][0]=dx,eque[er++][1]=des-1; for(int i=des;i&lt;7;i++) pz[cur][dx][i]=0; &#125;&#125;void dfs(int cur)&#123; if(flag)return ; if(cur==n)&#123; for(int i=0;i&lt;5;i++) if(pz[cur][i][0])return ; memcpy(ans,movement,sizeof(ans)); flag=1; return ; &#125; for(int i=1;i&lt;=10;i++)cnt[i]=0; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) cnt[pz[cur][i][j]]++; for(int i=1;i&lt;=10;i++) if(cnt[i]&amp;&amp;cnt[i]&lt;3)return ; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(!pz[cur][i][j])continue; if(i!=4&amp;&amp;pz[cur][i+1][j]!=pz[cur][i][j])&#123; //向右移动 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i+1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i+1,dque[dr++][1]=j; while(dr&gt;df) solve_drop(cur+1),solve_clear(cur+1); movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=1; dfs(cur+1); &#125; if(i&amp;&amp;!pz[cur][i-1][j]&amp;&amp;pz[cur][i-1][j]!=pz[cur][i][j])&#123;//向左边 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i-1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i-1,dque[dr++][1]=j; while(dr&gt;df)&#123; solve_drop(cur+1),solve_clear(cur+1); &#125; movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=-1; dfs(cur+1); &#125; &#125; &#125;&#125;void init()&#123; n=read(); int t; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;8;j++)&#123; t=read(); if(!t)break; pz[0][i][j]=t; &#125;&#125;void solve()&#123; dfs(0); if(!flag)printf("-1\n"); else &#123; for(int i=0;i&lt;n;i++) printf("%d %d %d\n",ans[i][0],ans[i][1],ans[i][2]); &#125;&#125;int main()&#123; freopen("a.in","r",stdin); init(); solve(); return 0;&#125; 提高D2T1 计算系数题目地址 套用二项式定理和组合数取模即可。$x^ny^m$的系数是$C_n^k \times a^n\times b^m$。时间复杂度：$O(k^2)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define M 10007using namespace std; int dp[1005]=&#123;0&#125;,a,b,k,m,n,ans; int Pow(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125;return res;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;k,&amp;n,&amp;m); a%=M,b%=M,dp[0]=1; for(int i=1;i&lt;=k;i++) for(int j=i;j&gt;=1;j--) dp[j]+=dp[j-1],dp[j]%=M; //计算组合数 ans=(dp[n]*Pow(a,n))%M, ans=(ans*Pow(b,m))%M; printf("%d\n",ans); return 0; &#125; 提高D2T2 聪明的质监员题目地址 较为明显的二分。二分一个$x$，然后扫一遍表，看看哪些$w$大于等于$x$，然后用前缀和存一下符合条件的$w$前缀和与$w$的数量前缀和，最后$m$个区间算一遍加起来即可。时间复杂度：$O((n+m)logn)$123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;ll S,tot,v[200005],ans,sum[200005],cnt[200005];int w[200005],n,m,ev[200005][2];void solve(int r)&#123; int i; sum[0]=cnt[0]=0; for(i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1], cnt[i]=cnt[i-1]; if(w[i-1]&gt;=r)sum[i]+=v[i-1],cnt[i]++; &#125; for(i=0;i&lt;m;i++) tot+=(cnt[ev[i][1]]-cnt[ev[i][0]-1])* (sum[ev[i][1]]-sum[ev[i][0]-1]);&#125;int main()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;S); int i,j,lb=0,rb=1000000,md; ans=S; for(i=0;i&lt;n;i++) scanf("%d%lld",&amp;w[i],&amp;v[i]); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;ev[i][0],&amp;ev[i][1]); while(rb-lb)&#123; md=(rb+lb)/2,tot=0; solve(md); if(tot==S)&#123;ans=0;break;&#125; else if(tot&gt;S)ans=min(ans,tot-S),lb=md+1; else ans=min(ans,S-tot),rb=md; &#125; printf("%lld\n",ans); return 0;&#125; 提高D2T3 观光公交（待考察）题目地址 题解题目的意思就是选择若干条路，修改他们的长度，使得总的旅行时间最少。具体的做法就是贪心，找省时间最多的路段用。我们把道路分块，为什么要这么做呢？我们把本题第一个数据画成图。123456710 5 05 7 2 4 8 2 8 3 110 3 41 1 333 6 914 4 81 1 4 上面的竖线表示到站的人的到站时间，点表示时间点。虚线部分是指车子到站之后还要等待虚线的时间才能等到人全部上齐。虚线左端是到站时间点，右端是发车时间点。设一个站i中，来的最晚的人到达时间是$latest[i]$。然后，我们手算后可以发现一些性质：性质1.如果车子到达i站的时间是$curt$，并且$curt\le latest[i]$，那么$i$前面和$i$后面，两个路段相互独立。什么意思呢？我们可以感性地这么想：让一段路的长度减少，就相当于把这段路以及其后面的到站时间点往前拉。但是第i站的点永远不会动，因为他的到站时间点和发车时间点是用虚线连接着的，发车时间一定不变。所以对i前面的路修改，$i$后面的就不会受影响；同理对$i$后面的路修改，$i$前面的路也不会受影响。我们称呼到达这样的站的路为隔离路。上图中，$5\rightarrow 6$就是隔离路。根据这个性质，我们可以很方便的把路分块，分割成几个相互不影响的路块以及分隔他们的隔离路。分完了块就可以计算优化一条路能节省的时间了。下面我们对一个路块进行探究：设一个块中开头的站编号为$belong$，末尾的站是$tail$。显然，由上文，$tail\rightarrow tail+1$的路是隔离路。性质2.一个块中，如果优化$i\rightarrow i+1$站的路，使其长度$-1$，可以节省的时间是在$i+1,i+2,…tail,tail+1$这些站下车的人数的总和。这个性质很容易证明，由于这些人都已经上了车，所以优化这段路就相当于把后面站的到站时间点都$-1$，每一个人的到达时间就$-1$，所以省下的时间是人数的和，证毕。根据这个性质，我们可以用后缀和计算出省下的时间，找到在块中最优的那段路。不在块中的隔离路也能优化，优化一次节省的时间是在隔离路通向的下一站下车的人数。接下来的问题是一段路最多可以优化多少次。根据上图可以发现，一段路被优化一定次数，前面的某一段路就会变成隔离路。比如优化$1\rightarrow 2$的路后，$3\rightarrow 4$就变成了隔离路。所以在分块时还要对每一段路统计一个$mingap$，表示一段路最多优化几次就会导致后面的某段路变为隔离路。优化$mingap$次数之后，原来的块就失效了，需要对当前操作块进行重构。如果一段路的长度变成了$0$，或者$mingap$为$0$，就称这一段路是无效路，在寻找最大值时忽略。之后重复以上步骤即可。分析一下时间复杂度：每一轮我们找出一段可以修改的路，修改完成后，至少会使得一段路变为隔离路，或者使得一条隔离路变为无效路。所以每一条路最多被修改$2$次。一共有$O(n)$条路，所以最多做$O(n)$次，所有的路就被修改完了。每一轮我们需要$O(n)$的时间找到省时间最多的路段，并且至多用$O(n)$的时间更新块的情况，结合上面可知，最多做$O(n)$轮，所以该算法的理论时间复杂度为$O(n^2)$。贪心的正确性比较显然，在此不证明。存在$O(nk)$的编程复杂度更低，但是可能会超时的做法。很可惜，本题数据太水，根本卡不掉。事实上，本题存在时间运行上比本题解程序实现更优的程序实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,K,dis[1005],latest[1005],dec[1005],cost[1005],cnt[1005],cnt2[1005];int belong[1005],mingap[1005],tail[1005],ans=0;void build_block(int l,int r)&#123; int bid=l,curt=latest[l]; for(int i=l+1;i&lt;=r;i++)&#123; curt+=dis[i-1]; if(curt&gt;latest[i])belong[i-1]=bid; else&#123; belong[i-1]=-1,mingap[i-1]=INF; int tmp=curt-dis[i-1]; for(int j=i-2;j&gt;=bid;j--) mingap[j]=min(min(tmp-latest[j+1],dis[j]),mingap[j+1]), tmp-=dis[j]; curt=latest[i],tail[bid]=i-1,bid=i; &#125; &#125; if(bid!=r)&#123; int bef=INF; for(int j=r-1;j&gt;=bid;j--) mingap[j]=min(bef,min(dis[j],curt-latest[j+1])), bef=min(bef,mingap[j]),curt-=dis[j]; tail[bid]=r; &#125;&#125;void init()&#123; n=read(),m=read(),K=read(); for(int i=1;i&lt;n;i++)dis[i]=read(); for(int i=1;i&lt;=m;i++)&#123; int Ti=read(),Ai=read(),Bi=read(); latest[Ai]=max(latest[Ai],Ti); cost[Ai]+=Ti; dec[Ai]++,dec[Bi]--,cnt[Ai]++,cnt2[Bi]++; &#125; for(int i=2;i&lt;=n+1;i++)dec[i]+=dec[i-1]; int curt=latest[1]; ans+=cnt[1]*latest[1]-cost[1]; for(int i=1;i&lt;n;i++)&#123; if(latest[i+1]&gt;curt+dis[i])&#123; ans+=cnt2[i+1]*dis[i]+(dec[i]-cnt2[i+1])*(latest[i+1]-curt); ans+=cnt[i+1]*latest[i+1]-cost[i+1]; curt=latest[i+1]; &#125;else&#123; ans+=dec[i]*dis[i],curt+=dis[i]; ans+=cnt[i+1]*curt-cost[i+1]; &#125; &#125; //每一段路上坐车人数 &#125;void solve()&#123; build_block(1,n); for(;K;)&#123; int maxi=0,maxid=-1,curb=0,bid,sum; for(int i=1;i&lt;n;i++)&#123; bid=belong[i]; if(bid&lt;0)&#123; if(dis[i]&amp;&amp;cnt2[i+1]&gt;maxi)maxi=cnt2[i+1],maxid=i; &#125;else&#123; if(curb!=bid)&#123; curb=bid,sum=0; for(int j=tail[bid]+1;j&gt;=i+1;j--)sum+=cnt2[j]; &#125; if(mingap[i]&amp;&amp;sum&gt;maxi)maxi=sum,maxid=i; sum-=cnt2[i+1]; &#125; &#125; if(maxid&lt;0)break; bid=belong[maxid]; if(bid&lt;0)&#123; if(K&gt;dis[maxid]) ans-=maxi*dis[maxid],K-=dis[maxid],dis[maxid]=0; else &#123; ans-=maxi*K; break; &#125; &#125;else&#123; if(K&gt;mingap[maxid])&#123; ans-=maxi*mingap[maxid],K-=mingap[maxid],dis[maxid]-=mingap[maxid]; &#125;else &#123; ans-=maxi*K; break; &#125; build_block(bid,tail[bid]); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>搜索</tag>
        <tag>二分</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>栈</tag>
        <tag>字符串DP</tag>
        <tag>字符串</tag>
        <tag>二路归并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2014%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2014十道题目的题解。 普及T1 珠心算测验题目地址 没读懂题目就会被坑。模拟即可，但是要注意先去重，不然会多次统计。另外还要注意整数对的无序性。也就是说，两个数$a+b=c$和$b+a=c$不能算$2$遍。在找到这个数$c$后，还要及时把他删除，以免多次统计。所以，$O(n^2)$扫一遍即可。12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int a[104],n,ans=0;char vis[20004]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); sort(a,a+n); n=unique(a,a+n)-a; for(int i=0;i&lt;n;i++)vis[a[i]]=1; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) if(vis[a[i]+a[j]])ans++,vis[a[i]+a[j]]=0; printf("%d\n",ans); return 0;&#125; 普及T2 比例简化题目地址 方法一模拟即可，注意简化后分数和原分数的比较，涉及浮点数的运算。时间复杂度$O(L^2)$。123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int a,b,lim,fz,fm;double bi,mini=1e9,cur;int gcd(int a,int b)&#123; return (!b)?a:gcd(b,a%b);&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;lim); bi=(double)a/b,cur=1e9; for(int i=1;i&lt;=lim;i++) for(int j=1;j&lt;=lim;j++)&#123; double t=(double)i/j; if(t-bi&gt;0&amp;&amp;t-bi&lt;cur) cur=t-bi,fz=i,fm=j; else if(fabs(t-bi)&lt;1e-8)&#123; fz=i,fm=j;break; &#125; &#125; int g=gcd(fz,fm); fz/=g,fm/=g; printf("%d %d\n",fz,fm); return 0;&#125; 方法二对每一个不大于$L$的数进行一次二分，找出以此数为分母时最接近$\frac {A}{B}$的分数的分子。时间复杂度：$O(LlogL)$。 普及T3 螺旋矩阵题目地址 观察发现这个结构很有规律，因为螺旋矩阵是一层一层螺旋的，所以考虑一层一层递进求解。我们每一次去掉矩阵最外面的一层，如12341 2 3 4 12 13 14 5 ---&gt; 13 1411 16 15 6 ---&gt; 16 1510 9 8 7 这样里面还是一个螺旋矩阵，但由$n\times n$变为了$(n-2)\times (n-2)$。最后到了要求的数的那一层的时候采用模拟算法，算出那个数即可。时间复杂度：$O(n)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n,x,y,tot=0;int main()&#123; scanf("%d%d%d",&amp;n,&amp;x,&amp;y); for(;x!=1&amp;&amp;y!=1&amp;&amp;x!=n&amp;&amp;y!=n;) tot+=4*n-4,n-=2,x--,y--; if(x==1)tot+=y; else&#123; tot+=n-1; if(y==n)tot+=x; else&#123; tot+=n-1; if(x==n)tot+=(n-y+1); else&#123; tot+=n-1; if(y==1)tot+=(n-x+1); &#125; &#125; &#125; printf("%d\n",tot); return 0;&#125; 普及T4 子矩阵题目地址 这题一脸不可做。是吗？我们先尝试搜索，按照计算，我们最多搜索$(C_{16}^8)^2$次。这样会$TLE$。别急，先搜出我们当前选取的行。然后问题就转化为了求这些行中某些列产生的最小的分数。这个问题我们就很熟悉了，这不是一个$O(m^2)$的$DP$么？设$f(i,j)$为选了$i$列，当前在第$j$列时最小的分数，则状态转移方程易导出。综上，我们使用搜索和$DP$相结合的方法解决了本题。实际上，这样的搜索和高效算法结合的思想早在许多年前就已经用到（即$NOI2003$智破连环阵），在这里出现着实很妙。而在$NOIP2015$中也有这样的思想。时间复杂度：$O(C_n^mm^2)$（近似）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,r,c,mat[20][20],ans=1000000000;int cur_r[20],cur_c[20],v_c[20]=&#123;0&#125;,w[20][20],dp[20][20]=&#123;0&#125;;void dfs_c(int at,int cur)&#123; int fm=cur_c[at-1],val,pos; cur+=v_c[fm]; if(cur&gt;=ans)return; if(at==c)&#123; ans=min(ans,cur);return ; &#125; for(int i=fm+1;i&lt;=m-c+at;i++)&#123; cur_c[at]=i; if(cur&gt;=ans)return ; else dfs_c(at+1,cur); for(int j=0;j&lt;r;j++)&#123; pos=cur_r[j]; val=mat[pos][i]-mat[pos][fm]; if(val&lt;0)val=-val; cur-=val; &#125; &#125;&#125;void solve_()&#123; int pos; memset(v_c,0,sizeof(v_c)); memset(w,0,sizeof(w)); memset(dp,0,sizeof(dp)); for(int i=0;i&lt;m;i++) for(int j=1;j&lt;r;j++) v_c[i]+=abs(mat[cur_r[j]][i]-mat[cur_r[j-1]][i]); for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=0;k&lt;r;k++) pos=cur_r[k], w[i][j]+=abs(mat[pos][i]-mat[pos][j]); for(int i=0;i&lt;m;i++) dp[1][i]=v_c[i]; for(int i=2;i&lt;=c;i++)&#123; for(int j=0;j&lt;m;j++)&#123; pos=1000000000; for(int k=0;k&lt;j;k++) if(dp[i-1][k]+w[k][j]&lt;pos) pos=dp[i-1][k]+w[k][j]; dp[i][j]=pos+v_c[j]; &#125; &#125; for(int i=c-1;i&lt;m;i++) ans=min(ans,dp[c][i]);&#125;void dfs_r(int at)&#123; int fm=cur_r[at-1],val; for(int i=fm+1;i&lt;=n-r+at;i++)&#123; cur_r[at]=i; for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]+=val; &#125; if(at==r-1)solve_(); else dfs_r(at+1); for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]-=val; &#125; &#125;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;r,&amp;c); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;mat[i][j]);&#125;void solve()&#123; for(int i=0;i&lt;=n-r;i++)&#123; cur_r[0]=i; dfs_r(1); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 生活大爆炸版石头剪刀布题目地址 判断胜负你可以用一堆if else 或者 switch case，但最简便的还是打表计算。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int tab[5][5]=&#123;//A打B &#123;0,0,1,1,0&#125;, &#123;1,0,0,1,0&#125;, &#123;0,1,0,0,1&#125;, &#123;0,0,1,0,1&#125;, &#123;1,1,0,0,0&#125;&#125;;int n,na,nb,a[205],b[205],ans1=0,ans2=0;void init()&#123; n=read(),na=read(),nb=read(); for(int i=0;i&lt;na;i++)a[i]=read(); for(int i=0;i&lt;nb;i++)b[i]=read();&#125;void solve()&#123; int ra,rb; for(int i=0;i&lt;n;i++) ra=i%na,rb=i%nb, ans1+=tab[a[ra]][b[rb]],ans2+=tab[b[rb]][a[ra]]; printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T2 联合权值题目地址 这是一棵树，同时点对距离为$2$这个条件也很微妙，所以先把他转化为一棵有根树，再利用父子关系求解。距离为$2$，我们可以枚举中心点。对于树上的一个点来说，这意味着以他为中心点的点对是由它的父亲与儿子，儿子与儿子构成的。这样最大的权值好做了，记录儿子中的最大权值和次大权值，比较父亲的权值和儿子中最大权值的积以及儿子中最大、次大权值的积，以此更新答案即可。但是权值的和就比较麻烦，儿子和父亲形成的点对的权值和好算，但儿子之间相互的乘积是相互乘的，一次要花费$O(儿子数^2)$的时间计算。最坏情况下是$O(n^2)$的。如何优化？这需要一些数学知识。设儿子的权值为a_1,a_2,a_3,...,a_m,那么儿子们的联合权值之和就是a_1a_2+a_1a_3+...+a_1a_m+a_2a_3+...+a_2a_m+...+a_{m-1}a_m。这里不加证明的给出$2$种在$O(n)$时间计算该值的方法：1.设f(i)=a_1+a_2+...+a_i，g(i)=a_1a_2+a_1a_3+...+a_1a_i+a_2a_3+...+a_2a_i+...+a_{i-1}a_i。更新$g(i)$需要$f(i)$。步骤如下：初始$f(0)=g(0)=0$，$i=1$。（1：g(i)=g(i-1)+a_i\times f(i-1)（2：f(i)=f(i-1)+a_i（3：$i=i+1$2.展开(a_1+a_2+a_3+...+a_m)^2可知维护儿子的权值和和权值平方和就可以算出联合权值之和。代码用的是方法2.综上所述，在使用$DFS/BFS$对树进行遍历的情况下，以上算法的时间复杂度是$O(n)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt; using namespace std;typedef struct&#123; int w,par,son,bro;&#125;Tree;Tree tr[200005];int n,q[200005],f=0,r=0,M=10007,ans=0,ans2=0;void prepare()&#123; int i,h,sum,sum2,mx,mx2,e; for(i=0;i&lt;n;i++) if(tr[i].par&lt;0)&#123;q[r++]=i;break;&#125; while(r-f)&#123; h=q[f++],sum=sum2=mx=mx2=0; for(i=tr[h].son;i!=-1;i=tr[i].bro)&#123; e=tr[i].w, sum=(sum+e)%M, sum2=(sum2+(e*e)%M)%M; if(e&gt;mx)mx2=mx,mx=e; else if(e&gt;mx2)mx2=e; q[r++]=i; &#125; ans2=max(ans2,max(mx*mx2,mx*tr[tr[h].par].w)), ans=(ans+(tr[tr[h].par].w*sum*2)%M)%M, ans=(ans+(sum*sum-sum2)%M+M)%M; &#125;&#125;int main()&#123; scanf("%d",&amp;n); int i,u,v; for(i=0;i&lt;n;i++) tr[i].par=tr[i].son=tr[i].bro=-1; for(i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v), u--,v--; if(tr[v].par&gt;=0)swap(u,v); tr[v].par=u,tr[v].bro=tr[u].son,tr[u].son=v; &#125; for(i=0;i&lt;n;i++) scanf("%d",&amp;tr[i].w); prepare(); printf("%d %d\n",ans2,ans); return 0;&#125; 提高D1T3 飞扬的小鸟题目地址 一个背包DP的模型。按$x$坐标划分阶段，状态是坐标，决策有：1.点若干次屏幕；2.不点屏幕。发现决策$1$对应无限背包，决策$2$对应$01$背包。所以做一次DP。设$f(i,j,l)$表示到了点$(i,j)$最少需要点击屏幕的次数，其中$l=0$表示本次不点击屏幕，$l=1$表示本次点击。则状态转移方程容易导出，在此就不列出了。在转移的时候注意之前转移而来的状态和当前转移的合法性，以及一个细节：在最高处，小鸟可以平移飞行。时间复杂度：$O(nm)$（近似，因为在最高点有一次枚举）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 2000000000using namespace std;int dp[2][1005][2],n,m,k,up[10005],down[10005],rec[10005][2];void input()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int i,j; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;up[i],&amp;down[i]), rec[i][0]=-1,rec[i][1]=m+3; rec[n][0]=-1,rec[n][1]=m+3; for(i=0;i&lt;k;i++) scanf("%d",&amp;j), scanf("%d%d",&amp;rec[j][0],&amp;rec[j][1]);&#125;void solve()&#123; int res,ans,i,j,t,u,v,o,l,p,q; for(i=0;i&lt;=m;i++) dp[0][i][0]=dp[0][i][1]=0; for(i=1;i&lt;=n;i++)&#123; for(o=0,j=1;j&lt;=m;j++)&#123; dp[i&amp;1][j][0]=dp[i&amp;1][j][1]=INF; if(j+down[i-1]&lt;=m) p=(j+down[i-1]&lt;rec[i-1][1])&amp;&amp;(j+down[i-1]&gt;rec[i-1][0]), q=(j&lt;rec[i][1])&amp;&amp;(j&gt;rec[i][0]), u=(p)?dp[1^(i&amp;1)][j+down[i-1]][0]:INF, v=(p)?dp[1^(i&amp;1)][j+down[i-1]][1]:INF, dp[i&amp;1][j][0]=(q)?min(u,v):INF; if(j-up[i-1]&gt;0) for(l=(j==m)?0:up[i-1];l&lt;=up[i-1];l++) p=(j-l&lt;rec[i-1][1])&amp;&amp;(j-l&gt;rec[i-1][0]), t=dp[i&amp;1][j-l][1], u=(p)?dp[1^(i&amp;1)][j-l][0]:INF, v=(p)?dp[1^(i&amp;1)][j-l][1]:INF, t=min(min(u,v),t), dp[i&amp;1][j][1]=min(dp[i&amp;1][j][1],t+1); if(j&lt;rec[i][1]&amp;&amp;j&gt;rec[i][0]&amp;&amp;(dp[i&amp;1][j][0]&lt;INF|| dp[i&amp;1][j][1]&lt;INF))o=1; &#125; if(!o)&#123;res=0;break;&#125; &#125; if(i==n+1)res=1; printf("%d\n",res); if(res) for(ans=INF,j=n,i=1;i&lt;=m;i++) ans=min(ans,min(dp[j&amp;1][i][0],dp[j&amp;1][i][1])); else for(ans=0,j=0;j&lt;i;j++) if(rec[j][0]!=-1)ans++; printf("%d\n",ans);&#125;int main()&#123; input(); solve(); return 0;&#125; 提高D2T1 无线网络发射器选址题目地址 枚举一下路口即可。或者玩矩阵前缀和。时间复杂度：$O(128^2 n)$或者$O(d^2)$（理论上）12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int d,R,n,sum[1000][1000],cnt=0,ans=0;void init()&#123; d=read(),n=read(),R=(d&lt;&lt;1|1); for(int i=1;i&lt;=n;i++) sum[read()+R][read()+R]=read(); for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i][j-1]; for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i-1][j];&#125;void solve()&#123; for(int i=R+d;i&lt;=128+R+d;i++) for(int j=R+d;j&lt;=128+R+d;j++)&#123; int val=sum[i][j]-sum[i-R][j]-sum[i][j-R]+sum[i-R][j-R]; if(val&gt;ans)ans=val,cnt=1; else if(val==ans)cnt++; &#125; printf("%d %d\n",cnt,ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T2 寻找道路题目地址 考虑先删不合法的点，再跑一遍BFS找到最短路。首先把边反向，从终点跑一下，看看哪些点是合法的。遍历到的点都是和终点直接或者间接连通着的。对于没有被遍历到的点，就要取消它和它连着的点的合法性。这一步可以直接在下一步跑最短路的时候做。时间复杂度：$O(n)$。注意判断起点的合法性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;typedef long long ll;typedef struct&#123; int v,_nex;&#125;Edge;Edge edge[400005];char vis[10005]=&#123;0&#125;;int n,m,que[20005],f,r,at[10005],cnt=0,S,T,d[10005];int at_[10005];void bfs1()&#123; f=r=0; que[r++]=T,vis[T]=1; int h,i,j,v; while(r-f)&#123; h=que[f++]; for(i=at[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!vis[v]) vis[v]=1,que[r++]=v; &#125; &#125;&#125;bool judge(int u)&#123; for(int i=at_[u];i;i=edge[i]._nex) if(!vis[edge[i].v])return 0; return 1;&#125;void bfs2()&#123; if(!judge(S))return ; d[S]=0,f=r=0; que[r++]=S; int i,j,h,v,st; while(r-f)&#123; h=que[f++]; for(i=at_[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!judge(v))continue; if(d[v]&gt;d[h]+1) d[v]=d[h]+1,que[r++]=v; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v; for(i=0;i&lt;m;i++) scanf("%d%d",&amp;u,&amp;v), edge[++cnt].v=u,edge[cnt]._nex=at[v],at[v]=cnt; scanf("%d%d",&amp;S,&amp;T); fill(d+1,d+n+1,INF); bfs1(); for(i=1;i&lt;=n;i++) for(j=at[i];j;j=edge[j]._nex) edge[++cnt].v=i,edge[cnt]._nex=at_[edge[j].v],at_[edge[j].v]=cnt; bfs2(); if(d[T]==INF)printf("-1\n"); else printf("%d\n",d[T]); return 0;&#125; 提高D2T3 解方程题目地址 高精大概可以做到$50$分。想一想，带进去一个$x$，怎么判断左边是否是$0$呢？可不可以避免计算这个准确值呢？学过哈希，我们知道可以把字符串映射到一个值上，值相等那么认为两个字符串相等。但是这个数一般而言很大，所以要对素数取模，来缩小这个值。（虽然哈希跟这题没什么关系）我们也可以用这种类似的做法。对于一个$x$，只要把左边的值模一下一个质数$p$，如果答案是$0$，那么左边的值就很有可能是$0$。为了提高准确程度，我们多模几个质数，如果得到的结果都是$0$，就认为$x$是一个根。这么做可以拿$70$分，因为判断一个解的时间复杂度是$O(n\times $质数个数$)$的，总时间复杂度是$O(m\times n\times $质数个数$)$。然后发现其实没必要全部枚举$m$，因为只要几个$x$模$p$的余数相同，左边的值都是相同的。所以只要保存$x=0,1,…p-1$的取模结果即可，时间复杂度是$O(n\times p_{max}\times $质数个数$+m)$。质数选几个不大不小的即可，推荐选$5$~$6$个。当然如果你幸运EX的话模一两个也是能A掉的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int p[]=&#123;9973,10723,10937,11161,13337&#125;;int n,m,a[5][105]=&#123;0&#125;,fx[5][20000];char s[100005];bool ans[1000005];int read_(int M)&#123;; int f=1,x=0; if(s[0]=='-')f=-f; for(char *t=(s[0]=='-'?s+1:s);*t;t++)x=(x*10+*t-'0')%M; return f*x;&#125;void init()&#123; n=read(),m=read(); for(int i=0;i&lt;=n;i++)&#123; scanf("%s",s); for(int j=0;j&lt;5;j++)a[j][i]=read_(p[j]); &#125; for(int i=0;i&lt;5;i++) for(int j=1;j&lt;=p[i];j++)&#123; int res=0; for(int k=n;k&gt;=0;k--) res=(res*j+a[i][k])%p[i]; fx[i][j]=res; &#125;&#125;void solve()&#123; int cnt=0,flag; for(int i=1;i&lt;=m;i++)&#123; flag=0; for(int j=0;j&lt;5;j++) if(fx[j][i%p[j]])&#123; flag=1; break; &#125; if(!flag)cnt++,ans[i]=1; &#125; printf("%d\n",cnt); for(int i=1;i&lt;=m;i++) if(ans[i])printf("%d\n",i);&#125;int main()&#123; init(); solve(); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
        <tag>枚举</tag>
        <tag>二分</tag>
        <tag>模拟</tag>
        <tag>树形结构</tag>
        <tag>最短路</tag>
        <tag>非完美算法</tag>
        <tag>部分搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2012%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2012十道题目的题解。 普及T1 质因数分解题目地址 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); for(int i=2;i*i&lt;=n;i++) if(n%i==0)&#123; printf("%d\n",n/i); return 0; &#125; return 0;&#125; 普及T2 寻宝题目地址 模拟，时间复杂度$O(nm)$。每一层记录一下有楼梯的房间数，找房间用一个循环实现。1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,sum=0,p=20123,at[10005][105][2],access[10005]=&#123;0&#125;,st;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int tmp=0,lf; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; scanf("%d%d",&amp;at[i][j][0],&amp;at[i][j][1]); if(at[i][j][0])access[i]++; &#125; scanf("%d",&amp;st); for(int i=0;i&lt;n;i++)&#123; lf=at[i][st][1]; sum+=lf,lf%=access[i],tmp=st; if(!lf)lf=access[i]; for(;;)&#123; if(at[i][tmp][0])lf--; if(!lf)break; tmp=(tmp+1)%m; &#125; st=tmp,sum%=p; &#125; printf("%d\n",sum); return 0;&#125; 普及T3 摆花题目地址 很容易看出来这是一个$DP$。设$f(i,j)$为摆到第i种花，共有$j$盆的方案数。那么 f(i,j)=\sum_{k=0}^{\min(j,a[i])}f(i-1,j-k)时间复杂度：$O(nm^2)$。12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;int n,m,a[105],dp[105][105]=&#123;0&#125;,p=1000007;int main()&#123; int i,j,k; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(i=0;i&lt;=a[0];i++) dp[1][i]=1; for(i=2;i&lt;=n;i++) for(j=0;j&lt;=m;j++) for(k=0;k&lt;=a[i-1];k++) if(j-k&gt;=0)dp[i][j]+=dp[i-1][j-k],dp[i][j]%=p; else break; printf("%d\n",dp[n][m]); return 0;&#125; 普及T4 文化之旅题目地址 错误方法不正确，但却能快速通过本题的方法是$SPFA$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 1000000000using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[20005];int cnt=0,at[105],n,k,m,s,t;int que[10005][105],f,r,c[105],mat[105][105],d[105],in[105]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125;void spfa_bfs()&#123; fill(d+1,d+n+1,INF); d[s]=0; que[r][0]=s,que[r++][c[s]]=1,in[s]=1; int i,_u,_v,_co,j,ok,cul; while(r-f)&#123; _u=que[f++][0],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost,cul=c[_v]; for(ok=1,j=1;j&lt;=k;j++) if(mat[cul][que[f-1][j]])&#123; ok=0;break; &#125; if(!ok)continue; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r][0]=_v; for(j=1;j&lt;=k;j++) que[r][j]=que[f-1][j]; r++; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;k,&amp;m,&amp;s,&amp;t); int i,j,u,v,_c; for(i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(i=1;i&lt;=k;i++) for(j=1;j&lt;=k;j++) scanf("%d",&amp;mat[i][j]); memset(at,-1,sizeof(at)); for(i=0;i&lt;m;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;_c), addedge(u,v,_c), addedge(v,u,_c); spfa_bfs(); printf("%d\n",d[t]&gt;=INF-100?-1:d[t]); return 0;&#125; 正解正解是搜索。考虑使用高效算法进行优化，那么先以$T$为起点跑$SPFA$，然后从起点搜索的时候，如果不考虑文化的容斥关系都有“当前点到$T$最短路长$+$当前已走距离$\ge ans$”的话就停止搜索。用$DFS$，跑的还比较快。upd:上述的做法是正确的，但是这题数据很恶，所以要调整搜索顺序，倒着搜。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int to[20005],at[105],nex[20005],cnt=0;int V,E,K,S,T,mat[105][105],c[105],dis[105][105];int que[10005],f,r,dist[105],in[105];int vis[105],ans=1000000000;void spfa()&#123; fill(dist+1,dist+V+1,INF); f=r=0,que[r++]=S,in[S]=1,dist[S]=0; int h,v; while(r&gt;f)&#123; h=que[f++],in[h]=0; for(int i=at[h];i;i=nex[i])&#123; v=to[i]; if(dist[v]&gt;dist[h]+dis[h][v])&#123; dist[v]=dist[h]+dis[h][v]; if(!in[v]) in[v]=1,que[r++]=v; &#125; &#125; &#125;&#125;void dfs(int cur,int d)&#123; if(cur==S)&#123; ans=min(ans,d); return ; &#125; if(d+dist[cur]&gt;=ans)return ; vis[c[cur]]=1; for(int i=at[cur];i;i=nex[i])&#123; int v=to[i],flag=0; if(vis[c[v]])continue; for(int j=1;j&lt;=K;j++) if(vis[j]&amp;&amp;mat[c[v]][j])&#123; flag=1; break; &#125; if(flag)continue; dfs(v,d+dis[cur][v]); &#125; vis[c[cur]]=0;&#125; void init()&#123; V=read(),K=read(),E=read(),S=read(),T=read(); for(int i=1;i&lt;=V;i++)c[i]=read(); for(int i=1;i&lt;=K;i++) for(int j=1;j&lt;=K;j++) mat[i][j]=read(); for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) dis[i][j]=INF; for(int i=1;i&lt;=E;i++)&#123; int u=read(),v=read(),co=read(); if(dis[u][v]&lt;co)continue; dis[u][v]=dis[v][u]=co; to[++cnt]=v,nex[cnt]=at[u],at[u]=cnt; to[++cnt]=u,nex[cnt]=at[v],at[v]=cnt; &#125; spfa();&#125;void solve()&#123; dfs(T,0); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 Vigenère密码题目地址 这个加密运算其实就是循环移位。密文是循环进位，我们倒着做就行了。12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char key[1005],tex[1005];int get(char a,char b)&#123; return (b-'a'-(a-'a')+26)%26;&#125;int main()&#123; scanf("%s%s",key,tex); int l1=strlen(key),l2=strlen(tex); for(int i=0;i&lt;l1;i++) key[i]=tolower(key[i]); for(int i=0;i&lt;l2;i++)&#123; if(isupper(tex[i])) putchar('A'+get(key[i%l1],tolower(tex[i]))); else putchar('a'+get(key[i%l1],tex[i])); &#125; return 0; &#125; 提高D1T2 国王游戏题目地址 考虑第$i$和第$i+1$个人，他们手上的数字分别为a_i,b_i,a_{i+1},b_{i+1}，第$i+1$个人站在第$i$个人身后。设第$i$个人前面所有人左手数字的积为$T$，那么这两个人拿到的金币数分别为\lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor如果两人交换顺序，那么两人拿到的金币数分别为\lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor为了让获得最多金币的人得到的金币尽量少，我们就需要根据\max \left \{ \lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor\right\}和\max \left \{ \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor\right\}判断是否该让两个人交换顺序。如果交换了顺序使得取得的$max$更小，那么就需要交换。而根据归纳法，对每一对人按这种方法排一个序，就可以求出正确的答案。此时排序的时间复杂度为$O(n^2)$。但仔细观察可以发现，\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor > \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor>\lfloor \frac{T}{b_i}\rfloor。因此只需要确定了\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor和\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor的大小关系，就可以根据不等号的传递性判断哪一种顺序产生的最大值更小。而对上面两个式子变形，消去$T$并且移项便可以发现：只要比较a_ib_i和a_{i+1}b_{i+1}的大小就可判断。于是可以以a_ib_i为关键字排序，来确定整个队伍的顺序。此时，时间复杂度为$O(nlogn+$高精度运算需要的时间$)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; using namespace std;typedef long long ll;struct P&#123; int a,b,t;&#125;;bool operator&lt;(const P &amp;u,const P &amp;v)&#123; return (u.t&lt;v.t);&#125;P p[1005];int d1[3]=&#123;0&#125;,d2[5000]=&#123;0&#125;,d3[5000],ans[5000]=&#123;0&#125;,n;void mul(int s1[],int s2[],int to[])&#123; to[0]=s1[0]+s2[0]; for(int i=1;i&lt;=s1[0];i++)&#123; int x=0; for(int j=1;j&lt;=s2[0];j++) x=s1[i]*s2[j]+x+to[i+j-1],to[i+j-1]=x%10000,x/=10000; to[i+s2[0]]=x; &#125; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void div(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=s1[0];i&gt;=1;i--) to[i]=(x*10000+s1[i])/s2,x=x*10000+s1[i]-to[i]*s2; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;int smaller(int n1[],int n2[])&#123;//&lt;0 ：小于 if(n1[0]!=n2[0])return n1[0]-n2[0]; else&#123; for(int i=n1[0];i&gt;=1;i--) if(n1[i]!=n2[i])return n1[i]-n2[i]; return 0; &#125;&#125;void output(int s[])&#123; printf("%d",s[s[0]]); for(int i=s[0]-1;i&gt;=1;i--) printf("%04d",s[i]); printf("\n");&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;=n;i++) scanf("%d%d",&amp;p[i].a,&amp;p[i].b),p[i].t=p[i].a*p[i].b; sort(p+1,p+1+n); d1[0]=d2[0]=d2[1]=1; for(int i=0;i&lt;n;i++)&#123; memset(d3,0,sizeof(d3)); d1[1]=p[i].a,mul(d1,d2,d3),memcpy(d2,d3,sizeof(d3)); div(d2,p[i+1].b,d3); if(smaller(ans,d3)&lt;0) memcpy(ans,d3,sizeof(d3)); &#125; output(ans); return 0;&#125; 提高D1T3 开车旅行题目地址 倍增。倍增出小A小B经过$2^k$个回合的情况，然后找最近的最小值用排序+双向链表或者$BST$即可。时间复杂度：$O((n+m)logn)$。边界的一些处理比较烦，需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2100000000using namespace std;typedef long long ll;int high[100005][2],_h[100005][2],lf[100005],rt[100005],n,lg,X,S;ll dis[100005][4],_dis[100005][18][4];//dis [0] 小A开距离 [1]小A开到 [2]小B开距离 [3]小B开到//_dis[i][j]过2^j个回合 [0]小a开距离 [1]小b开距离 [2]开到 [3]总路程 int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;void init()&#123; int i,j,lis[4],m1[2],m2[2],d; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;high[i][0]), high[i][1]=i; memcpy(_h,high,sizeof(high)); qsort(_h,n,sizeof(_h[0]),cmp); lf[_h[0][1]]=-1; for(i=1;i&lt;n;i++) lf[_h[i][1]]=_h[i-1][1]; rt[_h[n-1][1]]=-1; for(i=0;i&lt;n-1;i++) rt[_h[i][1]]=_h[i+1][1]; for(i=0;i&lt;n;i++)&#123; lis[0]=lf[i],lis[1]=rt[i]; lis[2]=(lf[i]&lt;0)?-1:lf[lis[0]]; lis[3]=(rt[i]&lt;0)?-1:rt[lis[1]]; m1[0]=m2[0]=INF; m1[1]=m2[1]=-1; //m1：最小 m2：第二小 [0]距离 [1]位置 for(j=0;j&lt;4;j++) if(lis[j]&gt;=0)&#123; d=abs(high[lis[j]][0]-high[i][0]); if(d&lt;m1[0]||(d==m1[0]&amp;&amp;high[lis[j]][0]&lt;high[m1[1]][0]))//lis[j]的海拔低 m2[0]=m1[0],m2[1]=m1[1], m1[0]=d,m1[1]=lis[j]; else if(d&lt;m2[0]||(d==m2[0]&amp;&amp;high[lis[j]][0]&lt;high[m2[1]][0])) m2[0]=d,m2[1]=lis[j]; &#125; if(m2[0]&gt;=INF)m2[0]=0; if(m1[0]&gt;=INF)m1[0]=0; dis[i][0]=m2[0], dis[i][1]=m2[1], dis[i][2]=m1[0], dis[i][3]=m1[1]; if(rt[i]&gt;=0)lf[rt[i]]=lf[i]; if(lf[i]&gt;=0)rt[lf[i]]=rt[i];//自我删除 &#125; for(i=1,d=0;i&lt;n;i&lt;&lt;=1,d++); lg=d; for(i=0;i&lt;n;i++)&#123; _dis[i][0][0]=dis[i][0]; if(dis[i][1]&gt;=0) _dis[i][0][1]=dis[dis[i][1]][2], _dis[i][0][2]=dis[dis[i][1]][3]; else _dis[i][0][1]=0,_dis[i][0][2]=-1; _dis[i][0][3]=_dis[i][0][0]+_dis[i][0][1]; &#125; for(j=1;j&lt;=lg;j++) for(i=0;i&lt;n;i++)&#123; _dis[i][j][0]=_dis[i][j-1][0], _dis[i][j][1]=_dis[i][j-1][1]; if(_dis[i][j-1][2]&gt;=0)//目的地存在 _dis[i][j][0]+=_dis[_dis[i][j-1][2]][j-1][0], _dis[i][j][1]+=_dis[_dis[i][j-1][2]][j-1][1], _dis[i][j][2]=_dis[_dis[i][j-1][2]][j-1][2]; else _dis[i][j][2]=-1; _dis[i][j][3]=_dis[i][j][0]+_dis[i][j][1]; &#125;&#125;void ask(int id,int &amp;a,int &amp;b)&#123; int i; for(i=lg;i&gt;=0;i-- ) if(_dis[id][i][3]+a+b&lt;=X&amp;&amp;_dis[id][i][2]&gt;=0)&#123; a+=_dis[id][i][0], b+=_dis[id][i][1], ask(_dis[id][i][2],a,b); break; &#125; if(i&lt;0) for(i=0;i&lt;=lg;i++) if(_dis[id][i][0]+a+b&lt;=X)&#123; a+=_dis[id][i][0]; break; &#125;&#125;void solve1()&#123; int i,_d[2],d_[2],ans; double bi=1e12,t1,t2; scanf("%d",&amp;X); for(i=0;i&lt;n;i++)&#123; d_[0]=d_[1]=0; ask(i,d_[0],d_[1]); t1=d_[0],t2=d_[1]; if(!t2)t1=1e11; else t1/=t2; if(bi&gt;t1||(abs(bi-t1)&lt;0.0000001&amp;&amp;high[i][0]&gt;high[ans][0])) bi=t1,_d[0]=d_[0],_d[1]=d_[1],ans=i; &#125; printf("%d\n",ans+1); &#125;void solve2()&#123; int m,i,u,v; scanf("%d",&amp;m); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;S,&amp;X), u=0,v=0, ask(S-1,u,v), printf("%d %d\n",u,v);&#125;int main()&#123; init(); solve1(); solve2(); return 0;&#125; 提高D2T1 同余方程题目地址 就是让你求一个逆元。用快速幂+欧拉函数或者扩欧都行。我只写了扩欧，但是前者应该好写一点。时间复杂度：$O(logn)$12345678910111213141516171819#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; ll d=a; if(b)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125;else x=1,y=0; return d; &#125;int main()&#123; ll a,m,x,y; scanf("%lld%lld",&amp;a,&amp;m); extgcd(a,m,x,y); x=(x%m+m)%m; printf("%lld\n",x); return 0; &#125; 提高D2T2 借教室题目地址 方法一维护一种数据结构，它支持:1.区间减法2.检查最小值的正负性线段树即可。这种方法常数很大。时间复杂度：$O((n+m)logn)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int seg[2200000],tag[2200000]=&#123;0&#125;;int n,size,_a,_b,m,rec[3][1000005],_v;int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar(); return x;&#125;void pushdown(int id)&#123; if(tag[id]&amp;&amp;id&lt;size) tag[id&lt;&lt;1]+=tag[id],tag[id&lt;&lt;1|1]+=tag[id], seg[id&lt;&lt;1]+=tag[id],seg[id&lt;&lt;1|1]+=tag[id], tag[id]=0; &#125;void init()&#123; int i; for(size=1;size&lt;n;size&lt;&lt;=1); for(i=size;i-size&lt;n;i++)seg[i]=read(); for(;i&lt;(size&lt;&lt;1);i++)seg[i]=INF; for(i=size-1;i&gt;=1;i--) seg[i]=min(seg[i&lt;&lt;1],seg[i&lt;&lt;1|1]);&#125;void minus(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(_a&lt;=l&amp;&amp;r&lt;=_b)&#123; tag[id]+=_v,seg[id]+=_v; return ; &#125; pushdown(id); minus(id&lt;&lt;1,l,(l+r)&gt;&gt;1); minus(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); seg[id]=min(seg[id&lt;&lt;1],seg[id&lt;&lt;1|1]);&#125;int solve()&#123; for(int i=0;i&lt;m;i++)&#123; _v=-rec[0][i],_a=rec[1][i],_b=rec[2][i], minus(1,1,size); if(seg[1]&lt;0)return i+1; &#125; return -1;&#125;int main()&#123; n=read(),m=read(); init(); for(int i=0;i&lt;m;i++) rec[0][i]=read(),rec[1][i]=read(),rec[2][i]=read(); int ans=solve(); if(ans&lt;0)printf("0\n"); else printf("-1\n%d\n",ans); return 0;&#125; 方法二我们发现随着订单的增多，可用教室的数量是只减不增的，所以我们尝试二分。二分一个最大订单量，然后区间减法用差分实现，最后扫一遍，看看是否存在负值即可。（差分：假设我们有一个数列:a_1,a_2,a_3,...,a_n 定义它的差分数列是a_1,a_2-a_1,a_3-a_2,...a_n-a_{n-1} 这样可以发现差分数列中前$n$个元素的和就是原来数列当前位置元素的值。然后为什么说他可以用来做区间减法呢？比方有$5$个数，$a_1,a_2,a_3,a_4,a_5$，差分数列就是$a_1,a_2-a_1,a_3-a_2,a_4-a_3,a_5-a_4$，然后第$2$到$4$个每一个减掉$p$，那么原数列就是 a_1,a_2-p,a_3-p,a_4-p,a_5新的差分数列就是 a_1,a_2-a_1-p,a_3-a_2,a_4-a_3,a_5-a_4+p可以发现，本来要修改多个元素，在差分数列里就只要修改$2$个元素。由于我们只要在处理完所有区间操作后再扫一遍查询负数，所以这么做能满足我们的需求。时间复杂度：$O((n+m)logn)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,d[N],q[N],s[N],e[N];int oold,nnew;void update()&#123; if(nnew&gt;oold)&#123; for(int i=oold+1;i&lt;=nnew;i++) d[s[i]]-=q[i],d[e[i]+1]+=q[i]; &#125;else&#123; for(int i=oold;i&gt;nnew;i--) d[s[i]]+=q[i],d[e[i]+1]-=q[i]; &#125;&#125;bool C()&#123; int flag=0,sum=0; update(); for(int i=1;i&lt;=n;i++)&#123; sum+=d[i]; if(sum&lt;0)&#123; flag=1; break; &#125; &#125; return flag;&#125;void init()&#123; n=read(),m=read(); int lst=read(); d[1]=lst; for(int i=2;i&lt;=n;i++) d[i]=read(),d[i]-=lst,lst+=d[i]; d[n+1]=-lst; for(int i=1;i&lt;=m;i++) q[i]=read(),s[i]=read(),e[i]=read();&#125;void solve()&#123; int L=1,R=m; oold=0; while(R&gt;L)&#123; nnew=(L+R)&gt;&gt;1; if(C())R=nnew; else L=nnew+1; oold=nnew; &#125; if(L==m)printf("0\n"); else printf("-1\n%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T3 疫情控制题目地址 容易发现时间越多，控制疫情的任务越有可能完成。所以先二分一个答案$x$，然后判断它可不可行。显然，一个军队走的越高，他能控制的就越多，所以让军队尽量向上走，直到走到根或者时间不够为止。如果可以走到根就记录一下走到根的时候剩余的时间，走不到就给最后到的点打一个标记，这个向上走可以用倍增实现。还可以发现的是，与根直接相连的点很重要，我们称呼他们为关键点，只要全部控制了他们就完成了任务。而判断一个关键点是否被控制可以用一遍$DFS$实现。对于没被控制的关键点，我们把他们到根的路径长记录下来。我们要让可以到根的军队发配到相应的关键点，并且使得这个分配尽可能合理。怎么做呢？考虑贪心，让剩余时间少的军队去占领最近的关键点，时间多的去占领远的。所以给军队剩余时间和关键点的距离分别排序，做一个贪心即可。注意，如果当前扫到的军队无法前往最近的关键点，那就让他回到他之前到根的路上经过的关键点。这样可以最大程度的利用军队。综上，我们在$O(nlogn+mlognlogw)$的时间复杂度内完成了本题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 10000000000000ll#define LOG 17using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P left[50005],city[50005];int to[100005],nex[100005],at[50005],cnt=0;int n,m,p[100005],par[50005][20],secfa[50005];int cost[100005],depth[50005],maxd=0,dis[50005][20];int tot=0,totc=0;bool vis[50005];int query(int u,int t)&#123; if(depth[u]&lt;=t)return 1; for(int i=LOG;i&gt;=0;i--) if(par[u][i]&amp;&amp;dis[u][i]&lt;=t) t-=dis[u][i],u=par[u][i]; return u;&#125;void dfs2(int cur,int fa)&#123; if(vis[cur])return ; bool flag=1,isleaf=1; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; dfs2(to[i],cur),flag&amp;=vis[to[i]]; isleaf=0; &#125; if(!isleaf)vis[cur]=flag;&#125;bool C(int x)&#123; tot=totc=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=m;i++)&#123; int goal=query(p[i],x); if(goal==1)left[++tot].first=x-depth[p[i]],left[tot].second=p[i]; else vis[goal]=1; //打标记 &#125; dfs2(1,0); if(vis[1])return 1;//根节点的子树全部被覆盖了 for(int i=at[1];i;i=nex[i]) if(!vis[to[i]])city[++totc].second=to[i],city[totc].first=cost[i]; sort(left+1,left+tot+1); sort(city+1,city+totc+1); int r=1,fr; for(int i=1;r&lt;=totc&amp;&amp;i&lt;=tot;i++)&#123; fr=left[i].second; if(left[i].first&lt;city[r].first)&#123; vis[secfa[fr]]=1; &#125;else&#123; vis[city[r].second]=1,r++; &#125; while(vis[city[r].second]&amp;&amp;r&lt;=totc)r++; &#125; if(r==totc+1)return 1; return 0;&#125;void addedge(int _u,int _v,int _c)&#123; to[++cnt]=_v,cost[cnt]=_c,nex[cnt]=at[_u],at[_u]=cnt;&#125;void dfs(int cur,int fa)&#123; par[cur][0]=fa,maxd=max(maxd,depth[cur]); for(int j=1;j&lt;=LOG;j++) if(par[cur][j-1]) par[cur][j]=par[par[cur][j-1]][j-1], dis[cur][j]=dis[cur][j-1]+dis[par[cur][j-1]][j-1]; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; int _v=to[i],_c=cost[i]; depth[_v]=depth[cur]+_c, dis[_v][0]=_c; if(cur==1)secfa[_v]=_v; else secfa[_v]=secfa[cur]; dfs(_v,cur); &#125;&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); m=read(); for(int i=1;i&lt;=m;i++)p[i]=read(); dfs(1,0);&#125;void solve()&#123; int son=0; for(int i=at[1];i;i=nex[i])son++; if(son&gt;m)&#123; printf("-1\n"); return ; &#125; int L=0,R=2*maxd,M; while(R&gt;L)&#123; M=(L+R)&gt;&gt;1; if(C(M))R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>搜索</tag>
        <tag>二分</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
        <tag>SPFA</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2013%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2013十道题目的题解。 普及T1 计数问题题目地址 某一道著名数位DP的弱化版。模拟即可，时间复杂度为$O(n)$。1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans=0,x;int main()&#123; scanf("%d%d",&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) for(int j=i;j;j/=10) ans+=(j%10==x); printf("%d\n",ans); return 0;&#125; 普及T2 表达式求值题目地址 简单而又基础的表达式计算的题目。连括号都没有，只要注意取模即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;char k[1200005]=&#123;0&#125;;int len,st[2][100005]=&#123;0&#125;,top[2]=&#123;0&#125;,pro[255];void push(int a,int to)&#123; st[to][top[to]++]=a;&#125;int pop(int to)&#123; top[to]--; return st[to][top[to]];&#125;void opr()&#123; int a1,a2,p; a2=pop(1),a1=pop(1),p=pop(0); if(p=='+')push((a1+a2)%10000,1); if(p=='*')push((a1%10000)*(a2%10000)%10000,1);&#125;int main()&#123; fgets(&amp;k[1],1200000,stdin); k[0]='(',len=strlen(k); while(isspace(k[len-1])) k[--len]='\0'; k[len++]=')'; pro['+']=pro['-']=1; pro['*']=pro['/']=2; int sum=-1; for(int i=0;i&lt;len;i++)&#123; if(isdigit(k[i]))&#123; if(sum==-1)sum=k[i]-'0'; else sum=sum*10+k[i]-'0'; &#125;else&#123; if(sum&gt;-1) push(sum,1),sum=-1; if(k[i]=='(') push('(',0); else if(k[i]==')')&#123; while(st[0][top[0]-1]!='(') opr(); pop(0); &#125;else&#123; while(st[0][top[0]-1]!='('&amp;&amp;pro[st[0][top[0]-1]]&gt;=pro[k[i]]) opr(); push(k[i],0); &#125; &#125; &#125; printf("%d\n",pop(1)%10000); return 0; &#125; 普及T3 小朋友的数字题目地址 容易看出这是一个最大子段和的问题。我们知道小朋友的分数是不递减的，所以边算便取模即可。 完了吗？没有。相信很多人都挂在了第一个点。这个点很有意思，因为通过它，我们发现上文的一个重要结论是错的。小朋友的分数在第2-n个是不递减的。但第一个不是。所以要加上对第一个的特判，方法就是：如果当前记录的（分数+特征值）的最大值还是负数，答案就取第一个分数和当前分数的较大值，否则直接取当前分数。因为如果（分数+特征值）的最大值还是负数，那么他一定还有可能小于第一个的分数。时间复杂度：$O(n)$。本题代码可能有疏漏，如果能hack掉请告诉我一声，谢谢！12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 2100000000000000llusing namespace std;typedef long long ll;ll d,maxspc=-INF,sum=0,ans,maxi=-INF,mini=INF,p,sc,beg; int n;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;p,&amp;d); mini=0,sum=d,maxi=d,maxspc=2*d,sc=maxi%p,ans=maxi%p; beg=d; for(int i=2;i&lt;=n;i++)&#123; mini=min(mini,sum), scanf("%lld",&amp;d),sum+=d, maxi=max(maxi,sum-mini);//sp[i] sc=maxspc%p; if(maxi&gt;0)&#123; maxspc=(maxi+sc)%p; if(maxspc&lt;0)ans=max(sc,beg); else ans=sc; &#125; &#125; printf("%lld\n",ans); return 0;&#125; 普及T4 车站分级题目地址 一眼看出来是差分约束，后来发现这个图是一个$DAG$（题目保证存在这么一个方案，就不会有环的存在），求最长路可以直接跑拓扑排序，所以就做完了。时间复杂度为$O(n^2m)$，理论上如此，但实际操作中还行。（主要花在建图上）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,cnt[1005]=&#123;0&#125;,to[1005][1005],lis[1005];int vis[1005],d[1005]=&#123;0&#125;,que[1005],f,r,du[1005]=&#123;0&#125;;bool mat[1005][1005]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; memset(vis,0,sizeof(vis)); int u,v,k,fi,en; scanf("%d",&amp;k); for(int j=0;j&lt;k;j++) scanf("%d",&amp;lis[j]),vis[lis[j]]=1; fi=lis[0],en=lis[k-1]; //有无人向我连边？ for(int j=fi+1;j&lt;en;j++)&#123; if(vis[j])continue; for(u=0;u&lt;k;u++) if(!mat[j][lis[u]]) mat[j][lis[u]]=1, to[j][cnt[j]++]=lis[u], du[lis[u]]++; &#125; &#125;&#125;void solve()&#123; int i,j,lst,at,ans=0; memset(vis,0,sizeof(vis)); fill(d+1,d+n+1,-1); f=r=0; for(i=1;i&lt;=n;i++) if(!du[i]) d[i]=0,que[r++]=i; while(r-f)&#123; int h=que[f++],v; for(int i=0;i&lt;cnt[h];i++)&#123; v=to[h][i]; d[v]=max(d[v],d[h]+1); du[v]--; if(!du[v])que[r++]=v; &#125; ans=max(ans,d[h]); &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 转圈游戏题目地址 相当于每一次对编号加一个$m$，然后对$n$取模，如此做$10^k$次。所以答案就是$(m+m+m+…+m+x)\mod n=(m\times 10^k+x)\mod n$。使用快速幂即可，时间复杂度$O(logk)$。1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll n,m,k,x;int main()&#123; scanf("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;x); printf("%lld\n",((Pow(10%n,k,n))*m+x)%n); return 0;&#125; 提高D1T2 火柴排队题目地址 如果你知道什么叫排序不等式，这题就是道裸题。如果你不知道，额，你也可以自己证明：当a_1]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>线性DP</tag>
        <tag>栈</tag>
        <tag>MST</tag>
        <tag>LCA</tag>
        <tag>拓扑排序</tag>
        <tag>树状数组</tag>
        <tag>分治</tag>
        <tag>快速幂</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2016%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2016十道题目的题解。 普及T1 买铅笔题目地址 对于每一种都判断一下，我要达到这个量最少要买几包铅笔。这是一个简单的除法和模运算。1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n,c,v,ans=2000000000;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;3;i++)&#123; scanf("%d%d",&amp;v,&amp;c); j=(n%v==0)?n/v:(n/v+1); j*=c,ans=min(ans,j); &#125; printf("%d\n",ans); return 0;&#125; 普及T2 回文日期题目地址 你可以估计一下年份的范围，然后直接暴力统计。使用字符串函数是基本功呢。（笑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;char a[10],b[10];int rs[]=&#123;1,3,5,7,8,10,12&#125;,ans=0,x1,x2,y1,y2,m1,m2,d1,d2;bool cmp(int ye,int mo,int da)&#123; if(ye&lt;y1||ye&gt;y2)return false; if(ye==y1)&#123; if(mo&lt;m1)return false; else if(mo==m1)&#123; if(da&lt;d1)return false; &#125; &#125;else if(ye==y2)&#123; if(mo&gt;m2)return false; else if(mo==m2)&#123; if(da&gt;d2)return false; &#125; &#125; return true;&#125;int main()&#123; scanf("%s%s",a,b); x1=atoi(a),x2=atoi(b); y1=x1/10000,y2=x2/10000; m1=(x1%10000)/100,m2=(x2%10000)/100; d1=x1%100,d2=x2%100; int i,j,k,l,t,ye,mo,da,ok; for(i=0;i&lt;=1;i++) for(j=0;j&lt;=9;j++)&#123; mo=i*10+j; if(mo&gt;12)break; if(!mo)continue; for(k=0;k&lt;=3;k++)&#123; if(k==3&amp;&amp;mo==2)break; for(l=0;l&lt;=9;l++)&#123; ye=l*1000+k*100+j*10+i, da=k*10+l; if(da&gt;31)break; if(!da)continue; if(da==31)&#123; for(ok=t=0;t&lt;7;t++) if(mo==rs[t])ok=1; if(!ok)break; &#125; if(ye%400==0||(ye%4==0&amp;&amp;ye%100!=0))&#123; if(mo==2&amp;&amp;da&gt;29)break; &#125;else if(mo==2&amp;&amp;da&gt;28)break; if(!cmp(ye,mo,da))continue; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 普及T3 海港题目地址 统计？12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int t,k,st;&#125;D;D _q[100005];int n,cnt[100005]=&#123;0&#125;,_cnt=0,q[300005],f,r,cur=0;int main()&#123; scanf("%d",&amp;n); int t,m,i,j,l; f=r=0; for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;t,&amp;m); _q[r].t=t,_q[r++].k=m; while(r&gt;f&amp;&amp;_q[f].t&lt;=t-86400)&#123; for(j=_q[f].st,l=0;l&lt;_q[f].k;l++,j++)&#123; cnt[q[j]]--; if(!cnt[q[j]])_cnt--; &#125; f++; &#125; _q[r-1].st=cur; for(l=0;l&lt;m;l++,cur++)&#123; scanf("%d",&amp;q[cur]); cnt[q[cur]]++; if(cnt[q[cur]]==1)_cnt++; &#125; printf("%d\n",_cnt); &#125; return 0;&#125; 普及T4 魔法阵题目地址 好方法不妨设x_a-x_b=len，那么对于每一个$i$，设i=x_b，枚举一次$len$。接下来的事情就很玄学了：$len$的限制是$len\le i-1$且$len\le 2\times\lfloor \frac{n-i-1}7 \rfloor$，算一下发现$len_{max}=\lfloor \frac{2n-4}9 \rfloor$，又由于$len$是偶数，所以每一次枚举的次数至多为$\lfloor \frac n 9 \rfloor$。这个常数很小，考虑暴力。总体上是枚举长度$len$，每一次枚举x_a，x_b，算出可行的x_c，x_d贡献，再对x_c，x_d做一遍。（当然也可以只做一遍，那样会很麻烦，见下面的下面的失败代码）这里可以发现随着x_c，x_d的递增x_a，x_b是递增的，所以可以用前缀和优化；对于x_c，x_d同理。时间复杂度$O(n^2)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],cnt[15005]=&#123;0&#125;;int ca[15005],cb[15005],cc[15005],cd[15005];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) a[i]=read(),cnt[a[i]]++;&#125;void solve()&#123; int hf_max=n/9,len,rp,xa,xb,xc,xd,sum; for(int hf=1;hf&lt;=hf_max;hf++)&#123;//长度的一半 len=hf&lt;&lt;1,sum=0; for(xc=4*len+2;xc&lt;=n-hf;xc++)&#123;//枚举xc xd=xc+hf,xa=xc-4*len-1,xb=xa+len; sum+=cnt[xa]*cnt[xb]; cc[xc]+=cnt[xd]*sum,cd[xd]+=cnt[xc]*sum; &#125; sum=0; for(xb=n-7*hf-1;xb&gt;=len+1;xb--)&#123;//枚举xb xa=xb-len,xd=7*hf+xb+1,xc=xd-hf; sum+=cnt[xc]*cnt[xd]; ca[xa]+=cnt[xb]*sum,cb[xb]+=cnt[xa]*sum; &#125; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]],cb[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125; 劣方法之前写了一个不够好，但是空间够大的情况下可以拿95分（大概）的程序。。。有兴趣的同学可以看看。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],ws[15005];int pre[2005][15005],dc[2005][15005],dd[2005][15005]; int ca[15005],cb[15005],cc[15005],cd[15005];bool calced[15005];void calc(int at,int len)&#123; int *cur=pre[len]; for(int i=at;i+len&lt;=n;i++) cur[i]=cur[i-1]+ws[i]*ws[i+len]; calced[len]=1;&#125;void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++)a[i]=read(),ws[a[i]]++;&#125;void solve()&#123; int xb,len,cnt,cnt_c,xs,hf; int lenmax=n/9,*tc,*td; for(int i=2;i&lt;=n;i++)&#123; if(!ws[i])continue; cnt=0; for(int len=2;len&lt;xb;len+=2)&#123; int rp=7*(len&gt;&gt;1)+i+1; if(rp&gt;n)break; if(!ws[i-len])continue; xs=ws[i-len]*ws[i],hf=(len&gt;&gt;1); dc[hf][rp-hf]+=xs,dc[hf][n-hf+1]-=xs; dd[hf][rp]+=xs,dd[hf][n+1]-=xs; if(!calced[hf])calc(rp-hf,hf); cnt_c=pre[hf][n-hf]-pre[hf][rp-hf-1]; cnt_c*=xs,cnt+=cnt_c,ca[i-len]+=cnt_c; &#125; cb[i]+=cnt; &#125; for(int i=1;i&lt;=lenmax;i++)&#123; tc=dc[i],td=dd[i]; for(int j=8*i+2;j&lt;=n-i;j++) tc[j]+=tc[j-1],td[j+i]+=td[j+i-1], cc[j]+=tc[j]*ws[j+i],cd[j+i]+=td[j+i]*ws[j]; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]]/ws[a[i]],cb[a[i]]/ws[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 玩具谜题题目地址 按照题意模拟即可。确定左右方向就用异或的方法。当然，多写几行判断也是可行的。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int in_or_out[100005],n,m;//in 0,out 1char job[100005][20];void init()&#123; n=read(),m=read(); for(int i=0;i&lt;n;i++) scanf("%d%s",&amp;in_or_out[i],job[i]);&#125;void solve()&#123; int opr,s,lst=0; while(m--)&#123; opr=read(),s=read(); int res=opr^in_or_out[lst]; if(!res)lst=(lst-s+n)%n; else lst=(lst+s)%n; &#125; printf("%s\n",job[lst]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T2 天天爱跑步题目地址 当初比赛的时候连暴力都没写对orz暴力的话，直接上$LCA$，大力模拟即可，大概可以拿25分。。。满分做法是从链状做法中过渡而来的。我们发现，从$S$到$T$总是经过他们的$LCA$的（废话），也就是说，可以从$LCA$的角度入手。然后考虑把树问题变成链问题，只要把$LCA$两边的链扯出来即可。对于一条链，一个点$S$可以给另一个点$i$贡献的情况只有从$S$到$i$走的步数=$W_i$。反映在链上，就是$|S-i|=W_i$。反映在树上，就是$depth[S]-depth[i]=W_i$，即$depth[S]=W_i+depth[i]$。这里假定$S$不是LCA，那么从$S$出发时不会往下面走的。我们显然希望对于$i$统计合法的对应$S$。那么就造一个数组，统计当前合法的$S$的个数，走到一个$i$上查一下即可。同理，另一边，有从LCA向下走到$T$，也是一样的道理，多开一个数组就行。（条件是$depth[i]-W_i=depth[T]-len(x,y)$）计算答案的顺序需要注意： 进入的时候先减掉答案，出去的时候再加上，才可以得到自身的贡献。（对于自己统计到的$S$和$T$） 由于$S$到$LCA$是向上，并且我们只希望在$S$到$LCA$的路径上查到我们想要的贡献，所以在向下DFS时添加自己作为$S$的信息，并在回到$LCA$时再减掉$S$的贡献；对$LCA$到$T$，我们只要它向上走的贡献，所以在回溯的时候在$T$处加上，再在$LCA$处减去。 负数下标。 总结一下，这道题有一个类似于差分的思想。。。在2015年应该有所领略。时间复杂度取决于你求$LCA$时算法的时间复杂度。为$O((n+m)logn)$或者$O(n+m)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define MAXN 300005#define MAXL 21using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,to[MAXN*2],_next[MAXN*2],at[MAXN]=&#123;0&#125;,Cnt=0;//树部分 int que[MAXN],depth[MAXN],par[MAXN][MAXL]=&#123;0&#125;,LOG;//LCA部分 int at2[MAXN]=&#123;0&#125;,to2[MAXN],_next2[MAXN],Cnt2=0;//存T的信息 int ats[MAXN]=&#123;0&#125;,tos[MAXN],_nexts[MAXN],Cnts=0;//自己是LCA时存S的深度 int att[MAXN]=&#123;0&#125;,tot[MAXN],_nextt[MAXN],Cntt=0;//自己是LCA时存T的深度 int m,ans[MAXN],w[MAXN],c[MAXN]=&#123;0&#125;;//ans答案 w出现时间 cS人数 int down[MAXN],up[MAXN*2]=&#123;0&#125;;//up S-&gt;LCA down LCA-&gt;T（可能有负数） void addedge(int _u,int _v)&#123; to[++Cnt]=_v,_next[Cnt]=at[_u],at[_u]=Cnt;&#125;void bfs()&#123; int f=0,r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; int h=que[f++]; for(int i=at[h];i;i=_next[i])&#123; int _v=to[i]; if(_v==par[h][0])continue; que[r++]=_v,depth[_v]=depth[h]+1,par[_v][0]=h; &#125; for(int i=1;i&lt;=LOG;i++) if(par[h][i-1])par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j,d; if(depth[u]&lt;depth[v]) swap(u,v); for(d=depth[u]-depth[v],i=0;(1&lt;&lt;i)&lt;=d;i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=LOG;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;//倍增求解LCAvoid dfs(int cur)&#123; //主要求解过程 int up_ans=up[depth[cur]+w[cur]], down_ans=down[depth[cur]-w[cur]+MAXN]; //旧的答案 up[depth[cur]]+=c[cur]; //作为S，添加自己 for(int i=at[cur];i;i=_next[i]) if(to[i]!=par[cur][0])dfs(to[i]); //搜索子树 for(int i=at2[cur];i;i=_next2[i]) down[to2[i]+MAXN]++; //作为T，添加自己的信息 ans[cur]=up[depth[cur]+w[cur]]+down[depth[cur]-w[cur]+MAXN]-up_ans-down_ans; //利用DFS性质计算自己的答案 for(int i=ats[cur];i;i=_nexts[i])&#123; up[tos[i]]--;//回溯时删去S if(tos[i]==depth[cur]+w[cur])ans[cur]--;//如果S就是LCA，那么答案重复，减掉1个 &#125; for(int i=att[cur];i;i=_nextt[i]) down[tot[i]+MAXN]--;//作为LCA，回溯时删去T&#125;void init()&#123; n=read(),m=read(); for(LOG=1;(1&lt;&lt;LOG)&lt;n;LOG++); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; bfs(); for(int i=1;i&lt;=n;i++)w[i]=read(); for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(); int lca=query(u,v),len=depth[u]+depth[v]-2*depth[lca]; c[u]++; tos[++Cnts]=depth[u],_nexts[Cnts]=ats[lca],ats[lca]=Cnts; tot[++Cntt]=depth[v]-len,_nextt[Cntt]=att[lca],att[lca]=Cntt; to2[++Cnt2]=depth[v]-len,_next2[Cnt2]=at2[v],at2[v]=Cnt2; &#125;&#125;void solve()&#123; dfs(1); for(int i=1;i&lt;n;i++) printf("%d ",ans[i]); printf("%d\n",ans[n]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T3 换教室题目地址 很水的期望DP，但是对于第一次写的人有点难度。（比方说我） 题目说要求最小的体力消耗期望值，并给出了地图，说明肯定先要求一次多源最短路。然后在现实意义上理解一下这里期望的意义。在这里，期望是概率和权值的乘积之和。并且每一次是否选课和其他几次都是没有关系的。会对权值造成影响的是这一次和前一次的申请情况。比如第$i$次申请了，第$i-1$次没申请，那么有两种情况：一是申请通过，本次体力消耗是c_{i-1}到d_i的最短路长；二是没有通过，本次体力消耗是c_{i-1}到c_i的最短路长。那么期望体力就是 E=k_i*d[c_{i-1},d_i]+(1-k_i)\times d[c_{i-1},c_i]以此类推，都申请有4种情况，一个申请一个不申请有2种情况，都不申请有1种情况，每种情况对应的期望体力是不变的。这样就转化为了一个类似背包的问题。设$f(i,j,k)$表示对于前$i$节课，使用了$j$次机会时需要的最小期望体力，$k=0$表示此次不申请，$k=1$表示此次不申请，分类讨论即可写出状态转移方程。具体见代码。时间复杂度：$O(nm+V^3)$注意，由于涉及了浮点数运算，该题的代码如果写的常数太大的话就会在最后一个点TLE。所以要适度卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,V,E,INF=1000000000;int d[305][305];int p1[2005],p2[2005];double f[2005][2005][2],p[2005],inf=1e9;void floyd()&#123; for(int k=0;k&lt;V;k++) for(int i=0;i&lt;V;i++) for(int j=0;j&lt;V;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;V,&amp;E); int i,j,u,v,c; for(i=0;i&lt;n;i++) scanf("%d",&amp;p1[i]),p1[i]--; for(i=0;i&lt;n;i++) scanf("%d",&amp;p2[i]),p2[i]--; for(i=0;i&lt;n;i++) scanf("%lf",&amp;p[i]); for(i=0;i&lt;V;i++) for(j=0;j&lt;V;j++) d[i][j]=(i==j)?0:INF; for(i=0;i&lt;E;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); if(d[u-1][v-1]&gt;c) d[u-1][v-1]=d[v-1][u-1]=c; &#125; floyd();&#125;void solve()&#123; int i,j,A,B,C,D; double choice,ans=inf; for(i=0;i&lt;n;i++) for(j=0;j&lt;=m;j++) f[i][j][0]=f[i][j][1]=inf; f[0][0][0]=f[0][1][1]=0; for(i=1;i&lt;n;i++)&#123; A=d[p1[i-1]][p1[i]], B=d[p1[i-1]][p2[i]], C=d[p2[i-1]][p1[i]], D=d[p2[i-1]][p2[i]]; f[i][0][0]=f[i-1][0][0]+A; for(j=1;j&lt;=m;j++)&#123; choice=min(f[i-1][j][0]+A, f[i-1][j][1]+p[i-1]*C+(1-p[i-1])*A); f[i][j][0]=min(f[i][j][0],choice); choice=min(f[i-1][j-1][0]+p[i]*B+ (1-p[i])*A, f[i-1][j-1][1]+p[i-1]*p[i]*D+ (1-p[i-1])*p[i]*B+ p[i-1]*(1-p[i])*C+ (1-p[i-1])*(1-p[i])*A); f[i][j][1]=min(f[i][j][1],choice); &#125; &#125; for(i=0;i&lt;=m;i++) ans=min(ans,min(f[n-1][i][0],f[n-1][i][1])); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T1 组合数问题题目地址 这题给你公式就是给你坑。（如果你不会求逆元的话）实际上没有必要求逆元，直接拿组合数经典公式就可以做了。我们知道：C_n^m=C_{n-1}^{m-1}+C_{n-1}^m。同时，如果一个组合数是$k$的倍数，那么C_n^m \mod k =0。所以就$O(nm)$递推一下，在递推的过程中让C_n^m对$k$取模，如果结果为$0$就在当前位置记录一下。这样可以解决一次回答，但时间复杂度不够优，每次都这么做是O(n_{max}\times m_{max}\times t)的，可能只能过70%左右的数据。发现$k$不变，所以考虑预处理再回答。这里使用前缀和思想。设$ans(n,m)$表示所有$0\le i\le n,0\le j \le m$中，有多少C_i^j是$k$的倍数，即C_i^j \mod k =0。先求出每一行的前缀和，再求一次每一列的前缀和就可得到所有的$ans(n,m)$。（详见代码）这样回答一个询问的时间是$O(1)$，总时间复杂度是O(n_{max}\times m_{max} +t)。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int T,k,C[2005][2005],sum[2005][2005]=&#123;0&#125;,maxn=0,maxm=0,n[10005],m[10005];void init()&#123; int i,j,v; for(i=0;i&lt;=maxn;i++) C[i][0]=1; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%k; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++)&#123; if(j&lt;=i&amp;&amp;C[i][j]==0)v=1;else v=0; sum[i][j]=sum[i-1][j]+v; &#125; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++) sum[i][j]+=sum[i][j-1];&#125;int main()&#123; scanf("%d%d",&amp;T,&amp;k); for(int i=1;i&lt;=T;i++) scanf("%d%d",&amp;n[i],&amp;m[i]),maxn=max(maxn,n[i]),maxm=max(maxm,m[i]); init(); for(int i=1;i&lt;=T;i++) printf("%d\n",sum[n[i]][m[i]]); return 0;&#125; 提高D2T2 蚯蚓题目地址 考场上我想到了这个方法，但因为没证明所以不敢用。。。结果一看题解就吓傻了。可以证明同一种切法下，先切割的比后切割的长度会更长，所以维护$3$个递减队列，然后先把所有初始蚯蚓放在队列$1$，然后不断取出，把$\lfloor px\rfloor$的放在队列$2$中，$x-\lfloor px\rfloor $放在队列$3$中，每一次取$1,2,3$中最大值出来切。注意：1.维护下标（切的时间）很麻烦，不妨直接先减去当前时间和$q$的乘积，然后到了它在加上。为什么可以这么做？因为一条蚯蚓的实际长度是len+(t_{当前}-t_{被切})*q，展开得(len-t_{被切}\times q)+q\times t_{当前}，所以队列里只需要维护前面括号里的元素即可。相应的，在求最大值时，初始最大值要取很小，因为要维护的值可能是个很小的负数。2.要卡常，STL慢的飞起。时间复杂度$O(n+m)$。 补充证明上面那个性质。假设有$2$条蚯蚓长度分别是$a,b(a&gt;b)$，那么$a$会比$b$先被切。设两个蚯蚓被切得时间点分别是t_a,t_b(t_a \lfloor p\times b\rfloor和a-\lfloor p\times a\rfloor +(t_b-t_a)\times q>b-\lfloor p\times b\rfloor。所以上面的命题成立，证毕。大家都看的出来好嘛1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int q1[100005]=&#123;0&#125;,q2[7000005],q3[7000005],n,m,q,u,v,t;int f1=0,f2=0,f3=0,r1=0,r2=0,r3=0;double xs,tmp;int main()&#123; scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t); xs=u,xs/=(double)v; int i,j,k,maxi,_max,fi,se,ok=0; for(i=0;i&lt;n;i++) scanf("%d",&amp;q1[i]); sort(q1,q1+n); r1=n,reverse(q1,q1+n); for(i=0;i&lt;m;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=i*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; tmp=_max,tmp*=xs; fi=(int)floor(tmp),se=_max-fi; q2[r2++]=fi-(i+1)*q, q3[r3++]=se-(i+1)*q; &#125; printf("\n"); for(ok=i=0;i&lt;m+n;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=m*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; &#125; printf("\n"); return 0;&#125; 提高D2T3 愤怒的小鸟题目地址 状压搜索/DP枚举抛物线，看一次抛物线能砸死哪些猪，然后跑DP搜索过不去？那就卡时呗。DP？设$f(i,S)$表示解决了前i头猪，正在解决第$i+1$头，猪被打死的情况为$S$的最小方案数。那么先算出以包含第$i$头猪在内的所有抛物线能砸死的猪的情况（压位表示），然后跑记忆化搜索即可。时间复杂度：搜索：$O($你卡时就能过$)$DP：$O($你不卡时也能过$)$实际检验发现，搜索效率很高，对于小数据非常轻松。但DP的发挥更加稳定，不会被奇奇怪怪的东西卡死。在洛谷上，搜索不卡时95分，花费254ms；DP花费2154ms。 DP做法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,tag,tab[20][500];int in[20][1&lt;&lt;19];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1;//x坐标相同 a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1;//a必须&lt;0 b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;//解方程void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=((1&lt;&lt;i)|(1&lt;&lt;j)); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]-_a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;int dfs(int at,int S)&#123; if(in[at][S]&lt;0x3f3f3f3f)return in[at][S]; int st=0x3f3f3f3f,i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; st=min(st,1+dfs(j,_S)); &#125; return (in[at][S]=st);&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); memset(in,0x3f,sizeof(in)); tag=(1&lt;&lt;n); for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); in[n][tag-1]=0; printf("%d\n",dfs(0,0)); &#125; return 0;&#125; 搜索做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,ans,tag,tab[20][500];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1; a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1; b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=0;S|=(1&lt;&lt;i);S|=(1&lt;&lt;j); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]- _a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;void dfs(int at,int st,int S)&#123; if(S!=tag-1&amp;&amp;st&gt;=ans-1)return ; if(S==tag-1)&#123;ans=min(ans,st);return ;&#125; int i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; dfs(j,st+1,_S); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); tag=(1&lt;&lt;n),ans=n; for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); dfs(0,0,0); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>最短路</tag>
        <tag>单调队列</tag>
        <tag>期望DP</tag>
        <tag>状压DP</tag>
        <tag>LCA</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2008%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2008八道题目的题解。 普及T1 ISBN号码题目地址 模拟即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;char isbn[20];int last,sum=0,cnt=1;int main()&#123; scanf("%s",isbn); for(int i=0;i&lt;13;i++)&#123; if(isdigit(isbn[i])&amp;&amp;i!=12) sum+=(isbn[i]-'0')*cnt,cnt++; else if(isdigit(isbn[i])&amp;&amp;i==12) sum%=11,last=isbn[i]-'0'; else sum%=11,last=10; &#125; if(last==sum)&#123; printf("Right"); &#125;else&#123; for(int i=0;i&lt;12;i++) putchar(isbn[i]); printf("%c\n",sum==10?'X':sum+'0'); &#125; return 0;&#125; 普及T2 排座椅题目地址 算一下选每一行或者每一列可以阻断的人数，然后排序贪心即可。注意行号和列号都要排序再输出。时间复杂度：$\mathcal O(nlogn+mlogm)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;struct Seat&#123; int id,tot;&#125;;Seat line[1005],row[1005];bool cmp(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.tot&gt;sb.tot;&#125;bool cmp2(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.id&lt;sb.id;&#125;int n,m,K,L,D;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;L,&amp;D); int x1,y1,x2,y2; for(int i=1;i&lt;=n;i++) line[i].tot=0,line[i].id=i;//该行上面 for(int i=1;i&lt;=m;i++) row[i].tot=0,row[i].id=i;//该列右边 for(int i=1;i&lt;=D;i++)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(x1==x2) row[min(y1,y2)].tot++; //同行记录列 else if(y1==y2) line[min(x1,x2)].tot++; &#125; sort(line+1,line+1+n,cmp),sort(line+1,line+K+1,cmp2); sort(row+1,row+1+m,cmp),sort(row+1,row+1+L,cmp2); for(int i=1;i&lt;K;i++) printf("%d ",line[i].id); printf("%d\n",line[K].id); for(int i=1;i&lt;L;i++) printf("%d ",row[i].id); printf("%d\n",row[L].id); return 0;&#125; 普及T3 传球游戏题目地址 方法一数据怎么小，怎么玩？打表！123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt;int q[28][28]=&#123;&#123;2,6,10,22,42,86,170,342,682,1366,2730,5462,10922,21846,43690,87382,174762,349526,699050,1398102,2796202,5592406,11184810,22369622,44739242,89478486,178956970,357913942&#125;,&#123;0,8,0,32,0,128,0,512,0,2048,0,8192,0,32768,0,131072,0,524288,0,2097152,0,8388608,0,33554432,0,134217728,0,536870912&#125;,&#123;0,6,2,20,14,70,72,254,330,948,1430,3614,6008,13990,24786,54740,101118,215766,409640,854702,1652090,3396916,6643782,13530350,26667864,53971350,106914242,215492564&#125;,&#123;0,6,0,22,0,86,0,342,0,1366,0,5462,0,21846,0,87382,0,349526,0,1398102,0,5592406,0,22369622,0,89478486,0,357913942&#125;,&#123;0,6,0,20,2,70,18,252,110,924,572,3434,2730,12902,12376,48926,54264,187036,232562,720062,980674,2789164,4086550,10861060,16878420,42484682,69242082,166823430&#125;,&#123;0,6,0,20,0,72,0,272,0,1056,0,4160,0,16512,0,65792,0,262656,0,1049600,0,4196352,0,16781312,0,67117056,0,268451840&#125;,&#123;0,6,0,20,0,70,2,252,22,924,156,3432,910,12870,4760,48622,23256,184796,108528,705894,490314,2708204,2163150,10430500,9373652,40313160,40060078,156305070&#125;,&#123;0,6,0,20,0,70,0,254,0,948,0,3614,0,13990,0,54740,0,215766,0,854702,0,3396916,0,13530350,0,53971350,0,215492564&#125;,&#123;0,6,0,20,0,70,0,252,2,924,26,3432,210,12870,1360,48620,7752,184756,40698,705434,201894,2704204,961400,10401250,4440150,40123152,20030010,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,926,0,3460,0,13110,0,50252,0,194446,0,758100,0,2973350,0,11716252,0,46333566,0,183739940&#125;,&#123;0,6,0,20,0,70,0,252,0,924,2,3432,30,12870,272,48620,1938,184756,11970,705432,67298,2704156,354200,10400602,1776060,40116656,8584290,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3434,0,12902,0,48926,0,187036,0,720062,0,2789164,0,10861060,0,42484682,0,166823430&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,2,12870,34,48620,342,184756,2660,705432,17710,2704156,106260,10400600,592020,40116600,3121560,155117522&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12872,0,48656,0,185136,0,708512,0,2725408,0,10532160,0,40870080,0,159189120&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,2,48620,38,184756,420,705432,3542,2704156,25300,10400600,161460,40116600,950040,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48622,0,184796,0,705894,0,2708204,0,10430500,0,40313160,0,156305070&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,2,184756,42,705432,506,2704156,4600,10400600,35100,40116600,237510,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184758,0,705476,0,2704708,0,10405800,0,40157550,0,155402532&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,2,705432,46,2704156,600,10400600,5850,40116600,47502,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705434,0,2704204,0,10401250,0,40123152,0,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,2,2704156,50,10400600,702,40116600,7308,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704158,0,10400652,0,40117356,0,155125640&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,2,10400600,54,40116600,812,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400602,0,40116656,0,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,2,40116600,58,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116602,0,155117580&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,2,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,0,155117522&#125;&#125;;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m);printf("%d\n",q[n-3][m-3]); return 0; &#125; 方法二实际上这个递推是很水，设$\mathcal f\left(i,j\right)$为当前球到了第$i$个人的时候是第$j$次的情况下，传球的方法数，则可以递推得 \mathcal f\left(i,j\right)=f\left(i-1,j-1\right)+f\left(i+1,j-1\right)其中$i-1$指$i$左边的人，$i+1$指$i$右边的人。假设开始的人是￥0￥号即可。时间复杂度：$\mathcal O\left(nm\right)$123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,f[35][35];int main()&#123; scanf("%d%d",&amp;n,&amp;m); f[0][0]=1; for(int j=1;j&lt;=m;j++)&#123; f[0][j]=f[n-1][j-1]+f[1][j-1]; f[n-1][j]=f[0][j-1]+f[n-2][j-1]; for(int i=1;i&lt;n-1;i++) f[i][j]=f[i-1][j-1]+f[i+1][j-1]; &#125; printf("%d\n",f[0][m]); return 0;&#125; 普及T4 立体图题目地址 这题目是不是一看就很恶劣啊？是的！但是只要知道构图的顺序就完成了一部分。我的构图顺序是从最底层构起，每一层按列构成，从远到近，从左到右，从下到上，这样就解决了图形覆盖的问题。然后就是坐标的计算以及图形具体元素坐标的计算，这里可以参考我的代码。时间复杂度：画一个正方体的时间是常数，所以是$O($正方体数$)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;char mp[20001][350];int n,m,mp2[55][55],BOT=20000;void lie(int x,int y)&#123; mp[x][y]=mp[x][y+4]='+', mp[x][y+1]=mp[x][y+2]=mp[x][y+3]='-';&#125;void build(int x,int y,int z)&#123; int dx=BOT,dy=0; dx-=(z-1)*3+3+2*(m-x+1);//yuanlaiwei x dy+=(m-x+1)*2+(y-1)*4; lie(dx,dy),lie(dx+2,dy-2),lie(dx+5,dy-2); mp[dx+3][dy+4]='+', mp[dx+1][dy-1]=mp[dx+1][dy+3]=mp[dx+4][dy+3]='/'; mp[dx+3][dy-2]=mp[dx+3][dy+2]= mp[dx+4][dy-2]=mp[dx+4][dy+2]= mp[dx+1][dy+4]=mp[dx+2][dy+4]='|', mp[dx+1][dy]=mp[dx+1][dy+1]=mp[dx+1][dy+2]= mp[dx+2][dy+3]=mp[dx+3][dy+3]= mp[dx+3][dy]=mp[dx+3][dy-1]=mp[dx+3][dy+1]= mp[dx+4][dy]=mp[dx+4][dy-1]=mp[dx+4][dy+1]=' ';&#125;void output()&#123; int s1=0,s2=0,i,j,ok; for(i=BOT;i&gt;=0;i--)&#123; for(j=0,ok=0;j&lt;350;j++) if(mp[i][j]!='.')ok=1; if(!ok)break; &#125; s1=i+1; for(i=349;i&gt;=0;i--)&#123; for(j=s1,ok=0;j&lt;=BOT;j++) if(mp[j][i]!='.')ok=1; if(ok)break; &#125; s2=i; //printf("%d %d\n",s1,s2); for(i=s1;i&lt;=BOT;i++)&#123; for(j=0;j&lt;=s2;j++) printf("%c",mp[i][j]); printf("\n"); &#125;&#125;int main()&#123; memset(mp,'.',sizeof(mp)); scanf("%d%d",&amp;m,&amp;n); int i,j,k; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mp2[i][j]); for(i=1;i&lt;=100;i++) for(k=0;k&lt;n;k++) for(j=0;j&lt;m;j++) if(mp2[j][k]&gt;=i) build(j+1,k+1,i); output(); return 0;&#125; 提高T1 笨小猴题目地址 模拟即可。注意0和1都不是质数。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;bool judge(int x)&#123; if(!x||x==1)return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0)return 0; return 1;&#125;char s[1005];int cnt[27],len;int main()&#123; scanf("%s",s); len=strlen(s); for(int i=0;i&lt;len;i++) cnt[s[i]-'a']++; int maxi=0,mini=1000; for(int i=0;i&lt;26;i++)&#123; if(!cnt[i])continue; maxi=max(maxi,cnt[i]),mini=min(mini,cnt[i]); &#125; if(judge(maxi-mini)) printf("Lucky Word\n%d\n",maxi-mini); else printf("No Answer\n0\n"); return 0;&#125; 提高T2 火柴棒等式题目地址 方法一大概划定一下加数的范围，然后暴力枚举即可。1是最少的，所以以他为标准，大概左右两边的加数是在2000左右。（实际上试验后发现在1000左右）1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int cnt[]=&#123;6,2,5,5,4,5,6,3,7,6&#125;,n,ans=0;int table[2005];int get(int a)&#123; int res=0; while(a)res+=cnt[a%10],a/=10; return res;&#125;int main()&#123; scanf("%d",&amp;n),n-=4; table[0]=6; for(int i=1;i&lt;=2000;i++) table[i]=get(i); for(int i=0;i&lt;=1000;i++) for(int j=0;j&lt;=1000;j++) if(table[i]+table[j]+table[i+j]==n)ans++; printf("%d\n",ans); return 0;&#125; 方法二题目是死的，人是活的。打表也是好手段。1int ans[]=&#123;0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128&#125;; 提高T3 传纸条题目地址 设$\mathcal f\left( k,i,j\right) \left( i \le j \right)$为走了$\mathcal k$步，第一条路径当前在第$\mathcal i$列，第二条在第$\mathcal j$列时的最大的爱心值。则转移方程为 \mathcal f\left( k,i,j\right) = \max \left\{ f\left( k-1,i,j\right) , f\left( k-1,i-1,j\right) , f\left( k-1,i,j-1\right),f\left( k-1,i-1,j-1\right) \right\} + \begin{cases} data[k-i][i] \quad \left(i=j\right)\\ data[k-i][i]+data[k-j][j] \quad \left(i \neq j\right) \\ \end{cases}1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][51][51]=&#123;0&#125;,m,n,mat[51][51];int main()&#123; int i,j,k;scanf("%d%d",&amp;m,&amp;n); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(k=1;k&lt;m+n-1;k++) for(j=0;j&lt;n;j++) for(i=0;i&lt;=j;i++)&#123; if(k-i&lt;0||k-i&gt;=m||k-j&lt;0||k-j&gt;=m)continue; dp[k][i][j]=max(dp[k-1][i][j],dp[k][i][j]); if(i)dp[k][i][j]=max(dp[k-1][i-1][j],dp[k][i][j]); if(j)dp[k][i][j]=max(dp[k-1][i][j-1],dp[k][i][j]); if(i&amp;&amp;j)dp[k][i][j]=max(dp[k-1][i-1][j-1],dp[k][i][j]); dp[k][i][j]+=mat[k-i][i]; if(i!=j)dp[k][i][j]+=mat[k-j][j]; &#125; printf("%d\n",dp[m+n-2][n-1][n-1]); return 0;&#125; 提高T4 双栈排序题目地址 双栈排序=单栈排序*2。那我们探究一下单栈排序吧！显然，单栈排序中，如果有两个数$\mathcal a_i$和$\mathcal a_k$，其中$\mathcal a_k&lt;a_i$，那么显然$\mathcal a_k$先弹出，$\mathcal a_i$后弹出。什么时候一个序列无法被单栈排序呢？如果因为某个原因，上面的事情做不到，就说明无法单栈排序。换言之，我们假设$\mathcal i&lt;k$且$\mathcal a_k&lt;a_i$，那么如果两个数之间有一个碍事的：有元素$\mathcal i&lt;j&lt;k$，并且$\mathcal a_i&lt;a_j$，那么显然在弹出$\mathcal a_k$后必须要先弹掉$\mathcal a_j$才能弹出$\mathcal a_i$，这不符合条件。所以无法单栈排序。一个栈做不成，那就两个。考虑把这些碍事的元素放到另一个栈里，这样就不矛盾了。问题是如何分配呢？我们知道，根据上述条件，$\mathcal a_i$和$\mathcal a_j$必然无法在同一个栈中。根据这种”二分“的性质，我们想到了二分图。把下标看做结点，然后不能在一个栈里的点对间连一条边，判断这个图是否是二分图即可。这一步可以直接用DFS实现。之后就比较简单了，输出排序过程即可。 还有一个瓶颈：怎么求这样的点对？直接枚举会带来$\mathcal O\left(n^3\right)$的时间复杂度，我们承受不住。观察到$\mathcal a_k$具体是多少不重要，只要有一个$\mathcal k$满足\mathcal j]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>暴力</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>二分图</tag>
        <tag>字符串</tag>
        <tag>多线程DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2015%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2015十道题目的题解。 普及T1 金币题目地址 模拟123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int k,ans=0; scanf("%d",&amp;k); for(int i=1,j=1;i&lt;=k;i++)&#123; ans+=j; if(j*(j+1)/2==i)j++; &#125; printf("%d\n",ans); return 0;&#125; 普及T2 扫雷游戏题目地址 模拟1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,mat[105][105],dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;char s[105];void get(int x,int y)&#123; int res=0; for(int i=0;i&lt;8;i++) res+=(mat[x+dx[i]][y+dy[i]]==-1); mat[x][y]=res; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) mat[i][j]-=(s[j]=='*'); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) if(!mat[i][j])get(i,j),printf("%d",mat[i][j]); else putchar('*'); putchar('\n'); &#125; return 0;&#125; 普及T3 求和题目地址 我们挖掘条件的性质可以发现：$y$无关紧要，当$x$和$z$的奇偶性相同时，他们之间旧就会产生分数。所以每一种颜色分奇偶计数，然后一种颜色一个奇偶性产生的分数为 score=(s_4-2)\times s_1+s_2\times s_3其中$s_4$为该种颜色该种奇偶性的格子数，$s_1$为这些格子$x\times num_x$的和，$s_2$和$s_3$分别为这些格子$x$和$num_x$的和。其中$x$指编号，$num_x$指编号为$x$的格子上的数。证明过程略，可以自己手动推导。综上，这个算法的时间复杂度是$O(n+m)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define INF 2000000000#define M 10007using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,num[100005],col[100005],ans=0;int s1[100005][2],s2[100005][2],s3[100005][2],s4[100005][2];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)num[i]=read()%M; for(int i=1;i&lt;=n;i++)col[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; int c=col[i],B=i&amp;1; s1[c][B]+=i*num[i],s1[c][B]%=M; s2[c][B]+=i,s2[c][B]%=M; s3[c][B]+=num[i],s3[c][B]%=M; s4[c][B]++; &#125; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;2;j++) ans+=(s4[i][j]-2)*s1[i][j]%M, ans+=s2[i][j]*s3[i][j]%M, ans%=M; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 推销员题目地址 一道贪心。我们可以先算出总的疲劳值，然后每一次选择哪一户人家再也不去。这个时候，我们要保证减少的疲劳值最少。我们可以发现一次只有$2$种删去住户的决策：如图，$head$表示当前疲劳值消耗最小的住户编号，$last$表示最低端的住户编号，$front$是$last$前一个住户的编号。每一次可以去掉$head$，也可以去掉$last$。而去掉$last$就没必要走$front$到$last$的路了，所以第二种决策会减少$(dis[last]-dis[front])\times 2+last$需要的疲劳值。对住户的(疲劳值,编号)二元组按疲劳值排个序，然后维护以上3个量即可：$last$,$front$和$head$。注意，还需要维护每一个住户是否已经被清除，是的话要打标记，否则$head$指向的住户可能会是$last$，这样就不合法。时间复杂度：$O(nlogn)$1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define M 100005using namespace std;int dis[M],cost[M][2],ans[M],tmp[M],front,t,n,last,head;bool vis[M]=&#123;0&#125;;int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;int main()&#123; scanf("%d",&amp;n); int i; for(i=0;i&lt;n;i++) scanf("%d",&amp;dis[i]); ans[n-1]=dis[n-1]*2; for(i=0;i&lt;n;i++) scanf("%d",&amp;tmp[i]), cost[i][1]=i, cost[i][0]=tmp[i], ans[n-1]+=cost[i][0]; qsort(cost,n,sizeof(cost[0]),cmp); last=n-1,front=n-2,head=0; vis[last]=true; for(i=n-2;i&gt;=0;i--)&#123; ans[i]=ans[i+1]; while(head&lt;n&amp;&amp;(vis[cost[head][1]]))head++; t=(dis[last]-dis[front])*2+tmp[last]; if(t&lt;cost[head][0]) vis[last]=vis[front]=1, ans[i]-=t, last=front--; else vis[cost[head][1]]=1, ans[i]-=cost[head][0], head++; while(vis[front])front--; &#125; for(i=0;i&lt;n;i++) printf("%d\n",ans[i]); return 0;&#125; 提高D1T1 神奇的幻方题目地址 模拟12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int n,ans[50][50]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); int i,j,x,y; for(i=2,x=0,y=n/2,ans[x][y]=1;i&lt;=n*n;i++)&#123; if(!x)&#123; if(y==n-1)x++; else x=n-1,y++; &#125;else&#123; if(y==n-1)y=0,x--; else &#123; if(!ans[x-1][y+1]) x--,y++; else x++; &#125; &#125; ans[x][y]=i; &#125; for(i=0;i&lt;n;i++,printf("\n")) for(j=0;j&lt;n;j++,(j&lt;n)?printf(" "):0) printf("%d",ans[i][j]); return 0;&#125; 提高D1T2 信息传递题目地址 乱搞。题目：求最小环。解：爆搜/tarjan。能用tarjan是因为这里面的强连通分量只能是简单环。 DFS解法123456789101112131415161718192021222324#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int n,to[200005],vis[200005]=&#123;0&#125;,ans=INF;void dfs(int cur,int st)&#123; if(vis[cur]==-1)return ; if(vis[cur])&#123; ans=min(ans,st-vis[cur]); vis[cur]=-1; return ; &#125; vis[cur]=st; dfs(to[cur],st+1),vis[cur]=-1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;to[i]); for(int i=1;i&lt;=n;i++) dfs(to[i],1); printf("%d\n",ans); return 0; &#125; Tarjan解法12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define addedge(_u,_v) edge[cnt].v=_v,edge[cnt].next=at[_u],at[_u]=cnt,cnt++using namespace std;typedef struct &#123; int v,next;&#125;Edge;Edge edge[200105];int at[200005],VNum,mini,D=0;int dfn[200005]=&#123;0&#125;,low[200005],stack[200005],top=0;bool in[200005];void init()&#123; int i,cnt=0,a,b,t; memset(at,-1,sizeof(at)); for(i=0;i&lt;VNum;i++) scanf("%d",&amp;a),addedge(i,a-1);&#125;void tarjan_scc(int id)&#123; dfn[id]=low[id]=++D; in[id]=true;stack[top++]=id; int i=at[id],vv;while(i!=-1)&#123;vv=edge[i].v; if(!dfn[vv])tarjan_scc(vv),low[id]=min(low[id],low[vv]); else if(in[vv])low[id]=min(low[id],dfn[vv]); i=edge[i].next; &#125; if(dfn[id]==low[id])&#123; i=0; do in[stack[--top]]=false,i++; while(stack[top]!=id); if(i!=1)mini=min(mini,i); &#125;&#125;int main()&#123; scanf("%d",&amp;VNum); init(); mini=VNum; for(int i=0;i&lt;VNum;i++)if(!dfn[i])tarjan_scc(i); printf("%d\n",mini); return 0;&#125; 提高D1T3 斗地主题目地址 部分搜索。先搞掉所有顺子，然后问题转化为一个简单的最优化问题，dp可解。设$f(i,j,k,l)$为一副牌，有$i$份4张，$j$份3张，$k$份2张，$l$份1张，最少打几次。这个最开始就可以做。然后搜索即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//剪枝:出牌数递减，（牌大小递增） //贪心：5个直接搞 int n,cnt[20],ans;int f[7][9][13][24],pat[5];void dp()&#123;//与顺子无关的dp memset(f,0x3f,sizeof(f)); f[0][0][0][0]=0; int xa=n/4,xb=n/3,xc=n/2; for(int i=0;i&lt;=xa;i++) for(int j=0;j&lt;=xb;j++) for(int k=0;k&lt;=xc;k++) for(int l=0;l&lt;=n;l++)&#123; int &amp;t=f[i][j][k][l]; if(i)&#123; t=min(t,f[i-1][j][k][l]+1); if(l&gt;=2)t=min(t,f[i-1][j][k][l-2]+1); if(k&gt;=2)t=min(t,f[i-1][j][k-2][l]+1); &#125; if(j)&#123; t=min(t,f[i][j-1][k][l]+1); if(l)t=min(t,f[i][j-1][k][l-1]+1); if(k)t=min(t,f[i][j-1][k-1][l]+1); &#125; if(k)t=min(t,f[i][j][k-1][l]+1); if(l)t=min(t,f[i][j][k][l-1]+1); &#125;&#125;int small_solve()&#123; for(int i=0;i&lt;=4;i++)pat[i]=0; for(int i=0;i&lt;=13;i++)pat[cnt[i]]++; return f[pat[4]][pat[3]][pat[2]][pat[1]];&#125;void dfs(int cd,int st)&#123; if(st+1&gt;=ans&amp;&amp;cd!=0)return ; if(cd==0)&#123; ans=min(ans,st); return ; &#125; int flag=0; //只搜索顺子 for(int k=1;k&lt;=12;k++)&#123; if(cnt[k]&gt;=3)&#123; if(k&lt;=11)&#123; for(int i=k+1;i&lt;=12&amp;&amp;cnt[i]&gt;=3;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=3; dfs(cd-(i-k+1)*3,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=3; &#125; &#125; &#125; if(cnt[k]&gt;=2)&#123; if(k&lt;=10&amp;&amp;cnt[k+1]&gt;=2)&#123; for(int i=k+2;i&lt;=12&amp;&amp;cnt[i]&gt;=2;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=2; dfs(cd-(i-k+1)*2,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=2; &#125; &#125; &#125; if(cnt[k])&#123; if(k&lt;=8&amp;&amp;cnt[k+1]&amp;&amp;cnt[k+2]&amp;&amp;cnt[k+3])&#123; for(int i=k+4;i&lt;=12&amp;&amp;cnt[i];i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]--; dfs(cd-(i-k+1),st+1); for(int j=k;j&lt;=i;j++)cnt[j]++; &#125; &#125; &#125; &#125; ans=min(ans,st+small_solve());&#125;void init()&#123; ans=n; memset(cnt,0,sizeof(cnt)); int u; for(int i=1;i&lt;=n;i++)&#123; u=read(); if(!u)cnt[u]++; else if(u&lt;=2)cnt[u+11]++; else cnt[u-2]++; read(); &#125;&#125;void solve()&#123; dfs(n,0); printf("%d\n",ans);&#125;int main()&#123; int T=read(); n=read(); dp(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 提高D2T1 跳石头题目地址 看到描述就看的出是二分答案。二分答案，设为$x$，把石头排序之后扫一遍，看看是否有石头与前一个石头的间隔小于$x$，有的话拆掉该石头，否则把这个石头作为“前一个石头”，再看下一个。如果拆的次数大于$M$就判定失败，否则判定成功。时间复杂度$O(NlogL)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,m,at[50005];bool C(int x)&#123; int left=m,lst=0; for(int i=2;i&lt;=n+2;i++)&#123; if(at[i]-lst&lt;x)left--; else lst=at[i]; if(left&lt;0)return 0; &#125; return 1;&#125;void init()&#123; L=read(),n=read(),m=read(); at[1]=0,at[n+2]=L; for(int i=2;i&lt;=n+1;i++) at[i]=read(); sort(at+2,at+n+2);&#125;void solve()&#123; int l=0,r=L,mid; while(r&gt;l)&#123; mid=(l+r+1)&gt;&gt;1; if(C(mid))l=mid; else r=mid-1; &#125; printf("%d\n",l);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T2 子串题目地址 看数据范围猜算法系列时间复杂度相信各位都看的出来：$O(nmk)$怎么刻画状态呢？首先有$2$维必不可缺：$i$表示$A$前$i$个字符，$j$表示$B$前$j$个字符。这里指的是用前$i$个$A$的字符来匹配$B$的前$j$个字符，串$A$的前$i$个不一定要严格匹配，但串$B$的前$j$个必须严格匹配上。之后，段也要表示：$t$表示现在做了$t$段。看到这些段不是连续的，所以使用情况也要表示出来，设一个布尔变量$l$表示串$A$的这个字符是不是被使用了，是为$1$，不是为$0$。够了，用$f(i,j,t,l)$来表示。不使用这个字符，就继承串$A$上一位的状态。使用的话，必须匹配成功，然后有$2$个决策：开启新的一段（前一个字符没用的话就默认开启新的一段了），或者接上前一段。得到状态转移方程： f(i,j,t,0)=f(i-1,j,t,0)+f(i-1,j,t,1) \\ f(i,j,t,1)= \begin{cases} f(i-1,j-1,t,1)+f(i-1,j-1,t-1,0)+f(i-1,j-1,t-1,1) \quad (a[i]=b[j]) \\0\quad (a[i] \neq b[j]) \end{cases}初始是$f(i,0,0,0)=1$。要用滚动数组，不然MLE。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,k,dp[2][205][205][2]=&#123;0&#125;,ans=0,M=1000000007;char a[1005]=&#123;0&#125;,b[205]=&#123;0&#125;;int main()&#123; scanf("%d%d%d%s%s",&amp;n,&amp;m,&amp;k,&amp;a[1],&amp;b[1]); int i,j,o,p,t; dp[0][0][0][0]=dp[1][0][0][0]=1; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; for(o=1;o&lt;=k;o++)&#123; if(a[i]==b[j]) dp[i&amp;1][j][o][1]=(( dp[1^(i&amp;1)][j-1][o-1][0]+ dp[1^(i&amp;1)][j-1][o][1])%M+ dp[1^(i&amp;1)][j-1][o-1][1])%M; else dp[i&amp;1][j][o][1]=0; dp[i&amp;1][j][o][0]=( dp[1^(i&amp;1)][j][o][0]+// dp[1^(i&amp;1)][j][o][1])%M; &#125; &#125; &#125; printf("%d\n",(dp[n&amp;1][m][k][0]+dp[n&amp;1][m][k][1])%M); return 0;&#125; 提高D2T3 运输计划题目地址 直接求解显然很困难，考虑转化为判定性问题，二分一个答案$x$，判定他是否可行。完成一次运输的时间取决于最长路的大小，也就是保证所有路径的长度都小于$x$。考虑大于$x$的路径，在他们的公共路上删掉一段路才可以使他们一起变小。理所当然的，这段路必须是他们的公共路径中最长的一段。怎么找这条最长的公共路呢？我们可以玩一玩区间加法，给每一个在$(u,v)$两点上的路径打一个标记，这样就说明这些点在$(u,v)$路径上。如果两点的标记数都等于长度大于$x$的路径总数，呢么两点间的这段路就是他们的公共路径。区间加法有$2$种实现方式：一种是树剖/$LCT$，一种是树上差分（和序列上的没区别）。由于只需要查询一遍，没必要用什么奇奇怪怪的数据结构，所以用差分，在$x$和$y$上打一个$+1$标记，在$LCA$处打一个$-2$标记。由于是对点操作，所以要把边和点捆绑起来。具体不难实现。时间复杂度取决于求解$LCA$时所用算法的时间复杂度。用倍增的时间复杂度是$O((n+m)logn)$。注意卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXN 300005using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[MAXN*2];int n,m,par[MAXN][20]=&#123;0&#125;,dis[MAXN]=&#123;0&#125;,cnt=0,at[MAXN];int son[MAXN]=&#123;0&#125;,bro[MAXN]=&#123;0&#125;,depth[MAXN];int bus[MAXN][4],_dis[MAXN];// 0 路径长 1 _dis 到父亲的路径长 int dec[MAXN]=&#123;0&#125;,que[MAXN],f,r,sum[MAXN];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;//从大到小 &#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;int bs(int lth)&#123; int s=0,len=m,md,pos; while(len)&#123; md=s+(len&gt;&gt;1); if(lth&lt;bus[md][0]) s=md+1,len=len-(len&gt;&gt;1)-1; else len&gt;&gt;=1; &#125; return s;&#125;void _init()&#123; int i,j,h,u,v,c; f=r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; h=que[f++]; for(i=at[h];i!=-1;i=edge[i]._next)&#123; v=edge[i].v; if(v==par[h][0])continue; que[r++]=v, depth[v]=depth[h]+1, par[v][0]=h, bro[v]=son[h],son[h]=v, _dis[v]=edge[i].cost, dis[v]=dis[h]+_dis[v]; &#125; for(i=1;i&lt;=19;i++) if(par[h][i-1]) par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j; if(depth[u]&lt;depth[v]) swap(u,v); for(i=0;(1&lt;&lt;i)&lt;=depth[u]-depth[v];i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=19;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;int C(int tot)&#123; int i,j,h,maxi=0,_max=0; for(i=r-1;i&gt;=0;i--)&#123; h=que[i]; for(sum[h]=dec[h],j=son[h];j;j=bro[j]) sum[h]+=sum[j]; if(sum[h]&gt;maxi) maxi=sum[h],_max=_dis[h]; else if(sum[h]==maxi) _max=max(_max,_dis[h]); &#125; return maxi==tot?_max:0; &#125;void prepare()&#123; n=read(),m=read(); int i,j,u,v,c; memset(at,-1,sizeof(at)); for(i=0;i&lt;n-1;i++) u=read(),v=read(),c=read(), addedge(u,v,c), addedge(v,u,c); _init(); for(i=0;i&lt;m;i++) u=read(),v=read(), bus[i][1]=u,bus[i][2]=v, bus[i][3]=query(u,v), bus[i][0]=dis[u]+dis[v]-2*dis[bus[i][3]];&#125;void solve()&#123; qsort(bus,m,sizeof(bus[0]),cmp); int s=max(0,bus[m-1][0]-1001),t=bus[0][0],md,i,w; while(t-s)&#123; md=(t+s)/2; memset(dec,0,sizeof(dec)); for(i=0;i&lt;m&amp;&amp;bus[i][0]&gt;md;i++) dec[bus[i][1]]++, dec[bus[i][2]]++, dec[bus[i][3]]-=2; w=C(i); if(bus[0][0]-w&lt;=md)t=md; else s=md+1; &#125; printf("%d\n",s);&#125;int main()&#123; prepare(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>其他DP</tag>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>搜索</tag>
        <tag>二分</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>字符串DP</tag>
        <tag>LCA</tag>
        <tag>差分</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shortest-path-problems]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2Fshortest-path-problems%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[对循环不变式的理解]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2Floop-invariants%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SPFA 学习笔记]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2FSPFA%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa106 Fermat vs. Pythagoras]]></title>
    <url>%2F2018%2F08%2F18%2Fuva106%2F</url>
    <content type="text"><![CDATA[题目链接 题解考察了素毕达哥拉斯三元组的生成。貌似没必要加很多的优化？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int ans1[1000005] = &#123;0&#125;, ans2[1000005] = &#123;0&#125;;bool vis[1000005] = &#123;0&#125;;int n;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void init()&#123; for(int v = 2; v &lt;= 1000; ++v)&#123; if(v * v &gt; n)break; for(int u = (v % 2 == 0) ? 1 : 2; u &lt; v; u += 2)&#123; if(u * u + v * v &gt; n) break; if(gcd(v, u) != 1) continue; int aa = v * v - u * u, bb = 2 * u * v, cc = v * v + u * u; ans1[cc]++; for(int i = 1; i * cc &lt;= n; ++i) vis[i * aa] = 1, vis[i * bb] = 1, vis[i * cc] = 1; &#125; &#125; for(int i = 1; i &lt;= n; ++i) ans1[i] += ans1[i - 1], ans1[i - 1] = 0, ans2[i] = ans2[i - 1] + 1 - vis[i], ans2[i - 1] = 0, vis[i] = 0;&#125;void solve()&#123; printf("%d %d\n", ans1[n], ans2[n]); ans1[n] = ans2[n] = 0;&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[勾股数探究]]></title>
    <url>%2F2018%2F08%2F18%2FPythagorean-triple%2F</url>
    <content type="text"><![CDATA[勾股数，又叫毕达哥拉斯三元数， 是由正整数构成的三元组。其三个数对应一个直角三角形的三条边。这里对勾股数的性质做一些探究。 基本性质一般用一个三元组表示一组勾股数：$(a, b, c)$其中有 a ^ 2 + b ^ 2 = c ^2容易看出，一组勾股数中每一个数乘上一个正整数$n$，得到的三元组$(na, nb, nc)$仍为一组勾股数。正因如此，我们希望找到这样的勾股数，使它不为除自己外某一个勾股数的倍数。换句话说，我们希望有一种方法可以枚举出所有的素勾股数，即使$(a, b, c)=1$。 构造方式先直接给出这样的构造方式：设$u &lt; v(u ,v\in \mathbb{N}^*)$，并且$u,v$奇偶性不同，且$(u, v) = 1$，那么令 \begin{cases} a = v ^ 2 - u ^ 2\\ b = 2 u v \\ c = v ^ 2 + u ^ 2\end{cases}即可构造出全部的素勾股数。证明：假设这样产生的勾股数存在$(a, b, c)= d$，那么由于$u, v$奇偶性不同， 故$a, c$必为奇数。故$d$为奇数。则对于$c$则必须有$u|d, v|d$，导出$(u, v)\ge d$，与前提中的$(u, v)=1$矛盾。故原命题得证，证毕。 由此可见，使用这样的方式构造出素勾股数之后再进行倍增，即可构造出所有可能的勾股数。 问题扩展问题：已知$a, b, c\in \mathbb{N}^*$和$b$，求满足$a ^ 2 + b ^ 2 = c ^ 2$的所有解。解题：把式子化为$b ^ 2 = (c - a)(c + a)$，设$x = c + a, y= c - a$，那么就有$b ^2 = x y$。对$b$枚举一次因数，然后对因数进行组合，同时考虑一下奇偶性带来的问题，计算出$x,y$，解出$a,c$即可。因为因数的个数为$O(\sqrt b)$，组合因数的时候会产生$O(b)$的因数个数，所以该方法的时间复杂度应为$O(b)$。 相关运用UVa106（同Poj1305） 参考资料 《什么是数学》 百度百科]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 最短路]]></title>
    <url>%2F2018%2F08%2F18%2Ftemplate-shortest-path%2F</url>
    <content type="text"><![CDATA[各种最短路的模板！首先可以利用反证法证明一个定理：最短路径的子路径也是最短路径。这个定理构成了之后算法的基石。 同时还有一个重要的不等式： d(v)\le d(u)+w(u, v)这个不等式叫三角不等式，它是松弛操作的理论基础。 Bellman-Ford算法容易知道，当一个图$G=(V, E)$中不存在负环时，该图中的最短路最多经过$|V|-1$条边。最短路上是不可能存在一个路径的权重和为正的环的。因此进行松弛操作时，最多进行$|V|-1$次就可以算出最短路。若在第$|V|$次仍可以进行松弛，那么就说明存在一个负环。Bellman-Ford算法基于上述思路，对每一条边都进行$|V|-1$次的松弛，从而就可求出最短路。同时，也可以用于判断负环是否存在。从上述说明也可以看出，Bellman-Ford算法允许图中有负权边。1234567891011121314bool Bellman_Ford()&#123; for(int i = 1; i &lt; V; ++i) for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost) d[v] = d[u] + edge[j].cost; &#125; for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost) return false;//还能松弛说明这个图存在负环 &#125; return true;&#125; 除了上述写法，还有一种经过了一定优化的写法：12345678910111213141516bool Bellman_Ford()&#123; for(int i = 1; i &lt;= V; ++i)&#123; int flag = 0; for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost)&#123; d[v] = d[u] + edge[j].cost, flag = 1; if(i == V) return false; &#125; &#125; if(!flag) break;//松弛的次数已经足够了，没有必要再进行下去 &#125; return true;&#125; 容易看出，Bellman-Ford算法的时间复杂度为$O(|V|\times |E|)$。因此，大部分情况下Bellman-Ford算法在解决问题的时候时间复杂度都不够好。但是，它的一个优化版本——SPFA的应用场合就相当多了。 Dijkstra算法DIjkstra算法在求单源最短路方面表现相当稳定。朴素实现时它的时间复杂度为$O(|V|^2+|E|)$，而在使用一定的数据结构时可以将时间复杂度降到$O(|E|log|V|)$。Dijkstra算法的使用条件是图中没有负权边。当图中的边权全为正时，可以从起点出发，采用贪心的方法，一步一步得到最短路径。具体方法是：找出所有没有使用过的顶点中离起点最近的点，然后松弛所有与其相邻的边，将其加入已使用过的点的集合，重复这一步骤。这样可以保证：每一次点在被使用时，之前算出来的它到起点的“最短距离”就是实际的它到起点的最短距离。这可以用归纳法证明。 朴素版本如下：12345678910111213void dijkstra(int S)&#123; memset(d, 0x3f, sizeof(d)); d[S] = 0; for(int i = 0; i &lt; V; ++i)&#123; int mind = 2000000000, minp = -1; for(int i = 0; i &lt; V; ++i) if(mind &gt; d[i] &amp;&amp; !vis[i]) mind = d[i], minp = i;//寻找当前扩展点 vis[i] = true; for(int i = at[minp]; i; i = e[i].nxt) d[e[i].v] = min(d[e[i].v], d[minp] + e[i].cost);//松弛 &#125;&#125; 用堆优化的版本如下：123456789101112131415161718192021222324252627282930struct Node&#123; int id, curd; Node(int _id, int _curd)&#123; id = _id, curd = _curd; &#125;&#125;;struct cmp&#123; inline bool operator() (const Node &amp;na, const Node &amp;nb)&#123; return na.curd &gt; nb.curd; &#125;&#125;;priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;void dijkstra(int S)&#123; memset(d, 0x3f, sizeof(d)); d[S] = 0; pq.push(Node(S, 0)); for(int i = 0; i &lt; V; ++i)&#123; while(!pq.empty())&#123; if(pq.top().curd &gt; d[pq.top().id])//用这种方式省去了一个vis数组 pq.pop(); else break; &#125; int minp = pq.top().id; pq.pop(); for(int i = at[minp]; i; i = e[i].nxt)&#123; if(d[e[i].v] &gt; d[minp] + e[i].cost) d[e[i].v] = d[minp] + e[i].cost, pq.push(Node(e[i].v, d[e[i].v]));//通过这种方式判断是否已被访问 &#125; &#125;&#125; 朴素搜索当边权相同或者图很特殊（如$DAG$）时，可以直接采用搜索或者递推的方式计算最短路。由于这不是一个统一的模型，故在此不给出代码。 以上算法一般用于解决单源最短路问题。 矩阵乘法将图上的边距离对应成矩阵中相应行列的一个点，即可构造出一个矩阵 Floyd算法Floyd最短路算法可以在$O(|V|^3)$的时间复杂度下解决多源最短路问题。Floyd算法用到了动态规划的思想。考虑原始情况下，令$d[i][j]$表示点$i$和点$j$之间的最短距离。但这并不够用来表示一个状态，因此我们加上一维$k$，令$d[k][i][j]$表示利用编号为$0$到$k - 1$的点作为中转站时，$i$和$j$之间的最短距离。初始化时令$d[0][i][j] = cost[i][j]$（此时认为不使用中转站），其他值设为$INF$。在$0$到$k-1$的答案被算出来后，考虑$k$的情况。当不以$k$为中转站时，有$d[k+1][i][j]=d[k][i][j]$；当以$k$为中转站时，有$d[k+1][i][j]=d[k][i][k]+d[k][k][j]$。结合一下就是 d[k+1][i][j]=\min\left\{d[k][i][j],d[k][i][k]+d[k][k][j]\right\}可以发现，此时第一维已经没有什么必要。故最后我们可以得到以下代码。1234567void Floyd()&#123; //此时d数组里面已经存了相关信息 for(int k = 0; k &lt; V; ++k) for(int i = 0; i &lt; V; ++i) for(int j = 0; j &lt; V; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; Floyd算法允许负权边的存在，同时也可以用来判断负环是否存在。当负环存在时，存在$i$使得$d[i][i]&lt;0$。Floyd算法在一些和动态规划有所联系的图论题目里也有不错的表现，比如题目最小密度路径里面，可以增加一维记录当前走过的路径的条数，然后求出恰好经过一定数目路径的最短路的长度。同时Floyd算法的实现性也很强，很容易实现。不过似乎Floyd算法无法求出最短路径树。 参考资料 《算法导论》 《挑战程序设计竞赛（第2版）》 相关博客]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学英语]]></title>
    <url>%2F2018%2F08%2F16%2Fmath-english%2F</url>
    <content type="text"><![CDATA[列出一些常见的数学英语 Aadjacentadj. 毗邻的 Ccuboidn. 立方体 Eequilateraladj. 等边的，等面的 Iintegraladj. 整的，整数的，完整的，积分的n. 积分，整体 Mmaximumadj. 最大值的，最大量的n. 最大的量、体积、强度等 minimumn. 最低限度; 最小量; 最低消费; 极小值adj. 最小的; 最低的; 最少的 Pperimetern. 周长，周围 primen. 质数adj. 质的 TtotientEuler’s totient function: 欧拉函数 Rrelatively prime互质e.g. 15 is relatively prime to 2.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连分数和佩尔方程 学习笔记]]></title>
    <url>%2F2018%2F08%2F15%2Fwriting%2Fcontinued-fraction-and-pell-equation%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectEuler 61-100题解]]></title>
    <url>%2F2018%2F08%2F15%2Fpe61-100%2F</url>
    <content type="text"><![CDATA[继续探索 PE61先枚举排列，然后按照排列顺序进行搜索即可。或者按照图论，构图搜索也可以。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int p[6][10005], cnt[6] = &#123;0&#125;;int per[] = &#123;0, 1, 2, 3, 4, 5&#125;;int ans[6], t_ans[6];void init()&#123; int i; for(i = 1; (i * (i + 1) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i + 1) &gt;&gt; 1) &lt; 10000; ++i) p[0][cnt[0]++] = (i * (i + 1) &gt;&gt; 1); for(i = 1; i * i &lt; 1000; ++i); for(; i * i &lt; 10000; ++i) p[1][cnt[1]++] = i * i; for(i = 1; (i * (i * 3 - 1) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i * 3 - 1) &gt;&gt; 1) &lt; 10000; ++i) p[2][cnt[2]++] = (i * (i * 3 - 1) &gt;&gt; 1); for(i = 1; i * (2 * i - 1) &lt; 1000; ++i); for(; i * (2 * i - 1) &lt; 10000; ++i) p[3][cnt[3]++] = i * (2 * i - 1); for(i = 1; (i * (i * 5 - 3) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i * 5 - 3) &gt;&gt; 1) &lt; 10000; ++i) p[4][cnt[4]++] = (i * (i * 5 - 3) &gt;&gt; 1); for(i = 1; i * (i * 3 - 2) &lt; 1000; ++i); for(; i * (i * 3 - 2) &lt; 10000; ++i) p[5][cnt[5]++] = i * (i * 3 - 2);&#125;void getN(int index, int tail)&#123; if(index == 6)&#123; if(ans[5] % 100 == ans[0] / 100) memcpy(t_ans, ans, sizeof(ans)); return ; &#125; int id = per[index], hd = tail * 100; int _index = lower_bound(p[id], p[id] + cnt[id], hd) - p[id]; if(p[id][_index] / 100 != tail) return ; for(int i = _index; i &lt; cnt[id]; ++i)&#123; if(p[id][i] / 100 != tail) break ; ans[index] = p[id][i]; getN(index + 1, p[id][i] % 100); &#125;&#125;void solve()&#123; do&#123; int st = per[0]; for(int i = 0; i &lt; cnt[st]; ++i) ans[0] = p[st][i], getN(1, p[st][i] % 100); &#125;while(next_permutation(per, per + 6)); int sum = 0; for(int i = 0; i &lt; 6; ++i) sum += t_ans[i]; printf("%d\n", sum);&#125; 答案：28684 PE62一个一个长度去试12345678910111213141516171819map&lt;string, int&gt; mp;map&lt;string, ll&gt; mp2;ll ans = INF;void solve()&#123; char s[20]; for(ll i = 4642ll; i * i * i &lt; 1000000000000ll; ++i)&#123; sprintf(s, "%lld", i * i * i); sort(s, s + 12); string ss(s); if(!mp.count(ss)) mp[ss] = 1, mp2[ss] = i; else&#123; mp[ss]++; if(mp[ss] == 5) ans = min(ans, mp2[ss]); &#125; &#125; printf("%lld\n", ans * ans * ans);&#125; 答案：127035954683 PE63拿python水过12345678ans = 0for n in range(1, 22, 1): for i in range(1, 10, 1): x = i ** n if len(str(x)) == n: ans += 1print(ans) 答案：49 PE64这个连分数的构造方法一开始还不太容易看出来。。。答案写在另一篇博文里了。12 答案： PE65用python水过12345678910111213141516171819202122232425262728p = 1q = 1def gcd(a, b): if b == 0: return a else: return gcd(b, a % b)for i in range(1, 99, 1): a = 0 if (99 - i) % 3 == 2: a = ((98 - i) / 3 + 1) * 2 else: a = 1 pp = q qq = p + q * a p = pp q = qqp = p + q + qp /= gcd(p, q)ans = 0while p &gt; 0: ans += p % 10 p /= 10print(ans) 答案：272 PE66这个方程有名字，叫做佩尔方程。它的解和连分数有着很大的关系，将其写在了另一篇博文里12 PE67水DP答案：7273 PE68PE69筛出欧拉函数然后直接枚举。。。123456789void solve()&#123; getPhi(); int maxi; double d = 0; for(int i = 2; i &lt;= 1000000; ++i) if(d &lt; 1.0 * i / phi[i]) d = 1.0 * i / phi[i], maxi = i; printf("%d\n", maxi);&#125; 答案：510510 PE70枚举即可123456789101112131415161718192021void solve()&#123; getPhi(); int maxi; double d = 10000000; char s1[10], s2[10]; for(int i = 2; i &lt; 10000000; ++i)&#123; sprintf(s1, "%d", i); sprintf(s2, "%d", phi[i]); int len1 = strlen(s1), len2 = strlen(s2); if(len1 == len2)&#123; sort(s1, s1 + len1); sort(s2, s2 + len2); if(!strcmp(s1, s2))&#123; double dd = 1.0 * i / phi[i]; if(dd &lt; d) d = dd, maxi = i; &#125; &#125; &#125; printf("%d\n", maxi);&#125; 答案：8319823 PE71对于每一个$d$二分即可123456789101112131415161718void solve()&#123; double rd = 1.0 * 3 / 7, eps = 1e6; int fz, fm; for(int d = 9; d &lt;= 1000000; ++d)&#123; if(d % 7 == 0)continue; int l = 1, r = d - 1; while(r - l)&#123; int mid = (r + l + 1) &gt;&gt; 1; double rr = 1.0 * mid / d; if(rr &gt; rd)r = mid - 1; else l = mid; &#125; double rr = 1.0 * r / d; if(rd - rr &lt; eps) eps = rd - rr, fz = r, fm = d; &#125; printf("%d %d\n", fz, fm);&#125; 答案：428570 PE72就是对1~1000000的欧拉函数求和。。。1234567891011121314151617181920212223242526bool vis[1000005] = &#123;0&#125;;int prime[500005], tot = 0;int phi[1000005];ll sum = 0;void getPhi()&#123; phi[1] = 1; for(int i = 2; i &lt;= 1000000; ++i)&#123; if(!vis[i]) phi[i] = i - 1, prime[++tot] = i; for(int j = 1; j &lt;= tot; ++j)&#123; if(1ll * prime[j] * i &gt; 1000000) break; vis[prime[j] * i] = 1; if(i % prime[j] == 0)&#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125;else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; sum += 1ll * phi[i]; &#125;&#125;void solve()&#123; getPhi(); printf("%lld\n", sum);&#125; 答案：303963552391 PE73注意分数为不可约。12345678910111213141516171819int ans = 0;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void solve()&#123; double l = 1.0 / 3, r = 1.0 / 2; for(int i = 4; i &lt;= 12000; ++i)&#123; for(int j = 1; j &lt; i; ++j)&#123; if(gcd(i, j) &gt; 1) continue; double cur = 1.0 * j / i; if(abs(cur - l) &lt; 1e-7 || abs(cur - r) &lt; 1e-7) continue ; if(cur &gt; l &amp;&amp; cur &lt; r) ans++; &#125; &#125; printf("%d\n", ans);&#125; 答案：7295372 PE74虽然这道题我给出了一个正确的答案但我还是觉得我写错了。。。怎么回事？做法就是顺着一个数DFS下去，然后记录步数。12345678910111213141516171819202122232425262728293031323334int fac[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int d[10000005], ans = 0, st[10000005] = &#123;0&#125;;bool vis[10000005] = &#123;0&#125;;void getD()&#123; for(int i = 0; i &lt; 10; ++i) d[i] = fac[i]; for(int i = 10; i &lt;= 10000000; ++i) d[i] = d[i / 10] + fac[i % 10];&#125;void dfs(int x)&#123; vis[x] = 1; int nx = d[x]; if(!vis[nx]) dfs(nx); else&#123; if(!st[nx])&#123; st[x] = 1; return ; &#125; &#125; st[x] = st[nx] + 1;&#125;void solve()&#123; getD(); vis[1] = vis[2] = true; st[1] = st[2] = 1; for(int i = 3; i &lt; 1000000; ++i) if(!vis[i]) dfs(i); for(int i = 3; i &lt; 1000000; ++i) if(st[i] == 60) ans++; printf("%d\n", ans);&#125; 答案：402 PE75一开始我写了一个暴力枚举，然后很干脆的挂掉了。。。后来我想到可以枚举所有的素毕达哥拉斯三元数， 然后用类似筛法的方法让其倍数的方法数$+1$， 最后统计方法数仅为$1$的对数。这样做就快多了。123456789101112131415161718192021222324int ans = 0;int cnt[1500005] = &#123;0&#125;;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void pre()&#123; for(int v = 2; v &lt;= 1000; ++v) for(int u = 1; u &lt; v; ++u)&#123; if((u &amp; 1) &amp;&amp; (v &amp; 1))continue; if(gcd(u, v) != 1)continue; int dis = 2 * v * v + 2 * u * v; if(dis &gt; 1500000) break; for(int i = dis; i &lt;= 1500000; i += dis) cnt[i]++; &#125;&#125;void solve()&#123; pre(); for(int i = 12; i &lt;= 1500000; i += 2) if(cnt[i] == 1) ans++; printf("%d\n", ans);&#125; 答案：161667 PE76划分问题。令$p(n, m)$表示$n$划分为若干个小于等于$m$的数的方法数。那么有 p(n, m)=\begin{cases} 1\quad(n = 0) \\ p(n, m - 1)\quad (m >n)\\p(n, m - 1) +p (n - m, m)\quad (else)\end{cases}1234567891011121314ll p[105][105] = &#123;0&#125;;void solve()&#123; for(int i = 1; i &lt;= 100; ++i) p[1][i] = 1ll; for(int i = 2; i &lt;= 100; ++i)&#123; p[i][1] = 1ll; for(int j = 2; j &lt; i; ++j) p[i][j] = p[i][j - 1] + p[i - j][j]; p[i][i] = p[i][i - 1] + 1; for(int j = i + 1; j &lt;= 100; ++j) p[i][j] = p[i][j - 1]; &#125; printf("%lld\n", p[100][99]);&#125; 答案：190569291 PE77对pe76进行一定程度的加工即可。12345678910111213141516171819202122232425262728293031ll p[10005][10005] = &#123;0&#125;;bool vis[10005] = &#123;0&#125;;int prime[5005], tot = 0;void init()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; prime[tot++] = i; &#125;&#125;void solve()&#123; int ans; for(int i = 0; i &lt; tot; ++i) p[0][prime[i]] = 1ll; for(int i = 2; i &lt;= 10000; ++i)&#123; int id = upper_bound(prime, prime + tot, i) - prime - 1; //int pp = prime[id]; if(i &amp; 1) p[i][2] = 0; else p[i][2] = 1; for(int j = 1; j &lt;= id; ++j) p[i][prime[j]] = p[i][prime[j - 1]] + p[i - prime[j]][prime[j]]; for(int j = id + 1; j &lt; tot; ++j) p[i][prime[j]] = p[i][prime[j - 1]]; if(p[i][prime[id]] &gt; 5000)&#123; ans = i; break; &#125; &#125; printf("%d\n", ans);&#125; 答案：71（蜜汁小） PE78一开始拿pe76写了很久，结果什么都没有。。。后来发现了一个很神奇的东西。12 PE79…手算…?对所有询问排个序，去个重，就差不多可以发现一些问题了。答案：73162890 PE80考虑到精度问题，我们考虑对一个大整数开根号。比如计算$\sqrt 2$的前一百位，可以改为计算$10^{100}\times \sqrt 2$的前一百位。即先把根号的值放大，然后二分出具体的值即可。12345678910111213141516171819x = 10 ** 300ans = 0for i in range(2, 100, 1): y = math.floor(math.sqrt(i) + 0.5) if y * y != i: z = i * x l = 1 r = z while r - l &gt; 0: mid = (r + l) &gt;&gt; 1 if mid * mid &lt; z: l = mid + 1 else: r = mid s = str(l) for j in range(0, 100, 1): ans += eval(s[j: j + 1])print(ans) 答案：40886 PE81水DP答案：427337 PE82根据矩阵和走路的方式建图，跑最短路即可。12 答案： PE83同上。 PE84我不会这样的神奇概率题。。。我就模拟这个游戏足够多次，然后根据访问次数判断哪三个地方访问概率最大。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int vis[49] = &#123;0&#125;, cur = 0;int curc = 0, curh = 0;int cc[20] = &#123;0&#125;, ch[20] = &#123;0&#125;;pair&lt;int, int&gt; pp[45];pair&lt;int, int&gt; getS()&#123; int i = 1 + rand() % 4, j = 1 + rand() % 4; return make_pair(i, j);&#125;int getR(int x)&#123; if(x == 7)return 15; if(x == 22)return 25; if(x == 36)return 5;&#125;int getU(int x)&#123; if(x == 7)return 12; if(x == 22)return 28; if(x == 36)return 12;&#125;void init()&#123; srand(time(NULL)); cc[rand() % 16] = 1; int i = rand() % 16; while(cc[i]) i = rand() % 16; cc[i] = 2; for(int j = 1; j &lt;= 10; ++j)&#123; i = rand() % 16; while(ch[i]) i = rand() % 16; ch[i] = j; &#125;&#125;void solve()&#123; int lst = 0; for(int i = 1; i &lt;= 100000000; ++i)&#123; pair&lt;int, int&gt; p = getS(); int d = p.first + p.second; if(p.first == p.second) lst++; else lst = 0; if(lst == 3)&#123; cur = 10, lst = 0; &#125;else&#123; int to = (cur + d) % 40; if(to == 2 || to == 17 || to == 33)&#123; int id = cc[curc]; curc = (curc + 1) % 16; if(id == 1)&#123; cur = 0; &#125;else if(id == 2)&#123; cur = 10; &#125;else&#123; cur = to; &#125; &#125;else if(to == 7 || to == 22 || to == 36)&#123; int id = ch[curh]; curh = (curh + 1) % 16; if(id == 1)&#123; cur = 0; &#125;else if(id == 2)&#123; cur = 10; &#125;else if(id == 3)&#123; cur = 11; &#125;else if(id == 4)&#123; cur = 24; &#125;else if(id == 5)&#123; cur = 39; &#125;else if(id == 6)&#123; cur = 5; &#125;else if(id == 7 || id == 8)&#123; cur = getR(to); &#125;else if(id == 9)&#123; cur = getU(to); &#125;else if(id == 10)&#123; cur = to - 3; &#125;else&#123; cur = to; &#125; &#125;else if(to == 30)&#123; cur = 10; &#125;else&#123; cur = to; &#125; &#125; vis[cur]++; &#125; for(int i = 0; i &lt; 40; ++i) pp[i] = make_pair(vis[i], i); sort(pp, pp + 40); for(int i = 39; i &gt; 36; --i) printf("%d", pp[i].second);&#125; 答案：101524 PE85小学奥数题。边长为$n,m$的矩形内部有C_{n+1}^2 C_{m+1}^2个小矩形。123456789101112ll ans = INF, maxi;void solve()&#123; for(int i = 1; i &lt;= 2000; ++i)&#123; for(int j = 1; j &lt;= 2000; ++j)&#123; ll pp = 1ll * i * j * (i + 1) * (j + 1); pp &gt;&gt;= 2; if(abs(pp - 2000000) &lt; ans) ans = abs(pp - 2000000), maxi = 1ll * i * j; &#125; &#125; printf("%lld\n", maxi);&#125; 答案：2772 PE87直接3重循环，算出所有可能即可。1234567891011121314151617181920212223242526272829303132bool vis[10005] = &#123;0&#125;;int prime[4][10005], tot[4] = &#123;0&#125;;bool dd[50000005] = &#123;0&#125;;void getP()&#123; for(int i = 2; i &lt;= 8000; ++i) if(!vis[i])&#123; for(int j = i + i; j &lt;= 8000; j += i) vis[j] = 1; prime[0][++tot[0]] = i; &#125;&#125;void solve()&#123; getP(); for(int i = 1; i &lt; 4; ++i)&#123; for(int j = 1; j &lt;= tot[i - 1]; ++j)&#123; if(1ll * prime[0][j] * prime[i - 1][j] &gt;= 50000000ll)&#123; tot[i] = j - 1; break; &#125; prime[i][j] = prime[0][j] * prime[i - 1][j]; &#125; &#125; for(int k = 1; k &lt;= tot[1]; ++k) for(int i = 1; i &lt;= tot[2]; ++i) for(int j = 1; j &lt;= tot[3]; ++j) if(prime[1][k] + prime[2][i] + prime[3][j] &lt; 50000000) dd[prime[1][k] + prime[2][i] + prime[3][j]] = 1; int ans = 0; for(int i = 1; i &lt; 50000000; ++i) ans += dd[i]; printf("%d\n", ans);&#125; 答案：1097343 PE90生成组合，然后测试即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int cb[2][10], ans = 0;void judge()&#123; int l[2]; l[0] = l[1] = 0; for(int o = 0; o &lt; 2; ++o)&#123; int flag = 0; for(int i = 0; i &lt; 6; ++i)&#123; l[o] |= (1 &lt;&lt; cb[o][i]); if(cb[o][i] == 6 || cb[o][i] == 9) flag += cb[o][i]; &#125; if(flag == 6) l[o] |= (1 &lt;&lt; 9); if(flag == 9) l[o] |= (1 &lt;&lt; 6); &#125; int flag = 1; for(int i = 1; i &lt; 10; ++i)&#123; int g = (i * i) % 10, s = (i * i) / 10; g = 1 &lt;&lt; g, s = 1 &lt;&lt; s; if(((s &amp; l[0]) &amp;&amp; (g &amp; l[1])) || (s &amp; l[1]) &amp;&amp; (g &amp; l[0]))&#123; continue; &#125;else&#123; flag = 0; break; &#125; &#125; ans += flag;&#125;void getC(int o, int index, int left)&#123; cb[o][5 - left] = index; if(!left)&#123; if(!o) for(int i = 0; i &lt;= 4; ++i) getC(1, i, 5); else&#123; judge(); &#125; return ; &#125; for(int i = index + 1; i &lt;= 10 - left; ++i) getC(o, i, left - 1);&#125;void solve()&#123; for(int i = 0; i &lt;= 4; ++i) getC(0, i, 5); printf("%d\n", ans &gt;&gt; 1);&#125; 答案：1217 PE91四重循环。。。12345678910111213141516int ans = 0;void solve()&#123; for(int i = 0; i &lt;= 50; ++i) for(int j = 0; j &lt;= 50; ++j) for(int k = 0; k &lt;= 50; ++k) for(int l = 0; l &lt;= 50; ++l)&#123; if(!i &amp;&amp; !j)continue; if(!k &amp;&amp; !l)continue; if(i == k &amp;&amp; j == l)continue; int a = i * i + j * j, b = k * k + l * l, c = (i - k) *(i - k) + (j - l) * (j - l); if(a + b == c || a + c == b || b + c == a) ans++; &#125; printf("%d\n", ans &gt;&gt; 1);&#125; 答案：14234 PE92直接模拟即可。。89的比例还是挺高的。1234567891011121314151617int ans = 0;int sqr(int x)&#123; return x * x;&#125;void solve()&#123; for(int i = 2; i &lt; 10000000; ++i)&#123; int j = i; for(; j != 1 &amp;&amp; j != 89; )&#123; int sum = 0; while(j) sum += sqr(j % 10), j /= 10; j = sum; &#125; if(j == 89)ans++; &#125; printf("%d\n", ans);&#125; 答案：8581146 PE94做一些数学上的分析根据海伦公式有：$S=\sqrt{p(p-a)(p-b)(p-c)}$其中$a,b,c$均为边长在这道题中上式可以化为$S=(p-i)\sqrt{p(p-i-1)}$或$S=(p-i)\sqrt{p(p-i+1)}$然后由于面积要求为正整数，所以需要$p(p-i+1)$为完全平方数按照这个枚举即可。123456789101112131415161718bool sqr(ll x)&#123; ll r = (ll)floor(sqrt(x) + 0.5); return r * r == x;&#125;void solve()&#123; int ans = 0; for(int i = 3; i &lt;= 333333333; i += 2)&#123; ll p = (3 * i - 1) &gt;&gt; 1; p *= (i + 1) &gt;&gt; 1; if(sqr(p)) ans += 3 * i - 1; p = (3 * i + 1) &gt;&gt; 1; p *= (i - 1) &gt;&gt; 1; if(sqr(p)) ans += 3 * i + 1; &#125; printf("%d\n", ans);&#125; 答案：518408346 PE95对每一个数DFS一遍即可。1234567891011121314151617181920212223242526272829303132int d[1000005] = &#123;0&#125;;int ans = 0, mini;int vis[1000005] = &#123;0&#125;, tot = 0;void getD()&#123; for(int i = 2; i &lt;= 1000000; ++i)&#123; int j; for(j = 1; j * j &lt; i; ++j) if(i % j == 0) d[i] += j + i / j; if(j * j == i)d[i] += j; d[i] -= i; &#125;&#125;void dfs(int x, int st)&#123; vis[x] = tot; if(d[x] &gt; 1000000 || !d[x]) return ; if(vis[d[x]] == tot)&#123; if(st &gt; ans) ans = st, mini = d[x]; return ; &#125;else if(!vis[d[x]])&#123; dfs(d[x], st + 1); &#125;&#125;void solve()&#123; getD(); for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i]) tot++, dfs(i, 1); printf("%d %d\n", mini, ans);&#125; 答案：14316 PE96把现成的数独模板丢上去即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0;int tans[10][10]=&#123;0&#125;;void get(int at)&#123; int mini=99,p,x,y,o; for(int i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(int j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini)mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1]; lis[at+1][0]=lis[p][0],lis[at+1][1]=lis[p][1]; lis[p][0]=x,lis[p][1]=y;&#125;void dfs(int at)&#123; int x=lis[at][0],y=lis[at][1]; for(int i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1,sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125;else &#123; memcpy(tans, sd, sizeof(sd)); &#125; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0,sd[x][y]=0; &#125;&#125;//0 行 1 列 2 宫 int main()&#123; int ans = 0; char s1[10], s2[10]; for(int i = 0; i &lt; 50; ++i)&#123; int tmp; tot = 0; memset(sd, 0, sizeof(sd)); memset(lis, 0, sizeof(lis)); memset(vis, 0, sizeof(vis)); scanf("%s%s", s1, s2); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp)&#123; sd[i][j]=tmp; vis[0][i][tmp]=vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; &#125;else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); ans += tans[0][0] * 100 + tans[0][1] * 10 + tans[0][2]; &#125; printf("%d\n", ans); return 0; &#125; 答案：24702 PE97python，这个我还能说什么。。。答案：8739992577 PE99化成对数比即可。1234567891011double maxm = 0;int ans;void solve()&#123; for(int i = 1; i &lt;= 1000; ++i)&#123; int b = read(), e = read(); double tt = 1.0 * e * log(b); if(tt &gt; maxm) maxm = tt, ans = i; &#125; printf("%d\n", ans);&#125; 答案：709]]></content>
      <categories>
        <category>ProjectEuler</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectEuler 1-60题解]]></title>
    <url>%2F2018%2F08%2F11%2Fpe1-60%2F</url>
    <content type="text"><![CDATA[探索新领域PE前面的题还是很比较简单的。除了某些题（如51，60）需要一定的枚举策略之外，其他题大部分靠暴力即可。 PE1直接枚举即可。1234567void solve()&#123; int sum = 0; for(int i = 3; i &lt; 1000; ++i) if(i % 3 == 0 || i % 5 == 0) sum += i; printf("%d\n", sum);&#125; 答案：233168 PE2直接枚举即可。1234567891011int fib[1005];void solve()&#123; int i, sum = 0; fib[0] = 1, fib[1] = 2; for(i = 2; fib[i - 1] &lt; 4000000; ++i) fib[i] = fib[i - 1] + fib[i - 2]; for(; i &gt;= 0; --i) if(fib[i] &lt;= 4000000 &amp;&amp; fib[i] % 2 == 0) sum += fib[i]; printf("%d\n", sum);&#125; 答案：4613732 PE3本来可以直接上Pollard-Rho，后来想了一下其实不用。因为这个数还是比较小的。1234567891011ll c = 600851475143;void solve()&#123; ll tmp = c; for(ll i = 2; i * i &lt;= c; ++i) if(tmp % i == 0)&#123; while(tmp % i == 0 &amp;&amp; tmp / i != 1) tmp /= i; if(tmp / i == 1)break ; &#125; printf("%d\n", tmp);&#125; 答案：6857 PE4枚举即可。1234567891011121314151617bool isP(int t)&#123; char s[8]; sprintf(s, "%d", t); int len = strlen(s); for(int i = 0; i &lt; (len &gt;&gt; 1); ++i) if(s[i] != s[len - i -1]) return false; return true;&#125;void solve()&#123; int ans = 0; for(int i = 100; i &lt; 1000; ++i) for(int j = 100; j &lt; 1000; ++j) if(isP(i * j)) ans = max(ans, i * j); printf("%d\n", ans);&#125; 答案：906609 PE5可以手算出答案。答案：232792560 PE6直接手算即可。答案：25164150 PE7直接用筛法计算即可。12345678910111213bool vis[1000005] = &#123;0&#125;;int sum = 0;void solve()&#123; int N = 1000000; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; sum++; if(sum == 10001)printf("%d\n", i); for(int j = i + i; j &lt;= N; j += i) vis[j] = 1; &#125; &#125;&#125; 答案：104743 PE8直接遍历即可。123456789101112131415char num[1005];ll ans = 0;void init()&#123; for(int i = 0; i &lt; 20; ++i) scanf("%s", num + i * 50);&#125;void solve()&#123; for(int i = 0; i &lt;= 987; ++i)&#123; ll pro = 1; for(int j = 0; j &lt; 13; ++j) pro *= (ll)(num[i + j] - '0'); ans = max(ans, pro); &#125; printf("%lld\n", ans);&#125; 答案：23514624000 PE9直接循环遍历，枚举即可。1234567891011ll ans;void solve()&#123; for(int i = 3; i &lt;= 1000; ++i) for(int j = 3; j &lt;= 1000; ++j) if(i * i + j * j == (1000 - i - j) * (1000 - i - j) &amp;&amp; 1000 &gt; i + j)&#123; ans = 1ll * i * j * (1000 - i - j); goto printans; &#125; printans: printf("%lld\n", ans);&#125; 答案：31875000 PE10使用筛法即可。12345678910111213bool vis[2000005] = &#123;0&#125;;ll sum = 0;void solve()&#123; int N = 2000000; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; sum += (ll)i; for(int j = i + i; j &lt;= N; j += i) vis[j] = 1; &#125; &#125; printf("%lld\n", sum);&#125; 答案：142913828922 PE11枚举即可。一个数只需要枚举4个方向。12345678910111213141516171819202122232425262728293031323334353637int dat[25][25];void init()&#123; for(int i = 0; i &lt; 20; ++i) for(int j = 0; j &lt; 20; ++j) dat[i][j] = read();&#125;void solve()&#123; int ans = 0; for(int i = 0; i &lt; 20; ++i) for(int j = 0; j &lt; 20; ++j)&#123; if(i &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j]; ans = max(ans, t); &#125; if(j &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i][j - k]; ans = max(ans, t); &#125; if(i &gt;= 3 &amp;&amp; j &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j - k]; ans = max(ans, t); &#125; if(i &gt;= 3 &amp;&amp; j &lt;= 16)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j + k]; ans = max(ans, t); &#125; &#125; printf("%d\n", ans);&#125; 答案：70600674 PE12直接枚举每一个三角形数的因子即可。123456789101112131415161718int getD(ll t)&#123; int cnt = 0; ll i; for(i = 1; i * i &lt; t; ++i) if(t % i == 0) cnt += 2; if(i * i == t)cnt++; return cnt;&#125;void solve()&#123; ll t, n; for(n = 11; ; ++n)&#123; t = n * (n + 1) &gt;&gt; 1; if(getD(t) &gt; 500) break; &#125; printf("%lld\n", t);&#125; 答案：76576500 PE13用python水过去123456y = 0for i in range(1, 101, 1): x = input() y = y + xprint(y) 答案：5537376230 PE14直接跑递归即可。看清题目，问的是什么数产生最长链而不是最长链有多长！12345678910111213141516171819202122int step[1000005] = &#123;0&#125;, ans = 0, maxi;int go(ll cur)&#123; if(cur &lt;= 1000000 &amp;&amp; step[cur]) return step[cur]; int res; if(cur &amp; 1) res = go(cur * 3 + 1) + 1; else res = go(cur &gt;&gt; 1) + 1; if(cur &lt;= 1000000) step[cur] = res; return res;&#125;void solve()&#123; step[1] = 1; for(int i = 2; i &lt;= 1000000; ++i)&#123; go(i); if(step[i] &gt; ans) ans = step[i], maxi = i; &#125; printf("%d\n", maxi);&#125; 答案：837799 PE15即为C_{40}^{20}答案：137846528820 PE16用python水过1234567x = 2 ** 1000sum = 0while x &gt; 0: sum += x % 10 x /= 10print(sum) 答案：1366 PE17神奇模拟题。了解一下英式的读数字方式即可。12345678910111213141516171819202122int ge[] = &#123;0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8&#125;;int ten[] = &#123;0, 0, 6, 6, 5, 5, 5, 7, 6, 6&#125;;void solve()&#123; int sum = 0; for(int i = 1; i &lt; 1000; ++i)&#123; if(i &lt; 20) sum += ge[i]; else if(i &lt; 100) sum += ge[i % 10] + ten[i / 10]; else &#123; sum += ge[i / 100] + 7; if(i % 100 != 0)&#123; sum += 3;//and if(i % 100 &lt; 20) sum += ge[i % 100]; else sum += ge[i % 10] + ten[(i % 100) / 10]; &#125; &#125; &#125; printf("%d\n", sum + 11);//one thousand&#125; 答案：21124 PE18一个简单的DP。12345678910111213141516int dat[17][17] = &#123;0&#125;;int dp[17][17] = &#123;0&#125;;void init()&#123; for(int i = 1; i &lt;= 15; ++i) for(int j = 1; j &lt;= i; ++j) dat[i][j] = read();&#125;void solve()&#123; for(int i = 1; i &lt;= 15; ++i) for(int j = 1; j &lt;= i; ++j) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + dat[i][j]; int ans = 0; for(int i = 1; i &lt;= 15; ++i) ans = max(ans, dp[15][i]); printf("%d\n", ans);&#125; 答案：1074 PE19模拟。1234567891011121314151617181920212223int month[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;void solve()&#123; int cury = 1901, curm = 1, curd = 1, curx = 2, ans = 0; for(; ; )&#123; curd++, curx++; if(curd &gt; month[curm])&#123; if(curm != 2)&#123; curm++, curd = 1; &#125;else&#123; if(cury % 4 != 0) curm++, curd = 1; else if(curd == 30) curm++, curd = 1; &#125; &#125; if(curm == 13) cury++, curm = 1; if(cury &gt; 2000)break; if(curx == 8)curx = 1; if(curx == 7 &amp;&amp; curd == 1)ans++; &#125; printf("%d\n", ans);&#125; 答案：171 PE20用python水过12345678910x = 1for i in range(2, 101, 1): x *= ians = 0while x &gt; 0: ans += x % 10 x /= 10print(ans) 答案：648 PE21遍历即可。1234567891011121314151617int ans = 0;int d(int x)&#123; int res = 0, i = 1; for(i = 1; i * i &lt; x; ++i) if(x % i == 0) res += i + x / i; if(i * i == x)res += i; return res - x;&#125;void solve()&#123; for(int i = 2; i &lt; 10000; ++i)&#123; int dd = d(i); if(dd != i &amp;&amp; d(dd) == i) ans += i + dd; &#125; printf("%d\n", ans &gt;&gt; 1);&#125; 答案：31626 PE22用string排序后水过。12345678910111213141516171819202122232425char s[105];string ss[10005];int n = 0;void solve()&#123; for(; ; )&#123; char c = getchar(); if(c == EOF)break; int i = 0; while((c = getchar()) != '"') s[i++] = c; s[i] = '\0'; getchar(); n++; ss[n] = s; &#125; sort(ss + 1, ss + n + 1); ll ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; int len = ss[i].length(), sum = 0; for(int j = 0; j &lt; len; ++j) sum += ss[i][j] - 'A' + 1; ans += 1ll * sum * i; &#125; printf("%lld\n", ans);&#125; 答案：871198282 PE23暴力水过12345678910111213141516171819202122232425int d[30005] = &#123;0&#125;, lis[30005], tot = 0;bool vis[30005] = &#123;0&#125;;void init()&#123; for(int i = 1; i &lt;= 28123; ++i)&#123; int j; for(j = 1; j * j &lt; i; ++j) if(i % j == 0) d[i] += j + i / j; if(j * j == i)d[i] += j; d[i] -= i; if(d[i] &gt; i) lis[++tot] = i; &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= tot; ++i) for(int j = i; j &lt;= tot; ++j) if(lis[i] + lis[j] &lt;= 28123) vis[lis[i] + lis[j]] = 1; int ans = 0; for(int i = 1; i &lt;= 28123; ++i) if(!vis[i]) ans += i; printf("%d\n", ans);&#125; 答案：4179871 PE24大力next_permutation答案：2783915460 PE25用python水过。123456789101112x = 1y = 1ind = 2while True: z = x + y x = y y = z ind += 1 if len(str(z)) == 1000: breakprint(ind) 答案：4782 PE26当余数出现循环时终止即可。12345678910111213141516171819202122int lis[1005], tot, cur[1005];int ans = 0, maxi;void solve()&#123; for(int i = 11; i &lt; 1000; ++i)&#123; int t = 10; memset(cur, 0, sizeof(cur)); for(tot = 1; ; ++tot)&#123; lis[tot] = t / i; if(!cur[t % i]) cur[t % i] = tot; else&#123; if(ans &lt; tot - cur[t % i]) ans = tot - cur[t % i], maxi = i; break ; &#125; t %= i; t *= 10; &#125; &#125; printf("%d %d\n", ans, maxi);&#125; 答案：983 PE27枚举即可。注意负数不能算质数。123456789101112131415161718192021int ans = 0, maxi;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;void solve()&#123; for(int a = -999; a &lt; 1000; ++a)&#123; for(int b = 2; b &lt;= 1000; ++b)&#123; int n; for(n = 0; ; ++n) if(!isP(n * n + a * n + b)) break; if(n &gt; ans) ans = n, maxi = a * b; &#125; &#125; printf("%d\n", maxi);&#125; 答案：-59231 PE28模拟出蛇形数阵即可。12345678910111213141516171819int d[1005][1005] = &#123;0&#125;;int dx[] = &#123;1, 0, -1, 0, 0&#125;, dy[] = &#123;0, -1, 0, 1, 1&#125;;void solve()&#123; int x = 501, y = 502, c = 2; d[501][501] = 1; for(int i = 2; i &lt;= 1000; i += 2)&#123; for(int j = 0; j &lt; 4; ++j)&#123; for(int k = 0; k &lt; i; ++k) d[x][y] = c, c++, x += dx[j], y += dy[j]; x -= dx[j], y -= dy[j]; x += dx[j + 1], y += dy[j + 1]; &#125; &#125; int sum = 0; for(int i = 1; i &lt;= 1001; ++i) sum += d[i][i] + d[i][1002 - i]; printf("%d\n", sum - 1);&#125; 答案：669171001 PE29用对数表示幂，排序去重即可。会有奇怪的精度问题。12345678910111213141516double d[10005];int tot = 0, ans = 0;bool cmp(const double&amp; d1, const double&amp; d2)&#123; return abs(d1 - d2) &lt; 1e-5;&#125;void solve()&#123; for(int i = 2; i &lt;= 100; ++i) for(int j = 2; j &lt;= 100; ++j) d[tot++] = 100.0 * j * log(i); sort(d, d + tot); double cur = -1; for(int i = 0; i &lt; tot; ++i) if(!cmp(cur, d[i])) cur = d[i], ans++; printf("%d\n", ans);&#125; 答案：9183 PE30枚举即可。上界小于100000012345678910111213int sum = 0;int qq(int x)&#123; return x * x * x * x * x;&#125;void solve()&#123; for(int i = 2; i &lt;= 1000000; ++i)&#123; int t = i, s = 0; while(t) s += qq(t % 10), t /= 10; if(s == i)sum += i; &#125; printf("%d\n", sum);&#125; 答案：443839 PE31多重背包。1234567891011121314int w[] = &#123;1, 2, 5, 10, 20, 50, 100, 200&#125;;int f[205] = &#123;0&#125;;void solve()&#123; f[0] = 1; for(int i = 0; i &lt; 8; ++i)&#123; for(int j = 1; ; j &lt;&lt;= 1)&#123; int d = j * w[i]; if(d &gt; 200)break ; for(int k = 200; k &gt;= d; --k) f[k] += f[k - d]; &#125; &#125; printf("%d\n", f[200]);&#125; 答案：73682 PE32从1234开始枚举即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int cnt[11];bool f(int x)&#123; bool flag = 1; while(x)&#123; if(cnt[x % 10] || x % 10 == 0) flag = 0; cnt[x % 10]++, x /= 10; &#125; return flag;&#125;void t(int x)&#123; while(x) cnt[x % 10]--, x /= 10;&#125;void solve()&#123; int ans = 0; for(int i = 1234; i &lt; 1000000; ++i)&#123; for(int j = 1; j &lt; 10; ++j) cnt[j] = 0; if(!f(i))continue ; for(int j = 2; j * j &lt; i; ++j)&#123; if(i % j == 0)&#123; if(!f(j))&#123; t(j); continue ; &#125;else&#123; if(!f(i / j))&#123; t(i / j), t(j); continue; &#125;else&#123; int flag = 1; for(int i = 1; i &lt; 10; ++i) if(cnt[i] != 1)&#123; flag = 0; break; &#125; if(flag)&#123; printf("%d %d %d\n", i, j, i / j); ans += i; break ; &#125;else &#123; t(j), t(i / j); continue; &#125; &#125; &#125; &#125; &#125; &#125; printf("%d\n", ans);&#125; 答案：45228 PE33枚举分子分母即可。题意有点不太好懂。1234567891011121314151617181920212223void solve()&#123; int fz = 1, fm = 1, cnt = 0; for(int i = 10; i &lt;= 99; ++i) for(int j = i + 1; j &lt;= 99; ++j)&#123; if(i % 10 == 0 &amp;&amp; j % 10 == 0) continue ; int a = i / 10, b = i % 10, c = j / 10, d = j % 10; if(a == c)&#123; if(i * d == j * b) fz *= i, fm *= j, cnt++; &#125;else if(a == d)&#123; if(i * c == j * b) fz *= i, fm *= j, cnt++; &#125;else if(b == c)&#123; if(i * d == j * a) fz *= i, fm *= j, cnt++; &#125;else if(b == d)&#123; if(i * c == j * a) fz *= i, fm *= j, cnt++; &#125; &#125; printf("%d %d\n", fm / gcd(fm, fz), cnt);&#125; 答案：100 PE34枚举即可只有2个数符合。。1234567891011121314int f[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;void solve()&#123; ll ans = 0; for(int i = 10; i &lt;= 100000000; ++i)&#123; int t = i, sum = 0; while(t) sum += f[t % 10], t /= 10; if(sum == i) ans += 1ll * i, printf("%d\n", i); &#125; printf("%lld\n", ans);&#125; 答案：40730 PE35循环枚举即可。1234567891011121314151617181920212223242526bool vis[1000005] = &#123;0&#125;;char s[16];void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; &#125;&#125;void solve()&#123; getP(); int ans = 13; for(int i = 111; i &lt; 1000000; i += 2)&#123; if(vis[i])continue; sprintf(s, "%d", i); int len = strlen(s), j; sprintf(s + len, "%d", i); for(j = len; j &gt; 0; --j)&#123; s[j + len] = '\0'; if(vis[atoi(s + j)]) break ; &#125; if(!j)ans++; &#125; printf("%d\n", ans);&#125; 答案：55 PE36直接枚举回文数即可。1234567891011121314151617181920212223ll sum = 0;int d[30];bool isP(int x)&#123; int t = x, cnt = 0; while(t) d[cnt++] = t % 10, t /= 10; for(int i = 0; i &lt; (cnt &gt;&gt; 1); ++i) if(d[i] != d[cnt - i - 1]) return false; t = x, cnt = 0; while(t) d[cnt++] = t % 2, t &gt;&gt;= 1; for(int i = 0; i &lt; (cnt &gt;&gt; 1); ++i) if(d[i] != d[cnt - i - 1]) return false; return true;&#125;void solve()&#123; for(int i = 1; i &lt; 1000000; i += 2) if(isP(i)) sum += 1ll * i; printf("%lld\n", sum);&#125; 答案：872187 PE37枚举即可1234567891011121314151617181920212223242526272829303132333435int sum = 0, ten[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000&#125;;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool is(int x)&#123; int t = x; if(!isP(x))return false; for(; ; )&#123; t /= 10; if(!t)break; if(!isP(t))return false; &#125; int m; for(m = 1; ten[m] &lt; x; m++) ; for(m--; m &gt; 0; --m)&#123; x %= ten[m]; if(!isP(x))return false; &#125; return true;&#125;void solve()&#123; int cnt = 0; for(int i = 11; cnt &lt; 11 &amp;&amp; i &lt; 1000000; i += 2)&#123; if(i % 10 != 3 &amp;&amp; i % 10 != 7) continue ; if(is(i)) cnt++, sum += i, printf("%d\n", i); &#125; printf("%d\n", sum);&#125; 答案：748317 PE38枚举这样的数即可12345678910111213141516171819202122232425262728int ans = 0;bool vis[11];void solve()&#123; char s[15]; for(int i = 2; i &lt; 10000; ++i)&#123; memset(vis, 0, sizeof(vis)); int cnt = 0, flag = 1, j; for(j = 1; flag &amp;&amp; cnt &lt; 9 &amp;&amp; j &lt; 10; ++j)&#123; int t = i * j; while(t)&#123; if(t % 10 == 0 || vis[t % 10])&#123; flag = 0; break; &#125;else vis[t % 10] = 1, cnt++, t /= 10; &#125; &#125; if(cnt == 9 &amp;&amp; flag)&#123; s[0] = '\0'; for(int k = 1, st = 0; k &lt; j; ++k) sprintf(s + st, "%d", k * i), st = strlen(s); ans = max(ans, atoi(s)); &#125; &#125; printf("%d\n", ans);&#125; 答案：932718654 PE39循环枚举即可1234567891011121314int ans = 0, maxi;void solve()&#123; for(int i = 12; i &lt;= 1000; ++i)&#123; int cnt = 0; for(int j = 3; j &lt;= i / 3; ++j)&#123; for(int k = j + 1; k &lt; i - j - j &amp;&amp; k &lt; (i - j) &gt;&gt; 1; ++k) if(j * j + k * k == (i - j - k) * (i - j - k)) cnt++; if(cnt &gt; ans) ans = cnt, maxi = i; &#125; &#125; printf("%d\n", maxi);&#125; 答案：840 PE40貌似只能枚举。。。数据还特别大。跑了几分钟才跑出来。123456789101112131415161718int len = 0;char s[1000105];int c(int x)&#123; return s[x - 1] - '0';&#125;void solve()&#123; s[0] = '\0'; for(int i = 1; len &lt; 1000000; ++i)&#123; sprintf(s + len, "%d", i); if(i &lt; 10)len++; else if(i &lt; 100)len += 2; else if(i &lt; 1000)len += 3; else if(i &lt; 10000)len += 4; else if(i &lt; 100000)len += 5; else if(i &lt; 1000000)len += 6; &#125; printf("%d\n", c(1) * c(10) * c(100) * c(1000) * c(10000) * c(100000) * c(1000000));&#125; 答案：210 PE41从长度为9的排列开始，一直向下尝试。123456789101112131415161718int p[] = &#123;7, 6, 5, 4, 3, 2, 1&#125;;bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;void solve()&#123; while(prev_permutation(p, p + 7))&#123; printf("x"); int x = 0; for(int i = 0; i &lt; 7; ++i) x = x * 10 + p[i]; if(isP(x))break ; &#125; for(int i = 0; i &lt; 7; ++i) printf("%d", p[i]);&#125; 答案：7652413 PE42字符串题。。。123456789101112131415161718int seq[10005], ans = 0;char s[16];void solve()&#123; for(int i = 1; i &lt;= 10000; ++i) seq[i - 1] = i * (i + 1) &gt;&gt; 1; for(; ; )&#123; char c = getchar(); if(c == EOF)break; int i = 0, sum = 0; while((c = getchar()) != '"') s[i++] = c, sum += c - 'A' + 1; s[i] = '\0'; getchar(); if(*lower_bound(seq, seq + 10000, sum) == sum) ans++; &#125; printf("%d\n", ans);&#125; 答案：162 PE43枚举排列即可。12345678910111213141516171819202122int p[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int pr[] = &#123;2, 3, 5, 7, 11, 13, 17&#125;;ll ans = 0;void solve()&#123; do&#123; int flag = 1; for(int i = 1; i &lt; 8; ++i)&#123; int j = p[i] * 100 + p[i + 1] * 10 + p[i + 2]; if(j % pr[i - 1] != 0)&#123; flag = 0; break; &#125; &#125; if(flag)&#123; ll x = 0; for(int i = 0; i &lt; 10; ++i) x = x * 10 + p[i]; ans += 1ll * x; &#125; &#125;while(next_permutation(p, p + 10)); printf("%lld\n", ans);&#125; 答案：16695334890 PE44枚举。但是数据有一点吓人。123456789101112131415161718192021222324ll seq[40005];void solve()&#123; for(ll i = 1; i &lt;= 40000; ++i) seq[i - 1] = i * (3 * i - 1) &gt;&gt; 1; int i; for(i = 0; i &lt; 40000; ++i)&#123; int flag = 0; for(int j = 0; j &lt; 40000; ++j)&#123; ll sum = seq[i] + seq[j]; int index = lower_bound(seq, seq + 40000, sum) - seq; if(index == 40000) break; if(seq[index] == sum)&#123; index = lower_bound(seq, seq + 40000, sum + seq[j]) - seq; if(index &lt; 40000 &amp;&amp; seq[index] == sum + seq[j])&#123; flag = 1; break; &#125; &#125; &#125; if(flag)break ; &#125; printf("%lld\n", seq[i]);&#125; 答案：5482660 PE45枚举即可。三角形数有点大。12345678910111213141516ll sqr(ll x)&#123; ll r = (ll)floor(sqrt(x) + 0.5); if(r * r != x) return -1; return r;&#125;void solve()&#123; ll n; for(n = 286; n &lt; 1000000; ++n)&#123; ll t = n * (n + 1) &gt;&gt; 1; ll a = sqr(1 + 8 * t), b = sqr(1 + 24 * t); if(a &gt; 0 &amp;&amp; (1 + a) % 4 == 0 &amp;&amp; b &gt; 0 &amp;&amp; (1 + b) % 6 == 0) break; &#125; printf("%lld\n", n);&#125; 答案：1533776805 PE46枚举即可。123456789101112131415161718192021222324252627282930313233343536373839int prime[100005], tot = 0;bool vis[1000005] = &#123;0&#125;;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool isQ(int x)&#123; int d = (int)floor(sqrt(x) + 0.5); return d * d == x;&#125;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; prime[tot++] = i; &#125;&#125;void solve()&#123; int ans; getP(); for(int i = 35; ; i += 2)&#123; if(isP(i))continue ; int flag = 0; for(int j = 1; j &lt; tot &amp;&amp; i - prime[j] &gt; 0; ++j) if(isQ((i - prime[j]) &gt;&gt; 1))&#123; flag = 1; break ; &#125; if(!flag)&#123; ans = i; break; &#125; &#125; printf("%d\n", ans);&#125; 答案：5777 PE47找质因数即可12345678910111213141516171819202122232425int get(int x)&#123; int cnt = 0, t = x; for(int i = 2; i * i &lt;= x; ++i)&#123; if(t % i == 0)&#123; while(t % i == 0) t /= i; cnt++; &#125; if(t == 1)break; &#125; if(t != 1)cnt++; return cnt;&#125;void solve()&#123; bool b1 = 0, b2 = 0, b3 = 0, b4 = 0; int i; for(i = 6; ; ++i)&#123; if(get(i) == 4) b4 = 1; if(b1 &amp;&amp; b2 &amp;&amp; b3 &amp;&amp; b4) break; b1 = b2, b2 = b3, b3 = b4, b4 = 0; &#125; printf("%d\n", i - 3);&#125; 答案：134043 PE48大力python答案：9110846700 PE49枚举即可1234567891011121314151617181920212223242526272829303132bool vis[10005] = &#123;0&#125;;char s1[10], s2[10];void getP()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; &#125;&#125;bool cmp(int x, int y)&#123; sprintf(s1, "%d", x); sprintf(s2, "%d", y); sort(s1, s1 + 4); sort(s2, s2 + 4); return strcmp(s1, s2) == 0;&#125;void solve()&#123; getP(); int ans1 = 0, ans2 = 0; for(int i = 1489; i &lt; 10000; i += 2)&#123; if(vis[i])continue; for(int j = 2; i + j + j &lt; 10000; ++j)&#123; if(vis[i + j] || vis[i + j + j]) continue; if(!cmp(i, i + j) || !cmp(i, i + j + j)) continue; ans1 = i, ans2 = j; &#125; if(ans1)break; &#125; printf("%d%d%d\n", ans1, ans1 + ans2, ans1 + 2 * ans2);&#125; 答案：296962999629 PE50用前缀和枚举即可12345678910111213141516171819202122232425int prime[100005], tot = 0, sum[100005] = &#123;0&#125;;bool vis[1000005] = &#123;0&#125;;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; prime[++tot] = i; &#125;&#125;void solve()&#123; getP(); for(int i = 1; i &lt;= 9592; ++i) sum[i] = sum[i - 1] + prime[i]; int ans = 0; for(int i = 547; i &gt;= 0; --i)&#123; for(int j = i; sum[j] - sum[j - i] &lt; 1000000; ++j) if(!vis[sum[j] - sum[j - i]])&#123; ans = sum[j] - sum[j - i]; break ; &#125; if(ans)break ; &#125; printf("%d\n", ans);&#125; 答案：997651 PE51千万看清楚题目！替换的数字一开始就需要相同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748char s[10];bool vis[1000005] = &#123;0&#125;;int yq[6], i;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; &#125;&#125;bool change()&#123; sprintf(s, "%d", i); int cnt = 0, lst = -1; for(int i = 0; i &lt; 5; ++i) if(yq[i])&#123; if(lst &lt; 0)lst = s[i] - '0'; else if(lst &gt; 2 || lst != s[i] - '0')return false; &#125; for(int i = lst; i &lt; 10; ++i)&#123; for(int j = 0; j &lt; 5; ++j) if(yq[j]) s[j] = i + '0'; if(!vis[atoi(s)]) cnt++; &#125; return cnt == 8;&#125;bool get(int d)&#123; if(d == 5)&#123; if(change()) return true; return false; &#125; yq[d] = 0; if(get(d + 1))return true; yq[d] = 1; if(get(d + 1))return true; return false;&#125;void solve()&#123; getP(); for(i = 100001; i &lt; 1000000; i += 2)&#123; if(i % 5 == 0 || vis[i])continue; if(get(0)) break ; &#125; printf("%d\n", i);&#125; 答案：121313 PE52居然真的是142857。。。12345678910111213141516171819int pp[8];void solve()&#123; int i; for(i = 1; i &lt;= 1000000; ++i)&#123; for(int j = 1; j &lt;= 6; ++j)&#123; pp[j] = 0; for(int t = i * j; t; t /= 10) pp[j] |= (1 &lt;&lt; (t % 10)); &#125; int flag = 1; for(int j = 2; j &lt;= 6; ++j) if(pp[j - 1] != pp[j])&#123; flag = 0; break; &#125; if(flag)break ; &#125; printf("%d\n", i);&#125; 答案：142857 PE53递推即可。123456789101112131415int dat[105][105] = &#123;0&#125;;void solve()&#123; dat[1][0] = dat[1][1] = 1; int ans = 0; for(int i = 2; i &lt;= 100; ++i)&#123; dat[i][0] = 1; for(int j = 1; j &lt;= 100; ++j)&#123; if(dat[i - 1][j] + dat[i - 1][j - 1] &gt; 1000000) dat[i][j] = 1000001, ans++; else dat[i][j] = dat[i - 1][j] + dat[i - 1][j - 1]; &#125; &#125; printf("%d\n", ans);&#125; 答案：4075 PE54这就是个模拟题和数学有毛关系123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224int p[2][6][2], ans = 0;int tab[128];int cnt[2][5], vcnt[2][19];void init()&#123; char cd[4]; for(int o = 0; o &lt; 2; ++o)&#123; for(int i = 0; i &lt; 5; ++i)&#123; scanf("%s", cd); p[o][i][1] = tab[cd[1]]; if(cd[0] == 'T') p[o][i][0] = 9; if(cd[0] == 'J') p[o][i][0] = 10; if(cd[0] == 'Q') p[o][i][0] = 11; if(cd[0] == 'K') p[o][i][0] = 12; if(cd[0] == 'A') p[o][i][0] = 13; if(isdigit(cd[0])) p[o][i][0] = cd[0] - '0' - 1; &#125; &#125; memset(cnt, 0, sizeof(cnt)); memset(vcnt, 0, sizeof(vcnt));&#125;int getRank(int o)&#123; for(int i = 0; i &lt; 5; ++i) cnt[o][p[o][i][1]]++, vcnt[o][p[o][i][0]]++; int flag1 = 0, flag2 = 0, flag3 = 0; for(int i = 0; i &lt; 4; ++i) if(cnt[o][i] == 5)&#123; flag1 = 1; if(vcnt[o][9] &amp;&amp; vcnt[o][10] &amp;&amp; vcnt[o][11] &amp;&amp; vcnt[o][12] &amp;&amp; vcnt[o][13]) return 10; else&#123; for(int j = 1; j &lt; 9; ++j) if(vcnt[o][j] &amp;&amp; vcnt[o][j + 1] &amp;&amp; vcnt[o][j + 2] &amp;&amp; vcnt[o][j + 3] &amp;&amp; vcnt[o][j + 4]) return 9; &#125; &#125; for(int i = 1; i &lt;= 13; ++i) if(vcnt[o][i] == 4) return 8; else if(vcnt[o][i] == 3)&#123; flag2 = 1; for(int j = 1; j &lt;= 13; ++j)&#123; if(j == i)continue; if(vcnt[o][j] == 2) return 7; &#125; &#125;else if(vcnt[o][i] == 2) flag3++; if(flag1)return 6; for(int j = 1; j &lt;= 9; ++j) if(vcnt[o][j] &amp;&amp; vcnt[o][j + 1] &amp;&amp; vcnt[o][j + 2] &amp;&amp; vcnt[o][j + 3] &amp;&amp; vcnt[o][j + 4]) return 5; if(flag2)return 4; if(flag3 == 2)return 3; else if(flag3 == 1)return 2; return 1;&#125;bool judge1(int lim)&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == lim)&#123; maxi[i] = j; break; &#125; &#125; return maxi[0] &gt; maxi[1]; &#125;bool judge1(int lim, int lf)&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == lim)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1]) return judge1(lf); else return maxi[0] &gt; maxi[1];&#125;bool judge2()&#123; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] &gt; vcnt[1][j]) return true; else if(vcnt[0][j] &lt; vcnt[1][j]) return false; &#125;&#125;bool judge3()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 3)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; maxi[0] = maxi[1] = 0; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(maxi[0])maxi[1] = j; else maxi[0] = j; &#125; &#125; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[1][j] == 1)&#123; if(maxi[0] &gt; j) return true; else if(maxi[0] &lt; j) return false; else&#123; for(--j; j &gt;= 1; --j) if(vcnt[1][j] == 1) return maxi[1] &gt; j; &#125; &#125; &#125; &#125;else return maxi[0] &gt; maxi[1];&#125;bool judge4()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 2)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; int maxii = maxi[0]; for(int i = maxii - 1; i &gt;= 1; ++i) if(vcnt[0][i] == 2)&#123; if(vcnt[1][i] == 2)&#123; for(int j = 13; j &gt;= 1; --j) if(vcnt[0][j] == 1 || vcnt[1][j] == 1) return vcnt[0][j] &gt; vcnt[1][j]; &#125;else return true; &#125;else if(vcnt[1][i] == 2) return false; &#125;else return maxi[0] &gt; maxi[1];&#125;bool judge5()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 2)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(vcnt[1][j] == 1)&#123; for(--j; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(vcnt[1][j] == 1)&#123; for(--j; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)return true; else if(vcnt[1][j] == 1)return false; &#125; &#125;else return true; &#125;else if(vcnt[1][j] == 1) return false; &#125; &#125;else return true; &#125;else if(vcnt[1][j] == 1) return false; &#125; &#125;else return maxi[0] &gt; maxi[1];&#125;void solve()&#123; int r1 = getRank(0), r2 = getRank(1); if(r1 &gt; r2)ans++; else if(r1 == r2)&#123; int flag = 0; if(r1 == 9 || r1 == 5) flag = judge1(1); if(r1 == 8) flag = judge1(4, 1); if(r1 == 7) flag = judge1(3); if(r1 == 6 || r1 == 1) flag = judge2(); if(r1 == 4) flag = judge3(); if(r1 == 3) flag = judge4(); if(r1 == 2) flag = judge5(); if(flag) ans++; &#125; printf("%d\n", ans);&#125;int main()&#123; freopen("a.in", "r", stdin); tab['C'] = 0, tab['D'] = 1, tab['H'] = 2, tab['S'] = 3; for(int i = 0; i &lt; 1000; ++i)&#123; init(); solve(); &#125; return 0;&#125; 答案：376 PE55还是用python水过1234567891011121314151617181920212223242526ans = 0def rev(x): s = str(x) return s[::-1]def judge(x): s = str(x) l = len(s) for i in range(0, l &gt;&gt; 1, 1): if s[i] != s[l - i - 1]: return 0 return 1for i in range(5, 10000, 1): x = i flag = 0 for j in range(1, 50, 1): x += string.atoi(rev(x)) if judge(x): flag = 1 break if flag == 0: ans += 1print(ans) 答案：249 PE56用python水过12345678910111213ans = 0for i in range(1, 100, 1): for j in range(1, 100, 1): x = i ** j sum = 0 while x &gt; 0: sum += x % 10 x /= 10 if sum &gt; ans: ans = sumprint(ans) 答案：972 PE57用python水过答案：153 PE58相当于PE28的加强版。数据很大！很大！不能模拟！123456789101112131415161718192021bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i)&#123; if(x % i == 0) return false; &#125; return true;&#125;void solve()&#123; int d, cnt = 0, cur = 1; for(d = 1; ; ++d)&#123; for(int i = 0; i &lt; 4; ++i)&#123; cur += d &lt;&lt; 1; if(isP(cur)) cnt++; &#125; double p = 1.0 * cnt / (4 * d + 1); if(p &lt; 0.1) break; &#125; printf("%d\n", d &lt;&lt; 1 | 1);&#125; 答案：26241 PE59用了一个剪枝就ok了。123456789101112131415161718192021222324252627282930313233int s[100005], n = 0, ss[100005];void init()&#123; while(scanf("%d,", &amp;s[n]) == 1) n++;&#125;/*void solve()&#123; int cc[4]; for(int i = 0; i &lt; 26; ++i) for(int j = 0; j &lt; 26; ++j) for(int k = 0; k &lt; 26; ++k)&#123; cc[0] = i + 'a', cc[1] = j + 'a', cc[2] = k + 'a'; int flag = 0; for(int t = 0; t &lt; n; ++t)&#123; ss[t] = (s[t] ^ cc[t % 3]); if(ss[t] == '`' || ss[t] == '|')&#123; flag = 1; break; &#125; &#125; if(!flag)&#123; for(int t = 0; t &lt; n; ++t) printf("%c", ss[t]); printf("\n%c%c%c\n", cc[0], cc[1], cc[2]); &#125; &#125;&#125;*/void solve()&#123; int cc[] = &#123;'g', 'o', 'd'&#125;, ans = 0; for(int i = 0; i &lt; n; ++i) ans += (s[i] ^ cc[i % 3]); printf("%d\n", ans);&#125; 答案：107359（密钥：god） PE60采用一定的枚举策略即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool vis[10005] = &#123;0&#125;;int prime[10005], tot = 2;int ans = INF, c[10];set&lt;int&gt; st[10005];int getL(int x)&#123; if(x &lt; 10)return 10; if(x &lt; 100)return 100; if(x &lt; 1000)return 1000; if(x &lt; 10000)return 10000;&#125;bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool judge(int x1, int x2)&#123; if(st[x1].count(x2)) return false; int l1 = getL(x1), l2 = getL(x2); if(!isP(x1 + l1 * x2) || !isP(x2 + l2 * x1))&#123; st[x1].insert(x2); return false; &#125; return true;&#125;void getP()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; &#125; prime[0] = 3, prime[1] = 7; for(int i = 11; i &lt; 10000; i += 2) if(!vis[i]) prime[tot++] = i;&#125;void getC(int index, int left, int sum)&#123; c[left] = prime[index]; for(int i = left + 1; i &lt; 5; ++i) if(!judge(c[i], prime[index])) return ; if(sum &gt;= ans)return ; if(left == 0)&#123; ans = sum; return ; &#125; for(int i = index + 1; i &lt;= tot - left; ++i) getC(i, left - 1, sum + prime[i]);&#125;void solve()&#123; getP(); for(int i = 0; i &lt;= tot - 5; ++i) getC(i, 4, prime[i]); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ProjectEuler</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契系列问题]]></title>
    <url>%2F2018%2F08%2F10%2Fproblem-fibonacci%2F</url>
    <content type="text"><![CDATA[我不会数学orz 基础斐波那契数列定义式： F(0) = 0, F(1) = 1, F(n) = F(n+1)+F(n+2) \quad (n\ge 2)通项公式是$F(n)=\frac{1}{\sqrt 5} \left[\left(\frac{1+\sqrt 5}{2} \right)^n - \left(\frac{1-\sqrt 5}{2}\right)^n\right]$。这个通项公式可以通过数列的特征方程或对矩阵求特征值得到。因为这个定义式也是一个线性齐次递推，所以也可以用矩阵来表示，写成 \begin{bmatrix} F(n) \\ F(n - 1) \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} F(n - 1) \\ F(n - 2) \end{bmatrix}意义斐波那契数列可以表示很多意义，即等价表示。 生兔子这个例子太经典了，跳过。 爬楼梯有$n-1$阶楼梯，每次可以爬1阶或者2阶，求总共上楼梯方法数。由递推易知答案为$F(n)$。而由排列组合容易知答案是\sum _{i = 0} ^{\lfloor \frac{n-1}{2} \rfloor} \tbinom{n-1-i}{n-1-2i} = \sum _{i = 0} ^{\lfloor \frac{n-1}{2} \rfloor} \tbinom{n-1-i}{i}。所以有 F(n)=\sum _{i = 0} ^{\lfloor \frac{n-1}{2} \rfloor} \tbinom{n-1-i}{i} \quad (n>0)用途分解$\phi ^n$其中$\phi = \frac{1+\sqrt 5}{2}$。因为$\phi^2 = \phi + 1$，因此可以把$\phi$的高次幂反复用这个式子，分解成$\phi$和$1$的线性组合。用归纳可以证明$\phi^n = F(n)\phi + F(n-1)$。 证明辗转相除法复杂度拉梅就是用了斐波那契数列证明了辗转相除法的时间复杂度是$O(\log n)$级别的。即Lame’s theorem。 性质判定一个数是否是斐波那契数对通项公式解方程可以得出 n=\log _{\phi} \left( \frac{\sqrt 5F(n) + \sqrt{5F^2(n) \pm 4}}{2}\right)因此$x$是斐波那契数$\iff$$5x^2+4$或者$5x^2-4$是完全平方数。 广义斐波那契数列首先看一个喜闻乐见的题目 （题目来源于中科大）答案：只要$\gcd (a, b) = 1$即可。下面对此进行证明：先证：\gcd(b, x_n) = 1 (n\ge 1) \quad (1)证明：用归纳，对于$n=1$显然成立。假设对于$n=k(k\ge 1)$成立，对于$n=k+1$：有\gcd(x_{k+1}, b)=\gcd(ax_{k}+bx_{k-1},b)=\gcd(ax_{k},b))=1。证毕。 再证：\gcd(x_n, x_{n-1})=1 (n\ge 2)\quad (2)证明：用归纳，对于$n=2$显然成立。假设对于$n=k(k\ge 2)$成立，对于$n=k+1$：有\gcd(x_{k+1}, x_k) = \gcd(ax_k+bx_{k-1}, x_k) = \gcd(bx_{k-1}, x_k) \overset{(1)}{=} \gcd(x_{k-1}, x_k)=1。证毕。 再证：x_{m+n}=x_mx_{n+1}+bx_{m-1}x_n(m, n\in \mathbb{N}) \quad (3)证明： \begin{aligned} x_{m+n} &= ax_{m+n-1}+bx_{m+n-2} \\ &= x_2x_{m+n-1}+bx_1x_{m+n-2} \\ &= (ax_2+bx_1)x_{m+n-2}+bx_2x_{m+n-3} \\ &= x_3x_{m+n-2} + bx_2x_{m+n-3} \\ &= \cdots = x_{i+1}x_{m+n-i}+bx_ix_{m+n-i-1}\end{aligned}令$i=n$有x_{m+n}=x_mx_{n+1}+bx_{m-1}x_n。证毕。 因此： \begin{aligned} \gcd(x_{m+n},x_n) &\overset{(3)}{=} \gcd(x_mx_{n+1}+bx_{m-1}x_n, x_n) \\ &= \gcd(x_mx_{n+1}, x_n) \\ &\overset{(2)}{=} \gcd(x_m, x_n) \end{aligned}相当于对$x$的下标做更相减损。所以最后的答案即为$x_{\gcd(m,n)}$。 若$\gcd(a, b)&gt; 1$，那么\gcd(x_2, x_3)\neq x_1。从而上述条件的充分性和必要性满足，证毕。 斐波那契的模问题古代人的难题要写。 参考材料： 维基百科]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEOI2014 南园满地堆轻絮]]></title>
    <url>%2F2018%2F08%2F10%2Fluogu4105%2F</url>
    <content type="text"><![CDATA[题目链接 题解容易看出$Ans$越大，数列调整的余地越大，数列就越有可能变成一个不下降序列。所以考虑二分答案，然后从头到尾遍历，尽量保持数列的不下降性。无法保持则判断为当前答案过小。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, s[5000005];ll a, b, c, d, mod;int f(ll x)&#123; ll res = (b + a * x) % mod; res = (res * x + c) % mod; res = (res * x + d) % mod; return (int)res;&#125;bool C(int g)&#123; int bef = max(1, s[1] - g); for(int i = 2; i &lt;= n; ++i)&#123; if(s[i] - g &gt;= bef) bef = s[i] - g; else if(s[i] + g &lt; bef) return false; &#125; return true;&#125;void init()&#123; n = read(); a = read(), b = read(), c = read(), d = read(); s[1] = read(), mod = read(); s[0] = 0; for(int i = 2; i &lt;= n; i++) s[i] = (f(s[i - 2]) + f(s[i - 1])) % mod;&#125;void solve()&#123; int l = 0, r = mod; while(r - l)&#123; int mid = (r + l) &gt;&gt; 1; if(C((r + l) &gt;&gt; 1)) r = mid; else l = mid + 1; &#125; printf("%d\n", r);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1382 楼房]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1382%2F</url>
    <content type="text"><![CDATA[题目链接 题解利用线段树进行区间取$max$和单点查询即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, len, x[200005], xx[200005], h[100005];int size, seg[800005] = &#123;0&#125;, tag[800005] = &#123;0&#125;, _a, _b, val;int node[400005][2], tot = 0;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) h[i] = read(), x[i &lt;&lt; 1] = read(), x[i &lt;&lt; 1 | 1] = read(); memcpy(xx, x, sizeof(xx)); sort(xx, xx + n + n); len = unique(xx, xx + n + n) - xx; for(size = 1; size &lt; len; size &lt;&lt;= 1);&#125;void pushdown(int id)&#123; if(tag[id])&#123; seg[id &lt;&lt; 1] = max(seg[id &lt;&lt; 1], tag[id]); tag[id &lt;&lt; 1] = max(tag[id &lt;&lt; 1], tag[id]); seg[id &lt;&lt; 1 | 1] = max(seg[id &lt;&lt; 1 | 1], tag[id]); tag[id &lt;&lt; 1 | 1] = max(tag[id &lt;&lt; 1 | 1], tag[id]); tag[id] = 0; &#125;&#125;void update(int id, int l, int r)&#123; if(l &gt; _b || r &lt; _a)return ; if(l &gt;= _a &amp;&amp; r &lt;= _b)&#123; seg[id] = max(seg[id], val); tag[id] = max(tag[id], val); return ; &#125; pushdown(id); update(id &lt;&lt; 1, l, (l + r) &gt;&gt; 1); update(id &lt;&lt; 1 | 1, (l + r + 1) &gt;&gt; 1, r); seg[id] = max(seg[id &lt;&lt; 1], seg[id &lt;&lt; 1 | 1]);&#125;int query(int id, int l, int r)&#123; if(l &gt; _b || r &lt; _a)return 0; if(l &gt;= _a &amp;&amp; r &lt;= _b)return seg[id]; pushdown(id); return max(query(id &lt;&lt; 1, l, (l + r) &gt;&gt; 1), query(id &lt;&lt; 1 | 1, (l + r + 1) &gt;&gt; 1, r));&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; _a = lower_bound(xx, xx + len, x[i &lt;&lt; 1]) - xx + 1; _b = lower_bound(xx, xx + len, x[i &lt;&lt; 1 | 1]) - xx; val = h[i]; update(1, 1, size); &#125; node[tot][0] = xx[0], node[tot++][1] = 0; _a = _b = 1; int h_last = query(1, 1, size); if(h_last) node[tot][0] = xx[0], node[tot++][1] = h_last; for(int i = 1; i &lt; len; ++i)&#123; _a = _b = i + 1; int h_cur = query(1, 1, size); if(h_cur != h_last) node[tot][0] = xx[i], node[tot++][1] = h_last, node[tot][0] = xx[i], node[tot++][1] = h_cur, h_last = h_cur; &#125; printf("%d\n", tot); for(int i = 0; i &lt; tot; ++i) printf("%d %d\n", node[i][0], node[i][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Balanced Lineup]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2880%2F</url>
    <content type="text"><![CDATA[题目链接 题解ST表模板题…线段树估计会挂，因为询问太多了。12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int f1[16][50005],dat[50005],f2[16][50005],N,Q; int max(int a,int b)&#123;return (a&gt;b)?a:b;&#125;int min(int a,int b)&#123;return (a&lt;b)?a:b;&#125;void sttable(int n)&#123; int i,j,p; memcpy(f1[0],dat,sizeof(dat)); memcpy(f2[0],dat,sizeof(dat)); for(i=1;(1&lt;&lt;i)&lt;=n;i++) for(j=0,p=(1&lt;&lt;(i-1));j&lt;n-p;j++) f1[i][j]=max(f1[i-1][j],f1[i-1][j+p]), f2[i][j]=min(f2[i-1][j],f2[i-1][j+p]);//同时对最大最小两个st表初始化，递推&#125;int rmq(int l,int r)&#123; int k=0;while((1&lt;&lt;(k+1))&lt;(r-l+1))k++; return max(f1[k][l],f1[k][r-(1&lt;&lt;k)+1])-min(f2[k][l],f2[k][r-(1&lt;&lt;k)+1]);//询问部分&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;Q); int i,l,r; for(i=0;i&lt;N;i++) scanf("%d",&amp;dat[i]); sttable(N); for(i=0;i&lt;Q;i++) scanf("%d%d",&amp;l,&amp;r), printf("%d\n",rmq(l-1,r-1)); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 遥远的行星]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3198%2F</url>
    <content type="text"><![CDATA[题目链接 题解看到数据规模就吓傻了这题暴力是根本过不动的。所以我们可以用一些玄学方法在这题中，有一个很关键的提示： 误差不超过$5\%$即可 可以发现在这种条件下正确答案的范围非常宽所以可以采用近似的方法，不必每一个$j-i$都计算，可以用一个值来代替某一个范围内的$j-i$。具体的程序实现是：对于一个$j$，有编号为i\in [1,a_j]的行星给他力将此区间分成$k$段，每段的分母$j-i$近似用该区间中点的分母表示$k$可以自行选一个定值，这里用的是100。可以往小里取，不TLE即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;int n;double a,m[100005],sum[100005],f[100005];void init()&#123; scanf("%d%lf",&amp;n,&amp;a); sum[0]=m[0]=0; for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;m[i]), sum[i]=sum[i-1]+m[i];&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; double s=a*i,mid; int lim=floor(s);//[1,ai] if(lim&lt;=100)&#123;//区间长不足100直接算 for(int j=1;j&lt;=lim;j++) f[i]+=m[i]*m[j]/(i-j); &#125;else&#123; int l2=lim/100; for(int j=l2;j&lt;=l2*100;j+=l2) mid=(i-j+i-j+l2-1)*0.5,//算中点的分母 f[i]+=(sum[j]-sum[j-l2])*m[i]/mid; for(int j=l2*100+1;j&lt;=lim;j++)//不足100直接算 f[i]+=m[i]*m[j]/(i-j); &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%.6lf\n",f[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>非完美算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2009 学校食堂Dining]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2157%2F</url>
    <content type="text"><![CDATA[题目链接 题解“写过小笼包你就会发现这是一道模板题”一开始我是这么想的，结果发现这样可能会出现没有头的情况。并且要找到头是一件非常困难的事。所以就用普通状压，设$f(i,j,k)$表示前$i-1$个人吃完，$i~i+7$个人吃饭的状态是$j$，上一个吃的人是$i+k$。就可以愉快的转移了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000#define offset 8using namespace std;typedef long long ll;int n,d[1005],t[1005],f[1005][257][17];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int val(int x,int y)&#123; return (x&lt;=0)?0:(t[x]^t[y]);&#125;void solve()&#123; for(int i=1;i&lt;=n+1;i++) for(int j=0;j&lt;(1&lt;&lt;8);j++) for(int k=-8;k&lt;=7;k++) f[i][j][k+offset]=INF; f[1][0][-1+offset]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;(1&lt;&lt;8);j++)&#123; for(int k=-8;k&lt;=7;k++)&#123; if(f[i][j][k+offset]&gt;=INF)continue; if(j&amp;1)//自己吃过了 f[i+1][j&gt;&gt;1][k-1+offset]=min(f[i+1][j&gt;&gt;1][k-1+offset],f[i][j][k+offset]); else&#123; int r=n+2; for(int u=1,v=0;v&lt;8;v++,u&lt;&lt;=1)&#123; if((j&amp;u)==0)&#123; if(i+v&gt;r)break; r=min(r,i+v+d[i+v]);//不能在这之后选人 f[i][j|u][v+offset]=min(f[i][j|u][v+offset],f[i][j][k+offset]+val(i+k,i+v)); &#125; &#125; &#125; &#125; &#125; &#125;&#125;void init()&#123; int T=read(); while(T--)&#123; n=read(),d[0]=n+2; for(int i=1;i&lt;=n;i++)t[i]=read(),d[i]=read(); solve(); int ans=INF; for(int i=-8;i&lt;=-1;i++) ans=min(ans,f[n+1][0][i+offset]); printf("%d\n",ans); &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1999 高维正方体]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1999%2F</url>
    <content type="text"><![CDATA[题目链接 题解给出一种这个题的思考方法吧…设$f(i,j)$表示$i$维超立方体中$j$维元素的个数。先思考：点的个数如何变化？很显然，每升一维，点的个数就多一倍，故$f(i,0)=2^i$。而根据规律可以看出，某一维在升维之后，他自己这一维复制了一份，同时原来比他小一维德元素也升为了他这一维。故得到递推关系：$f(i,j)=2f(i-1,j)+f(i-1,j-1)$。结合以上两个方程，很容易想到这是一个$O(n^2)$的dp。但显然不行。这么做复杂度大的太可怕。可以发现，这个递推模型和杨辉三角很像。所以我们写一下：观察发现，每一斜列都构成一个高阶等差数列。换言之，第$q$个斜列上的数都可以表示成一个$q-1$次多项式。计算后可以发现，对于同样的$q$，右边的第$k$个位置的数总是比左边的同样位置的数大$2^{q-1}$倍。根据这个就可以发现，下面每一个数的通项为C_i^j\times 2^{i-j}所以答案就是C_a^b\times 2^{a-b}。之后组合数取模什么的拿线性逆元做即可。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define P 1000000007llusing namespace std;typedef long long ll;ll a,b,inv[100005];ll q_pow(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%P; a=(a*a)%P,b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; scanf("%lld%lld",&amp;a,&amp;b);&#125;void solve()&#123; if(a&lt;b)&#123; printf("0\n"); return ; &#125;//特判 inv[1]=1; for(ll i=2;i&lt;=100000;i++) inv[i]=(P-(P/i))*inv[P%i]%P;//逆元 ll ans=q_pow(2,a-b); for(int i=1;i&lt;=b;i++) ans=ans*(a-i+1)%P, ans=ans*inv[i]%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI2014预选 小笼包]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2808%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题很厉害。我也是看了题解才知道怎么做的。（官网日文真心看不懂）（如果日语学的很6的话可以看这里：链接）我们看到这道题，首先想到的是什么？对！就是爆搜。…先留着这个看似不切实际的想法。我们暴力算排列，然后$O(n^2)$算结果，复杂度不用想，肯定上天。然后观察：$D$最大不过$7$，然后我们又有上面那个算法，所以现在考虑用这个条件来优化转移。设$dp(i,Perm)$，其中$Perm$表示从$i-maxd+1$吃到第$i$个小笼包的顺序，$i$表示当前正在处理第$i$个。则这样就可以状态转移了，每一次向前推进一位，然后对于前面的排列，我们试图插入新的小笼包，并且计算新的小笼包在其中造成的贡献。（被泼到，泼别的）时间复杂度O(D_{max}!P)（官方说是$P$一个多项式，算了也别管了）这种新的状压方式学到了。不过可能看的时候会有疑问：$k$为什么会到$7$呢？还是要考虑到原来整个排列全被枚举的情况。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int f[2][7000000]=&#123;0&#125;,permu[10],permu2[10];//在第i次吃第j个小笼包int n,d[105],a[105]; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init_permu()&#123; for(int j=0;j&lt;7;j++) permu[j]=j;&#125; int ptoi(int *L)&#123; int res=0; for(int i=0;i&lt;7;i++) res=res*10+L[i]; return res;&#125;void init()&#123; n=read(); for(int i=0;i&lt;n;i++)d[i]=read(); for(int i=0;i&lt;n;i++)a[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;n;i++)&#123; init_permu(); int B=(i&amp;1),B_=(B^1),cnt,code1,code2; do&#123; code1=ptoi(permu); for(int k=0;k&lt;=7;k++)&#123; //枚举新加入的位置 cnt=0; int contribution=0; //在第i个被吃掉之前他被泼到的 for(int kk=0;kk&lt;k;kk++)&#123; int loc=i-1-permu[kk]; if(loc&gt;=0&amp;&amp;permu[kk]+1&lt;=d[loc]) contribution+=a[loc]; if(permu[kk]&lt;6) permu2[cnt++]=permu[kk]+1; &#125; permu2[cnt++]=0; //在第i个被吃掉之后他被泼到的 for(int kk=k;kk&lt;7;kk++)&#123; int loc=i-1-permu[kk]; if(loc&gt;=0&amp;&amp;permu[kk]+1&lt;=d[i]) contribution+=a[i]; if(permu[kk]&lt;6) permu2[cnt++]=permu[kk]+1; &#125; code2=ptoi(permu2); f[B_][code2]=max(f[B_][code2],f[B][code1]+contribution); &#125; f[B][code1]=0; &#125;while(next_permutation(permu,permu+7)); &#125; int ans=0; init_permu(); do&#123; ans=max(ans,f[n&amp;1][ptoi(permu)]); &#125;while(next_permutation(permu,permu+7)); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>JOI</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2013 数列]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3228%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题我用了一种不够数学的方法来解。30分做法：DP，设$f(i,j)$表示第$i$天以$j$为当天股价的方案数，则 f(i,j)=\begin{cases} 1\quad (i=1)\\ \sum_{k=1}^M f(i-1,j-k) \quad(i>1)\end{cases}答案为$\sum_{j=1}^N f(K,j)$数据太大，只能拿30分。100分做法：在30分做法上做文章。可以发现，对于所有$i\le N-(K-1)M$的$f(0,i)$而言，他们对最终答案的贡献是一样的。（因为他们可以给出的贡献的上界都是$i+(K-1)M$，下界都是$i+K-1$）但对于更大的$i$，由于要求的答案范围的上界为$N$，所以他们对更高股价的贡献是要去掉的。问题转化为求$N-(K-1)M$个相同的贡献值的和以及$(K-1)M$个不同贡献值的和。对于前一个子问题，我们考虑一个等价的问题：从第一个格子出发，每一个格子有$M$条路通向下一个格子，问走$K-1$步的走法数，一种走法和另外一种走法相同当且仅当两条路径完全相同。由乘法原理知答案为$M^{K-1}$。所以前一个子问题的答案为$[N-(K-1)M]M^{K-1}$。后一个子问题不好办。怎么弄？假设，画图，观察。（这是我的方法，当然有其他方法发现这个规律。）设$M=3,K=4$，则作图：（$i$表示天数，这张表表示开始的某个$f(1,j)$对后面第$i$天答案的贡献）然后依次写出$j=N-(K-1)M+1,N-(K-1)M+2,…,N-(K-1)$时对答案的贡献。（$j&gt;N-(K-1)$时，$j$对答案贡献为$0$。）这是个很对称的图形，沿对角线翻折后发现每一列都变为了完整的一列。一列的和我们之前已经求了出来，就是$M^{K-1}$。设其内部所有数的和为$sum$，则 sum= \frac{(K-1)(M-1)}{2} M^{K-1}总答案即为 \left( N-\frac{(K-1)(M+1)}{2}\right)M^{K-1}使用快速幂和逆元计算即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;ll N,M,K,P;ll Pow(ll a,ll b,ll c)&#123; ll res=1; a%=c; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%lld%lld%lld%lld",&amp;N,&amp;K,&amp;M,&amp;P);&#125;void solve()&#123; ll ans1=Pow(M,K-1,P); ll inv2,ans; N%=P,ans=(N*ans1)%P; if(M&amp;1)inv2=(M+1)/2,inv2=inv2*M%P; else inv2=M/2,inv2=inv2*(M+1)%P; inv2=inv2*(K-1)%P; inv2=inv2*Pow(M,K-2,P)%P; ans+=P,ans=(ans-inv2)%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 彩票]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2236%2F</url>
    <content type="text"><![CDATA[题目链接 题解暴搜加个上下界的判断就A了顺带一题，这题卡精度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,x,y,ans=0;double sum[55]=&#123;0&#125;,lim,EPS=1e-11;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void dfs(int at,int lst,double t)&#123; //再取n-at个数 if(at==n)&#123; if(t-lim&lt;EPS&amp;&amp;t-lim&gt;-EPS)ans++; return ; &#125; if(t+sum[m]-sum[m-n+at]-EPS&gt;lim)return ; //加了最小的还是超过了 for(int i=lst+1;i&lt;=m-n+at+1;i++)&#123; if(t+sum[i+n-at-1]-sum[i-1]+EPS&lt;lim)return ; //加了最大的还是达不到 dfs(at+1,i,t+1.0/(double)i); &#125; &#125;void init()&#123; n=read(),m=read(),x=read(),y=read(); for(int i=1;i&lt;=m;i++) sum[i]=sum[i-1]+1.0/(double)i; lim=x,lim/=(double)y;&#125;void solve()&#123; for(int i=1;i&lt;=m-n+1;i++) dfs(1,i,1.0/(double)i); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2001 求正整数]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1128%2F</url>
    <content type="text"><![CDATA[题目链接 题解一看就是DP按质因数DP，转移的时候保存一下指数即可。对了，还要加上对数的优化。直接保存一个巨大的整数不是什么容易的事。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;double f[20][50005],P_[20];int F[20][50005]=&#123;0&#125;,n,P[17]=&#123;1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;int real_ans[50005]=&#123;0&#125;;int multiply_to_int(int s1[],int s2)&#123; int i,j,x=0; for(i=1;i&lt;=s1[0];i++) x+=s1[i]*s2, s1[i]=x%10000,x/=10000; while(x) s1[++s1[0]]=x%10000,x/=10000;&#125;int main()&#123; scanf("%d",&amp;n); int i,j,k,mini,cnt; double m,ans; for(i=0;i&lt;20;i++) for(j=0;j&lt;=n;j++) f[i][j]=1e9; for(i=0;i&lt;=16;i++) P_[i]=log(P[i]); for(i=1;i&lt;=n;i++) f[1][i]=(i-1)*P_[1],F[1][i]=1; for(i=1;i&lt;=15;i++) for(j=1;j&lt;=n;j++) for(k=1;j*k&lt;=n;k++)&#123; m=f[i][j]+(k-1)*P_[i+1]; if(m&lt;f[i+1][j*k]) f[i+1][j*k]=m,F[i+1][j*k]=j; &#125; for(ans=1e9,i=1;i&lt;=16;i++) if(ans&gt;f[i][n]) ans=f[i][n],mini=i; real_ans[0]=real_ans[1]=1; for(j=mini,k=n;j&gt;0;j--)&#123; cnt=k/F[j][k]; for(i=1;i&lt;cnt;i++) multiply_to_int(real_ans,P[j]); k=F[j][k]; &#125; printf("%d",real_ans[real_ans[0]]); for(i=real_ans[0]-1;i&gt;=1;i--) printf("%04d",real_ans[i]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2004 宠物收养场]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2286%2F</url>
    <content type="text"><![CDATA[题目链接 题解直接用平衡树模拟即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,cnt; int cmp(int x) const &#123; if(x==v)return -1; return x&gt;v; &#125; void maintain()&#123; siz=cnt; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[400005];int n,S=0,ans,ANS=0;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;cnt=1,tr-&gt;v=x; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); return ; &#125; tr-&gt;siz++; if(tr-&gt;v==x)&#123; tr-&gt;cnt++; &#125;else&#123; int d=tr-&gt;cmp(x); insert_tr(tr-&gt;ch[d],x); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1); &#125;&#125;void del(Tr* &amp;tr,int x)&#123; int d=tr-&gt;cmp(x); if(d==-1)&#123; if(tr-&gt;cnt&gt;1)tr-&gt;siz--,tr-&gt;cnt--; else&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),tr-&gt;siz--,del(tr-&gt;ch[d_],x); &#125; &#125; &#125;else tr-&gt;siz--,del(tr-&gt;ch[d],x);&#125; void previous(Tr *tr,int x)&#123; if(tr==NULL)return ; if(x&gt;tr-&gt;v) ans=tr-&gt;v,previous(tr-&gt;ch[1],x); else previous(tr-&gt;ch[0],x);&#125;void success(Tr *tr,int x)&#123; if(tr==NULL)return ; if(x&lt;tr-&gt;v) ans=tr-&gt;v,success(tr-&gt;ch[0],x); else success(tr-&gt;ch[1],x);&#125;void solve()&#123; n=read(); Tr *root=NULL; int cnt1=0,cnt2=0,a,b; for(int i=1;i&lt;=n;i++)&#123; a=read(),b=read(); if(!a)&#123; if(!cnt2)insert_tr(root,b),cnt1++; else&#123; int ans1,ans2,res; ans=-1,previous(root,b),ans1=ans; ans=-1,success(root,b),ans2=ans; if(ans1==-1)res=ans2; else if(ans2==-1)res=ans1; else if(ans2-b&lt;b-ans1)res=ans2; else res=ans1; del(root,res),ANS+=abs(res-b),ANS%=1000000; cnt2--; &#125; &#125;else&#123; if(!cnt1)insert_tr(root,b),cnt2++; else&#123;//有宠物 int ans1,ans2,res; ans=-1,previous(root,b),ans1=ans; ans=-1,success(root,b),ans2=ans; if(ans1==-1)res=ans2; else if(ans2==-1)res=ans1; else if(ans2-b&lt;b-ans1)res=ans2; else res=ans1; del(root,res),ANS+=abs(res-b),ANS%=1000000; cnt1--; &#125; &#125; &#125; printf("%d\n",ANS);&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2009 梦幻布丁]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3201%2F</url>
    <content type="text"><![CDATA[题目链接 题解膜一发启发式合并启发式合并从前我都只在并查集上用到过，但今天是在这种上面…这道题的做法非常暴力：直接对每一个颜色节点构建链式前向星，然后合并的时候短链合并到长链上。为什么这么做是对的呢？因为短链合并之后最少比原来要长一倍，所以合并起来最多合并$logn$次，这样均摊总时间复杂度就是$O(nlogn)$。感觉这种思想跟线段数的区间开方的分析有着异曲同工之妙…有一个细节：要记录合并时操作的真正颜色，因为短合长或者长合短在程序操作上是等价的，但颜色是不等价的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,id[1000005],ans,a[100005]=&#123;0&#125;;int cnt[1000005]=&#123;0&#125;,at[1000005]=&#123;0&#125;,_nex[100005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void _merge(int x,int y)&#123; if(x==y)return ; if(cnt[id[x]]&gt;cnt[id[y]])swap(id[x],id[y]); x=id[x],y=id[y]; if(!cnt[x])return ; //x,y号元素代表的真正颜色（程序操作上） cnt[y]+=cnt[x],cnt[x]=0; //x合并到y上 for(int i=at[x];i;i=_nex[i])&#123; if(a[i-1]==y)ans--; if(a[i+1]==y)ans--; &#125; for(int i=at[x];i;i=_nex[i])&#123; a[i]=y; if(!_nex[i])&#123; _nex[i]=at[y]; break; &#125; &#125; at[y]=at[x],at[x]=0;&#125; void init()&#123; n=read(),m=read(); int col; for(int i=1;i&lt;=n;i++)&#123; a[i]=read(),col=a[i]; if(a[i]!=a[i-1])ans++; cnt[col]++,_nex[i]=at[col],at[col]=i; &#125; for(int i=1;i&lt;=1000000;i++)id[i]=i;&#125;void solve()&#123; int opr,x,y; for(int i=1;i&lt;=m;i++)&#123; opr=read(); if(opr==2)printf("%d\n",ans); else x=read(),y=read(),_merge(x,y); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 营业额统计]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2234%2F</url>
    <content type="text"><![CDATA[题目链接 题解双向链表裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;pair&lt;ll,int&gt; P[100005];int n,nex[100005],pre[100005],id[100005];ll a[100005],ans=0;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); int i=1; while(~scanf("%lld",&amp;a[i]))P[i].first=a[i],P[i].second=i,i++; while(i&lt;=n)P[i].first=0,P[i].second=i,a[i++]=0; sort(P+1,P+n+1); //for(i=1;i&lt;=n;i++)printf("%lld %d\n",P[i].first,P[i].second); for(i=1;i&lt;=n;i++)id[i]=P[i].second; pre[id[1]]=nex[id[n]]=0; for(i=1;i&lt;n;i++) nex[id[i]]=id[i+1],pre[id[i+1]]=id[i];&#125;void solve()&#123; for(int i=n;i&gt;=2;i--)&#123; int tp=pre[i],tn=nex[i]; ll res=INF; if(tp)res=min(res,a[i]-a[tp]); if(tn)res=min(res,a[tn]-a[i]); ans+=res; if(tn)pre[tn]=tp; if(tp)nex[tp]=tn; &#125; printf("%lld\n",ans+a[1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 玩具装箱TOY]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3195%2F</url>
    <content type="text"><![CDATA[题目链接 题解一道很简单的斜率优化DP。设$f(i)$表示装到第$i$个玩具为止的时候，最小的花费。那么 f(i)=\min \limits_{1 \le j]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 越狱]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3197%2F</url>
    <content type="text"><![CDATA[题目链接 题解总共情况有$M^N$种不会越狱的情况有$M\times (M-1)^{N-1}$种。前者减去后者即为答案。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll n,m,P=100003;ll qpow(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%P; a=(a*a)%P,b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; scanf("%lld%lld",&amp;m,&amp;n); m%=P;&#125;void solve()&#123; ll ans=qpow(m,n),ans2=qpow(m-1,n-1); ans2=(ans2*m)%P; ans=(ans+P-ans2)%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2006 公路修建问题]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2323%2F</url>
    <content type="text"><![CDATA[题目链接 题解二分最大限制，kruskal判断。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int u,v,c1,c2;&#125;;Edge edge[20005];int n,k,m,par[10005],q1[20005],q2[20005],vis[20005];bool cmp1(int a,int b)&#123; return edge[a].c1&lt;edge[b].c1;&#125;bool cmp2(int a,int b)&#123; return edge[a].c2&lt;edge[b].c2;&#125;int Find(int t)&#123; if(par[t]==t)return t; return (par[t]=Find(par[t]));&#125;void unite(int a,int b)&#123; if(Find(a)==Find(b))return ; par[Find(a)]=Find(b);&#125;int judge(int M)&#123; int cnt=0,tot=n,at,ans=0,u,v,c; for(int i=1;i&lt;=n;i++)par[i]=i; memset(vis,0,sizeof(vis)); for(at=0;tot&gt;n-k&amp;&amp;at&lt;m;at++)&#123; if(edge[q1[at]].c1&gt;M)continue; u=edge[q1[at]].u,v=edge[q1[at]].v, c=edge[q1[at]].c1; if(Find(u)!=Find(v)) unite(u,v),ans+=c,vis[q1[at]]=1,tot--; &#125; if(at==m&amp;&amp;tot!=n-k)return -1; for(at=0;tot&gt;1&amp;&amp;at&lt;m;at++)&#123; if(edge[q2[at]].c2&gt;M||vis[q2[at]])continue; u=edge[q2[at]].u,v=edge[q2[at]].v, c=edge[q2[at]].c2; if(Find(u)!=Find(v)) unite(u,v),ans+=c,vis[q2[at]]=2,tot--; &#125; if(at==m&amp;&amp;tot!=1)return -1; return ans;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].c1,&amp;edge[i].c2); for(int i=0;i&lt;m;i++) q1[i]=q2[i]=i; sort(q1,q1+m,cmp1); sort(q2,q2+m,cmp2);&#125;void solve()&#123; int L=0,R=INF,M,ans; while(R-L)&#123; M=(L+R)/2; ans=judge(M); if(ans&gt;=0) R=M; else L=M+1; &#125; printf("%d\n",L); judge(L); for(int i=0;i&lt;m;i++) if(vis[i])printf("%d %d\n",i+1,vis[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 GT考试]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3193%2F</url>
    <content type="text"><![CDATA[题目链接 题解构造状态转移图，用矩阵优化DP。状态转移图是现成的，就是KMP的匹配图。按照这个对每一个点处理：把模式串每一位看作一个点，最开始也加一个点（0号点，表示匹配不到模式串的任何一个点）每一个点都有0-9共9条边，每个点（除了最后一个点）都向下一个点连一条相应数字边，然后最初的0号点就只有9个自环边。之后每一个点（除了最后一个）能往前转移就往前转，转不了就转到0号点上去。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,Mod,fail[55],ans=0;char danger[55];struct Mat&#123; int dat[22][22]; int r,c; Mat()&#123; memset(dat,0,sizeof(dat)); &#125;&#125;;Mat mul(Mat &amp;a,Mat &amp;b)&#123; Mat newed; newed.r=a.r,newed.c=b.c; int i,j,k,t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p)&#123; Mat E;E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)E=mul(E,a); a=mul(a,a),p&gt;&gt;=1; &#125; return E;&#125;int mat[21][21];void build_fail(char *pat,int l,int *fail)&#123; fail[0]=-1; for(int i=1,j=-1;i&lt;l;i++)&#123; for(;j&gt;-1&amp;&amp;pat[i]!=pat[j+1];j=fail[j]); if(pat[i]==pat[j+1]&amp;&amp;i&gt;j+1) fail[i]=++j; else fail[i]=-1; &#125;&#125;void init()&#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;Mod,danger); build_fail(danger,m,fail);&#125;void solve()&#123; Mat Ori,Plu,res; Ori.r=Plu.r=Plu.c=m+1; Ori.c=1; Plu.dat[0][0]=9,Plu.dat[1][0]=1; bool used[10]; int CNT=10; for(int i=1;i&lt;m;i++)&#123; int f=i-1,flag=0; memset(used,0,sizeof(used)); CNT=10; do&#123; f=fail[f]; if(danger[f+1]!=danger[i])&#123; if(!used[danger[f+1]-'0']) used[danger[f+1]-'0']=1, Plu.dat[f+2][i]=1, CNT--; &#125; &#125;while(f!=-1); Plu.dat[i+1][i]=1; CNT--; Plu.dat[0][i]=CNT; &#125; for(int i=0;i&lt;=m;i++) Plu.dat[m][i]=0; Ori.dat[0][0]=1; Plu=Pow(Plu,n); res=mul(Plu,Ori); for(int i=0;i&lt;m;i++) ans=(ans+res.dat[i][0])%Mod; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 公交车路线]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2233%2F</url>
    <content type="text"><![CDATA[题目链接 题解构造递推关系，设$f(p,n)$表示换了$n$次车到了$p$点的方案数，发现F点与D点均只能由上一个点转移而来，E点由F与D点转移而来，其余点由两侧的点转移而来。由此得到递推方程，但是$n$太大，故使用矩阵乘法加速。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Mat&#123; int dat[10][10],r,c; Mat(int a,int b)&#123; this-&gt;r=a,this-&gt;c=b, memset(this-&gt;dat,0,sizeof(this-&gt;dat)); &#125;&#125;;int Mod=1000,n,dx[]=&#123;0,0,1,1,2,2,3,3,4,4,5,6,7,7&#125;,dy[]=&#123;1,2,0,3,0,4,1,5,2,6,3,4,5,6&#125;;void mul(Mat &amp;a,Mat &amp;b,Mat &amp;newed)&#123; newed.r=a.r,newed.c=b.c; int i,j,k,t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125;&#125;Mat pow(Mat a,int p)&#123; Mat E(a.c,a.c),F(a.c,a.c); int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)mul(E,a,F),E=F; mul(a,a,F),a=F,p&gt;&gt;=1; &#125; return E;&#125;int main()&#123; n=read(); Mat q(8,8),s(8,1),e(8,1); for(int i=0;i&lt;14;i++) q.dat[dx[i]][dy[i]]=1; s.dat[0][0]=1; q=pow(q,n),mul(q,s,e); printf("%d\n",e.dat[7][0]); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 操作系统]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2278%2F</url>
    <content type="text"><![CDATA[题目链接 题解中心思想就是模拟，堆按优先级大小排序，每次看堆顶元素是否完成，如果完成则就退出，否则等待下一个任务并减去这段等待时间，最后插入下一个任务，循环往复。本题具有一定的实际意义。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef struct&#123; int id,st,ls,pr;&#125;Pro;Pro q[400005];bool operator &lt;(Pro a,Pro b)&#123; if(a.pr==b.pr)return a.st&gt;b.st; else return a.pr&lt;b.pr;&#125;priority_queue&lt;Pro&gt; pq;int at=0,r=0;int s(Pro &amp;x)&#123; if(scanf("%d",&amp;x.id)==1) scanf("%d%d%d",&amp;x.st,&amp;x.ls,&amp;x.pr); else return 0; return 1;&#125;int main()&#123; Pro pre,n,a; while(s(q[r]))r++; pq.push(q[0]); at=q[0].st; for(int i=1;i&lt;r;i++)&#123; while(!pq.empty()&amp;&amp;at+pq.top().ls&lt;=q[i].st) a=pq.top(), printf("%d %d\n",a.id,at+a.ls), at+=a.ls, pq.pop();//若此项目已经完成，则退出 if(!pq.empty()) a=pq.top(), pq.pop(), a.ls-=q[i].st-at, pq.push(a);//结束部分等待时间 at=q[i].st, pq.push(q[i]);//放入优先队列 &#125; while(!pq.empty()) a=pq.top(), printf("%d %d\n",a.id,at+a.ls), at+=a.ls, pq.pop(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2011 数学作业]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3216%2F</url>
    <content type="text"><![CDATA[题目链接 题解\begin{bmatrix} n&ans&1 \end{bmatrix} \begin{bmatrix} 1 & 1 & 0 \\0 & 10^q & 0 \\ 1 & 0 & 1 \end{bmatrix} = \begin{bmatrix} n+1 & ans\times10^q+n &1\end{bmatrix}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef unsigned long long ll;ll n,Mod;struct Mat&#123; ll dat[3][3]; int r,c; Mat(int _r,int _c)&#123; r=_r,c=_c; memset(this-&gt;dat,0,sizeof(this-&gt;dat)); &#125;&#125;;Mat mul(Mat &amp;a,Mat &amp;b)&#123; Mat newed(a.r,b.c); int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p)&#123; Mat E(a.c,a.c); int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)E=mul(E,a); a=mul(a,a),p&gt;&gt;=1; &#125; return E;&#125;void print(Mat q)&#123; for(int i=0;i&lt;q.r;i++)&#123; for(int j=0;j&lt;q.c;j++) printf("%llu ",q.dat[i][j]); printf("\n"); &#125;&#125;void init()&#123; scanf("%llu%llu",&amp;n,&amp;Mod); n++;&#125;void solve()&#123; ll cur=1,nex=10; Mat Ori(1,3),Plu(3,3),Copy(3,3),res(3,3); Ori.dat[0][0]=Ori.dat[0][2]=1; Plu.dat[0][0]=Plu.dat[0][1]= Plu.dat[2][0]=Plu.dat[2][2]=1; Plu.dat[1][1]=10; for(;;)&#123; Copy=Pow(Plu,min(nex,n)-cur); res=mul(Ori,Copy); if(nex&gt;=n)break; Plu.dat[1][1]*=10,Plu.dat[1][1]%=Mod; cur*=10,nex*=10; Ori=res; &#125; printf("%llu\n",res.dat[0][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2006 超级英雄]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2319%2F</url>
    <content type="text"><![CDATA[题目链接 题解裸的二分图匹配洛谷上是强化的版本左边的点代表题目，右边的点代表锦囊用匈牙利算法从上至下匹配即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;bool mat[1005][1005]=&#123;0&#125;;int n,m,op[1005]=&#123;0&#125;,vis[1005];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); mat[i][u]=mat[i][v]=1; &#125;&#125;int dfs(int cur)&#123; for(int j=0;j&lt;n;j++)&#123; if(mat[cur][j]&amp;&amp;!vis[j])&#123; vis[j]=1; if(!op[j]||dfs(op[j]))&#123; op[j]=cur; return 1; &#125; &#125; &#125; return 0;&#125;int Edmonds()&#123; int ret=0; for(int i=1;i&lt;=m;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))ret++; else break; &#125; return ret;&#125;void solve()&#123; int ans=Edmonds(); printf("%d\n",ans); for(int i=1;i&lt;=ans;i++)&#123; int j; for(j=0;j&lt;n;j++) if(op[j]==i)&#123; printf("%d\n",j); break; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最大匹配</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2012 永无乡]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3224%2F</url>
    <content type="text"><![CDATA[题目链接 题解并查集，然后利用启发式合并最多带来一个$log$的代价，暴力拆treap，然后合并。时间复杂度$O(nlog^2 n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,cnt,id; int cmp(int x) const &#123; if(x==v)return -1; return x&gt;v; &#125; void maintain()&#123; siz=cnt; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[1700005],*pos[400005],*root;int S=0,n,m;int par[100005],rk[100005]; void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x,int i_)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;cnt=1,tr-&gt;v=x; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); tr-&gt;id=i_; return ; &#125; tr-&gt;siz++; if(tr-&gt;v==x)&#123; tr-&gt;cnt++; &#125;else&#123; int d=tr-&gt;cmp(x); insert_tr(tr-&gt;ch[d],x,i_); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1); &#125;&#125;int Kth(Tr *tr,int x)&#123; if(tr==NULL||x&lt;=0||x&gt;tr-&gt;siz)return -1; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(x&lt;=evid)return Kth(tr-&gt;ch[0],x); else if(x&gt;evid+tr-&gt;cnt)return Kth(tr-&gt;ch[1],x-evid-tr-&gt;cnt); else return tr-&gt;id;&#125;int Find(int t)&#123; if(par[t]==t)return t; else return (par[t]=Find(par[t]));&#125;int unite(int a,int b)&#123; int x=Find(a),y=Find(b); if(x==y)return -1; if(rk[x]&gt;rk[y])&#123; par[y]=x; return x; &#125;else &#123; par[x]=y; if(rk[x]==rk[y])rk[y]++; return y; &#125;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void dfs(Tr *t)&#123; if(t==NULL)return ; insert_tr(root,t-&gt;v,t-&gt;id); dfs(t-&gt;ch[0]),dfs(t-&gt;ch[1]);&#125;void MMerge(int x,int y)&#123; if(Find(x)==Find(y))return ; int ss=Find(x),tt=Find(y); int res=unite(x,y);//大的 if(res==tt)root=pos[tt],dfs(pos[ss]),pos[tt]=root; else root=pos[ss],dfs(pos[tt]),pos[ss]=root;&#125; void init()&#123; n=read(),m=read(); int pri,u,v; for(int i=1;i&lt;=n;i++) par[i]=i,rk[i]=0,pri=read(), insert_tr(pos[i],pri,i); for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(); MMerge(u,v); &#125;&#125;void solve()&#123; int q=read(),x,y; char ord[3]; while(q--)&#123; scanf("%s%d%d",ord,&amp;x,&amp;y); if(ord[0]=='B')MMerge(x,y); else printf("%d\n",Kth(pos[Find(x)],y)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>BST</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 消防局的设立]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2279%2F</url>
    <content type="text"><![CDATA[题目链接 题解这道题是一个贪心，蓝书上面讲过。就是每次从最大深度的开始向上面走，走2步，然后如果上面的点还没有被覆盖就覆盖上面的点。这么做可以被证明是正确的。实际上从直觉上来看也是正确的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;vector&lt;int&gt; depth[1005];int n,par[1005]=&#123;0&#125;,bro[1005],son[1005],dep[1005]=&#123;0&#125;,maxd=0;bool vis[1005]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); dep[1]=0,depth[0].push_back(1); for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;par[i]); bro[i]=son[par[i]],son[par[i]]=i; dep[i]=dep[par[i]]+1; depth[dep[i]].push_back(i); maxd=max(maxd,dep[i]); &#125;&#125;void dfs(int cur,int k)&#123; if(k==2)return; if(par[cur]&amp;&amp;k&lt;2) vis[par[cur]]=1,dfs(par[cur],k+1); for(int i=son[cur];i;i=bro[i]) if(k&lt;2) vis[i]=1,dfs(i,k+1);&#125; void solve()&#123; int ans=0; for(int i=maxd;i&gt;=0;i--)&#123; int S=depth[i].size(); for(int j=0;j&lt;S;j++)&#123; int u=depth[i][j]; if(vis[u])continue; if(par[par[u]])u=par[par[u]]; else if(par[u])u=par[u]; vis[u]=1,dfs(u,0),ans++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2001 矩阵乘积]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2222%2F</url>
    <content type="text"><![CDATA[题目链接 题解三元组矩阵乘法…数据结构书上一般都会讲到。因为指定了要求的值的位置，所以可以在矩阵$A\times B$的过程中，只保留$A$的$x$一行上的值，然后用$B$中的值去乘。对$B\times C$也如此。这样矩阵乘法的复杂度就会远低于$O(n^3)$，就做完了。复杂度大概是$O(n^2)$?实际上这题更麻烦的是读入…123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int x,y,m,n,o,p;int Am[6005]=&#123;0&#125;,Bm[6005]=&#123;0&#125;;char input[10005];int main()&#123; int i,j,u,v,val; scanf("%d%d%d%d%d%d",&amp;x,&amp;y,&amp;m,&amp;n,&amp;o,&amp;p); fgets(input,10000,stdin); for(;;)&#123; fgets(input,10000,stdin); if(!isdigit(input[0]))break; sscanf(input,"%d%d%d",&amp;u,&amp;v,&amp;val); if(u==x)Am[v]=val; &#125; for(;;)&#123; fgets(input,10000,stdin); if(!isdigit(input[0]))break; sscanf(input,"%d%d%d",&amp;u,&amp;v,&amp;val); Bm[v]+=Am[u]*val; &#125; memcpy(Am,Bm,sizeof(Bm)); memset(Bm,0,sizeof(Bm)); while(~scanf("%d%d%d",&amp;u,&amp;v,&amp;val)) Bm[v]+=Am[u]*val; printf("%d\n",Bm[y]); return 0;&#125; ​]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 激光炸弹]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2280%2F</url>
    <content type="text"><![CDATA[题目链接 题解一开始看错题目，以为有很多个炸弹…暴力即可123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,r,mat[5005][5005]=&#123;0&#125;,x=0,y=0;void init()&#123; n=read(),r=read(); int dx,dy,c; for(int i=1;i&lt;=n;i++) dx=read(),dy=read(),c=read(), dx++,dy++,mat[dx][dy]+=c, x=max(x,dx),y=max(y,dy); x=max(x,r),y=max(y,r); for(int i=1;i&lt;=x;i++) for(int j=1;j&lt;=y;j++) mat[i][j]+=mat[i][j-1]; for(int j=1;j&lt;=y;j++) for(int i=1;i&lt;=x;i++) mat[i][j]+=mat[i-1][j];&#125;void solve()&#123; int ans=0; for(int i=r;i&lt;=x;i++) for(int j=r;j&lt;=y;j++) ans=max(ans,mat[i][j]-mat[i-r][j]-mat[i][j-r]+mat[i-r][j-r]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2004 L语言]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2292%2F</url>
    <content type="text"><![CDATA[题目链接 题解Hash和DP。实际上也可以拿trie做。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef unsigned int ui;char t[1000005];bool able[1000005]=&#123;0&#125;; int n,m,lth[25];ui hsh[25],h[1000005],P=1005257,Pow[1000005];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%s",t); hsh[i]=0,lth[i]=strlen(t); for(int j=0;j&lt;lth[i];j++) hsh[i]=P*hsh[i]+t[j]; &#125; Pow[0]=1; for(int i=1;i&lt;=1000000;i++) Pow[i]=Pow[i-1]*P; for(int i=0;i&lt;m;i++)&#123; scanf("%s",t); int len=strlen(t),ans=0,j,k; h[0]=0,able[0]=1; for(j=1;j&lt;=len;j++)&#123; h[j]=h[j-1]*P+t[j-1]; for(k=0;k&lt;n;k++)&#123; if(lth[k]&lt;=j&amp;&amp;h[j]-Pow[lth[k]]*h[j-lth[k]]==hsh[k]) able[j]|=able[j-lth[k]]; if(able[j])break; &#125; if(able[j])ans=j; &#125; printf("%d\n",ans); memset(able,0,sizeof(able)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>字符串DP</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2010 弹飞绵羊]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3203%2F</url>
    <content type="text"><![CDATA[题目链接 题解LCT模板题。把跳到的点当作是父亲，支持删边和连边即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,fa[200005]=&#123;0&#125;,ch[200005][2],siz[200005]=&#123;0&#125;,rev[200005]=&#123;0&#125;;int val[200005],to[200005];int cmp(int k)&#123; return ch[fa[k]][1]==k;&#125;int isroot(int k)&#123; return ch[fa[k]][0]!=k&amp;&amp;ch[fa[k]][1]!=k;&#125;void Rev(int k)&#123; swap(ch[k][0],ch[k][1]); rev[k]^=1;&#125;void maintain(int k)&#123; siz[k]=siz[ch[k][0]]+siz[ch[k][1]]+1;&#125;void pushdown(int k)&#123; if(k&amp;&amp;rev[k])&#123; rev[k]=0; if(ch[k][0])Rev(ch[k][0]); if(ch[k][1])Rev(ch[k][1]); &#125;&#125;void pushup(int k)&#123; if(!k)return ; if(!isroot(k))pushup(fa[k]); pushdown(k);&#125; void Rotate(int k)&#123; int Fa=fa[k],Gfa=fa[Fa],d=cmp(k); ch[Fa][d]=ch[k][d^1],fa[ch[k][d^1]]=Fa; ch[k][d^1]=Fa,fa[Fa]=k; fa[k]=Gfa; if(!isroot(Fa))&#123; if(Fa==ch[Gfa][0])ch[Gfa][0]=k; else if(Fa==ch[Gfa][1])ch[Gfa][1]=k; &#125; maintain(Fa); &#125;void splay(int k)&#123; pushup(k); for(int Fa=fa[k];!isroot(k);Rotate(k),Fa=fa[k]) if(fa[Fa]&amp;&amp;!isroot(Fa))Rotate(cmp(k)==cmp(Fa)?Fa:k); maintain(k);&#125; void access(int k)&#123; for(int t=0;k;t=k,k=fa[k])splay(k),ch[k][1]=t,maintain(k);&#125; void makeroot(int k)&#123; access(k),splay(k),Rev(k);&#125;int findroot(int k)&#123; while(fa[k])k=fa[k];return k;&#125;void Split(int u,int v)&#123; makeroot(u),access(v),splay(v);&#125;void cut(int u,int v)&#123; Split(u,v); ch[v][0]=fa[u]=0; maintain(v);&#125;void link(int u,int v)&#123; makeroot(u),fa[u]=v;&#125;void init()&#123; n=read(),siz[n+1]=1; for(int i=1;i&lt;=n;i++)val[i]=read(),to[i]=min(n+1,i+val[i]),siz[i]=1; for(int i=1;i&lt;=n;i++)link(i,to[i]); &#125;void solve()&#123; m=read(); int opr,x,y; while(m--)&#123; opr=read(),x=read()+1; if(opr==1) Split(x,n+1),printf("%d\n",siz[n+1]-1); if(opr==2)&#123; y=read(); if(to[x]==n+1&amp;&amp;x+y&gt;n)continue; cut(x,to[x]),val[x]=y,to[x]=min(x+y,n+1),link(x,to[x]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 GameZ游戏排名系统]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2584%2F</url>
    <content type="text"><![CDATA[题目链接 题解双关键字平衡树。其实也没什么，跟排序的时候写两个关键字一样操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt; #define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,tim; char name[12]; int cmp(int x,int tt) const &#123; if(x==v&amp;&amp;tt==tim)return -1; return x==v?tt&gt;tim:x&gt;v; &#125; void maintain()&#123; siz=1; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[400005],*ans;int S=0,n,T;char ord[12];map&lt;unsigned int,int&gt; mp1;//最近一次得分 map&lt;unsigned int,int&gt; mp2;//最近一次插入 void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x,int tt)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;v=x,tr-&gt;tim=tt; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); memcpy(tr-&gt;name,ord,sizeof(ord)); return ; &#125; tr-&gt;siz++; int d=tr-&gt;cmp(x,tt); insert_tr(tr-&gt;ch[d],x,tt); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1);&#125;void del(Tr* &amp;tr,int x,int tt)&#123; int d=tr-&gt;cmp(x,tt); if(d==-1)&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),tr-&gt;siz--,del(tr-&gt;ch[d_],x,tt); &#125; &#125;else tr-&gt;siz--,del(tr-&gt;ch[d],x,tt);&#125; Tr* Kth(Tr *tr,int x)&#123; if(tr==NULL||x&lt;=0||x&gt;tr-&gt;siz)return NULL; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(x&lt;=evid)return Kth(tr-&gt;ch[0],x); else if(x&gt;evid+1)return Kth(tr-&gt;ch[1],x-evid-1); else return tr;&#125;int Rank(Tr *tr,int x,int tt)&#123; if(tr==NULL)return 0; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(tr-&gt;cmp(x,tt)&lt;0)return evid+1; if(!tr-&gt;cmp(x,tt))return Rank(tr-&gt;ch[0],x,tt); else return evid+1+Rank(tr-&gt;ch[1],x,tt);&#125; bool Find(Tr *tr,int x)&#123; while(tr!=NULL)&#123; if(tr-&gt;v==x)return true; else tr=tr-&gt;ch[(tr-&gt;v&lt;x)]; &#125; return false;&#125;unsigned int Hash(char *s)&#123; unsigned int res=0; for(;*s;s++)res=res*133u+*s; return res;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void solve()&#123; n=read(),T=0; Tr *root=NULL; while(n--)&#123; scanf("%s",ord); if(ord[0]=='+')&#123; int u=-read(),pre,close; unsigned int code=Hash(ord+1); pre=mp1[code],close=mp2[code]; //上一次的得分和插入时间 if(pre&amp;&amp;Find(root,pre)) del(root,pre,close); mp1[code]=u,mp2[code]=T,insert_tr(root,u,T); &#125;else if(isdigit(ord[1]))&#123; int rk=atoi(ord+1); for(int i=0;i&lt;10;i++)&#123; ans=Kth(root,rk+i); if(ans==NULL)break; if(i)printf(" "); printf("%s",ans-&gt;name+1); &#125; printf("\n"); &#125;else &#123; unsigned int code=Hash(ord+1); int pre=mp1[code],close=mp2[code]; printf("%d\n",Rank(root,pre,close)); &#125; T++; &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 书架]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2596%2F</url>
    <content type="text"><![CDATA[题目链接 题解平衡树裸题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; int siz,v,pr,l,r,fa;&#125;;Tr tr[400005];int S=0,root=0,n,m,a[200005];int pos[200005];void maintain(int k)&#123; tr[k].siz=1; if(tr[k].l)tr[k].siz+=tr[tr[k].l].siz,tr[tr[k].l].fa=k; if(tr[k].r)tr[k].siz+=tr[tr[k].r].siz,tr[tr[k].r].fa=k;&#125;int newnode(int k)&#123; S++,tr[S].v=k,tr[S].pr=rand(),tr[S].siz=1; tr[S].l=tr[S].r=tr[S].fa=0; return S;&#125;void Split_K(int now,int k,int &amp;x,int &amp;y)&#123; if(!now)x=y=0; else&#123; if(k&gt;tr[tr[now].l].siz) x=now,Split_K(tr[now].r,k-tr[tr[now].l].siz-1,tr[now].r,y); else y=now,Split_K(tr[now].l,k,x,tr[now].l); maintain(now); &#125;&#125;int Merge(int x,int y)&#123; if(!x||!y)return x+y; if(tr[x].pr&lt;tr[y].pr)&#123; tr[x].r=Merge(tr[x].r,y); maintain(x); return x; &#125;else&#123; tr[y].l=Merge(x,tr[y].l); maintain(y); return y; &#125;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int get_pos(int x)&#123; int res=1+tr[tr[x].l].siz; while(tr[x].fa)&#123; if(x==tr[tr[x].fa].r) res+=tr[tr[tr[x].fa].l].siz+1; x=tr[x].fa; &#125; return res;&#125;void init()&#123; srand(12414841); tr[0].siz=tr[0].v=tr[0].fa=0; n=read(),m=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++) pos[a[i]]=newnode(a[i]), root=Merge(root,pos[a[i]]);//rank数组&#125;void solve()&#123; char ord[10]; int x,u,v,w,y,z,t,i1,i2; for(int i=1;i&lt;=m;i++)&#123; scanf("%s",ord); u=v=w=y=z=t=0; if(ord[0]=='A') x=read(), printf("%d\n",get_pos(pos[x])-1); if(ord[0]=='T')&#123; x=read(),u=get_pos(pos[x]); Split_K(root,u-1,w,z); Split_K(z,1,y,v); root=Merge(Merge(y,w),v); &#125; if(ord[0]=='B')&#123; x=read(),u=get_pos(pos[x]); Split_K(root,u-1,w,z); Split_K(z,1,y,v); root=Merge(Merge(w,v),y); &#125; if(ord[0]=='Q')&#123; x=read(); Split_K(root,x-1,w,z); Split_K(z,1,y,v); printf("%d\n",tr[y].v); root=Merge(Merge(w,y),v); &#125; if(ord[0]=='I')&#123; x=read(),y=read(); if(y)&#123; u=get_pos(pos[x]); Split_K(root,u-1,w,v); Split_K(v,1,t,z); if(y==-1)&#123; Split_K(w,u-2,i1,i2); root=Merge(Merge(Merge(i1,t),i2),z); &#125;else&#123; Split_K(z,1,i1,i2); root=Merge(Merge(Merge(w,i1),t),i2); &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 三色二叉树]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2585%2F</url>
    <content type="text"><![CDATA[题目链接 题解水DP。分别给每个点设3个状态即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[10005];int n,l[10005]=&#123;0&#125;,r[10005]=&#123;0&#125;,ans,f[10005][3],o;int dfs(int cur)&#123; if(s[cur]=='0')return cur; if(s[cur]=='1')&#123; l[cur]=cur+1; return dfs(cur+1); &#125; if(s[cur]=='2')&#123; l[cur]=cur+1; int t=dfs(cur+1); r[cur]=t+1; return dfs(t+1); &#125; &#125;int dfs2(int cur)&#123; if(l[cur])dfs2(l[cur]); if(r[cur])dfs2(r[cur]); if(l[cur]&amp;&amp;r[cur])&#123; if(!o)&#123; f[cur][0]=max(f[l[cur]][1]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][1]), f[cur][2]=max(f[l[cur]][1]+f[r[cur]][0],f[l[cur]][0]+f[r[cur]][1]), f[cur][1]=max(f[l[cur]][0]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][0])+1; &#125;else&#123; f[cur][0]=min(f[l[cur]][1]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][1]), f[cur][2]=min(f[l[cur]][1]+f[r[cur]][0],f[l[cur]][0]+f[r[cur]][1]), f[cur][1]=min(f[l[cur]][0]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][0])+1; &#125; &#125;else if(l[cur])&#123; if(!o)&#123; f[cur][0]=max(f[l[cur]][1],f[l[cur]][2]), f[cur][2]=max(f[l[cur]][1],f[l[cur]][0]), f[cur][1]=max(f[l[cur]][0],f[l[cur]][2])+1; &#125;else&#123; f[cur][0]=min(f[l[cur]][1],f[l[cur]][2]), f[cur][2]=min(f[l[cur]][1],f[l[cur]][0]), f[cur][1]=min(f[l[cur]][0],f[l[cur]][2])+1; &#125; &#125;else&#123; f[cur][0]=f[cur][2]=0,f[cur][1]=1; &#125;&#125;void init()&#123; scanf("%s",s+1); n=strlen(s+1),dfs(1);&#125;void solve()&#123; ans=0,o=0,dfs2(1); ans=max(ans,max(f[1][0],max(f[1][1],f[1][2]))); printf("%d ",ans); memset(f,0,sizeof(f)); ans=INF,o=1,dfs2(1); ans=min(ans,min(f[1][0],min(f[1][1],f[1][2]))); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI2014 HOT-Hotels]]></title>
    <url>%2F2018%2F08%2F09%2Fpoi2014-hot%2F</url>
    <content type="text"><![CDATA[题目链接 题解一个比较容易证明的结论是：这三个点必然会经过某一个点，并且该点到他们的距离相等。这样，我们枚举每一个点，然后算一下每层深度有多少个这样的点，计数即可。这样会有重复，不妨这么考虑：一个点是“中心点”的前提是他是另外$3$个点的$LCA$。所以为了避免某$2$个深度相同的点的$LCA$不是当前枚举的点，我们就把每一颗当前枚举点的子树看作是一个集合，集合中深度相同的$2$个点不可同时选取，就转化为了一个组合问题。假设有$n$个集合，大小分别为a_1,a_2,a_3,...,a_n要从其中$3$个集合中各选一个元素组成$3$元组个方案数显然是a_ia_ja_k。这些方案数的和就是当前点的答案。然后考虑加入一个集合，要快速得到这个集合的贡献，就要维护其他集合两两乘积的和，把新集合大小乘上去就是新集合的贡献。维护两两乘积的和又需要维护所有集合大小之和，这就是代码里开了$f,g$2个数组的原因。$f$就是集合大小和，$g$就是两两乘积和。这么做是$O(n^2)$的。容易被卡。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,to[10005],nex[10005],at[10005]=&#123;0&#125;,cnt=0;ll ans=0,f[5005],g[5005],d[5005]=&#123;0&#125;;//次数1 2 3 void dfs(int cur,int fa,int de)&#123; d[de]++; for(int i=at[cur];i;i=nex[i]) if(to[i]!=fa) dfs(to[i],cur,de+1); &#125;void init()&#123; n=read(); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); to[++cnt]=v,nex[cnt]=at[u],at[u]=cnt; to[++cnt]=u,nex[cnt]=at[v],at[v]=cnt; &#125; &#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); for(int j=at[i];j;j=nex[j])&#123; dfs(to[j],i,1); for(int k=1;k&lt;=n;k++)//合并集合 ans+=d[k]*g[k],g[k]+=d[k]*f[k],f[k]+=d[k],d[k]=0; &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POI</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI2014 PTA-Little Bird]]></title>
    <url>%2F2018%2F08%2F09%2Fpoi2014-pta%2F</url>
    <content type="text"><![CDATA[题目链接 题解要用单调队列这一点比较明显，DP也可以看得出来。所以就是单调队列+DP。保证单调队列里的元素相同体力消耗下靠近队首的高度尽量高即可，相当于在维护队列体力消耗值从队首到队尾递增的基础上对高度进行递减的维护。时间复杂度是$O(Nq)$。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[1000005],m,d,que[1000005],f,r,dp[1000005];void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();&#125;void solve()&#123; m=read(); while(m--)&#123; d=read(); f=r=0; dp[1]=0,que[r++]=1; for(int i=2;i&lt;=n;i++)&#123; while(r-f&amp;&amp;i-que[f]&gt;d)f++; dp[i]=dp[que[f]]+(a[que[f]]&lt;=a[i]); while(r-f&amp;&amp;(dp[que[r-1]]&gt;dp[i]||(dp[que[r-1]]==dp[i]&amp;&amp;a[que[r-1]]&lt;a[i]))) r--; que[r++]=i; &#125; printf("%d\n",dp[n]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POI</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2011 兔农]]></title>
    <url>%2F2018%2F08%2F09%2Fnoi2011t1%2F</url>
    <content type="text"><![CDATA[题目链接 题解模拟能拿75分。题目肯定是和斐波那契数列有关，但有关在哪里呢？由于有取模，所以我们看看有没有什么和循环有关的性质。我们设$fib[i]$为斐波那契数列的第$i$项，而设$F[i]$为该数列的第i项。把$k=7$作为例子，观察$F[i]$对$k$取模的序列：$1,1,2,3,5,0, $$5,5,3,0, $$3,3,6,2,0,$$2,2,4,6,3,2,5,0,5,5,3,0,$（之所以这一段前面的$0$不算是一段的结尾，是因为这个$0$不是由于减了一个$1$而产生的）$3,3,6,2,0,…$设$fib[0]=0$，则可以发现： 每一段的开头两个数都是相同的两个数，并且正好就是前面那一个段的最后一个非$0$数。同时只有除$k$和$0$以外的$k-1$种数，所以最多在不超过$k$段的情况下就会出现循环。（假设这个循环是存在的话。） 对于某一段而言，这一段都相当于一段小的斐波那契数列。比如说某一段的开头是$x$，那么这一段就是$x,x,2x,3x,5x,8x,…$换言之，这一段的第$i$个数就是$fib[i]\cdot x$。如果这一段有长度，那么设长度是$Len$，则$fib[Len]\cdot x \mod k=1$.这个时候就是我们要减掉$1$的时候。 有了以上的推导，我们不难得出具体算法： 根据$fib[Len]\cdot x \mod k=1$求出$fib[Len]$ 反推出$Len$ 求出下一段的开头，也就是$fib[Len-1]\cdot x$，转回第1步 第1步里头，不难发现$fib[Len]$就是$x^{-1}(mod\quad k)$，所以如果逆元都不存在的话这就成了裸题。否则，算出逆元。第2步，预处理出对于每个$i$，$fib[Len]=i$的最小$Len$。如果是不存在，那么也变成了矩阵乘法裸题。但是可能这个$Len$很大啊？有2个方法： 估计一下$fib \mod k$的循环节长度，直接算 数学证明。vfk大佬的博客上有证明，我不会证，只知道了结论：$fib \mod k$的循环节是以$0,1,1$为开头的，且长度不超过$6000$。就直接算了。 第3步，由于直接模拟可能超时，所以要用矩阵快速幂。一个数减掉$1$是一个很好写的矩阵，这里就不列了，有兴趣的看代码吧。 剩下的细节还挺好处理的。边算边记录答案即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll n,k,p,ans;ll minlen[1000005],block[1000005][3],vis[1000005]=&#123;0&#125;,top=0;ll sum[1000005]=&#123;0&#125;;ll FIB[3][3]=&#123; &#123;0,1,0&#125;, &#123;1,1,0&#125;, &#123;0,0,1&#125;&#125;,MINUS[3][3]=&#123; &#123;1,0,0&#125;, &#123;0,1,0&#125;, &#123;0,-1,1&#125;&#125;;//vis 总长度为什么时开头变成了i // block保存段长信息 struct Mat&#123; ll dat[3][3]; int r,c; Mat()&#123; memset(dat,0,sizeof(dat)); &#125;&#125;;Mat Minus,Fib;Mat mul(Mat &amp;a,Mat &amp;b,ll Mod)&#123; Mat newed; newed.r=a.r,newed.c=b.c; int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p,ll Mod)&#123; Mat E;E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) E.dat[i][i]=1; while(p)&#123; if(p&amp;1)E=mul(E,a,Mod); a=mul(a,a,Mod),p&gt;&gt;=1; &#125; return E;&#125;ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll d=extgcd(b,a%b,y,x); y-=(a/b)*x; return d;&#125;void setfib(Mat &amp;mat)&#123; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) mat.dat[i][j]=FIB[i][j]; mat.r=mat.c=3;&#125;void setminus(Mat &amp;mat)&#123; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) mat.dat[i][j]=MINUS[i][j]; mat.r=mat.c=3;&#125;void init()&#123; scanf("%lld%lld%lld",&amp;n,&amp;k,&amp;p); memset(minlen,-1,sizeof(minlen)); memset(vis,-1,sizeof(vis)); ll fib1=1,fib2=1,fib3,t; for(ll i=3;i&lt;=6*k;i++)&#123; fib3=(fib1+fib2),t=fib3%k; //printf("\t %lld %lld %lld\n",fib1,fib2,t); if(t==1&amp;&amp;fib2==1&amp;&amp;fib1==0)break; if(minlen[t]&lt;0)minlen[t]=i; fib1=fib2,fib2=t; &#125; MINUS[2][1]=p-1; //计算对应的Len setfib(Fib),setminus(Minus);&#125;void solve()&#123; ll x=1,dx,dy,d,len; ll cyc=-1; Mat Ori,Plu,res; Ori.r=1,Ori.c=3; Ori.dat[0][0]=Ori.dat[0][2]=1, Ori.dat[0][1]=0; for(;;)&#123; d=extgcd(x,k,dx,dy); //ax+bk=1 if(d!=1) break; else&#123; //逆元存在 dx=(dx+k)%k,len=minlen[dx]; if(len==-1)//不存在对应的 break; block[top][0]=x,block[top][1]=len; Plu=Pow(Fib,len-1,k); res=mul(Ori,Plu,k); //求出fib[len-1] block[top++][2]=(x*res.dat[0][1])%k; x=block[top-1][2]; sum[top]=sum[top-1]+len; if(vis[x]&gt;=0)&#123; //说明top-1的后面和cyc是一样的 cyc=vis[x]+1; break; &#125; vis[x]=top-1; &#125; &#125; if(cyc==-1)&#123; //没有最终的循环节，就变成矩阵乘法裸题 for(ll i=0;i&lt;top&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; if(n) Plu=Pow(Fib,n,p), Ori=mul(Ori,Plu,p); ans=Ori.dat[0][1]; &#125;else&#123; for(ll i=0;i&lt;cyc&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; if(!n)&#123; ans=Ori.dat[0][1];goto build_ans; &#125; d=n/(sum[top]-sum[cyc]),n%=(sum[top]-sum[cyc]); if(d)&#123; //至少存在一个循环节 for(ll i=0;i&lt;3;i++) for(ll j=0;j&lt;3;j++) Plu.dat[i][j]=(i==j)?1:0; Plu.r=Plu.c=3; for(ll i=cyc;i&lt;top;i++) res=Pow(Fib,block[i][1],p),res=mul(res,Minus,p),Plu=mul(Plu,res,p); Plu=Pow(Plu,d,p),Ori=mul(Ori,Plu,p); &#125; for(ll i=cyc;i&lt;top&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; ans=Ori.dat[0][1]; &#125; build_ans: printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI2011</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa100 The 3n + 1 problem]]></title>
    <url>%2F2018%2F08%2F07%2Fuva100%2F</url>
    <content type="text"><![CDATA[题目链接 题解模拟即可不需要RMQ也不需要记忆化…因为数据好像超出了1000012345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int rec(int cur)&#123; if(cur == 1)return 1; if(cur &amp; 1) return rec(3 * cur + 1) + 1; else return rec(cur &gt;&gt; 1) + 1;&#125;void init()&#123;&#125;void solve()&#123; int l, r; while(scanf("%d%d", &amp;l, &amp;r) == 2)&#123; int aans = 0; if(l &lt; r)&#123; for(int i = l; i &lt;= r; ++i) aans = max(aans, rec(i)); &#125;else &#123; for(int i = r; i &lt;= l; ++i) aans = max(aans, rec(i)); &#125; printf("%d %d %d\n", l, r, aans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 堆]]></title>
    <url>%2F2018%2F08%2F06%2Ftemplate-heap%2F</url>
    <content type="text"><![CDATA[堆包括二叉堆，二项堆，可并堆，斐波那契堆，等。 普通二叉堆最经典的堆结构。其本身为一颗完全二叉树，并且每一个节点都遵循着自身的值大于（或者小于）父节点的值的规律。至于出现重复的值该怎么办，这就要具体情况具体分析。一般而言不需要手写二叉堆，使用C++自带的即可。 以下操作默认为小根堆： 上浮操作让当前位置为$id$的节点不断与其父节点比较，若其比父节点大则符合小根堆的标准，停止上浮；若其小于父节点则与父节点相交换，实现上浮。12345678910void pushup(int *h, int id)&#123; int tmp = h[id]; while(id &gt;= 1)&#123; int par = id &gt;&gt; 1; if(h[par] &lt; tmp) break; h[id] = h[par], id &gt;&gt;= 1; &#125; h[id] = tmp;&#125; 下沉操作让当前位置为$id$的节点不断与其子节点比较，边界是其自身为叶子。若其只有一个子节点，且其小于子节点则符合堆的要求，停止下沉；否则其与子节点交换，下沉。若其有两个子节点且小于两个子节点，则停止下沉；否则让更小的那个子节点与自身交换，下沉。12345678910111213141516171819202122void pushdown(int *h, int id)&#123;//下称操作 int tmp = h[id]; while(id &lt;= (n &gt;&gt; 1))&#123; int lson = id &lt;&lt; 1, rson = id &lt;&lt; 1 | 1; if(rson &gt; n)&#123; if(tmp &lt; h[lson]) break; else h[id] = h[lson], id = lson; &#125;else&#123; if(tmp &lt; h[lson] &amp;&amp; tmp &lt; h[rson]) break; else &#123; if(h[lson] &lt; h[rson]) h[id] = h[lson], id = lson; else h[id] = h[rson], id = rson; &#125; &#125; &#125; h[id] = tmp;&#125; 插入操作将新数$val$插入堆的最底层中，从左到右第一个空出的位置（即堆的最后一个位置的后面）。然后执行上浮操作。12345void pushin(int *h, int val)&#123;//增加数操作 int id = ++n; h[id] = val; pushup(h, id);&#125; 弹出操作将堆最后一个位置的节点与根节点交换，删去最后一个位置的节点，然后让根下沉。123456int popout(int *h)&#123; int top = heap[1]; heap[1] = heap[n--]; pushdown(h, 1); return top;&#125; 建堆操作从底到顶，一层一层对非叶子节点进行下沉操作。1234void build_heap(int *h, int n)&#123;//建堆 for(int i = n &gt;&gt; 1; i &gt;= 1; --i) pushdown(heap, i);&#125; 斐波那契堆斐波那契堆是一种可并堆，虽然其的写法比较复杂，但是其的摊还时间复杂度比较优秀。许多操作可以做到平摊$O(1)$的时间复杂度。确切地说，一个斐波那契堆是一个具有最小堆序的有根树森林。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷1338 末日的传说]]></title>
    <url>%2F2018%2F08%2F06%2Fluogu1338%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题其实可以这么考虑。我们考虑把这个问题缩小范围。比如$n=5$，在决定了最小的数”$1$”的位置之后，剩下的几个数是$2,3,4,5$，但是他们具体是多少没必要关心，我们只要关心他们的相对大小关系。所以考虑完当前最小的数，算出这个数对答案的贡献，然后减掉这个贡献，就可以转而解决一个更小的子问题。（即$n\rightarrow n-1$）回到题目上，要求是求一个有$m$个逆序对的字典序最小的排列。我们知道一个长度为$n$的排列最多有$\frac {n(n-1)}2$个逆序对，也知道一个排列的逆序对数越多，排列字典序越大。所以如果当前$m$不比当前的$\frac {(n-2)(n-1)}2$（也就是减少一个数之后的最多的逆序对数）大，就可以直接把当前的最小数放在最前面，这肯定是最优的。反之，则考虑最小数的放置位置。假设当前排列长为$n$，最小数为$a$，则$a$有$n$种放法，放在从左到右第$i$个位置时会生成$i-1$个逆序对（因为它左边有$i-1$个比他大）。因为$m$大于$n-1$长度排列最多所能产生的逆序数，所以$a$不可能放在最前面，否则不满足条件。怎么办呢？想到之前说的逆序对越多字典序越大，我们就必须让剩下的数能构成的逆序对数尽量小，所以$a$要放到最后，这样$m$减少的最多。放完了$a$，问题就变成了$n-1$和$m-(a$的贡献$)$的子问题，递归求解即可。时间复杂度$O(n)$。123456789101112131415#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll n,m,a[50005];int main()&#123; scanf("%lld%lld\n",&amp;n,&amp;m); ll lst=n,fst=1; for(int i=1;i&lt;=n;i++)&#123; ll t=(ll)(n-i)*(n-i-1)/2; if(t&gt;=m)a[fst++]=i; else a[lst--]=i,m-=(lst-fst+1); &#125; for(int i=1;i&lt;=n;i++)printf("%d ",a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 排序算法]]></title>
    <url>%2F2018%2F08%2F05%2Ftemplate-sort%2F</url>
    <content type="text"><![CDATA[不能忘的基本排序！ 插入排序重点在于：在排第$k$个元素的时候，前$k-1$个已经有序。因此只要把第$k$个元素放到它应该在的地方即可。123456789101112void sort1(int* a, int n)&#123; for(int i = 1; i &lt; n; ++i)&#123; int tmp = a[i], j; for(j = i; j &gt; 0; --j)&#123; if(tmp &lt; a[j - 1]) a[j] = a[j - 1];//向后面移动 else break; &#125;//寻找位置 a[j] = tmp;//插入 &#125;&#125; 选择排序简单直观的排序方法。始终寻找当前的最小值，放在它应当在的地方。12345void sort2(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = i + 1; j &lt; n; ++j) if(a[i] &gt; a[j])swap(a[i], a[j]);&#125; 冒泡排序比较相邻元素，调整顺序以达到排序的目的。123456void sort3(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = 0; j &lt; n - i; ++j) if(a[j] &gt; a[j + 1]) swap(a[j], a[j + 1]);//交换过程&#125; 希尔排序希尔排序使用了一个序列（称之为增量序列） h_1,h_2,h_3,...,h_n其中h_1=1。排序时将序列划为h_k组，元素之间间隔为h_k，然后每组内部进行一个插入排序。随着增量减小数据间的有序程度也就越高，最终在增量达到$1$时达到有序。增量序列的选择直接与算法的效率挂钩。此处用的为$Hibbard$增量，即$1,3,7,…,2^k-1$。123456789101112131415void sort4(int *a, int n)&#123; int h[] = &#123;1, 3, 7, 15, 31&#125;; for(int i = lower_bound(h, h + 5, n) - h - 1; i &gt;= 0; --i)&#123;//寻找最大增量 for(int j = h[i]; j &lt; n; ++j)&#123; int tmp = a[j], k; for(k = j; k &gt;= h[i]; k -= h[i])&#123; if(tmp &lt; a[k - h[i]]) a[k] = a[k - h[i]]; else break; &#125; a[k] = tmp; &#125; &#125;&#125; 以上为常见的$O(n^2)$排序算法。 归并排序分治算法的典型应用，将数据层层分割，直到最简单的两个一组的情况，然后不断进行二路归并。1234567891011121314151617181920void Merge(int *a, int *tmp, int lhead, int rhead, int rend)&#123; int lpos = lhead, rpos = rhead, tpos = lhead; while(lpos &lt; rhead &amp;&amp; rpos &lt; rend)&#123; if(a[lpos] &lt; a[rpos]) tmp[tpos++] = a[lpos++]; else tmp[tpos++] = a[rpos++]; &#125; while(lpos &lt; rhead)tmp[tpos++] = a[lpos++]; while(rpos &lt; rend)tmp[tpos++] = a[rpos++]; for(int i = lhead; i &lt; rend; ++i) a[i] = tmp[i];&#125;void MergeSort(int *a, int left, int right)&#123;//左闭右开 int n = right - left, mid = (right + left) &gt;&gt; 1; if(n == 1)return ; MergeSort(a, left, mid); MergeSort(a, mid, right); Merge(a, b, left, mid, right);&#125; 快速排序快速排序的关键在于选择基准以及分割策略，其余的工作交给递归即可。一种比较优秀的选择基准的方法是对最左端，最右端，和最中间的三个数排序，选择第二大（即中间大小）的数作为基准。这种选择比纯粹的随机选择和固定的选择更加高明。之后，将基准和当前序列的倒数第二个值交换。分割时，利用两个指针，其中一个（设为$i$）从最左边向右扫，另一个（设为$j$）从倒数第二个位置向左扫。$i$只会在大于或等于基准的位置停下，$j$只会在小于或等于基准的位置停下。此时若$i&lt;j$，那么交换$i$和$j$对应的数；若$i \ge j$，那么指针停止行动，本次分割结束。之后由于$i$指针左右分别为小于等于和大于等于基准的数，故把基准换到$i$所在位置，再对$i$两侧递归执行排序。 以上的做法避免了几个隐患： 基准换到倒数第二个位置，为$i$提供了一个界限；同时选择基准时进行的排序也为$j$提供了一个界限。 $i$和$j$在遇到等于基准的值时都会停下，这是因为当多个相同元素存在时，若$i$和$j$都不停下，那么$i$会一直进行到接近末尾的地方，导致分割出来的左右两边序列长度不均衡，进而导致算法实际运行效率变差。 123456789101112131415161718192021222324252627282930void Median3(int *a, int left, int right)&#123; int mid = (left + right) &gt;&gt; 1; if(a[left] &gt; a[mid])swap(a[left], a[mid]); if(a[mid] &gt; a[right])swap(a[mid], a[right]); if(a[left] &gt; a[mid])swap(a[left], a[mid]); swap(a[mid], a[right - 1]);&#125;void Qsort(int *a, int left, int right)&#123;// 闭区间 int len = right - left + 1, pivot; if(len &lt;= 1)return ; if(len == 2)&#123; if(a[right] &lt; a[left])swap(a[left], a[right]); return ; &#125; Median3(a, left, right); pivot = a[right - 1]; int i = left, j = right - 1; for(;;)&#123; while(a[++i] &lt; pivot) ; while(a[--j] &gt; pivot) ; if(i &gt;= j)break; swap(a[i], a[j]); &#125; swap(a[i], a[right - 1]); Qsort(a, left, i - 1); Qsort(a, i + 1, right);&#125;void QuickSort(int *a, int n)&#123; Qsort(a, 0, n - 1);&#125; 堆排序建立一个堆，直接操作即可。此处不再赘述。 以上为常见的$O(nlogn)$排序算法。 记数排序计数排序的中心思想是：对于每一个输入的元素$x$，确定小于或等于$x$的元素的个数。利用这一信息，即可把该元素放在他应在的位置。12345678910void CountingSort(int *a, int *cnt, int *ans, int n)&#123; for(int i = 0; i &lt;= 10; ++i) cnt[i] = 0; for(int i = 0; i &lt; n; ++i) cnt[a[i]]++; for(int i = 1; i &lt;= 10; ++i) cnt[i] += cnt[i - 1]; for(int i = n - 1; i &gt;= 0; --i) ans[--cnt[a[i]]] = a[i];&#125; 基数排序基数排序执行这样一个过程：对$n$个$d$位数，从最低位开始，一直到最高位，以数的当前位上的数字作为关键字进行排序。 桶排序桶排序将$n$个分布在$[0,1)$上的实数放入$m$个“桶”里，每个桶对应着一个区间，并且对每一个桶里的数据进行排序，以达到总体的有序。 以上为常见的线性时间复杂度排序算法。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷1396 营救]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1396%2F</url>
    <content type="text"><![CDATA[题目地址 题解为什么专门拿出这道题来写一个题解呢？因为这道题考察到了一个我们平时（可能）没有注意到的地方。并查集不仅可以用来做连通性状态的维护，还可以用来解决一些图论上的最值问题。像是这道题，就把二分和并查集结合在一起。二分答案，只把拥挤度小于答案的加入并查集，维护$S$和$T$的联通状态。这个思路真的很妙。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;struct Edge&#123; int u,v,cost; &#125;; Edge edge[20005];bool cmp(int a,int b)&#123; return edge[a].cost&lt;edge[b].cost;&#125;int id[20005],n,m,S,T;int par[10005];int Find(int x)&#123; if(par[x]==x)return x; return par[x]=(Find(par[x]));&#125;void Unite(int u,int v)&#123; par[Find(u)]=Find(v);&#125;bool judge(int M)&#123; for(int i=1;i&lt;=n;i++) par[i]=i; for(int i=0;i&lt;m;i++)&#123; if(edge[id[i]].cost&gt;M)break; Unite(edge[id[i]].u,edge[id[i]].v); if(Find(S)==Find(T))return 1; &#125; return 0;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost), id[i]=i; sort(id,id+m,cmp);&#125;void solve()&#123; int L=0,R=20000,M; while(R-L)&#123; M=(R+L)/2; if(judge(M))//&lt;=M R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2420]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2420%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出每一个点到根的$xor$路径，然后直接$O(1)$回答询问。答案就是$val[u]\quad xor\quad val[v]$，因为$val[lca]$被消去了。这真的是经典问题？我怀疑你就是在水1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[200006];int cnt=0,at[100005]=&#123;0&#125;,n,val[100005]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[++cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int x,int fa)&#123; for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa) val[edge[i].v]=val[x]^edge[i].cost, dfs(edge[i].v,x);&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); dfs(1,0);&#125;void solve()&#123; int m=read(),u,v; while(m--) u=read(),v=read(), printf("%d\n",val[u]^val[v]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1730 最小密度路径]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1730%2F</url>
    <content type="text"><![CDATA[题目地址 题解这是floyd的一个拓展应用。可以求出恰好经过一定数目条路的最短路径长度。也是运用到了动态规划的思想，不过DP数组则变成了3维。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 0x14141414using namespace std;typedef long long ll;int d[1005][105][105],V,E,Q;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; V=read(),E=read(); int u,v,c; memset(d,0x14,sizeof(d)); for(int i=1;i&lt;=E;i++)&#123; u=read(),v=read(),c=read(); if(d[1][u][v]&gt;c)d[1][u][v]=c; &#125; for(int l=2;l&lt;=E;l++) for(int k=1;k&lt;=V;k++) for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) d[l][i][j]=min(d[l][i][j],d[l-1][i][k]+d[1][k][j]); Q=read();&#125;void solve()&#123; int u,v; double ans; for(int i=1;i&lt;=Q;i++)&#123; u=read(),v=read(); ans=INF; for(int l=1;l&lt;=E;l++) if(d[l][u][v]&lt;INF) ans=min(ans,d[l][u][v]/(double)l); if(ans&gt;INF-1)printf("OMG!\n"); else printf("%.3lf\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2758 编辑距离]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2758%2F</url>
    <content type="text"><![CDATA[题目地址 题解非常经典的$DP$题目。转移方程和$LCS$问题非常相似，设$f(i,j)$表示$a$串的第$i$位匹配到$b$串的第$j$位所需要的最少操作数，那么有: f(i,j)=\begin {cases} f(i-1,j-1)\quad (a[i]=b[j])\\ \min \left\{f(i-1,j),f(i-1,j-1),f(i,j-1)\right\}+1 \quad (a[i]\neq b[j]) \end{cases}以上三个数分别对应删除，修改和插入时间复杂度O(l_1l_2)123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char a[2005],b[2005];int f[2005][2005],l1,l2,l3;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b);&#125;void solve()&#123; f[0][0]=0; for(int i=1;i&lt;=l1;i++) f[i][0]=i; for(int i=1;i&lt;=l2;i++) f[0][i]=i; for(int i=1;i&lt;=l1;i++)&#123; for(int j=1;j&lt;=l2;j++)&#123; if(a[i-1]==b[j-1])&#123; f[i][j]=f[i-1][j-1]; &#125;else f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+1; //printf("%d %d:%d\n",i,j,f[i][j]); &#125; &#125; printf("%d\n",f[l1][l2]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>字符串DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1122 最大子树和]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1122%2F</url>
    <content type="text"><![CDATA[题目地址 题解树形DP。主要是体会一下树形DP于树形这种递归结构的关系。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,at[100005],to[100005],_next[100005],cnt=0;bool vis[100005];ll val[100005],dp[100005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int cur)&#123; //包含自己在内 dp[cur]=val[cur]; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]])&#123; vis[to[i]]=1,dfs(to[i]); if(dp[to[i]]&gt;0)dp[cur]+=dp[to[i]]; &#125; &#125;&#125;void init()&#123; n=read(); memset(at,-1,sizeof(at)); int u,v; for(int i=1;i&lt;=n;i++) val[i]=read(); for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); to[cnt]=v,_next[cnt]=at[u],at[u]=cnt++; to[cnt]=u,_next[cnt]=at[v],at[v]=cnt++; &#125;&#125;void solve()&#123; ll ans=-INF; ans*=2ll; vis[1]=1,dfs(1); for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i]); printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待改进 COCI2007 Patrik 音乐会的等待]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1823%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题就是在教你怎么玩单调栈…经典做法就是，维护一个不递增的栈，然后有人比栈顶的人还高的话，就把他加进来，然后因为这个人肯定能看见他与他前面第一个比他高的人之间的人，所以在出栈的时候累加答案。同时还要注意人身高相等的情况。下面我的程序给出的实现方式并不是一个很好的方式，所以有待改进具体的改进方式应该就是令栈单调递减并且维护一段数据的大小…12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll stack[500005],ans=0,tmp,len,lst;int main()&#123; int i,top=1,n,j; scanf("%d%lld",&amp;n,&amp;stack[0]); for(i=1;i&lt;n;i++)&#123; scanf("%lld",&amp;tmp); while(top&amp;&amp;stack[top-1]&lt;tmp) top--,ans++; stack[top++]=tmp; if(top&gt;1)ans++; for(j=top-2;j&amp;&amp;stack[j]==tmp;j--,ans++); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>COCI</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4203 Doubloon Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu4203%2F</url>
    <content type="text"><![CDATA[题目地址 题解先大力打表，看SG函数有没有什么规律发现打表结果非常神奇：当$K$是奇数的时候，SG函数是$010101$变化的。$K$是偶数的时候，每逢$K$的倍数，$SG（x\cdot K）$就为$2$。否则仍然按照$010101$变化。比如$K=2:0,1,2,0,1,2 …$$K=4:0,1,0,1,2,0,1,0,1,2…$之后就简单了。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int S,k,T;int SG(int x)&#123; if(k%2)return x%2; else &#123; int mod=x%(k+1); if(mod&lt;k)return mod%2; else return 2; &#125; &#125;void solve()&#123; T=read(); while(T--)&#123; S=read(),k=read(); int ans=SG(S); if(ans!=2)printf("%d\n",ans); else &#123; for(int j=1;S-j&gt;=0;j*=k) if(!SG(S-j))&#123; printf("%d\n",j); break; &#125; &#125; &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4203 Pythagoras]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu6211%2F</url>
    <content type="text"><![CDATA[题目地址 题解枚举素勾股数。这道题由于数据很大，所以肯定要一开始就枚举好。枚举的时候要注意，使用gcd会超时，所以改为使用枚举素因子判断互质。由于$\sqrt{1000000000} \approx 31622$，而$2\times 3\times 5\times 7\times 11\times 13\times 17 &gt; 31622$，所以素因子最多不会超过6个。这样的话效率就比较好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int cnt[200005] = &#123;0&#125;, tot = 0;int p[10], a[200005];void init()&#123; for(int v = 2; v &lt;= 31622; ++v)&#123; int pcnt = 0, t = v; for(int i = 2; i * i &lt;= v; ++i)&#123; if(t % i == 0)&#123; t /= i; while(t % i == 0) t /= i; p[++pcnt] = i; if(t == 1) break ; &#125; &#125; if(t != 1) p[++pcnt] = t; for(int u = (v % 2 == 0) ? 1 : 2; u &lt; v; u += 2)&#123; int cc = u * u + v * v, flag = 1; if(cc &gt; 1000000000) break; for(int i = 1; i &lt;= pcnt; ++i) if(u % p[i] == 0)&#123; flag = 0; break ; &#125; if(!flag) continue ; int aa = v * v - u * u, bb = 2 * u * v; if(aa &gt; bb) cnt[(aa &amp; 131071)]++; else cnt[(bb &amp; 131071)]++; &#125; &#125;&#125;void solve()&#123; int k = read(), t; k = (1 &lt;&lt; k), t = k - 1; for(int i = 0; i &lt; k; ++i) a[i] = read(); ll ans = 0; for(int i = 0; i &lt; 131072; ++i) ans += 1ll * cnt[i] * a[(i &amp; t)]; printf("%lld\n", ans);&#125;int main()&#123; int T = read(); init(); while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1704 Georgia and Bob]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1704%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个模型，没记错是叫做阶梯博弈。他这个模型可以转化成Nim游戏。把每一对移动的棋子之间的间距看作是石头的数目，就可以依靠Nim游戏的结论进行解答。但是为什么这样的转化是正确的呢？首先两个棋子逼近，就相当于取走若干个石头；如果两个石头远离，那么不要紧，下一步可以把这个多出来的部分减掉去，所以还是相当于没有增加。如果石头个数是奇数就虚拟一个边界上的石头和他配对。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int T,n,a[1005];void solve()&#123; T=read(); while(T--)&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); if(n&amp;1)a[n+1]=0,n++; sort(a+1,a+n+1); int res=0; for(int i=1;i&lt;=n;i+=2) res^=(a[i+1]-a[i]-1); printf("%s\n",res?"Georgia will win":"Bob will win"); &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1079 Calendar Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu1079%2F</url>
    <content type="text"><![CDATA[题目地址 题解写成递推的形式即可。边界条件挺烦的，还好1A了。反正大力码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char dp[200][13][40]=&#123;0&#125;;//1900--&gt;0int days[]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int run(int x,int y)&#123; return (y==2&amp;&amp;x&amp;&amp;x%4==0);&#125;void init()&#123; dp[101][11][3]=1; int r1=0,r2=0; for(int i=101;i&gt;=0;i--) for(int j=12;j&gt;=1;j--) for(int d=31;d&gt;=1;d--)&#123; if(i==101&amp;&amp;(j==12||(j==11&amp;&amp;d&gt;=3)))continue; if(d&gt;days[j]+run(i,j))continue; if(i==101&amp;&amp;(j&gt;=11||(j==10&amp;&amp;d&gt;4)))r1=-1; else&#123; if(j==12)r1=dp[i+1][1][d]; else if(d&lt;=days[j+1]+run(i,j+1))r1=dp[i][j+1][d]; else r1=-1; &#125; if(d==days[j]+run(i,j))&#123; if(j==12)r2=dp[i+1][1][1]; else r2=dp[i][j+1][1]; &#125;else r2=dp[i][j][d+1]; if(!r1||!r2)dp[i][j][d]=1; else dp[i][j][d]=0; &#125;&#125;void solve()&#123; int T=read(),yy,mm,dd; while(T--)&#123; yy=read(),mm=read(),dd=read(); printf("%s\n",dp[yy-1900][mm][dd]==1?"YES":"NO"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1740 A New Stone Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1740%2F</url>
    <content type="text"><![CDATA[题目地址 题解一般而言，这种题目都需要一定的找规律的技巧。首先$n=1$，先手必胜，这是显然的。$n=2$,如果两堆石头一样多，那么先手必败，因为后手可以不断模仿先手的操作来使石头数始终相同，达到自己不败的目的。如果石头数不相等，那么先手可以转移到石头相同的状态。$n=3$，可以构造出$2$堆相同的情况，只要去掉最多的那一堆就行。$n=4$，只要可以拆成$2$个完全一样的子局面，先手就是必败态，其余是必胜态。归纳一下，$n$是奇数，先手必胜；$n$是偶数，除非局面对称，否则先手必胜。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int n,a[1005];void init()&#123; &#125;void solve()&#123; for(;;)&#123; n=read(); if(!n)break; for(int i=1;i&lt;=n;i++)a[i]=read(); if(n%2)&#123; printf("1\n"); continue; &#125; sort(a+1,a+1+n); int flag=0; for(int i=1;i+i&lt;=n;i+=2) if(a[i]!=a[i+1])&#123; flag=1;break; &#125; printf("%d\n",flag); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3863 No Gambling]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu3863%2F</url>
    <content type="text"><![CDATA[题目地址 题解由于后手只能不断采取行动去堵先手的路，而先手一定可以采取方式突破，所以先手必胜。1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; for(int n;;)&#123; n=read(); if(n&lt;0)break; printf("I bet on Oregon Maple~\n"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2234 Matches Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2234%2F</url>
    <content type="text"><![CDATA[题目地址 题解简单的Nim游戏。推荐看国家集训队2002年张一飞的论文，他的论文深入浅出地用集合的观点解释了nim游戏和的原理。之后的很多博弈论的题目都建立在这么一个基本模型的基础上。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; int M,a[25],res; while(~scanf("%d",&amp;M))&#123; res=0; for(int i=1;i&lt;=M;i++)a[i]=read(),res^=a[i]; printf("%s\n",res?"Yes":"No"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1442 Black Box]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1442%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一无脑平衡树。 方法二堆的神奇操作。发现这个求第$k$小$k$是递增的，所以可以维护一个大根堆和一个小根堆，然后在其中一个堆上维护前$k$个数，另一个堆上维护剩下的数，这样只要关注第$k$个数是什么即可，而不需要管在他前面的或者在他后面的是不是有序的。所以操作就很简单了，$k$加$1$的时候从某个堆弹一个走就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define l(x) (x&lt;&lt;1)+1#define r(x) (x&lt;&lt;1)+2using namespace std;int h[200005]=&#123;0&#125;,size=0,n,m,k[200005];priority_queue&lt;int&gt; pq;//pq下&lt;pq顶&lt;h顶&lt;h底 void up(int s)&#123; int at,tmp=h[s]; while(s&gt;0)&#123; at=(s-1)/2; if(h[at]&lt;=tmp)break; h[s]=h[at],s=at; &#125; h[s]=tmp;&#125;void down(int s,int e)&#123; int lch,rch,tmp=h[s]; while(l(s)&lt;e)&#123; lch=l(s),rch=r(s); if(rch&lt;e&amp;&amp;h[rch]&lt;h[lch]) lch=rch; if(tmp&lt;=h[lch])break; h[s]=h[lch],s=lch; &#125; h[s]=tmp;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int i,j,at; for(i=0;i&lt;m;i++) scanf("%d",&amp;k[i]); pq.push(k[0]); for(i=0,j=1;i&lt;n;i++)&#123; scanf("%d",&amp;at); while(j&lt;at)&#123; if(pq.top()&gt;k[j])&#123; h[size++]=pq.top(),pq.pop(); pq.push(k[j]),up(size-1); &#125;else h[size++]=k[j],up(size-1); j++; &#125; printf("%d\n",pq.top()); if(!size)h[size++]=k[j++]; pq.push(h[0]),h[0]=h[--size],down(0,size); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2823 Sliding Window]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2823%2F</url>
    <content type="text"><![CDATA[题目地址 题解经典的单调队列入门题。思路很简单，就是先判断队头是否“过期”，然后再在队尾进行比较。这里的代码是可以进行空间上的优化的。注意一个点：$k=1$时最好特判。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; int n,k,a[1000005],d1[1000005][2],d2[1000005][2],f1=0,f2=0,r1=1,r2=1,ans[1000005][2];void in(int at,int p)&#123; while(r1&gt;f1&amp;&amp;d1[f1][1]&lt;=at-k) f1++; while(r2&gt;f2&amp;&amp;d2[f2][1]&lt;=at-k) f2++; while(r1&gt;f1&amp;&amp;d1[r1-1][0]&gt;p) d1[r1-1][0]=d1[r1-1][1]=0,r1--; while(r2&gt;f2&amp;&amp;d2[r2-1][0]&lt;p) d2[r2-1][0]=d2[r2-1][1]=0,r2--; d1[r1][0]=p,d1[r1++][1]=at; d2[r2][0]=p,d2[r2++][1]=at;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); i=(k==1)?0:1; d1[0][0]=d2[0][0]=a[0]; d1[0][1]=d2[0][1]=0; for(;i&lt;n;i++)&#123; in(i,a[i]); ans[i][0]=d1[f1][0]; ans[i][1]=d2[f2][0]; &#125; for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][0]); printf("%d\n",ans[n-1][0]); for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][1]); printf("%d\n",ans[n-1][1]); return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3017 Cut the Sequence]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3017%2F</url>
    <content type="text"><![CDATA[题目地址 题解第一次做这样的利用决策单调性来优化DP的题目。设$f(i)$表示分割到第$i$个元素时，最大和的最小值。很容易得到方程： f(i)=\min \limits_{sum[j+1...i]]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2918 Tudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2918%2F</url>
    <content type="text"><![CDATA[题目地址 题解基本同26761234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); for(int TT=1;TT&lt;=T;TT++)&#123; printf("Scenario #%d:\n",TT); tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); if(!tot&amp;&amp;!flag)print(); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2676 Sudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2676%2F</url>
    <content type="text"><![CDATA[题目地址 题解一道很经典的题。用的是NOIP2009的程序，没加修改就过了。总体上来说有2个大优化 记录了每一个空的位置 每次找可能的数字最少的空搜 0ms过，还行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); while(T--)&#123; tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3764 The xor-longest Path]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3764%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出从根出发到每一个点的异或距离，然后问题转化为在这些距离中找两个异或值最大的。这是个经典问题，只需要在用trie树查询时进行反向行走即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt;using namespace std;typedef unsigned int ll;struct Tree&#123; int l,r; Tree()&#123;l=r=-1;&#125;&#125;;typedef struct&#123; int v,_next; ll cost;&#125;Edge;Edge edge[200005];int cnt=0,at[100005]; void addedge(int _u,int _v,ll _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int n,siz=1;Tree tr[3000005];ll vx[100005];bool vis[100005];void Trie_insert(ll num)&#123; //printf("%u\n",num); for(ll j=(1&lt;&lt;31),cur=0;j;j&gt;&gt;=1) if((j&amp;num)==0)&#123;//l:0 r:1 if(tr[cur].l&lt;0) tr[cur].l=siz++; cur=tr[cur].l; &#125;else&#123; if(tr[cur].r&lt;0) tr[cur].r=siz++; cur=tr[cur].r; &#125;&#125;ll Trie_search(ll x)&#123; ll res=0; for(ll j=1&lt;&lt;31,cur=0;j;j&gt;&gt;=1)&#123; if(x&amp;j)&#123; if(tr[cur].l&gt;0)res+=j,cur=tr[cur].l; else cur=tr[cur].r; &#125;else&#123; if(tr[cur].r&gt;0)res+=j,cur=tr[cur].r; else cur=tr[cur].l; &#125; &#125; return res;&#125;void dfs(int cur,ll val)&#123; for(int i=at[cur];i!=-1;i=edge[i]._next)&#123; int _v=edge[i].v; if(!vis[_v]) vis[_v]=1, vx[_v]=val^edge[i].cost, Trie_insert(vx[_v]), dfs(_v,vx[_v]); &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=0;i&lt;siz;i++) tr[i].l=tr[i].r=-1; siz=1,cnt=0; memset(at,-1,sizeof(at)); memset(vis,0,sizeof(vis)); int u,v;ll c; for(int i=0;i&lt;n-1;i++) scanf("%d%d%u",&amp;u,&amp;v,&amp;c), addedge(u,v,c), addedge(v,u,c); dfs(0,0); vx[0]=0; //Trie_insert(0u); ll ans=0; for(int i=0;i&lt;n;i++) ans=max(ans,Trie_search(vx[i])); printf("%u\n",ans); &#125; return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2142 The Balance]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2142%2F</url>
    <content type="text"><![CDATA[题目地址 题解注意$a$,$b$可以交换位置。之后就是简单的解方程了。要使$|x|+|y|$最小，需要保证$x$最小，之后保证$y$最小即可。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,d,x1,x2,y1,y2;ll gcd(ll aa,ll bb)&#123; return bb?gcd(bb,aa%bb):aa;&#125;ll extgcd(ll aa,ll bb,ll &amp;xx,ll &amp;yy)&#123; if(!bb)&#123; xx=1,yy=0; return aa; &#125; ll dd=extgcd(bb,aa%bb,yy,xx); yy-=(aa/bb)*xx; return dd;&#125;ll Abs(ll x)&#123; return (x&lt;0)?(-x):x;&#125;void work(ll a_,ll b_,ll &amp;x,ll &amp;y)&#123; ll g=extgcd(a_,b_,x,y),t=b_/g; x*=d/g,x=(x%t+t)%t; y=Abs((a_*x-d)/b_);&#125;int main()&#123; for(;;)&#123; scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;d); if(!a&amp;&amp;!b&amp;&amp;!d)break; work(a,b,x1,y1); work(b,a,x2,y2); if(x1+y1&lt;x2+y2)printf("%lld %lld\n",x1,y1); else printf("%lld %lld\n",y2,x2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1811 Prime Test]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1811%2F</url>
    <content type="text"><![CDATA[题目地址 题解算导上面有讲解。用MillerRabin和PollardRho合力解决。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int T;ll prime[]=&#123;2,3,5,7,11,13,17,19,23,61&#125;;ll gcd(ll a,ll b)&#123; return (!b)?a:gcd(b,a%b);&#125;ll mul(ll a,ll b,ll c)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%c; a=(a+a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll Pow(ll a,ll b,ll c)&#123; ll res=1; a%=c; while(b)&#123; if(b&amp;1)res=mul(res,a,c); a=mul(a,a,c),b&gt;&gt;=1; &#125; return res;&#125;bool witness(ll a,ll n,ll d,ll r)&#123; ll t=Pow(a,d,n),_t=t; for(ll i=1;i&lt;=r;i++)&#123; t=mul(t,t,n); if(t==1&amp;&amp;_t!=1&amp;&amp;_t!=n-1) return 1; _t=t;//基于二次探测定理的操作 &#125; if(t!=1)return 1;//基于费马小定理的操作 return 0;&#125;bool Miller_Rabin(ll n)&#123;//1:质数 if(n==2)return 1; if(n&lt;=1||n%2==0)return 0; for(int i=0;i&lt;10;i++) if(n==prime[i])return 1; ll R=n-1,S=0; for(;R%2==0;R&gt;&gt;=1,S++);//n-1=d*2^r for(int i=0;i&lt;10;i++)//10:测试次数 if(witness(prime[i],n,R,S)) return 0; return 1;&#125;//根据算导，c最好不要是0或者2...//为什么呢？ ll Pollard_Rho(ll n,ll c)&#123; ll x=Pow(rand(),rand(),n),y=x,k=2,d=1,t; for(ll i=1;d==1;i++)&#123; x=(mul(x,x,n)+c)%n; if(x-y&lt;0)t=y-x; else t=x-y; d=gcd(t,n); if(i==k)y=x,k&lt;&lt;=1; &#125; return d;&#125;ll dfs(ll n)&#123; if(n==1)return 1; if(Miller_Rabin(n))return n; ll fac=n,Lans,Rans; while(fac==n) fac=Pollard_Rho(n,rand()%(n-1)+1); Lans=dfs(fac),Rans=dfs(n/fac); return min(Lans,Rans);&#125;void init()&#123; scanf("%d",&amp;T); srand('z'+'q'+'y'+'1'+'0'+'1'+'8'+1);&#125;void solve()&#123; while(T--)&#123; ll N; scanf("%lld",&amp;N); ll ans=dfs(N); if(ans==N)printf("Prime\n"); else printf("%lld\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2774 Long Long Message]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2774%2F</url>
    <content type="text"><![CDATA[题目地址 题解就是求最长公共子串哈希+排序+二分=暴力卡过哈希要用unsigned long long，用unsigned int极其容易撞车12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef unsigned long long ui;char a[200005],b[200005];ui P=1000000007,list[200005],h1[200005],h2[200005],pow1[200005];int l1,l2;bool check(int c)&#123; int i,j;ui t; for(i=1;i&lt;=l1-c+1;i++) list[i-1]=h1[i+c-1]-h1[i-1]*pow1[c]; sort(list,list+l1-c); for(i=1;i&lt;=l2-c+1;i++)&#123; t=h2[i+c-1]-h2[i-1]*pow1[c]; if((*lower_bound(list,list+l1-c,t))==t) return true; &#125; return false;&#125;int main()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b); int i,j,l,r,md; for(pow1[0]=1,i=1;i&lt;=200000;i++) pow1[i]=pow1[i-1]*P; for(i=1;i&lt;=l1;i++) h1[i]=h1[i-1]*P+a[i-1]; for(i=1;i&lt;=l2;i++) h2[i]=h2[i-1]*P+b[i-1]; l=0,r=min(l1,l2); //用b匹配a while(l&lt;r)&#123; md=l+(r-l+1)/2; if(check(md)) l=md; else r=md-1; &#125; printf("%d\n",r); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2348 Euclid's Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2348%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设$a&gt;b$。显然当$a\mod b=0$时，先手必胜。当$a\mod b\neq 0$时，若$a&gt;2b$，则可以证明在接下来先手所有可以采取的$k$种策略中必有必胜策略，故这个也是必胜态。我讲的比较浅显，各位不妨看下《挑战程序设计竞赛》的P310。123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,f;int main()&#123; for(;;)&#123; scanf("%lld%lld",&amp;a,&amp;b); if(!a&amp;&amp;!b)break; f=1; for(;;)&#123; if(a&lt;b)swap(a,b); if(a%b==0)break; if(a&gt;2*b)break; a-=b,f^=1; &#125; if(f)printf("Stan wins\n"); else printf("Ollie wins\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2484 A Funny Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2484%2F</url>
    <content type="text"><![CDATA[题目地址 题解 当$n=1$或者$n=2$时，明显先手必胜。当$n=3$时，明显先手必败。由于每次只可取$1$或$2$个，而取$2$个时，$2$个必须相邻，推断有：当$n&gt;3$时，若$n$为偶数，先手无论如何取，后手可在先手对称的位置上取同等数量，于是先手必败。若$n$为奇数，先手取$1$个时，后手可在先手对称的位置上取$2$个，之后无论先手如何取，后手都可在先手对称的位置上取同等数量，先手必败。如果先手一开始取$2$个时，后手可在先手对称的位置上取$1$个,之后还剩下偶数个,可如上推出先手必败。故当$n&gt;3$时,先手必败(来自链接) 这种模仿对手以判断是否是必胜的思想方式很有效，学到了。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int main()&#123; int n; for(;;)&#123; scanf("%d",&amp;n); if(!n)break; printf("%s\n",(n&lt;=2)?"Alice":"Bob"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1306 Combinations]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1306%2F</url>
    <content type="text"><![CDATA[题目地址 题解计算组合数即可12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef unsigned long long ll;ll C[105][105];ll read()&#123; ll x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void build()&#123; for(ll i=0;i&lt;=100;i++) C[i][0]=1; for(ll i=1;i&lt;=100;i++) for(ll j=1;j&lt;=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];&#125; int main()&#123; build(); ll u,v; for(;;)&#123; u=read(),v=read(); if(!u&amp;&amp;!v)return 0; printf("%llu things taken %llu at a time is %llu exactly.\n",u,v,C[u][v]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1285 Combinations, Once Again]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1285%2F</url>
    <content type="text"><![CDATA[题目地址 题解用基本的背包处理即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n[56],N,q,r;ll f[56];void packX(int d)&#123; int p=1,_n,j; for(j=N;j&gt;=0;j--) for(_n=1;_n&lt;=min(n[d],j);_n++) f[j]+=f[j-_n];&#125; int main()&#123; int i,j,T=1; for(;;T++)&#123; memset(n,0,sizeof(n)); memset(f,0,sizeof(f)); scanf("%d%d",&amp;N,&amp;q); if(!N&amp;&amp;!q)break; for(i=0;i&lt;N;i++) scanf("%d",&amp;j), n[j-1]++; for(f[0]=1ll,i=0;i&lt;N;i++) packX(i); printf("Case %d:\n",T); for(i=0;i&lt;q;i++) scanf("%d",&amp;r), printf("%lld\n",f[r]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Paired Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3669%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。按照产奶时间从大到小排序，然后小的和大的配对，更新最长时间即可。这不是普及组原题么123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P p[100005];int n,ans=0;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)p[i].second=read(),p[i].first=read(); sort(p+1,p+1+n);&#125;void solve()&#123; int po=n; for(int i=1;i&lt;=n;i++)&#123; while(po&gt;i&amp;&amp;p[i].second&gt;=p[po].second)&#123; if(p[po].second) p[i].second-=p[po].second,ans=max(ans,p[i].first+p[po].first); po--; &#125; if(po==i)break; p[po].second-=p[i].second; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Bovine Genomics S]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3670%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟吧。没想到更加优秀的做法。时间复杂度：$O(nm^3)$123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,ans=0,vis[100],key[256];char dna[1005][55];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n+n;i++)scanf("%s",dna[i]); key['A']=0,key['C']=1,key['G']=2,key['T']=3;&#125;void solve()&#123; int code,tot=0,flag=0; for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=j+1;k&lt;m;k++)&#123; tot++,flag=0; for(int t=1;t&lt;=n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; vis[code]=tot; &#125; for(int t=n+1;t&lt;=n+n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; if(vis[code]==tot)&#123; flag=1;break; &#125; &#125; if(!flag)ans++; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16JAN Radio Contact]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3133%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP。按照时间变化递推即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,pos1[1005][2],pos2[1005][2],f[1005][1005];char s1[1005],s2[1005];void movement(char c,int &amp;x,int &amp;y)&#123; if(c=='N')y++;if(c=='S')y--; if(c=='E')x++;if(c=='W')x--;&#125;int sqr(int a,int b)&#123; return (pos1[a][0]-pos2[b][0])*(pos1[a][0]-pos2[b][0])+ (pos1[a][1]-pos2[b][1])*(pos1[a][1]-pos2[b][1]);&#125;void init()&#123; n=read(),m=read(); pos1[0][0]=read(),pos1[0][1]=read(); pos2[0][0]=read(),pos2[0][1]=read(); scanf("%s%s",s1+1,s2+1); for(int i=1,x=pos1[0][0],y=pos1[0][1];i&lt;=n;i++) movement(s1[i],x,y), pos1[i][0]=x,pos1[i][1]=y; for(int i=1,x=pos2[0][0],y=pos2[0][1];i&lt;=m;i++) movement(s2[i],x,y), pos2[i][0]=x,pos2[i][1]=y;&#125;void solve()&#123; memset(f,0x14,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++) f[i][0]=f[i-1][0]+sqr(i,0); for(int i=1;i&lt;=m;i++) f[0][i]=f[0][i-1]+sqr(0,i); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[i][j]=min(f[i-1][j],f[i][j-1]), f[i][j]=min(f[i][j],f[i-1][j-1]), f[i][j]+=sqr(i,j); printf("%d\n",f[n][m]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16FEB Load Balancing]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3138%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。拿线扫描，然后直接模拟。可以二分，套上线段树可以做到$O(nlogn)$的复杂度。实际上应该不需要离散化。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P pp[1005],p1[1005],p2[1005];int n;int cmp(P a,P b)&#123; return a.second&lt;b.second||(a.second==b.second&amp;&amp;a.first&lt;b.first);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)pp[i].first=read(),pp[i].second=read(); sort(pp+1,pp+n+1); int cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].first==pp[i].first) pp[i-1].first=cnt; else pp[i-1].first=cnt,cnt+=2; &#125; pp[n].first=cnt; memcpy(p1+1,pp+1,sizeof(P)*n); sort(pp+1,pp+n+1,cmp); cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].second==pp[i].second) pp[i-1].second=cnt; else pp[i-1].second=cnt,cnt+=2; &#125; pp[n].second=cnt; memcpy(p2+1,pp+1,sizeof(P)*n); //离散化之后分别按照x,y坐标排序，进行扫描。。。 &#125;void solve()&#123; //a | c //------- //b | d //一开始放在最左点左边，最下点下面 int a=0,b=0,c=0,d=0,A=0,B=n,sep,ans=n,maxi; p1[0].first=0,p2[0].second=0; for(int i=1;i&lt;=n;i++,A++,B--)&#123; if(p1[i].first==p1[i-1].first)continue; a=A,c=B,b=d=0; sep=p1[i].first-1; for(int j=1;j&lt;=n;j++)&#123; if(p2[j].second!=p2[j-1].second)&#123; maxi=0; if(maxi&lt;a)maxi=a;if(maxi&lt;b)maxi=b; if(maxi&lt;c)maxi=c;if(maxi&lt;d)maxi=d; if(maxi&lt;ans)ans=maxi; &#125; if(p2[j].first&lt;sep) a--,b++; else c--,d++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN Diamond Collector]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3143%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。先排序，对于每一个钻石枚举他能到的最长区间，然后看他之前的和他这个区间不相交的最长区间。统计答案即可，时间复杂度$O(nlogn)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int a[100005],n,k,b[100005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1);&#125;void solve()&#123; int lst=0,ans=0,maxi=0; for(int i=1;i&lt;=n;i++)&#123; int loc=lower_bound(a+1,a+n+1,a[i]+k+1)-a-i; b[i]=loc; while(lst+b[lst+1]&lt;i) lst++,maxi=max(maxi,b[lst]); ans=max(ans,maxi+loc); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN 262144]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3147%2F</url>
    <content type="text"><![CDATA[题目地址 题解奇妙的做法。考虑倍增，由于合并必然是一整段连续的序列，所以设$f(i,j)$表示从$j$开始一直合并，直到出现$i$时的下标（开）。然后就可以倍增了。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int f[65][270000]=&#123;0&#125;,n,ans=0;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int u; scanf("%d",&amp;u),f[u][i]=i+1;//左闭右开 ans=max(ans,u); &#125;&#125;void solve()&#123; for(int i=2;i&lt;=60;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(!f[i][j]&amp;&amp;f[i-1][j]&amp;&amp;f[i-1][f[i-1][j]]) f[i][j]=f[i-1][f[i-1][j]], ans=max(ans,i); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO15OPEN Bessie Goes Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3123%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力枚举…单纯从经验上来说，这道题有背包的解法，但是讨论极其复杂，还不如套一堆循环。注意负数的处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//1B2E2S1I GOES 1M2Oll ans=0,cnt[7][7]=&#123;0&#125;;int n,mp[256];void init()&#123; n=read(); mp['B']=0,mp['E']=1,mp['S']=2, mp['I']=3,mp['G']=4,mp['O']=5, mp['M']=6; char ord[3]; ll u; for(int i=1;i&lt;=n;i++)&#123; scanf("%s%lld",ord,&amp;u); cnt[mp[ord[0]]][(u%7+7)%7]++; &#125;&#125;void solve()&#123; ll t1,t2,t3; for(int A=0;A&lt;7;A++) for(int B=0;B&lt;7;B++) for(int C=0;C&lt;7;C++) for(int D=0;D&lt;7;D++) for(int E=0;E&lt;7;E++) for(int F=0;F&lt;7;F++) for(int G=0;G&lt;7;G++)&#123; t1=A+B+B+C+C+D,t2=B+C+E+F,t3=G+F+F; if(t1%7==0||t2%7==0||t3%7==0) ans+=cnt[0][A]*cnt[1][B]*cnt[2][C]*cnt[3][D] *cnt[4][E]*cnt[5][F]*cnt[6][G]; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14FEB Roadblock]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2176%2F</url>
    <content type="text"><![CDATA[题目地址 题解先跑一次最短路，然后对最短路上的边进行操作即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;int mp[105][105],E,V,vis[105],d[105],pre[105];void dijkstra(int o)&#123; int lst,at,i,j; fill(d,d+V,INF); memset(vis,0,sizeof(vis)); if(o)memset(pre,-1,sizeof(pre)); d[0]=0; for(i=0;i&lt;V;i++)&#123; for(lst=INF,j=0;j&lt;V;j++) if(!vis[j]&amp;&amp;d[j]&lt;lst)at=j,lst=d[j]; vis[at]=1; for(j=0;j&lt;V;j++) if(d[j]&gt;d[at]+mp[at][j])&#123; d[j]=d[at]+mp[at][j]; if(o)pre[j]=at; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); memset(mp,0x3f,sizeof(mp)); int i,j,u,v,ans=0,rec; for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;j), u--,v--,mp[u][v]=mp[v][u]=j; dijkstra(1),rec=d[V-1]; for(i=V-1;i!=-1;i=pre[i]) if(pre[i]!=-1) mp[i][pre[i]]&lt;&lt;=1, mp[pre[i]][i]&lt;&lt;=1, dijkstra(0), ans=max(ans,d[V-1]-rec), mp[i][pre[i]]&gt;&gt;=1, mp[pre[i]][i]&gt;&gt;=1; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Sabotage]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2115%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分答案，设为$ans$，那么判定条件 C(ans):\exists [i,j],\frac {sum[n]-sum[i...j]}{n-(j-i+1)}\le ans移项，等价于 sum[n]-ans\times n\le sum[j]-ans\times j-(sum[i-1]-ans\times (i-1))求右边的最大值即可。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[100005];double eps=1e-4,sum[100005]=&#123;0&#125;; bool C(double ans)&#123; double mini=sum[1]-ans,maxi=sum[2]-2*ans-(sum[1]-ans); for(int i=2;i&lt;n;i++)&#123; maxi=max(maxi,sum[i]-(double)i*ans-mini); mini=min(mini,sum[i]-(double)i*ans); &#125; return (sum[n]-(double)n*ans&lt;=maxi);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];&#125;void solve()&#123; double L=0,R=(a[1]+a[n])*0.5,M; while(R-L&gt;eps)&#123; M=(R+L)*0.5; if(C(M))R=M;else L=M; &#125; printf("%.3lf\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Mooo Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2214%2F</url>
    <content type="text"><![CDATA[题目地址 题解一开始很智障的每一步都求了一个背包…实际上只要求一次，然后$O(1)$回答询问。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,b,v[1005],s[100005],a[1005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125; void init()&#123; n=read(),b=read(); for(int i=1;i&lt;=b;i++)v[i]=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); &#125;void solve()&#123; int ans=0,cur=a[1]; memset(s,0x7f,sizeof(s)); s[0]=0; for(int j=1;j&lt;=b;j++)&#123; int *A=s,*B=s+v[j]; for(;B-s&lt;=100000;A++,B++)&#123; *B=min(*B,*A+1); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cur=a[i]-a[i-1]; if(a[i-1])cur++; if(s[cur]==0x7f7f7f7f)&#123; ans=-1;break; &#125;else ans+=s[cur]; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12JAN Video Game Combos]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3041%2F</url>
    <content type="text"><![CDATA[题目地址 题解AC自动机学了一天之后，终于想明白了一件事：为什么有时候按照AC图的递推形式不用$fail$?因为在$buildfail$的时候，已经利用了“指向的点要打上同样结束标记的性质”。这样貌似就无形之中运用了$fail$数组。真是神奇的东西啊。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,que[10005],f,r;char T[10005],tmp[10005];int trie[10005][26]=&#123;0&#125;,cnt=0;int val[10005];int fail[10005],SIG_SIZE=26;int dp[1005][305]=&#123;0&#125;;bool vis[1005][305]=&#123;0&#125;;//0-&gt;rootvoid trie_insert(char *a)&#123; int p=0; for(;*a;a++)&#123; if(!trie[p][*a-'A']) trie[p][*a-'A']=++cnt; p=trie[p][*a-'A']; &#125; val[p]++;&#125;void getFail()&#123; f=r=0,fail[0]=0; for(int i=0;i&lt;SIG_SIZE;i++)&#123; int h=trie[0][i]; if(h) fail[h]=0,que[r++]=h; &#125; while(r-f)&#123; int h=que[f++],i,_v,f; for(i=0;i&lt;SIG_SIZE;i++)&#123; _v=trie[h][i]; if(!_v)&#123; trie[h][i]=trie[fail[h]][i]; continue; &#125; que[r++]=_v,f=fail[h]; for(;f&amp;&amp;!trie[f][i];f=fail[f]); fail[_v]=trie[f][i]; val[_v]+=val[fail[_v]];// &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",tmp),trie_insert(tmp); getFail(); for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=cnt;j++) dp[i][j]=-2000000000; dp[0][0]=0; for(int i=1;i&lt;=m;i++)&#123; for(int j=0;j&lt;=cnt;j++)&#123; int x; for(int k=0;k&lt;3;k++)&#123; x=trie[j][k]; dp[i][x]=max(dp[i][x],dp[i-1][j]+val[x]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;=cnt;i++) ans=max(ans,dp[m][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12OPEN Bookshelf]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1848%2F</url>
    <content type="text"><![CDATA[题目地址 题解同poj cut the sequence然而开始我还没发现这是原题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,l=1,r=1,que[100005];ll m,h[100005],w[100005],f[100005];multiset&lt;ll&gt; s;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;h[i],&amp;w[i]);&#125;void solve()&#123; ll cnt=0,ans_; int j=0;//左边是开区间,que[l...r]递减 for(int i=1;i&lt;=n;i++)&#123; cnt+=w[i]; while(cnt&gt;m)cnt-=w[++j]; while(r-l&amp;&amp;que[l]&lt;=j)&#123; if(r-l&gt;1) s.erase(h[que[l+1]]+f[que[l]]); //在读这一段代码的时候，请仔细思考。 //有两个，更大的在l，更小的在l+1 l++; &#125; while(r-l&amp;&amp;h[que[r-1]]&lt;=h[i])&#123; if(r-l&gt;1) s.erase(h[que[r-1]]+f[que[r-2]]); r--; &#125; que[r++]=i; if(r-l&gt;1&amp;&amp;i&gt;que[r-2])s.insert(h[i]+f[que[r-2]]); ans_=*s.begin(); f[i]=h[que[l]]+f[j]; if(r-l&gt;1&amp;&amp;ans_&lt;f[i])f[i]=ans_; &#125; printf("%lld\n",f[n]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Cow Line]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3014%2F</url>
    <content type="text"><![CDATA[题目地址 题解虽然可以用高中数学题的思路，但也可以用康拓展开。实现上估计差别不会很大。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40],vis[30];ll fac[40];void makep()&#123; ll x,t;int rk,j,k; scanf("%lld",&amp;x); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; t=0; for(j=1;j&lt;=n-i+1;j++)&#123; if(x&lt;=t+fac[n-i])break; t+=fac[n-i]; &#125; x-=t,rk=0; for(k=1;k&lt;=n;k++)&#123; if(!vis[k])rk++; if(rk==j)break; &#125; printf("%d ",k); vis[k]=1; &#125; for(int i=1;i&lt;=n;i++) if(!vis[i])printf("%d\n",i);&#125;ll query()&#123; ll ans=0;int rk,j,k; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; rk=0; for(k=1;k&lt;a[i];k++) if(!vis[k])rk++; vis[a[i]]=1; ans+=(ll)rk*fac[n-i]; &#125; return ans+1;&#125;void init()&#123; n=read(),m=read(); fac[1]=fac[0]=1; for(int i=2;i&lt;=20;i++)fac[i]=fac[i-1]*(ll)i;&#125;void solve()&#123; char ord[3]; while(m--)&#123; scanf("%s",ord); if(ord[0]=='P')makep(); else&#123; for(int i=1;i&lt;=n;i++)a[i]=read(); printf("%lld\n",query()); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Generic Cow Protest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1569%2F</url>
    <content type="text"><![CDATA[题目地址 题解水$DP$，设$f(i)$为以$i$为某一组结尾的最大组数，那么 f(i)=\max \limits_{0\le j]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11DEC Grass Planting]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3038%2F</url>
    <content type="text"><![CDATA[题目地址 题解树剖，不过是边问题，所以把边问题改成边的下面那个点的问题。处理的时候注意一下即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int v,_next; &#125;; Edge edge[200005];int cnt=0,at[100005]=&#123;0&#125;;int fa[100005],son[100005]=&#123;0&#125;,siz[100005],top[100005],depth[100005],pos[100005],fp[100005],val[100005];int S,nows=0,n,m,_a,_b,C[400005];int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int k,int v)&#123; while(k&lt;=S)C[k]+=v,k+=lowbit(k);&#125;int query(int r)&#123; int res=0; while(r)res+=C[r],r-=lowbit(r); return res;&#125;void addedge(int _u,int _v)&#123; edge[++cnt].v=_v, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; void dfs1(int x,int par,int d)&#123; depth[x]=d,fa[x]=par,siz[x]=1; for(int i=at[x];i;i=edge[i]._next)&#123; if(edge[i].v==par)continue; int _v=edge[i].v; dfs1(_v,x,d+1); siz[x]+=siz[_v]; if(!son[x]||siz[_v]&gt;siz[son[x]]) son[x]=_v; &#125;&#125;void dfs2(int x,int tp)&#123; top[x]=tp,pos[x]=++nows,fp[nows]=x; if(!son[x])return; dfs2(son[x],tp); for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa[x]&amp;&amp;edge[i].v!=son[x]) dfs2(edge[i].v,edge[i].v);&#125;void update_tr(int u,int v)&#123; while(top[u]!=top[v])&#123; if(depth[top[u]]&lt;depth[top[v]]) swap(u,v); update(pos[top[u]],1); update(pos[u]+1,-1); u=fa[top[u]]; &#125; if(depth[u]&lt;depth[v])swap(u,v); if(u==v)return ; v=son[v]; update(pos[u]+1,-1); update(pos[v],1);&#125;int query_tr(int u,int v)&#123; if(depth[u]&lt;depth[v])swap(u,v); return query(pos[u]);&#125;void init()&#123; n=read(),m=read(); for(S=1;S&lt;=n;S&lt;&lt;=1); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; dfs1(1,0,1); dfs2(1,1);&#125;void solve()&#123; char ord[3]; int x,y; while(m--)&#123; scanf("%s%d%d",ord,&amp;x,&amp;y); if(ord[0]=='P')update_tr(x,y); else printf("%d\n",query_tr(x,y)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11NOV Cow Steeplechase]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3033%2F</url>
    <content type="text"><![CDATA[题目地址 题解把线段抽象成点，线段相交就连一条边，然后求一个最大独立集。由于在二分图中，最大匹配就等于最小顶点覆盖，并且对于图来说，最大独立集加上最小顶点覆盖就等于点个数，所以直接上二分图匹配就行了。线段求交…计算几何123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,vis[255],match[255]=&#123;0&#125;,seg[255][4];int X[255],Y[255],cx=0,cy=0;bool mat[255][255]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int Edmond(int S)&#123; for(int i=1;i&lt;=cy;i++)&#123; if(mat[S][i]&amp;&amp;!vis[i])&#123; vis[i]=1; if(!match[i]||Edmond(match[i]))&#123; match[i]=S; return 1; &#125; &#125; &#125; return 0;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=4;j++) seg[i][j]=read(); if(seg[i][1]==seg[i][3])&#123; Y[++cy]=i;//竖直 if(seg[i][2]&gt;seg[i][4]) swap(seg[i][2],seg[i][4]); &#125;else &#123; X[++cx]=i;//水平 if(seg[i][1]&gt;seg[i][3]) swap(seg[i][1],seg[i][3]); &#125; &#125; for(int i=1;i&lt;=cx;i++) for(int j=1;j&lt;=cy;j++) if(seg[Y[j]][1]&gt;=seg[X[i]][1]&amp;&amp;seg[Y[j]][1]&lt;=seg[X[i]][3]&amp;&amp; seg[X[i]][2]&gt;=seg[Y[j]][2]&amp;&amp;seg[X[i]][2]&lt;=seg[Y[j]][4]) mat[i][j]=1;&#125;void solve()&#123; int ans=0; for(int i=1;i&lt;=cx;i++)&#123; memset(vis,0,sizeof(vis)); if(Edmond(i))ans++; &#125; printf("%d\n",n-ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最大匹配</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Chocolate buying]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2983%2F</url>
    <content type="text"><![CDATA[题目地址 题解差点写成多重背包，好险好险其实就是水贪心…1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n;ll b;pair&lt;ll,ll&gt; P[100005];void init()&#123; scanf("%d%lld",&amp;n,&amp;b); for(int i=0;i&lt;n;i++) scanf("%lld%lld",&amp;P[i].first,&amp;P[i].second);&#125;void solve()&#123; ll ans=0; sort(P,P+n); for(int i=0;i&lt;n;i++)&#123; if(b&lt;P[i].first)break; ll res=min(b/P[i].first,P[i].second); ans+=res; b-=res*P[i].first; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Treasure Chest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3004%2F</url>
    <content type="text"><![CDATA[题目地址 题解$DP$。时间复杂度为$O(n^2)$。我的方法是设$f(i,j)$表示从$i$到$j$先手最高分数，然后转移方程就是 f(i,j)=\max \left\{ c[i]+\min\left\{f(i+2,j),f(i+1,j-1)\right\} ,c[j]+\min\left\{f(i+1,j-1),f(i,j-2)\right\}\right\}但不知道为什么本机过了,洛谷上T了。当然本题的官方做法更巧妙。观察前面带有$\min$的式子，我们发现里面的$\min$可以拿掉，因为我们刚好也算出了第二个人作为先手的最大解。所以上面的$\min$就可以表示为$f$的形式，即 \min \left\{ f(i+2,j),f(i+1,j-1) \right\} =sum(i+1,j)-f(i+1,j)这样常数貌似很小，就可以过，还可以干掉一维空间。 修改前：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005][5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=0;i&lt;n;i++)c[i]=read();&#125;void solve()&#123; int d1,d2,d3,b1,b2,lim; for(int i=0;i&lt;n;i++) dp[i][i]=c[i]; for(int j=0;j&lt;n-1;j++) dp[j][j+1]=max(c[j],c[j+1]); for(int j=2;j&lt;n;j++)&#123; d1=dp[0][j-2],d2=dp[1][j-1],d3=dp[2][j]; lim=n-j; for(int i=0;i&lt;lim;i++)&#123; b1=d3;if(d2&lt;d3)b1=d2;b1+=c[i]; b2=d1;if(d2&lt;d1)b2=d2;b2+=c[i+j]; dp[i][i+j]=b1;if(b1&lt;b2)dp[i][i+j]=b2; d1=d2,d2=d3,d3=dp[i+3][i+1+j]; &#125; &#125; printf("%d\n",dp[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125; 修改后：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005]=&#123;0&#125;,sum[5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)c[i]=read(),sum[i]=sum[i-1]+c[i];&#125;void solve()&#123; for(int j=0;j&lt;n;j++) for(int i=1;i+j&lt;=n;i++) dp[i]=sum[i+j]-sum[i-1]-min(dp[i],dp[i+1]); printf("%d\n",dp[1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09MAR Look Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2947%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力肯定行不通，考虑到无用元素的去除以及单调性的维护，我们使用单调栈这一数据结构。实际上这题跟06年那道题一个意思，所以要看的话可以去前面找一下我写的另一篇题解。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int n,s[100005][2],dat[100005],top=0,ans[100005];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;dat[i]); s[top][0]=dat[n-1], s[top++][1]=n-1, ans[n-1]=-1; for(int i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;dat[i]&gt;=s[top-1][0]) top--; if(!top)ans[i]=-1; else ans[i]=s[top-1][1]; s[top][0]=dat[i], s[top++][1]=i; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09OPEN Cow Digit Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2953%2F</url>
    <content type="text"><![CDATA[题目地址 题解很标准的博弈论递推。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool sg[1000005];void init()&#123; sg[0]=0; int bit[9]=&#123;0&#125;,maxi,mini,len=1; for(int i=1;i&lt;=1000000;i++)&#123; bit[0]++; for(int j=0;bit[j]==10&amp;&amp;j&lt;len;j++) bit[j]=0,bit[j+1]++; if(bit[len])len++; mini=10,maxi=0; for(int j=0;j&lt;len;j++)&#123; if(bit[j]&gt;maxi)maxi=bit[j]; if(bit[j]&lt;mini&amp;&amp;bit[j])mini=bit[j]; &#125; if(!sg[i-maxi]||!sg[i-mini])sg[i]=1; &#125;&#125;void solve()&#123; int T=read(),n; while(T--) n=read(),printf("%s\n",sg[n]?"YES":"NO");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09NOV A Coin Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2964%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$dp(i,j)$表示还剩$i$个，之前选了$j$个的状态。正面非常不好做，所以要用这个倒着推的状态。转移只要$2$个，因为其他转移之前已经包含了。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int dp[2005][2005],n,a[2005],sum[2005],que[4000005][2],f=0,r=0;void init()&#123; n=read(); sum[0]=0; for(int i=n;i&gt;=1;i--)a[i]=read(); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; //正面不好写 &#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=dp[i][j-1]; if(i-2*j&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j][2*j]); if(i-2*j+1&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j+1][2*j-1]); &#125; &#125; printf("%d\n",dp[n][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09FEB Revamping Trails]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2939%2F</url>
    <content type="text"><![CDATA[题目地址 题解最短路模型，这很显然。顺带一提，不要用SPFA，真心卡成狗。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 1010000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int to,_next,cost;&#125;;struct Node&#123; int h,e,dis; Node(int h_,int e_,int d_)&#123; h=h_,e=e_,dis=d_; &#125; Node()&#123;&#125;&#125;;bool operator &lt;(const Node &amp;n1,const Node &amp;n2)&#123; return n1.dis&gt;n2.dis;&#125;priority_queue&lt;Node&gt; pq;Edge edge[100005];int n,m,k,at[10005]=&#123;0&#125;,F[10005][21]=&#123;0&#125;,cnt=0;void addedge(int u,int v,int c)&#123; edge[++cnt].to=v, edge[cnt].cost=c, edge[cnt]._next=at[u], at[u]=cnt;&#125;void Dij()&#123; F[1][0]=0,pq.push(Node(1,0,0)); Node tmp; int h_,e_,d_,v_,c_; while(!pq.empty())&#123; tmp=pq.top(),pq.pop(); if(tmp.dis&gt;F[tmp.h][tmp.e])continue; h_=tmp.h,e_=tmp.e,d_=tmp.dis; for(int i=at[h_];i;i=edge[i]._next)&#123; v_=edge[i].to,c_=edge[i].cost; if(F[v_][e_]&gt;F[h_][e_]+c_) F[v_][e_]=F[h_][e_]+c_, pq.push(Node(v_,e_,F[v_][e_])); if(e_&lt;k&amp;&amp;F[v_][e_+1]&gt;F[h_][e_]) F[v_][e_+1]=F[h_][e_], pq.push(Node(v_,e_+1,F[v_][e_+1])); &#125; &#125;&#125;void init()&#123; n=read(),m=read(),k=read(); int u,v,c; for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),c=read(); addedge(u,v,c),addedge(v,u,c); &#125;&#125;void solve()&#123; memset(F,0x3F,sizeof(F)); Dij(); int ans=INF*2; for(int i=0;i&lt;=k;i++)ans=min(ans,F[n][i]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08DEC Patting Heads]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2926%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力筛倍数即可。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,a[100005],cnt[1000005]=&#123;0&#125;,ans[1000005]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]),cnt[a[i]]++;&#125;void solve()&#123; for(int i=1;i&lt;=1000000;i++)&#123; if(cnt[i])&#123; for(int j=i;j&lt;=1000000;j+=i) ans[j]+=cnt[i]; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[a[i]]-1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08JAN Telephone Lines]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu1948%2F</url>
    <content type="text"><![CDATA[题目地址 题解一看就知道是二分答案的类型。二分最小费用$x$，然后看路上最少经过几条费用比他多的路。这题就一个地方有点绕：怎么求$1$-$n$之间路上有几条这样的路？要么边跑最短路边特判，要么把边分类，大于$x$的边权设$1$，小于的设$0$。这样就解决了这道题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next;&#125;;Edge edge[20005],_edge[20005];int V,E,K,at[1005],cnt=0,maxi=0;int d[1005],que[50005],f,r,in[1005]=&#123;0&#125;;void addedge(int _u,int _v,int _c)&#123; edge[cnt].v=_v, edge[cnt].cost=_c, edge[cnt]._next=at[_u], at[_u]=cnt++; &#125;void spfa_bfs(int S)&#123; fill(d,d+V,INF); d[S]=0; f=r=0,que[r++]=S,in[S]=1; while(r-f)&#123; int h=que[f++],_v,_c; for(int i=at[h];i!=-1;i=_edge[i]._next)&#123; _v=_edge[i].v,_c=_edge[i].cost; if(d[_v]&gt;d[h]+_c)&#123; d[_v]=d[h]+_c; if(!in[_v]) in[_v]=1,que[r++]=_v; &#125; &#125; in[h]=0; &#125;&#125;void init()&#123; scanf("%d%d%d",&amp;V,&amp;E,&amp;K); memset(at,-1,sizeof(at)); int u,v,c; for(int i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;c), addedge(u-1,v-1,c), addedge(v-1,u-1,c), maxi=max(maxi,c);&#125;void solve()&#123; int L=0,R=maxi,M; memcpy(_edge,edge,sizeof(edge)); while(R-L)&#123; int M=(R+L)/2; for(int i=0;i&lt;cnt;i++) _edge[i].cost=(edge[i].cost&gt;M); spfa_bfs(0); if(d[V-1]==INF)&#123; printf("-1\n"); return ; &#125; if(d[V-1]&gt;K)L=M+1; else R=M; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Time Management]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2920%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分+贪心每次优先完成期限最短且时间最短的任务。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,t[1005],s[1005],mini=INF;pair&lt;int,int&gt; P[1005];bool judge(int M)&#123; for(int i=0;i&lt;n;i++)&#123; if(M+P[i].second&lt;=P[i].first) M+=P[i].second; else return 0; &#125; return 1;&#125;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;t[i],&amp;s[i]), P[i].first=s[i],P[i].second=t[i], mini=min(mini,s[i]); sort(P,P+n);&#125;void solve()&#123; int L=0,R=mini,M; while(R-L)&#123; M=(R+L+1)/2; if(judge(M)) L=M; else R=M-1; &#125; if(!judge(0))L=-1; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR River Crossing]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2904%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP注意划船回来的时间12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int sum[2505],n,f[2505]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%d",&amp;n,&amp;sum[0]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;sum[i]), sum[i]+=sum[i-1];&#125;void solve()&#123; fill(f,f+n+1,INF); f[0]=0; for(int i=1;i&lt;=n;i++) for(int j=i-1;j&gt;=0;j--) f[i]=min(f[i],f[j]+sum[i-j]+sum[0]); printf("%d\n",f[n]-sum[0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OPEN Cow Neighborhoods]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2906%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个绝对值很难搞啊。拆开来试试看？ |x_1-x_2|+|y_1-y_2|=x_1-x_2+y_1-y_2或x_2-x_1+y_1-y_2或x_1-x_2+y_2-y_1或x_2-x_1+y_2-y_1发现前两个是相反数，中间俩也是。原式=|x_1+y_1-(x_ 2+y_2)|或|(x_1-y_1)-(x_2-y_2)|。这时候发现两个式子里面都是只与下标有关值的差，就设xx_i=x_i+y_i,yy_i=x_i-y_i。原式=|xx_1-xx_2|或|yy_1-yy_2|。我怎么知道取哪个?不知道，就让他们都满足。即使\max \left\{|xx_1-xx_2|,|yy_1-yy_2|\right\}\le c。之后就是乱搞了，维护一下差即可，用并查集合并可行部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,C,x[100005],y[100005],xx[100005],yy[100005],rk[100005];int par[100005],cnt[100005],ans1=0,ans2=0,S=0,ans,loc;int que[100005],f,r;struct Tr&#123; Tr *ch[2]; int r,v,id; int cmp(int w,int z) const &#123; if(w==v&amp;&amp;z==id)return -1; return w&gt;v||(w==v&amp;&amp;z&gt;id); &#125;&#125;;Tr tree[400005],*root=NULL;void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr,tr=k;&#125;void insert_tr(Tr* &amp;tr,int _v,int _id)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;v=_v,tr-&gt;id=_id; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); return ; &#125; int d=tr-&gt;cmp(_v,_id); insert_tr(tr-&gt;ch[d],_v,_id); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1);&#125;void delete_tr(Tr* &amp;tr,int _v,int _id)&#123; int d=tr-&gt;cmp(_v,_id); if(d==-1)&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),delete_tr(tr-&gt;ch[d_],_v,_id); &#125; &#125;else delete_tr(tr-&gt;ch[d],_v,_id);&#125; void previous(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&gt;=tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,previous(tr-&gt;ch[1],_v); else previous(tr-&gt;ch[0],_v);&#125;void success(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&lt;tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,success(tr-&gt;ch[0],_v); else success(tr-&gt;ch[1],_v);&#125;int Find(int k)&#123; if(k==par[k])return k; return (par[k]=(Find(par[k])));&#125;void Unite(int u,int v)&#123; if(Find(u)==Find(v))return; par[Find(u)]=Find(v);&#125;bool cmp(int ia,int ib)&#123; return xx[ia]&lt;xx[ib]||(xx[ia]==xx[ib]&amp;&amp;yy[ia]&lt;yy[ib]);&#125;void init()&#123; srand(21451); n=read(),C=read(); for(int i=1;i&lt;=n;i++) x[i]=read(),y[i]=read(),xx[i]=x[i]+y[i],yy[i]=x[i]-y[i],rk[i]=par[i]=i; sort(rk+1,rk+1+n,cmp);&#125;void solve()&#123; f=r=0,que[r++]=rk[1],insert_tr(root,yy[rk[1]],rk[1]); for(int i=2;i&lt;=n;i++)&#123; int index=rk[i]; while(r&gt;f&amp;&amp;xx[index]-xx[que[f]]&gt;C) delete_tr(root,yy[que[f]],que[f]),f++; ans=-INF,success(root,yy[index]);//查后缀 if(ans&gt;-INF&amp;&amp;ans-yy[index]&lt;=C)Unite(loc,index); ans=INF,previous(root,yy[index]);//查前缀 if(ans&lt;INF&amp;&amp;yy[index]-ans&lt;=C)Unite(loc,index); insert_tr(root,yy[index],index); que[r++]=index; &#125; for(int i=1;i&lt;=n;i++)cnt[Find(i)]++; for(int i=1;i&lt;=n;i++)ans1+=(cnt[i]!=0),ans2=max(ans2,cnt[i]); printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Eating Together]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2896%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一大力$O(nlogn)LIS$。优点：不容易错，缺点：时间复杂度高。 方法二运用特殊性质，分段$DP$，分别用$f(x),g(x),h(x)$表示以$1,2,3$为结尾的一段的最小修改次数。优点：时间复杂度线性缺点：容易错容易错容易错难调难调难调123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[30005],f[30005],g[30005],h[30005];void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();&#125;int dp()&#123; int mini,dif=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=1),f[i]=dif; dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=2),g[i]=mini+dif,mini=min(mini,f[i]-dif); dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=3),h[i]=mini+dif,mini=min(mini,min(g[i]-dif,f[i]-dif)); return min(f[n],min(g[n],h[n]));&#125;void solve()&#123; int ans=dp(); reverse(a+1,a+n+1); ans=min(ans,dp()); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Game of Lines]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2665%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力统计即可。wa了2次的我就是sb啊12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,x[205],y[205],tot=0;double lis[40005],eps=1e-8;double slope(int a,int b)&#123; if(x[a]==x[b])return 1e9; return (double)(y[b]-y[a])/(x[b]-x[a]);&#125;int cmp(double a,double b)&#123; return (a-b)&gt;-eps&amp;&amp;(a-b)&lt;eps;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)x[i]=read(),y[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;i;j++) lis[++tot]=slope(i,j); sort(lis+1,lis+tot+1); int ans=0; for(int i=2;i&lt;=tot;i++)&#123; while(cmp(lis[i],lis[i-1])&amp;&amp;i&lt;=tot) i++; ans++; &#125; if(!cmp(lis[tot],lis[tot-1]))ans++; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Watering Hole]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1550%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果没说全部连通的话就会形成一个特殊的局面：森林。把一个无向森林结合起来的常用方法就是加点。加一个超级源，使打井变成这个源到节点的边权，再MST即可。数据小，貌似暴力也行？12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int mat[405][405],w[405],n;int vis[405],mini[405];int prim(int S)&#123; memset(mini,0x3f,sizeof(mini)); mini[S]=0; int i,j,_min,at,ans=0; for(i=0;i&lt;n;i++)&#123; for(at=-1,j=0;j&lt;n;j++) if(!vis[j]&amp;&amp;(at&lt;0||mini[j]&lt;mini[at])) at=j; vis[at]=1,ans+=mini[at]; for(j=0;j&lt;n;j++) mini[j]=min(mini[j],mat[at][j]); &#125; return ans; &#125;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;w[i]); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(int i=0;i&lt;n;i++) mat[i][n]=mat[n][i]=w[i]; mat[n][n]=0; n++; printf("%d\n",prim(n-1)); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR Land Acquisition]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2900%2F</url>
    <content type="text"><![CDATA[题目地址 题解斜率优化。 合并部分土地，使$y$递减，$x$递增 注意单调队列的增减性。 决策的单调性… 凸壳的中间点在什么情况下一定不优？考虑不同的限定条件，可以证明两端分别在2种情况下都更优。这是单调队列单调的理由。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; P;P a[50005],b[50005];int n,cnt=0,que[50005]=&#123;0&#125;,l=1,r=1; ll f[50005];double slope(int j,int k)&#123; return (f[k]-f[j])/(b[j+1].second-b[k+1].second);&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i].first=read(),a[i].second=read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; //printf("%d %d\n",a[i].first,a[i].second); while(cnt&amp;&amp;a[i].second&gt;=b[cnt].second) cnt--; b[++cnt]=a[i]; &#125;&#125;void solve()&#123; que[r++]=0; for(int i=1;i&lt;=cnt;i++)&#123; while(r-l&gt;1&amp;&amp;slope(que[l],que[l+1])&lt;b[i].first) l++; f[i]=f[que[l]]+b[que[l]+1].second*b[i].first; while(r-l&gt;1&amp;&amp;slope(que[r-2],que[r-1])&gt;slope(que[r-1],i)) r--; que[r++]=i; &#125; printf("%lld\n",f[cnt]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OPEN Cheapest Palindrome]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2890%2F</url>
    <content type="text"><![CDATA[题目地址 题解区间DP没想出来的我该去看脑科12345678910111213141516171819202122232425262728293031323334353637 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,add[30],rem[30],dp[2005][2005];char s[2005],ord[3],is[2005][2005]=&#123;0&#125;;void init()&#123; scanf("%d%d%s",&amp;n,&amp;m,s); for(int i=0;i&lt;n;i++)&#123; scanf("%s",ord); scanf("%d%d",&amp;add[ord[0]-'a'],&amp;rem[ord[0]-'a']); &#125; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) dp[i][j]=(i&lt;j)?INF:0;&#125;void solve()&#123; for(int j=0;j&lt;m;j++) for(int i=0;i+j&lt;m;i++) if(s[i]==s[i+j])dp[i][i+j]=dp[i+1][i+j-1]; else&#123; dp[i][i+j]=min(dp[i+1][i+j]+rem[s[i]-'a'], min(dp[i+1][i+j]+add[s[i]-'a'], min(dp[i][i+j-1]+rem[s[i+j]-'a'], dp[i][i+j-1]+add[s[i+j]-'a']))); &#125; printf("%d\n",dp[0][m-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Protecting the Flowers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2878%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设牛$i$和牛$j$相邻，那么比较他们谁先送走更划算的依据是$T_iD_j$和$T_jD_i$。$T_iD_j&gt;T_jD_i$那么$j$先走，否则$i$先走。由此得判断依据：$\frac {T_i}{D_i}$与$\frac {T_j}{D_j}$。小的先走。之后排序贪心即可。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll n,t[100005],d[100005],ans=0,sum=0;pair&lt;double,ll&gt; P[100005];void init()&#123; scanf("%lld",&amp;n); for(ll i=0;i&lt;n;i++) scanf("%lld%lld",&amp;t[i],&amp;d[i]), P[i].first=(double)t[i]/d[i], P[i].second=i; sort(P,P+n); for(ll i=0;i&lt;n;i++) sum+=d[i];&#125;void solve()&#123; for(ll i=0;i&lt;n;i++)&#123; ll id=P[i].second; sum-=d[id]; ans+=2*t[id]*sum; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待考察 USACO07JAN Problem Solving]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2876%2F</url>
    <content type="text"><![CDATA[题目地址 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,b,f[605][305],A[305],B[305],sum[305],sumb[305],ans;void init()&#123; b=read(),n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(),B[i]=read(),sum[i]=sum[i-1]+A[i],sumb[i]=sumb[i-1]+B[i];&#125;void solve()&#123; f[2][0]=b; for(int i=1;i&lt;=n;i++) if(b&gt;=sum[i]&amp;&amp;b&gt;=sumb[i])f[2][i]=b-sumb[i]; else f[2][i]=-INF; for(int i=3;i&lt;=2*n;i++)&#123; f[i][0]=b; for(int j=1;j&lt;=n;j++)&#123; f[i][j]=-INF; for(int k=0;k&lt;=j;k++) if(f[i-1][k]-(sum[j]-sum[k])&gt;=0) f[i][j]=max(f[i][j],b-(sumb[j]-sumb[k])); &#125; if(f[i][n]&gt;=0)&#123; ans=i;break; &#125; &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OCT Obstacle Course]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1649%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力建图跑SPFA即可。就是要注意建图的方式：一个点拆成4个。同时注意输入，有坑！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[2000005];int cnt=0,at[40005],n,V;int d[40005],in[40005],que[500005],f=0,r=0;void spfa_bfs(int s)&#123; fill(d+1,d+4*V+1,INF); for(int i=0;i&lt;4;i++) d[s+i*V]=0,in[s+i*V]=1,que[r++]=s+i*V; int i,_u,_v,_co; while(r-f)&#123; _u=que[f++],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r++]=_v; &#125; &#125; &#125; &#125;&#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int xa,xb,ya,yb;char mat[105][105];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); char ord[1005]; int tot,len; for(int i=1;i&lt;=n;i++)&#123; fgets(ord,300,stdin); len=strlen(ord),tot=1; for(int j=0;j&lt;len;j++) if(!isspace(ord[j]))mat[i][tot++]=ord[j]; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(mat[i][j]=='A')xa=i,ya=j; else if(mat[i][j]=='B')xb=i,yb=j; V=n*n; memset(at,-1,sizeof(at)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(mat[i][j]=='x') continue; //1上2下3左4右 int id=(i-1)*n+j; addedge(id,2*V+id,1),addedge(2*V+id,id,1), addedge(id,V+id,2),addedge(V+id,id,2), addedge(id,3*V+id,1),addedge(3*V+id,id,1), addedge(2*V+id,V+id,1),addedge(V+id,2*V+id,1), addedge(3*V+id,V+id,1),addedge(V+id,3*V+id,1), addedge(2*V+id,3*V+id,2),addedge(3*V+id,2*V+id,2); if(i!=1&amp;&amp;mat[i-1][j]!='x')addedge(id,id-n,0); if(i!=n&amp;&amp;mat[i+1][j]!='x')addedge(V+id,V+(id+n),0); if(j!=1&amp;&amp;mat[i][j-1]!='x')addedge(2*V+id,2*V+(id-1),0); if(j!=n&amp;&amp;mat[i][j+1]!='x')addedge(3*V+id,3*V+(id+1),0); &#125;&#125;void solve()&#123; int id=(xa-1)*n+ya; spfa_bfs(id); id=(xb-1)*n+yb; int ans=min(min(min(d[id],d[V+id]),d[2*V+id]),d[3*V+id]); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07DEC Gourmet Grazers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2869%2F</url>
    <content type="text"><![CDATA[题目地址 题解STL大法好multiset水题按照贪心的思想，每次给牛中对草的质量最高的安排一个草的质量比他高的，且最便宜的。用平衡树维护即可。时限宽松，所以用multiset暴力水过123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;multiset&lt;int&gt; s;pair&lt;int,int&gt; P[100005],C[100005];ll ans=0; int n,m;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)C[i].second=read(),C[i].first=read(); for(int i=1;i&lt;=m;i++)P[i].second=read(),P[i].first=read(); sort(P+1,P+m+1); sort(C+1,C+n+1);&#125;void solve()&#123; for(int i=n,j=m;i&gt;=1;i--)&#123; while(j&gt;=1&amp;&amp;P[j].first&gt;=C[i].first) s.insert(P[j].second),j--; if(s.empty())&#123; printf("-1\n"); return ; &#125;else&#123; int ans_=*s.lower_bound(C[i].second); ans+=ans_,s.erase(s.find(ans_)); &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06FEB Treats for the Cows]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2858%2F</url>
    <content type="text"><![CDATA[题目地址 题解傻DP…区间转移形式12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,v[2005],f[2005][2005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=0;i&lt;n;i++) v[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;n;i++) f[i][i]=v[i]*n; for(int j=1;j&lt;n;j++) for(int i=0;i+j&lt;n;i++)&#123; f[i][i+j]=max(f[i+1][i+j]+v[i]*(n-j),f[i][i+j-1]+v[i+j]*(n-j)); &#125; printf("%d\n",f[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06NOV Bad Hair Day]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2866%2F</url>
    <content type="text"><![CDATA[题目地址 题解单调栈模板题。从右到左记录一个递减的序列即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; #include &lt;cstdlib&gt;using namespace std;int st[80005][2],top=0,n,h[80005];long long ans=0;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;h[i]); st[top][0]=h[n-1],st[top++][1]=n-1; for(i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;h[i]&gt;st[top-1][0]) top--; if(!top) ans+=(n-1-i); else ans+=(st[top-1][1]-i-1); st[top][0]=h[i],st[top++][1]=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06DEC Cow Roller Coaster]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2854%2F</url>
    <content type="text"><![CDATA[题目地址 题解先排序，把整个轨道考虑的顺序弄起来，再做01背包。注意状态的可行性。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,B,dp[1005][1005];struct C&#123; int l,r,fun,cost; bool operator &lt;(C &amp;a)&#123; return l&lt;a.l||(l==a.l&amp;&amp;r&lt;a.r); &#125;&#125;comp[10005];void init()&#123; L=read(),n=read(),B=read(); for(int i=1;i&lt;=n;i++) comp[i].l=read(),comp[i].r=read()+comp[i].l, comp[i].fun=read(),comp[i].cost=read(); sort(comp+1,comp+1+n);&#125;void solve()&#123; int c_,l_,r_,f_; memset(dp,-1,sizeof(dp)); for(int i=0;i&lt;=B;i++)dp[i][0]=0; for(int i=1;i&lt;=n;i++)&#123; c_=comp[i].cost,l_=comp[i].l,r_=comp[i].r,f_=comp[i].fun; for(int j=B;j&gt;=c_;j--) if(dp[j-c_][l_]&gt;=0) dp[j][r_]=max(dp[j][r_],dp[j-c_][l_]+f_); &#125; printf("%d\n",dp[B][L]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2012 随机数生成器]]></title>
    <url>%2F2018%2F08%2F02%2Fnoi2012t1%2F</url>
    <content type="text"><![CDATA[题目地址 题解水矩乘。唯一要注意的是爆炸的乘法运算。快速乘解决即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;typedef struct&#123; ll dat[3][3]; int r,c;&#125;Mat;ll M,A,C,x0,n,G;Mat mid,tmp;ll mulll(ll a,ll b)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%M; a=(a+a)%M;b&gt;&gt;=1; &#125; return res;&#125; void mul(Mat &amp;a,Mat &amp;b,Mat *to)&#123; to-&gt;r=a.r,to-&gt;c=b.c; int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; t=0;for(k=0;k&lt;a.c;k++)t+=mulll(a.dat[i][k],b.dat[k][j]),t%=M; to-&gt;dat[i][j]=t%M; &#125;&#125;Mat pow(Mat a,ll p)&#123; Mat E,F; E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)mul(E,a,&amp;F),E=F; mul(a,a,&amp;F),a=F;p&gt;&gt;=1; &#125;return E;&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;M,&amp;A,&amp;C,&amp;x0,&amp;n,&amp;G); Mat fib,d,u,v; fib.r=fib.c=2; fib.dat[0][0]=A%M; fib.dat[0][1]=fib.dat[1][1]=1; fib.dat[1][0]=0; u=pow(fib,n); d.r=2,d.c=1; d.dat[0][0]=x0%M,d.dat[1][0]=C%M; mul(u,d,&amp;v); printf("%lld\n",v.dat[0][0]%G); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI2012</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>快速乘</tag>
      </tags>
  </entry>
</search>
