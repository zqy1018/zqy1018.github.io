<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[模板 排序算法]]></title>
    <url>%2F2018%2F08%2F05%2Ftemplate-sort%2F</url>
    <content type="text"><![CDATA[不能忘的基本排序！ 插入排序重点在于：在排第$k$个元素的时候，前$k-1$个已经有序。因此只要把第$k$个元素放到它应该在的地方即可。123456789101112void sort1(int* a, int n)&#123; for(int i = 1; i &lt; n; ++i)&#123; int tmp = a[i], j; for(j = i; j &gt; 0; --j)&#123; if(tmp &lt; a[j - 1]) a[j] = a[j - 1];//向后面移动 else break; &#125;//寻找位置 a[j] = tmp;//插入 &#125;&#125; 选择排序简单直观的排序方法。始终寻找当前的最小值，放在它应当在的地方。12345void sort2(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = i + 1; j &lt; n; ++j) if(a[i] &gt; a[j])swap(a[i], a[j]);&#125; 冒泡排序比较相邻元素，调整顺序以达到排序的目的。123456void sort3(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = 0; j &lt; n - i; ++j) if(a[j] &gt; a[j + 1]) swap(a[j], a[j + 1]);//交换过程&#125; 希尔排序希尔排序使用了一个序列（称之为增量序列） h_1,h_2,h_3,...,h_n其中h_1=1。排序时将序列划为h_k组，元素之间间隔为h_k，然后每组内部进行一个插入排序。随着增量减小数据间的有序程度也就越高，最终在增量达到$1$时达到有序。增量序列的选择直接与算法的效率挂钩。此处用的为$Hibbard$增量，即$1,3,7,…,2^k-1$。123456789101112131415void sort4(int *a, int n)&#123; int h[] = &#123;1, 3, 7, 15, 31&#125;; for(int i = lower_bound(h, h + 5, n) - h - 1; i &gt;= 0; --i)&#123;//寻找最大增量 for(int j = h[i]; j &lt; n; ++j)&#123; int tmp = a[j], k; for(k = j; k &gt;= h[i]; k -= h[i])&#123; if(tmp &lt; a[k - h[i]]) a[k] = a[k - h[i]]; else break; &#125; a[k] = tmp; &#125; &#125;&#125; 以上为常见的$O(n^2)$排序算法。 归并排序分治算法的典型应用，将数据层层分割，直到最简单的两个一组的情况，然后不断进行二路归并。1234567891011121314151617181920void Merge(int *a, int *tmp, int lhead, int rhead, int rend)&#123; int lpos = lhead, rpos = rhead, tpos = lhead; while(lpos &lt; rhead &amp;&amp; rpos &lt; rend)&#123; if(a[lpos] &lt; a[rpos]) tmp[tpos++] = a[lpos++]; else tmp[tpos++] = a[rpos++]; &#125; while(lpos &lt; rhead)tmp[tpos++] = a[lpos++]; while(rpos &lt; rend)tmp[tpos++] = a[rpos++]; for(int i = lhead; i &lt; rend; ++i) a[i] = tmp[i];&#125;void MergeSort(int *a, int left, int right)&#123;//左闭右开 int n = right - left, mid = (right + left) &gt;&gt; 1; if(n == 1)return ; MergeSort(a, left, mid); MergeSort(a, mid, right); Merge(a, b, left, mid, right);&#125; 快速排序快速排序的关键在于选择基准以及分割策略，其余的工作交给递归即可。一种比较优秀的选择基准的方法是对最左端，最右端，和最中间的三个数排序，选择第二大（即中间大小）的数作为基准。这种选择比纯粹的随机选择和固定的选择更加高明。之后，将基准和当前序列的倒数第二个值交换。分割时，利用两个指针，其中一个（设为$i$）从最左边向右扫，另一个（设为$j$）从倒数第二个位置向左扫。$i$只会在大于或等于基准的位置停下，$j$只会在小于或等于基准的位置停下。此时若$i&lt;j$，那么交换$i$和$j$对应的数；若$i \ge j$，那么指针停止行动，本次分割结束。之后由于$i$指针左右分别为小于等于和大于等于基准的数，故把基准换到$i$所在位置，再对$i$两侧递归执行排序。 以上的做法避免了几个隐患： 基准换到倒数第二个位置，为$i$提供了一个界限；同时选择基准时进行的排序也为$j$提供了一个界限。 $i$和$j$在遇到等于基准的值时都会停下，这是因为当多个相同元素存在时，若$i$和$j$都不停下，那么$i$会一直进行到接近末尾的地方，导致分割出来的左右两边序列长度不均衡，进而导致算法实际运行效率变差。 123456789101112131415161718192021222324252627282930void Median3(int *a, int left, int right)&#123; int mid = (left + right) &gt;&gt; 1; if(a[left] &gt; a[mid])swap(a[left], a[mid]); if(a[mid] &gt; a[right])swap(a[mid], a[right]); if(a[left] &gt; a[mid])swap(a[left], a[mid]); swap(a[mid], a[right - 1]);&#125;void Qsort(int *a, int left, int right)&#123;// 闭区间 int len = right - left + 1, pivot; if(len &lt;= 1)return ; if(len == 2)&#123; if(a[right] &lt; a[left])swap(a[left], a[right]); return ; &#125; Median3(a, left, right); pivot = a[right - 1]; int i = left, j = right - 1; for(;;)&#123; while(a[++i] &lt; pivot) ; while(a[--j] &gt; pivot) ; if(i &gt;= j)break; swap(a[i], a[j]); &#125; swap(a[i], a[right - 1]); Qsort(a, left, i - 1); Qsort(a, i + 1, right);&#125;void QuickSort(int *a, int n)&#123; Qsort(a, 0, n - 1);&#125; 堆排序建立一个堆，直接操作即可。此处不再赘述。 以上为常见的$O(nlogn)$排序算法。 记数排序计数排序的中心思想是：对于每一个输入的元素$x$，确定小于或等于$x$的元素的个数。利用这一信息，即可把该元素放在他应在的位置。12345678910void CountingSort(int *a, int *cnt, int *ans, int n)&#123; for(int i = 0; i &lt;= 10; ++i) cnt[i] = 0; for(int i = 0; i &lt; n; ++i) cnt[a[i]]++; for(int i = 1; i &lt;= 10; ++i) cnt[i] += cnt[i - 1]; for(int i = n - 1; i &gt;= 0; --i) ans[--cnt[a[i]]] = a[i];&#125; 基数排序基数排序执行这样一个过程：对$n$个$d$位数，从最低位开始，一直到最高位，以数的当前位上的数字作为关键字进行排序。 桶排序桶排序将$n$个分布在$[0,1)$上的实数放入$m$个“桶”里，每个桶对应着一个区间，并且对每一个桶里的数据进行排序，以达到总体的有序。 以上为常见的线性时间复杂度排序算法。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷1396 营救]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1396%2F</url>
    <content type="text"><![CDATA[题目地址 题解为什么专门拿出这道题来写一个题解呢？因为这道题考察到了一个我们平时（可能）没有注意到的地方。并查集不仅可以用来做连通性状态的维护，还可以用来解决一些图论上的最值问题。像是这道题，就把二分和并查集结合在一起。二分答案，只把拥挤度小于答案的加入并查集，维护$S$和$T$的联通状态。这个思路真的很妙。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;struct Edge&#123; int u,v,cost; &#125;; Edge edge[20005];bool cmp(int a,int b)&#123; return edge[a].cost&lt;edge[b].cost;&#125;int id[20005],n,m,S,T;int par[10005];int Find(int x)&#123; if(par[x]==x)return x; return par[x]=(Find(par[x]));&#125;void Unite(int u,int v)&#123; par[Find(u)]=Find(v);&#125;bool judge(int M)&#123; for(int i=1;i&lt;=n;i++) par[i]=i; for(int i=0;i&lt;m;i++)&#123; if(edge[id[i]].cost&gt;M)break; Unite(edge[id[i]].u,edge[id[i]].v); if(Find(S)==Find(T))return 1; &#125; return 0;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost), id[i]=i; sort(id,id+m,cmp);&#125;void solve()&#123; int L=0,R=20000,M; while(R-L)&#123; M=(R+L)/2; if(judge(M))//&lt;=M R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2420]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2420%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出每一个点到根的$xor$路径，然后直接$O(1)$回答询问。答案就是$val[u]\quad xor\quad val[v]$，因为$val[lca]$被消去了。这真的是经典问题？我怀疑你就是在水1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[200006];int cnt=0,at[100005]=&#123;0&#125;,n,val[100005]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[++cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int x,int fa)&#123; for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa) val[edge[i].v]=val[x]^edge[i].cost, dfs(edge[i].v,x);&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); dfs(1,0);&#125;void solve()&#123; int m=read(),u,v; while(m--) u=read(),v=read(), printf("%d\n",val[u]^val[v]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1730 最小密度路径]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1730%2F</url>
    <content type="text"><![CDATA[题目地址 题解这是floyd的一个拓展应用。可以求出恰好经过一定数目条路的最短路径长度。也是运用到了动态规划的思想，不过DP数组则变成了3维。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 0x14141414using namespace std;typedef long long ll;int d[1005][105][105],V,E,Q;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; V=read(),E=read(); int u,v,c; memset(d,0x14,sizeof(d)); for(int i=1;i&lt;=E;i++)&#123; u=read(),v=read(),c=read(); if(d[1][u][v]&gt;c)d[1][u][v]=c; &#125; for(int l=2;l&lt;=E;l++) for(int k=1;k&lt;=V;k++) for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) d[l][i][j]=min(d[l][i][j],d[l-1][i][k]+d[1][k][j]); Q=read();&#125;void solve()&#123; int u,v; double ans; for(int i=1;i&lt;=Q;i++)&#123; u=read(),v=read(); ans=INF; for(int l=1;l&lt;=E;l++) if(d[l][u][v]&lt;INF) ans=min(ans,d[l][u][v]/(double)l); if(ans&gt;INF-1)printf("OMG!\n"); else printf("%.3lf\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2758 编辑距离]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2758%2F</url>
    <content type="text"><![CDATA[题目地址 题解非常经典的$DP$题目。转移方程和$LCS$问题非常相似，设$f(i,j)$表示$a$串的第$i$位匹配到$b$串的第$j$位所需要的最少操作数，那么有: f(i,j)=\begin {cases} f(i-1,j-1)\quad (a[i]=b[j])\\ \min \left\{f(i-1,j),f(i-1,j-1),f(i,j-1)\right\}+1 \quad (a[i]\neq b[j]) \end{cases}以上三个数分别对应删除，修改和插入时间复杂度O(l_1l_2)123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char a[2005],b[2005];int f[2005][2005],l1,l2,l3;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b);&#125;void solve()&#123; f[0][0]=0; for(int i=1;i&lt;=l1;i++) f[i][0]=i; for(int i=1;i&lt;=l2;i++) f[0][i]=i; for(int i=1;i&lt;=l1;i++)&#123; for(int j=1;j&lt;=l2;j++)&#123; if(a[i-1]==b[j-1])&#123; f[i][j]=f[i-1][j-1]; &#125;else f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+1; //printf("%d %d:%d\n",i,j,f[i][j]); &#125; &#125; printf("%d\n",f[l1][l2]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>字符串DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1122 最大子树和]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1122%2F</url>
    <content type="text"><![CDATA[题目地址 题解树形DP。主要是体会一下树形DP于树形这种递归结构的关系。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,at[100005],to[100005],_next[100005],cnt=0;bool vis[100005];ll val[100005],dp[100005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int cur)&#123; //包含自己在内 dp[cur]=val[cur]; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]])&#123; vis[to[i]]=1,dfs(to[i]); if(dp[to[i]]&gt;0)dp[cur]+=dp[to[i]]; &#125; &#125;&#125;void init()&#123; n=read(); memset(at,-1,sizeof(at)); int u,v; for(int i=1;i&lt;=n;i++) val[i]=read(); for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); to[cnt]=v,_next[cnt]=at[u],at[u]=cnt++; to[cnt]=u,_next[cnt]=at[v],at[v]=cnt++; &#125;&#125;void solve()&#123; ll ans=-INF; ans*=2ll; vis[1]=1,dfs(1); for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i]); printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待改进 COCI2007 Patrik 音乐会的等待]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1823%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题就是在教你怎么玩单调栈…经典做法就是，维护一个不递增的栈，然后有人比栈顶的人还高的话，就把他加进来，然后因为这个人肯定能看见他与他前面第一个比他高的人之间的人，所以在出栈的时候累加答案。同时还要注意人身高相等的情况。下面我的程序给出的实现方式并不是一个很好的方式，所以有待改进具体的改进方式应该就是令栈单调递减并且维护一段数据的大小…12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll stack[500005],ans=0,tmp,len,lst;int main()&#123; int i,top=1,n,j; scanf("%d%lld",&amp;n,&amp;stack[0]); for(i=1;i&lt;n;i++)&#123; scanf("%lld",&amp;tmp); while(top&amp;&amp;stack[top-1]&lt;tmp) top--,ans++; stack[top++]=tmp; if(top&gt;1)ans++; for(j=top-2;j&amp;&amp;stack[j]==tmp;j--,ans++); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>COCI</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009提高 最优贸易]]></title>
    <url>%2F2018%2F08%2F04%2Fnoip2009tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解题意：找一条从$1 $到$n $的路径，使得经过的所有点中，最大点权和最小点权的差最大，并且最小点权应比最大点权早出现。我们把这个路径分解一下，分解为$1\rightarrow a\rightarrow b\rightarrow n$。在$a $点买入，在$b $点卖出。因此我们可以考虑分别处理$1\rightarrow a$和$b\rightarrow n$，给每一个点维护一下从起点到他可经过的的最小点权和从他到终点可经过的最大点权。这样只要在正反图上各跑一次SPFA即可。或者还可以先进行一次缩点，然后图就变成了一个DAG。这样只要在进行2次BFS即可。综上，使用tarjan算法+BFS的情况下，时间复杂度为$O(n+m)$。有趣的是，这种做法虽然理论上更优，实际上却不是。大概是我的代码常数太大了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; #include &lt;cstdlib&gt;#define K 100005#define KD 1000005using namespace std;int V,E,at[2][K],par[K],cnt[2]=&#123;0&#125;,tail[2][K];int dfn[K],low[K],D=0,in[K],stack[K],top=0;int mini[K],maxi[K],que[5*K],f,r; typedef struct&#123; int v,_next; &#125;Edge; Edge edge[2][KD];void addedge(int _u,int _v,int o)&#123; edge[o][cnt[o]].v=_v, edge[o][cnt[o]]._next=at[o][_u]; if(at[o][_u]==-1) tail[o][_u]=cnt[o]; at[o][_u]=cnt[o]++;&#125;void tarjan_scc(int id)&#123; dfn[id]=low[id]=++D; in[id]=true; stack[top++]=id; int i=at[0][id],vv,t1,t2,_min,_max; while(i!=-1)&#123; vv=edge[0][i].v; if(!dfn[vv])tarjan_scc(vv),low[id]=min(low[id],low[vv]); else if(in[vv])low[id]=min(low[id],dfn[vv]); i=edge[0][i]._next; &#125; if(dfn[id]==low[id])&#123; t1=t2=-1,i=stack[top-1],_min=101,_max=-1; do vv=stack[--top], in[vv]=false, par[vv]=i, edge[0][tail[0][vv]]._next=t1, t1=at[0][vv], edge[1][tail[1][vv]]._next=t2, t2=at[1][vv], _min=min(_min,mini[vv]), _max=max(_max,maxi[vv]); while(stack[top]!=id); at[0][i]=t1,at[1][i]=t2; mini[i]=_min,maxi[i]=_max; &#125;&#125;void init()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,u,v,o,c; memset(at,-1,sizeof(at)); for(i=0;i&lt;V;i++) scanf("%d",&amp;c), mini[i]=maxi[i]=c; for(i=0;i&lt;E;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;o), addedge(u-1,v-1,0), addedge(v-1,u-1,1); if(o==2) addedge(v-1,u-1,0), addedge(u-1,v-1,1); &#125; for(i=0;i&lt;V;i++) par[i]=i; tarjan_scc(0);&#125;void solve()&#123; int h,vv,i,o,c,ans=0; f=r=0,que[r++]=par[0]; memset(in,0,sizeof(in)); while(r-f)&#123; h=que[f++]; for(i=at[0][h];i!=-1;i=edge[0][i]._next)&#123; vv=par[edge[0][i].v]; if(mini[vv]&gt;mini[h]) mini[vv]=mini[h], in[vv]=1, que[r++]=vv; else if(!in[vv]) in[vv]=1, que[r++]=vv; &#125; &#125; f=r=0,que[r++]=par[V-1]; memset(dfn,0,sizeof(dfn)); while(r-f)&#123; h=que[f++]; for(i=at[1][h];i!=-1;i=edge[1][i]._next)&#123; vv=par[edge[1][i].v]; if(maxi[vv]&lt;maxi[h]) maxi[vv]=maxi[h], dfn[vv]=1, que[r++]=vv; else if(!dfn[vv]) dfn[vv]=1, que[r++]=vv; &#125; &#125; for(i=0;i&lt;V;i++) if(in[par[i]]&amp;&amp;dfn[par[i]]) ans=max(ans,maxi[par[i]]-mini[par[i]]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>强连通分量</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待考察 NOIP2009提高 Hankson的趣味题]]></title>
    <url>%2F2018%2F08%2F04%2Fnoip2009tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解一道奇怪的数学题。（理论上这题爆搜比正解快，数据好像不是很好）考虑唯一分解和$GCD$，$LCM$的关系。设对于一个质数$p$，其为b_1的一个因数。那么：设k_{a_0},k_{a_1},k_{b_0},k_{b_1},k_x为a_0,a_1,b_0,b_1,x中$p$的次数。则：因为k_{a_1}=\min\{k_{a_0},k_x\},k_{b_1}=\max\{k_{b_0},k_x\}，若k_{a_0}>k_{a_1}那么k_x=k_{a_1}；若k_{a_0}=k_{a_1}，那么k_x\ge k_{a_1}.若k_{b_0}]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009提高 潜伏者]]></title>
    <url>%2F2018%2F08%2F04%2Fnoip2009tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解稍微麻烦的模拟。只要注意及时停止即可。12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;char f[27],sec[105],ori[105],s[105];int flag=1,vis[27];int main()&#123; scanf("%s%s%s",sec,ori,s); int l1=strlen(sec),l2=strlen(s); if(l1&lt;26)&#123; flag=0;goto end; &#125;//不够26个字母 for(int i=0;i&lt;l1;i++)&#123; if(f[sec[i]-'A']&amp;&amp;ori[i]!=f[sec[i]-'A'])&#123; flag=0;goto end; &#125;//没对上 f[sec[i]-'A']=ori[i],vis[sec[i]-'A']=1; &#125; for(int i=0;i&lt;26;i++) if(!vis[i]||!f[i])&#123; flag=0;goto end; &#125;//禁止没有得对 for(int i=0;i&lt;26;i++)vis[f[i]-'A']++; for(int i=0;i&lt;26;i++) if(vis[i]&gt;2)&#123; flag=0;goto end; &#125;//禁止一对多 end: if(!flag)printf("Failed\n"); else &#123; for(int i=0;i&lt;l2;i++) printf("%c",f[s[i]-'A']); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009普及 道路游戏]]></title>
    <url>%2F2018%2F08%2F04%2Fnoip2009pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一这是一道比较难的DP。状态的表示比较难想，我个人一开始给出的转移方程是：设$f(i,j,k)$表示当前在$i$工厂，$j$时间，$k$状态时的最大金币量，其中$k=0$表示当前机器人刚刚走出了第一步，$k=1$表示当前机器人走出了$2$到$p$步，并且已经被回收。这样状态转移方程就很好写，$f(i,j,0)$就从上一秒的$f(i-1,j-1,1)$里面找最大值，$f(i,j,1)$就枚举一下步数。这么做的时间复杂度是$O(nmp)$的。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005][1005][2]=&#123;0&#125;,m[1005][1005],n,t,p,cost[1005];int deque[4005][2],f=0,r=0,R;void in(int o,int at)&#123; while(r&gt;f&amp;&amp;o&gt;deque[r-1][0]) r--; deque[r][0]=o,deque[r++][1]=at;&#125;int out(int at)&#123; if(deque[f][1]==(at+R-p)%n) f++; return deque[f][0];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;t,&amp;p); int i,j,m2=0,m3=0,k,l,ans=0,sum; R=1000*n; for(i=0;i&lt;n;i++) for(j=0;j&lt;t;j++) scanf("%d",&amp;m[i][j]); for(i=0;i&lt;n;i++) scanf("%d",&amp;cost[i]); for(i=1;i&lt;=t;i++)&#123;//[f,r] for(j=0;j&lt;n;j++)&#123; dp[i][j][1]=m2; if(!j)dp[i][j][1]+=m[n-1][i-1]-cost[n-1]; else dp[i][j][1]+=m[j-1][i-1]-cost[j-1]; for(k=(j-1+n)%n,l=1,sum=0;l&lt;p;l++,k=(k-1+n)%n) if(i-l&gt;0) sum+=m[k][i-l], dp[i][j][0]=max(dp[i][j][0],dp[i-l][k][1]+sum); else break; m3=max(m3,max(dp[i][j][0],dp[i][j][1])); &#125; m2=m3,m3=0; &#125; for(i=0;i&lt;n;i++) ans=max(ans,max(dp[t][i][0],dp[t][i][1])); printf("%d\n",ans); return 0;&#125; 但是居然过了！我就没留意这道题了（其实我都写了单调队列但没用上）今天想了一下，发现没必要那么麻烦，很多地方可以优化。 方法二设$f(i,j)$为机器人走到$i$工厂，$j$时间所能收集的最大金币量。那么 f(i,j)=\max \limits_{i\le k \le p} \left\{ \max \limits_{1\le s\le n}\left\{f(s,j-k) \right\} +sum(i-1,j)-sum(i-k-1,j-k)-cost[i-k]\right\}其中 sum(i,j)=sum(i-1,j-1)+coin[i][j]那么提出$sum(i,j)$就可以发现括号里的量只与$k$有关，就用单调队列。而$sum$是可以前后递推出来的。所以，解决本题的时间复杂度就优化为了$O(nm)$。其实你如果读上面的题解读得仔细的话就会发现我没有讲到一个东西，那就是单调队列该怎么用。本题的优化方式十分特殊，由于$sum$是斜方格形进行求和的（$i-k,j-k \rightarrow i,j$），所以单调队列的下标也要随着$i$改变而改变。具体可以看代码。 完了么？没有。很多题解都会被洛谷上的Extra Test卡掉，虽然我也不知道这数据怎么出的但反正很厉害。（提示：其实读懂了题就不会被坑）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,p,coin[2005][1005],sum[1005][1005],cost[2005];int Deque[1005][1005][2],f[1005],r[1005],maxi[1005];int dp[1005][1005];void init()&#123; n=read(),m=read(),p=read(); for(int i=0;i&lt;n;i++) for(int j=1;j&lt;=m;j++) coin[i][j]=coin[i+n][j]=read(); for(int i=0;i&lt;n;i++)cost[i]=cost[i+n]=read();&#125;void inque(int x,int val,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;val&gt;Deque[x][r[x]-1][0])r[x]--; Deque[x][r[x]][0]=val,Deque[x][r[x]++][1]=k;&#125;int outque(int x,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;k-Deque[x][f[x]][1]&gt;p)f[x]++; return Deque[x][f[x]][0];&#125;void solve()&#123; for(int i=0;i&lt;n;i++)inque(i,-cost[i],0); int R=1000*n; //R：当前单调队列的偏移量 for(int j=1;j&lt;=m;j++)&#123; R--; sum[n-1][j]=sum[n-2][j-1]+coin[n-1][j]; sum[0][j]=sum[n-1][j-1]+coin[0][j]; dp[0][j]=outque(R%n,j)+sum[n-1][j]; maxi[j]=dp[0][j]; for(int i=1;i&lt;n;i++)&#123; sum[i][j]=sum[i-1][j-1]+coin[i][j]; dp[i][j]=outque((i+R)%n,j)+sum[i-1][j]; maxi[j]=max(maxi[j],dp[i][j]); &#125; inque(R%n,maxi[j]-cost[0]-sum[n-1][j],j); for(int i=1;i&lt;n;i++) inque((i+R)%n,maxi[j]-cost[i]-sum[i-1][j],j); &#125; //以上把0单独处理了 printf("%d\n",maxi[m]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4203 Doubloon Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu4203%2F</url>
    <content type="text"><![CDATA[题目地址 题解先大力打表，看SG函数有没有什么规律发现打表结果非常神奇：当$K$是奇数的时候，SG函数是$010101$变化的。$K$是偶数的时候，每逢$K$的倍数，$SG（x\cdot K）$就为$2$。否则仍然按照$010101$变化。比如$K=2:0,1,2,0,1,2 …$$K=4:0,1,0,1,2,0,1,0,1,2…$之后就简单了。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int S,k,T;int SG(int x)&#123; if(k%2)return x%2; else &#123; int mod=x%(k+1); if(mod&lt;k)return mod%2; else return 2; &#125; &#125;void solve()&#123; T=read(); while(T--)&#123; S=read(),k=read(); int ans=SG(S); if(ans!=2)printf("%d\n",ans); else &#123; for(int j=1;S-j&gt;=0;j*=k) if(!SG(S-j))&#123; printf("%d\n",j); break; &#125; &#125; &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1704 Georgia and Bob]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1704%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个模型，没记错是叫做阶梯博弈。他这个模型可以转化成Nim游戏。把每一对移动的棋子之间的间距看作是石头的数目，就可以依靠Nim游戏的结论进行解答。但是为什么这样的转化是正确的呢？首先两个棋子逼近，就相当于取走若干个石头；如果两个石头远离，那么不要紧，下一步可以把这个多出来的部分减掉去，所以还是相当于没有增加。如果石头个数是奇数就虚拟一个边界上的石头和他配对。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int T,n,a[1005];void solve()&#123; T=read(); while(T--)&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); if(n&amp;1)a[n+1]=0,n++; sort(a+1,a+n+1); int res=0; for(int i=1;i&lt;=n;i+=2) res^=(a[i+1]-a[i]-1); printf("%s\n",res?"Georgia will win":"Bob will win"); &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1079 Calendar Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu1079%2F</url>
    <content type="text"><![CDATA[题目地址 题解写成递推的形式即可。边界条件挺烦的，还好1A了。反正大力码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char dp[200][13][40]=&#123;0&#125;;//1900--&gt;0int days[]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int run(int x,int y)&#123; return (y==2&amp;&amp;x&amp;&amp;x%4==0);&#125;void init()&#123; dp[101][11][3]=1; int r1=0,r2=0; for(int i=101;i&gt;=0;i--) for(int j=12;j&gt;=1;j--) for(int d=31;d&gt;=1;d--)&#123; if(i==101&amp;&amp;(j==12||(j==11&amp;&amp;d&gt;=3)))continue; if(d&gt;days[j]+run(i,j))continue; if(i==101&amp;&amp;(j&gt;=11||(j==10&amp;&amp;d&gt;4)))r1=-1; else&#123; if(j==12)r1=dp[i+1][1][d]; else if(d&lt;=days[j+1]+run(i,j+1))r1=dp[i][j+1][d]; else r1=-1; &#125; if(d==days[j]+run(i,j))&#123; if(j==12)r2=dp[i+1][1][1]; else r2=dp[i][j+1][1]; &#125;else r2=dp[i][j][d+1]; if(!r1||!r2)dp[i][j][d]=1; else dp[i][j][d]=0; &#125;&#125;void solve()&#123; int T=read(),yy,mm,dd; while(T--)&#123; yy=read(),mm=read(),dd=read(); printf("%s\n",dp[yy-1900][mm][dd]==1?"YES":"NO"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1740 A New Stone Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1740%2F</url>
    <content type="text"><![CDATA[题目地址 题解一般而言，这种题目都需要一定的找规律的技巧。首先$n=1$，先手必胜，这是显然的。$n=2$,如果两堆石头一样多，那么先手必败，因为后手可以不断模仿先手的操作来使石头数始终相同，达到自己不败的目的。如果石头数不相等，那么先手可以转移到石头相同的状态。$n=3$，可以构造出$2$堆相同的情况，只要去掉最多的那一堆就行。$n=4$，只要可以拆成$2$个完全一样的子局面，先手就是必败态，其余是必胜态。归纳一下，$n$是奇数，先手必胜；$n$是偶数，除非局面对称，否则先手必胜。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int n,a[1005];void init()&#123; &#125;void solve()&#123; for(;;)&#123; n=read(); if(!n)break; for(int i=1;i&lt;=n;i++)a[i]=read(); if(n%2)&#123; printf("1\n"); continue; &#125; sort(a+1,a+1+n); int flag=0; for(int i=1;i+i&lt;=n;i+=2) if(a[i]!=a[i+1])&#123; flag=1;break; &#125; printf("%d\n",flag); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3863 No Gambling]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu3863%2F</url>
    <content type="text"><![CDATA[题目地址 题解由于后手只能不断采取行动去堵先手的路，而先手一定可以采取方式突破，所以先手必胜。1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; for(int n;;)&#123; n=read(); if(n&lt;0)break; printf("I bet on Oregon Maple~\n"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2234 Matches Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2234%2F</url>
    <content type="text"><![CDATA[题目地址 题解简单的Nim游戏。推荐看国家集训队2002年张一飞的论文，他的论文深入浅出地用集合的观点解释了nim游戏和的原理。之后的很多博弈论的题目都建立在这么一个基本模型的基础上。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; int M,a[25],res; while(~scanf("%d",&amp;M))&#123; res=0; for(int i=1;i&lt;=M;i++)a[i]=read(),res^=a[i]; printf("%s\n",res?"Yes":"No"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1442 Black Box]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1442%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一无脑平衡树。 方法二堆的神奇操作。发现这个求第$k$小$k$是递增的，所以可以维护一个大根堆和一个小根堆，然后在其中一个堆上维护前$k$个数，另一个堆上维护剩下的数，这样只要关注第$k$个数是什么即可，而不需要管在他前面的或者在他后面的是不是有序的。所以操作就很简单了，$k$加$1$的时候从某个堆弹一个走就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define l(x) (x&lt;&lt;1)+1#define r(x) (x&lt;&lt;1)+2using namespace std;int h[200005]=&#123;0&#125;,size=0,n,m,k[200005];priority_queue&lt;int&gt; pq;//pq下&lt;pq顶&lt;h顶&lt;h底 void up(int s)&#123; int at,tmp=h[s]; while(s&gt;0)&#123; at=(s-1)/2; if(h[at]&lt;=tmp)break; h[s]=h[at],s=at; &#125; h[s]=tmp;&#125;void down(int s,int e)&#123; int lch,rch,tmp=h[s]; while(l(s)&lt;e)&#123; lch=l(s),rch=r(s); if(rch&lt;e&amp;&amp;h[rch]&lt;h[lch]) lch=rch; if(tmp&lt;=h[lch])break; h[s]=h[lch],s=lch; &#125; h[s]=tmp;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int i,j,at; for(i=0;i&lt;m;i++) scanf("%d",&amp;k[i]); pq.push(k[0]); for(i=0,j=1;i&lt;n;i++)&#123; scanf("%d",&amp;at); while(j&lt;at)&#123; if(pq.top()&gt;k[j])&#123; h[size++]=pq.top(),pq.pop(); pq.push(k[j]),up(size-1); &#125;else h[size++]=k[j],up(size-1); j++; &#125; printf("%d\n",pq.top()); if(!size)h[size++]=k[j++]; pq.push(h[0]),h[0]=h[--size],down(0,size); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2823 Sliding Window]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2823%2F</url>
    <content type="text"><![CDATA[题目地址 题解经典的单调队列入门题。思路很简单，就是先判断队头是否“过期”，然后再在队尾进行比较。这里的代码是可以进行空间上的优化的。注意一个点：$k=1$时最好特判。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; int n,k,a[1000005],d1[1000005][2],d2[1000005][2],f1=0,f2=0,r1=1,r2=1,ans[1000005][2];void in(int at,int p)&#123; while(r1&gt;f1&amp;&amp;d1[f1][1]&lt;=at-k) f1++; while(r2&gt;f2&amp;&amp;d2[f2][1]&lt;=at-k) f2++; while(r1&gt;f1&amp;&amp;d1[r1-1][0]&gt;p) d1[r1-1][0]=d1[r1-1][1]=0,r1--; while(r2&gt;f2&amp;&amp;d2[r2-1][0]&lt;p) d2[r2-1][0]=d2[r2-1][1]=0,r2--; d1[r1][0]=p,d1[r1++][1]=at; d2[r2][0]=p,d2[r2++][1]=at;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); i=(k==1)?0:1; d1[0][0]=d2[0][0]=a[0]; d1[0][1]=d2[0][1]=0; for(;i&lt;n;i++)&#123; in(i,a[i]); ans[i][0]=d1[f1][0]; ans[i][1]=d2[f2][0]; &#125; for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][0]); printf("%d\n",ans[n-1][0]); for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][1]); printf("%d\n",ans[n-1][1]); return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3017 Cut the Sequence]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3017%2F</url>
    <content type="text"><![CDATA[题目地址 题解第一次做这样的利用决策单调性来优化DP的题目。设$f(i)$表示分割到第$i$个元素时，最大和的最小值。很容易得到方程： f(i)=\min \limits_{sum[j+1...i]]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2918 Tudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2918%2F</url>
    <content type="text"><![CDATA[题目地址 题解基本同26761234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); for(int TT=1;TT&lt;=T;TT++)&#123; printf("Scenario #%d:\n",TT); tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); if(!tot&amp;&amp;!flag)print(); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2676 Sudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2676%2F</url>
    <content type="text"><![CDATA[题目地址 题解一道很经典的题。用的是NOIP2009的程序，没加修改就过了。总体上来说有2个大优化 记录了每一个空的位置 每次找可能的数字最少的空搜 0ms过，还行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); while(T--)&#123; tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3764 The xor-longest Path]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3764%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出从根出发到每一个点的异或距离，然后问题转化为在这些距离中找两个异或值最大的。这是个经典问题，只需要在用trie树查询时进行反向行走即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt;using namespace std;typedef unsigned int ll;struct Tree&#123; int l,r; Tree()&#123;l=r=-1;&#125;&#125;;typedef struct&#123; int v,_next; ll cost;&#125;Edge;Edge edge[200005];int cnt=0,at[100005]; void addedge(int _u,int _v,ll _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int n,siz=1;Tree tr[3000005];ll vx[100005];bool vis[100005];void Trie_insert(ll num)&#123; //printf("%u\n",num); for(ll j=(1&lt;&lt;31),cur=0;j;j&gt;&gt;=1) if((j&amp;num)==0)&#123;//l:0 r:1 if(tr[cur].l&lt;0) tr[cur].l=siz++; cur=tr[cur].l; &#125;else&#123; if(tr[cur].r&lt;0) tr[cur].r=siz++; cur=tr[cur].r; &#125;&#125;ll Trie_search(ll x)&#123; ll res=0; for(ll j=1&lt;&lt;31,cur=0;j;j&gt;&gt;=1)&#123; if(x&amp;j)&#123; if(tr[cur].l&gt;0)res+=j,cur=tr[cur].l; else cur=tr[cur].r; &#125;else&#123; if(tr[cur].r&gt;0)res+=j,cur=tr[cur].r; else cur=tr[cur].l; &#125; &#125; return res;&#125;void dfs(int cur,ll val)&#123; for(int i=at[cur];i!=-1;i=edge[i]._next)&#123; int _v=edge[i].v; if(!vis[_v]) vis[_v]=1, vx[_v]=val^edge[i].cost, Trie_insert(vx[_v]), dfs(_v,vx[_v]); &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=0;i&lt;siz;i++) tr[i].l=tr[i].r=-1; siz=1,cnt=0; memset(at,-1,sizeof(at)); memset(vis,0,sizeof(vis)); int u,v;ll c; for(int i=0;i&lt;n-1;i++) scanf("%d%d%u",&amp;u,&amp;v,&amp;c), addedge(u,v,c), addedge(v,u,c); dfs(0,0); vx[0]=0; //Trie_insert(0u); ll ans=0; for(int i=0;i&lt;n;i++) ans=max(ans,Trie_search(vx[i])); printf("%u\n",ans); &#125; return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2142 The Balance]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2142%2F</url>
    <content type="text"><![CDATA[题目地址 题解注意$a$,$b$可以交换位置。之后就是简单的解方程了。要使$|x|+|y|$最小，需要保证$x$最小，之后保证$y$最小即可。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,d,x1,x2,y1,y2;ll gcd(ll aa,ll bb)&#123; return bb?gcd(bb,aa%bb):aa;&#125;ll extgcd(ll aa,ll bb,ll &amp;xx,ll &amp;yy)&#123; if(!bb)&#123; xx=1,yy=0; return aa; &#125; ll dd=extgcd(bb,aa%bb,yy,xx); yy-=(aa/bb)*xx; return dd;&#125;ll Abs(ll x)&#123; return (x&lt;0)?(-x):x;&#125;void work(ll a_,ll b_,ll &amp;x,ll &amp;y)&#123; ll g=extgcd(a_,b_,x,y),t=b_/g; x*=d/g,x=(x%t+t)%t; y=Abs((a_*x-d)/b_);&#125;int main()&#123; for(;;)&#123; scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;d); if(!a&amp;&amp;!b&amp;&amp;!d)break; work(a,b,x1,y1); work(b,a,x2,y2); if(x1+y1&lt;x2+y2)printf("%lld %lld\n",x1,y1); else printf("%lld %lld\n",y2,x2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1811 Prime Test]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1811%2F</url>
    <content type="text"><![CDATA[题目地址 题解算导上面有讲解。用MillerRabin和PollardRho合力解决。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int T;ll prime[]=&#123;2,3,5,7,11,13,17,19,23,61&#125;;ll gcd(ll a,ll b)&#123; return (!b)?a:gcd(b,a%b);&#125;ll mul(ll a,ll b,ll c)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%c; a=(a+a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll Pow(ll a,ll b,ll c)&#123; ll res=1; a%=c; while(b)&#123; if(b&amp;1)res=mul(res,a,c); a=mul(a,a,c),b&gt;&gt;=1; &#125; return res;&#125;bool witness(ll a,ll n,ll d,ll r)&#123; ll t=Pow(a,d,n),_t=t; for(ll i=1;i&lt;=r;i++)&#123; t=mul(t,t,n); if(t==1&amp;&amp;_t!=1&amp;&amp;_t!=n-1) return 1; _t=t;//基于二次探测定理的操作 &#125; if(t!=1)return 1;//基于费马小定理的操作 return 0;&#125;bool Miller_Rabin(ll n)&#123;//1:质数 if(n==2)return 1; if(n&lt;=1||n%2==0)return 0; for(int i=0;i&lt;10;i++) if(n==prime[i])return 1; ll R=n-1,S=0; for(;R%2==0;R&gt;&gt;=1,S++);//n-1=d*2^r for(int i=0;i&lt;10;i++)//10:测试次数 if(witness(prime[i],n,R,S)) return 0; return 1;&#125;//根据算导，c最好不要是0或者2...//为什么呢？ ll Pollard_Rho(ll n,ll c)&#123; ll x=Pow(rand(),rand(),n),y=x,k=2,d=1,t; for(ll i=1;d==1;i++)&#123; x=(mul(x,x,n)+c)%n; if(x-y&lt;0)t=y-x; else t=x-y; d=gcd(t,n); if(i==k)y=x,k&lt;&lt;=1; &#125; return d;&#125;ll dfs(ll n)&#123; if(n==1)return 1; if(Miller_Rabin(n))return n; ll fac=n,Lans,Rans; while(fac==n) fac=Pollard_Rho(n,rand()%(n-1)+1); Lans=dfs(fac),Rans=dfs(n/fac); return min(Lans,Rans);&#125;void init()&#123; scanf("%d",&amp;T); srand('z'+'q'+'y'+'1'+'0'+'1'+'8'+1);&#125;void solve()&#123; while(T--)&#123; ll N; scanf("%lld",&amp;N); ll ans=dfs(N); if(ans==N)printf("Prime\n"); else printf("%lld\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2774 Long Long Message]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2774%2F</url>
    <content type="text"><![CDATA[题目地址 题解就是求最长公共子串哈希+排序+二分=暴力卡过哈希要用unsigned long long，用unsigned int极其容易撞车12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef unsigned long long ui;char a[200005],b[200005];ui P=1000000007,list[200005],h1[200005],h2[200005],pow1[200005];int l1,l2;bool check(int c)&#123; int i,j;ui t; for(i=1;i&lt;=l1-c+1;i++) list[i-1]=h1[i+c-1]-h1[i-1]*pow1[c]; sort(list,list+l1-c); for(i=1;i&lt;=l2-c+1;i++)&#123; t=h2[i+c-1]-h2[i-1]*pow1[c]; if((*lower_bound(list,list+l1-c,t))==t) return true; &#125; return false;&#125;int main()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b); int i,j,l,r,md; for(pow1[0]=1,i=1;i&lt;=200000;i++) pow1[i]=pow1[i-1]*P; for(i=1;i&lt;=l1;i++) h1[i]=h1[i-1]*P+a[i-1]; for(i=1;i&lt;=l2;i++) h2[i]=h2[i-1]*P+b[i-1]; l=0,r=min(l1,l2); //用b匹配a while(l&lt;r)&#123; md=l+(r-l+1)/2; if(check(md)) l=md; else r=md-1; &#125; printf("%d\n",r); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2348 Euclid's Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2348%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设$a&gt;b$。显然当$a\mod b=0$时，先手必胜。当$a\mod b\neq 0$时，若$a&gt;2b$，则可以证明在接下来先手所有可以采取的$k$种策略中必有必胜策略，故这个也是必胜态。我讲的比较浅显，各位不妨看下《挑战程序设计竞赛》的P310。123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,f;int main()&#123; for(;;)&#123; scanf("%lld%lld",&amp;a,&amp;b); if(!a&amp;&amp;!b)break; f=1; for(;;)&#123; if(a&lt;b)swap(a,b); if(a%b==0)break; if(a&gt;2*b)break; a-=b,f^=1; &#125; if(f)printf("Stan wins\n"); else printf("Ollie wins\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2484 A Funny Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2484%2F</url>
    <content type="text"><![CDATA[题目地址 题解 当$n=1$或者$n=2$时，明显先手必胜。当$n=3$时，明显先手必败。由于每次只可取$1$或$2$个，而取$2$个时，$2$个必须相邻，推断有：当$n&gt;3$时，若$n$为偶数，先手无论如何取，后手可在先手对称的位置上取同等数量，于是先手必败。若$n$为奇数，先手取$1$个时，后手可在先手对称的位置上取$2$个，之后无论先手如何取，后手都可在先手对称的位置上取同等数量，先手必败。如果先手一开始取$2$个时，后手可在先手对称的位置上取$1$个,之后还剩下偶数个,可如上推出先手必败。故当$n&gt;3$时,先手必败(来自链接) 这种模仿对手以判断是否是必胜的思想方式很有效，学到了。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int main()&#123; int n; for(;;)&#123; scanf("%d",&amp;n); if(!n)break; printf("%s\n",(n&lt;=2)?"Alice":"Bob"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1306 Combinations]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1306%2F</url>
    <content type="text"><![CDATA[题目地址 题解计算组合数即可12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef unsigned long long ll;ll C[105][105];ll read()&#123; ll x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void build()&#123; for(ll i=0;i&lt;=100;i++) C[i][0]=1; for(ll i=1;i&lt;=100;i++) for(ll j=1;j&lt;=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];&#125; int main()&#123; build(); ll u,v; for(;;)&#123; u=read(),v=read(); if(!u&amp;&amp;!v)return 0; printf("%llu things taken %llu at a time is %llu exactly.\n",u,v,C[u][v]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1285 Combinations, Once Again]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1285%2F</url>
    <content type="text"><![CDATA[题目地址 题解用基本的背包处理即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n[56],N,q,r;ll f[56];void packX(int d)&#123; int p=1,_n,j; for(j=N;j&gt;=0;j--) for(_n=1;_n&lt;=min(n[d],j);_n++) f[j]+=f[j-_n];&#125; int main()&#123; int i,j,T=1; for(;;T++)&#123; memset(n,0,sizeof(n)); memset(f,0,sizeof(f)); scanf("%d%d",&amp;N,&amp;q); if(!N&amp;&amp;!q)break; for(i=0;i&lt;N;i++) scanf("%d",&amp;j), n[j-1]++; for(f[0]=1ll,i=0;i&lt;N;i++) packX(i); printf("Case %d:\n",T); for(i=0;i&lt;q;i++) scanf("%d",&amp;r), printf("%lld\n",f[r]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Paired Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3669%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。按照产奶时间从大到小排序，然后小的和大的配对，更新最长时间即可。这不是普及组原题么123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P p[100005];int n,ans=0;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)p[i].second=read(),p[i].first=read(); sort(p+1,p+1+n);&#125;void solve()&#123; int po=n; for(int i=1;i&lt;=n;i++)&#123; while(po&gt;i&amp;&amp;p[i].second&gt;=p[po].second)&#123; if(p[po].second) p[i].second-=p[po].second,ans=max(ans,p[i].first+p[po].first); po--; &#125; if(po==i)break; p[po].second-=p[i].second; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Bovine Genomics S]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3670%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟吧。没想到更加优秀的做法。时间复杂度：$O(nm^3)$123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,ans=0,vis[100],key[256];char dna[1005][55];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n+n;i++)scanf("%s",dna[i]); key['A']=0,key['C']=1,key['G']=2,key['T']=3;&#125;void solve()&#123; int code,tot=0,flag=0; for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=j+1;k&lt;m;k++)&#123; tot++,flag=0; for(int t=1;t&lt;=n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; vis[code]=tot; &#125; for(int t=n+1;t&lt;=n+n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; if(vis[code]==tot)&#123; flag=1;break; &#125; &#125; if(!flag)ans++; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16JAN Radio Contact]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3133%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP。按照时间变化递推即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,pos1[1005][2],pos2[1005][2],f[1005][1005];char s1[1005],s2[1005];void movement(char c,int &amp;x,int &amp;y)&#123; if(c=='N')y++;if(c=='S')y--; if(c=='E')x++;if(c=='W')x--;&#125;int sqr(int a,int b)&#123; return (pos1[a][0]-pos2[b][0])*(pos1[a][0]-pos2[b][0])+ (pos1[a][1]-pos2[b][1])*(pos1[a][1]-pos2[b][1]);&#125;void init()&#123; n=read(),m=read(); pos1[0][0]=read(),pos1[0][1]=read(); pos2[0][0]=read(),pos2[0][1]=read(); scanf("%s%s",s1+1,s2+1); for(int i=1,x=pos1[0][0],y=pos1[0][1];i&lt;=n;i++) movement(s1[i],x,y), pos1[i][0]=x,pos1[i][1]=y; for(int i=1,x=pos2[0][0],y=pos2[0][1];i&lt;=m;i++) movement(s2[i],x,y), pos2[i][0]=x,pos2[i][1]=y;&#125;void solve()&#123; memset(f,0x14,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++) f[i][0]=f[i-1][0]+sqr(i,0); for(int i=1;i&lt;=m;i++) f[0][i]=f[0][i-1]+sqr(0,i); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[i][j]=min(f[i-1][j],f[i][j-1]), f[i][j]=min(f[i][j],f[i-1][j-1]), f[i][j]+=sqr(i,j); printf("%d\n",f[n][m]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16FEB Load Balancing]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3138%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。拿线扫描，然后直接模拟。可以二分，套上线段树可以做到$O(nlogn)$的复杂度。实际上应该不需要离散化。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P pp[1005],p1[1005],p2[1005];int n;int cmp(P a,P b)&#123; return a.second&lt;b.second||(a.second==b.second&amp;&amp;a.first&lt;b.first);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)pp[i].first=read(),pp[i].second=read(); sort(pp+1,pp+n+1); int cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].first==pp[i].first) pp[i-1].first=cnt; else pp[i-1].first=cnt,cnt+=2; &#125; pp[n].first=cnt; memcpy(p1+1,pp+1,sizeof(P)*n); sort(pp+1,pp+n+1,cmp); cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].second==pp[i].second) pp[i-1].second=cnt; else pp[i-1].second=cnt,cnt+=2; &#125; pp[n].second=cnt; memcpy(p2+1,pp+1,sizeof(P)*n); //离散化之后分别按照x,y坐标排序，进行扫描。。。 &#125;void solve()&#123; //a | c //------- //b | d //一开始放在最左点左边，最下点下面 int a=0,b=0,c=0,d=0,A=0,B=n,sep,ans=n,maxi; p1[0].first=0,p2[0].second=0; for(int i=1;i&lt;=n;i++,A++,B--)&#123; if(p1[i].first==p1[i-1].first)continue; a=A,c=B,b=d=0; sep=p1[i].first-1; for(int j=1;j&lt;=n;j++)&#123; if(p2[j].second!=p2[j-1].second)&#123; maxi=0; if(maxi&lt;a)maxi=a;if(maxi&lt;b)maxi=b; if(maxi&lt;c)maxi=c;if(maxi&lt;d)maxi=d; if(maxi&lt;ans)ans=maxi; &#125; if(p2[j].first&lt;sep) a--,b++; else c--,d++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN Diamond Collector]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3143%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。先排序，对于每一个钻石枚举他能到的最长区间，然后看他之前的和他这个区间不相交的最长区间。统计答案即可，时间复杂度$O(nlogn)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int a[100005],n,k,b[100005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1);&#125;void solve()&#123; int lst=0,ans=0,maxi=0; for(int i=1;i&lt;=n;i++)&#123; int loc=lower_bound(a+1,a+n+1,a[i]+k+1)-a-i; b[i]=loc; while(lst+b[lst+1]&lt;i) lst++,maxi=max(maxi,b[lst]); ans=max(ans,maxi+loc); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN 262144]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3147%2F</url>
    <content type="text"><![CDATA[题目地址 题解奇妙的做法。考虑倍增，由于合并必然是一整段连续的序列，所以设$f(i,j)$表示从$j$开始一直合并，直到出现$i$时的下标（开）。然后就可以倍增了。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int f[65][270000]=&#123;0&#125;,n,ans=0;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int u; scanf("%d",&amp;u),f[u][i]=i+1;//左闭右开 ans=max(ans,u); &#125;&#125;void solve()&#123; for(int i=2;i&lt;=60;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(!f[i][j]&amp;&amp;f[i-1][j]&amp;&amp;f[i-1][f[i-1][j]]) f[i][j]=f[i-1][f[i-1][j]], ans=max(ans,i); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO15OPEN Bessie Goes Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3123%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力枚举…单纯从经验上来说，这道题有背包的解法，但是讨论极其复杂，还不如套一堆循环。注意负数的处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//1B2E2S1I GOES 1M2Oll ans=0,cnt[7][7]=&#123;0&#125;;int n,mp[256];void init()&#123; n=read(); mp['B']=0,mp['E']=1,mp['S']=2, mp['I']=3,mp['G']=4,mp['O']=5, mp['M']=6; char ord[3]; ll u; for(int i=1;i&lt;=n;i++)&#123; scanf("%s%lld",ord,&amp;u); cnt[mp[ord[0]]][(u%7+7)%7]++; &#125;&#125;void solve()&#123; ll t1,t2,t3; for(int A=0;A&lt;7;A++) for(int B=0;B&lt;7;B++) for(int C=0;C&lt;7;C++) for(int D=0;D&lt;7;D++) for(int E=0;E&lt;7;E++) for(int F=0;F&lt;7;F++) for(int G=0;G&lt;7;G++)&#123; t1=A+B+B+C+C+D,t2=B+C+E+F,t3=G+F+F; if(t1%7==0||t2%7==0||t3%7==0) ans+=cnt[0][A]*cnt[1][B]*cnt[2][C]*cnt[3][D] *cnt[4][E]*cnt[5][F]*cnt[6][G]; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14FEB 路障Roadblock]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2176%2F</url>
    <content type="text"><![CDATA[题目地址 题解先跑一次最短路，然后对最短路上的边进行操作即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;int mp[105][105],E,V,vis[105],d[105],pre[105];void dijkstra(int o)&#123; int lst,at,i,j; fill(d,d+V,INF); memset(vis,0,sizeof(vis)); if(o)memset(pre,-1,sizeof(pre)); d[0]=0; for(i=0;i&lt;V;i++)&#123; for(lst=INF,j=0;j&lt;V;j++) if(!vis[j]&amp;&amp;d[j]&lt;lst)at=j,lst=d[j]; vis[at]=1; for(j=0;j&lt;V;j++) if(d[j]&gt;d[at]+mp[at][j])&#123; d[j]=d[at]+mp[at][j]; if(o)pre[j]=at; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); memset(mp,0x3f,sizeof(mp)); int i,j,u,v,ans=0,rec; for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;j), u--,v--,mp[u][v]=mp[v][u]=j; dijkstra(1),rec=d[V-1]; for(i=V-1;i!=-1;i=pre[i]) if(pre[i]!=-1) mp[i][pre[i]]&lt;&lt;=1, mp[pre[i]][i]&lt;&lt;=1, dijkstra(0), ans=max(ans,d[V-1]-rec), mp[i][pre[i]]&gt;&gt;=1, mp[pre[i]][i]&gt;&gt;=1; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Sabotage]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2115%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分答案，设为$ans$，那么判定条件 C(ans):\exists [i,j],\frac {sum[n]-sum[i...j]}{n-(j-i+1)}\le ans移项，等价于 sum[n]-ans\times n\le sum[j]-ans\times j-(sum[i-1]-ans\times (i-1))求右边的最大值即可。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[100005];double eps=1e-4,sum[100005]=&#123;0&#125;; bool C(double ans)&#123; double mini=sum[1]-ans,maxi=sum[2]-2*ans-(sum[1]-ans); for(int i=2;i&lt;n;i++)&#123; maxi=max(maxi,sum[i]-(double)i*ans-mini); mini=min(mini,sum[i]-(double)i*ans); &#125; return (sum[n]-(double)n*ans&lt;=maxi);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];&#125;void solve()&#123; double L=0,R=(a[1]+a[n])*0.5,M; while(R-L&gt;eps)&#123; M=(R+L)*0.5; if(C(M))R=M;else L=M; &#125; printf("%.3lf\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Mooo Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2214%2F</url>
    <content type="text"><![CDATA[题目地址 题解一开始很智障的每一步都求了一个背包…实际上只要求一次，然后$O(1)$回答询问。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,b,v[1005],s[100005],a[1005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125; void init()&#123; n=read(),b=read(); for(int i=1;i&lt;=b;i++)v[i]=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); &#125;void solve()&#123; int ans=0,cur=a[1]; memset(s,0x7f,sizeof(s)); s[0]=0; for(int j=1;j&lt;=b;j++)&#123; int *A=s,*B=s+v[j]; for(;B-s&lt;=100000;A++,B++)&#123; *B=min(*B,*A+1); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cur=a[i]-a[i-1]; if(a[i-1])cur++; if(s[cur]==0x7f7f7f7f)&#123; ans=-1;break; &#125;else ans+=s[cur]; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12JAN Video Game Combos]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3041%2F</url>
    <content type="text"><![CDATA[题目地址 题解AC自动机学了一天之后，终于想明白了一件事：为什么有时候按照AC图的递推形式不用$fail$?因为在$buildfail$的时候，已经利用了“指向的点要打上同样结束标记的性质”。这样貌似就无形之中运用了$fail$数组。真是神奇的东西啊。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,que[10005],f,r;char T[10005],tmp[10005];int trie[10005][26]=&#123;0&#125;,cnt=0;int val[10005];int fail[10005],SIG_SIZE=26;int dp[1005][305]=&#123;0&#125;;bool vis[1005][305]=&#123;0&#125;;//0-&gt;rootvoid trie_insert(char *a)&#123; int p=0; for(;*a;a++)&#123; if(!trie[p][*a-'A']) trie[p][*a-'A']=++cnt; p=trie[p][*a-'A']; &#125; val[p]++;&#125;void getFail()&#123; f=r=0,fail[0]=0; for(int i=0;i&lt;SIG_SIZE;i++)&#123; int h=trie[0][i]; if(h) fail[h]=0,que[r++]=h; &#125; while(r-f)&#123; int h=que[f++],i,_v,f; for(i=0;i&lt;SIG_SIZE;i++)&#123; _v=trie[h][i]; if(!_v)&#123; trie[h][i]=trie[fail[h]][i]; continue; &#125; que[r++]=_v,f=fail[h]; for(;f&amp;&amp;!trie[f][i];f=fail[f]); fail[_v]=trie[f][i]; val[_v]+=val[fail[_v]];// &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",tmp),trie_insert(tmp); getFail(); for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=cnt;j++) dp[i][j]=-2000000000; dp[0][0]=0; for(int i=1;i&lt;=m;i++)&#123; for(int j=0;j&lt;=cnt;j++)&#123; int x; for(int k=0;k&lt;3;k++)&#123; x=trie[j][k]; dp[i][x]=max(dp[i][x],dp[i-1][j]+val[x]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;=cnt;i++) ans=max(ans,dp[m][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12OPEN Bookshelf]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1848%2F</url>
    <content type="text"><![CDATA[题目地址 题解同poj cut the sequence然而开始我还没发现这是原题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,l=1,r=1,que[100005];ll m,h[100005],w[100005],f[100005];multiset&lt;ll&gt; s;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;h[i],&amp;w[i]);&#125;void solve()&#123; ll cnt=0,ans_; int j=0;//左边是开区间,que[l...r]递减 for(int i=1;i&lt;=n;i++)&#123; cnt+=w[i]; while(cnt&gt;m)cnt-=w[++j]; while(r-l&amp;&amp;que[l]&lt;=j)&#123; if(r-l&gt;1) s.erase(h[que[l+1]]+f[que[l]]); //在读这一段代码的时候，请仔细思考。 //有两个，更大的在l，更小的在l+1 l++; &#125; while(r-l&amp;&amp;h[que[r-1]]&lt;=h[i])&#123; if(r-l&gt;1) s.erase(h[que[r-1]]+f[que[r-2]]); r--; &#125; que[r++]=i; if(r-l&gt;1&amp;&amp;i&gt;que[r-2])s.insert(h[i]+f[que[r-2]]); ans_=*s.begin(); f[i]=h[que[l]]+f[j]; if(r-l&gt;1&amp;&amp;ans_&lt;f[i])f[i]=ans_; &#125; printf("%lld\n",f[n]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Cow Line]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3014%2F</url>
    <content type="text"><![CDATA[题目地址 题解虽然可以用高中数学题的思路，但也可以用康拓展开。实现上估计差别不会很大。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40],vis[30];ll fac[40];void makep()&#123; ll x,t;int rk,j,k; scanf("%lld",&amp;x); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; t=0; for(j=1;j&lt;=n-i+1;j++)&#123; if(x&lt;=t+fac[n-i])break; t+=fac[n-i]; &#125; x-=t,rk=0; for(k=1;k&lt;=n;k++)&#123; if(!vis[k])rk++; if(rk==j)break; &#125; printf("%d ",k); vis[k]=1; &#125; for(int i=1;i&lt;=n;i++) if(!vis[i])printf("%d\n",i);&#125;ll query()&#123; ll ans=0;int rk,j,k; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; rk=0; for(k=1;k&lt;a[i];k++) if(!vis[k])rk++; vis[a[i]]=1; ans+=(ll)rk*fac[n-i]; &#125; return ans+1;&#125;void init()&#123; n=read(),m=read(); fac[1]=fac[0]=1; for(int i=2;i&lt;=20;i++)fac[i]=fac[i-1]*(ll)i;&#125;void solve()&#123; char ord[3]; while(m--)&#123; scanf("%s",ord); if(ord[0]=='P')makep(); else&#123; for(int i=1;i&lt;=n;i++)a[i]=read(); printf("%lld\n",query()); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Generic Cow Protest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1569%2F</url>
    <content type="text"><![CDATA[题目地址 题解水$DP$，设$f(i)$为以$i$为某一组结尾的最大组数，那么 f(i)=\max \limits_{0\le j]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11DEC Grass Planting]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3038%2F</url>
    <content type="text"><![CDATA[题目地址 题解树剖，不过是边问题，所以把边问题改成边的下面那个点的问题。处理的时候注意一下即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int v,_next; &#125;; Edge edge[200005];int cnt=0,at[100005]=&#123;0&#125;;int fa[100005],son[100005]=&#123;0&#125;,siz[100005],top[100005],depth[100005],pos[100005],fp[100005],val[100005];int S,nows=0,n,m,_a,_b,C[400005];int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int k,int v)&#123; while(k&lt;=S)C[k]+=v,k+=lowbit(k);&#125;int query(int r)&#123; int res=0; while(r)res+=C[r],r-=lowbit(r); return res;&#125;void addedge(int _u,int _v)&#123; edge[++cnt].v=_v, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; void dfs1(int x,int par,int d)&#123; depth[x]=d,fa[x]=par,siz[x]=1; for(int i=at[x];i;i=edge[i]._next)&#123; if(edge[i].v==par)continue; int _v=edge[i].v; dfs1(_v,x,d+1); siz[x]+=siz[_v]; if(!son[x]||siz[_v]&gt;siz[son[x]]) son[x]=_v; &#125;&#125;void dfs2(int x,int tp)&#123; top[x]=tp,pos[x]=++nows,fp[nows]=x; if(!son[x])return; dfs2(son[x],tp); for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa[x]&amp;&amp;edge[i].v!=son[x]) dfs2(edge[i].v,edge[i].v);&#125;void update_tr(int u,int v)&#123; while(top[u]!=top[v])&#123; if(depth[top[u]]&lt;depth[top[v]]) swap(u,v); update(pos[top[u]],1); update(pos[u]+1,-1); u=fa[top[u]]; &#125; if(depth[u]&lt;depth[v])swap(u,v); if(u==v)return ; v=son[v]; update(pos[u]+1,-1); update(pos[v],1);&#125;int query_tr(int u,int v)&#123; if(depth[u]&lt;depth[v])swap(u,v); return query(pos[u]);&#125;void init()&#123; n=read(),m=read(); for(S=1;S&lt;=n;S&lt;&lt;=1); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; dfs1(1,0,1); dfs2(1,1);&#125;void solve()&#123; char ord[3]; int x,y; while(m--)&#123; scanf("%s%d%d",ord,&amp;x,&amp;y); if(ord[0]=='P')update_tr(x,y); else printf("%d\n",query_tr(x,y)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11NOV Cow Steeplechase]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3033%2F</url>
    <content type="text"><![CDATA[题目地址 题解把线段抽象成点，线段相交就连一条边，然后求一个最大独立集。由于在二分图中，最大匹配就等于最小顶点覆盖，并且对于图来说，最大独立集加上最小顶点覆盖就等于点个数，所以直接上二分图匹配就行了。线段求交…计算几何123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,vis[255],match[255]=&#123;0&#125;,seg[255][4];int X[255],Y[255],cx=0,cy=0;bool mat[255][255]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int Edmond(int S)&#123; for(int i=1;i&lt;=cy;i++)&#123; if(mat[S][i]&amp;&amp;!vis[i])&#123; vis[i]=1; if(!match[i]||Edmond(match[i]))&#123; match[i]=S; return 1; &#125; &#125; &#125; return 0;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=4;j++) seg[i][j]=read(); if(seg[i][1]==seg[i][3])&#123; Y[++cy]=i;//竖直 if(seg[i][2]&gt;seg[i][4]) swap(seg[i][2],seg[i][4]); &#125;else &#123; X[++cx]=i;//水平 if(seg[i][1]&gt;seg[i][3]) swap(seg[i][1],seg[i][3]); &#125; &#125; for(int i=1;i&lt;=cx;i++) for(int j=1;j&lt;=cy;j++) if(seg[Y[j]][1]&gt;=seg[X[i]][1]&amp;&amp;seg[Y[j]][1]&lt;=seg[X[i]][3]&amp;&amp; seg[X[i]][2]&gt;=seg[Y[j]][2]&amp;&amp;seg[X[i]][2]&lt;=seg[Y[j]][4]) mat[i][j]=1;&#125;void solve()&#123; int ans=0; for(int i=1;i&lt;=cx;i++)&#123; memset(vis,0,sizeof(vis)); if(Edmond(i))ans++; &#125; printf("%d\n",n-ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Chocolate buying]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2983%2F</url>
    <content type="text"><![CDATA[题目地址 题解差点写成多重背包，好险好险其实就是水贪心…1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n;ll b;pair&lt;ll,ll&gt; P[100005];void init()&#123; scanf("%d%lld",&amp;n,&amp;b); for(int i=0;i&lt;n;i++) scanf("%lld%lld",&amp;P[i].first,&amp;P[i].second);&#125;void solve()&#123; ll ans=0; sort(P,P+n); for(int i=0;i&lt;n;i++)&#123; if(b&lt;P[i].first)break; ll res=min(b/P[i].first,P[i].second); ans+=res; b-=res*P[i].first; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Treasure Chest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3004%2F</url>
    <content type="text"><![CDATA[题目地址 题解$DP$。时间复杂度为$O(n^2)$。我的方法是设$f(i,j)$表示从$i$到$j$先手最高分数，然后转移方程就是 f(i,j)=\max \left\{ c[i]+\min\left\{f(i+2,j),f(i+1,j-1)\right\} ,c[j]+\min\left\{f(i+1,j-1),f(i,j-2)\right\}\right\}但不知道为什么本机过了,洛谷上T了。当然本题的官方做法更巧妙。观察前面带有$\min$的式子，我们发现里面的$\min$可以拿掉，因为我们刚好也算出了第二个人作为先手的最大解。所以上面的$\min$就可以表示为$f$的形式，即 \min \left\{ f(i+2,j),f(i+1,j-1) \right\} =sum(i+1,j)-f(i+1,j)这样常数貌似很小，就可以过，还可以干掉一维空间。 修改前：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005][5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=0;i&lt;n;i++)c[i]=read();&#125;void solve()&#123; int d1,d2,d3,b1,b2,lim; for(int i=0;i&lt;n;i++) dp[i][i]=c[i]; for(int j=0;j&lt;n-1;j++) dp[j][j+1]=max(c[j],c[j+1]); for(int j=2;j&lt;n;j++)&#123; d1=dp[0][j-2],d2=dp[1][j-1],d3=dp[2][j]; lim=n-j; for(int i=0;i&lt;lim;i++)&#123; b1=d3;if(d2&lt;d3)b1=d2;b1+=c[i]; b2=d1;if(d2&lt;d1)b2=d2;b2+=c[i+j]; dp[i][i+j]=b1;if(b1&lt;b2)dp[i][i+j]=b2; d1=d2,d2=d3,d3=dp[i+3][i+1+j]; &#125; &#125; printf("%d\n",dp[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125; 修改后：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005]=&#123;0&#125;,sum[5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)c[i]=read(),sum[i]=sum[i-1]+c[i];&#125;void solve()&#123; for(int j=0;j&lt;n;j++) for(int i=1;i+j&lt;=n;i++) dp[i]=sum[i+j]-sum[i-1]-min(dp[i],dp[i+1]); printf("%d\n",dp[1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09MAR Look Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2947%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力肯定行不通，考虑到无用元素的去除以及单调性的维护，我们使用单调栈这一数据结构。实际上这题跟06年那道题一个意思，所以要看的话可以去前面找一下我写的另一篇题解。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int n,s[100005][2],dat[100005],top=0,ans[100005];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;dat[i]); s[top][0]=dat[n-1], s[top++][1]=n-1, ans[n-1]=-1; for(int i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;dat[i]&gt;=s[top-1][0]) top--; if(!top)ans[i]=-1; else ans[i]=s[top-1][1]; s[top][0]=dat[i], s[top++][1]=i; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09OPEN Cow Digit Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2953%2F</url>
    <content type="text"><![CDATA[题目地址 题解很标准的博弈论递推。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool sg[1000005];void init()&#123; sg[0]=0; int bit[9]=&#123;0&#125;,maxi,mini,len=1; for(int i=1;i&lt;=1000000;i++)&#123; bit[0]++; for(int j=0;bit[j]==10&amp;&amp;j&lt;len;j++) bit[j]=0,bit[j+1]++; if(bit[len])len++; mini=10,maxi=0; for(int j=0;j&lt;len;j++)&#123; if(bit[j]&gt;maxi)maxi=bit[j]; if(bit[j]&lt;mini&amp;&amp;bit[j])mini=bit[j]; &#125; if(!sg[i-maxi]||!sg[i-mini])sg[i]=1; &#125;&#125;void solve()&#123; int T=read(),n; while(T--) n=read(),printf("%s\n",sg[n]?"YES":"NO");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09NOV A Coin Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2964%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$dp(i,j)$表示还剩$i$个，之前选了$j$个的状态。正面非常不好做，所以要用这个倒着推的状态。转移只要$2$个，因为其他转移之前已经包含了。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int dp[2005][2005],n,a[2005],sum[2005],que[4000005][2],f=0,r=0;void init()&#123; n=read(); sum[0]=0; for(int i=n;i&gt;=1;i--)a[i]=read(); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; //正面不好写 &#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=dp[i][j-1]; if(i-2*j&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j][2*j]); if(i-2*j+1&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j+1][2*j-1]); &#125; &#125; printf("%d\n",dp[n][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09FEB Revamping Trails]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2939%2F</url>
    <content type="text"><![CDATA[题目地址 题解最短路模型，这很显然。顺带一提，不要用SPFA，真心卡成狗。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 1010000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int to,_next,cost;&#125;;struct Node&#123; int h,e,dis; Node(int h_,int e_,int d_)&#123; h=h_,e=e_,dis=d_; &#125; Node()&#123;&#125;&#125;;bool operator &lt;(const Node &amp;n1,const Node &amp;n2)&#123; return n1.dis&gt;n2.dis;&#125;priority_queue&lt;Node&gt; pq;Edge edge[100005];int n,m,k,at[10005]=&#123;0&#125;,F[10005][21]=&#123;0&#125;,cnt=0;void addedge(int u,int v,int c)&#123; edge[++cnt].to=v, edge[cnt].cost=c, edge[cnt]._next=at[u], at[u]=cnt;&#125;void Dij()&#123; F[1][0]=0,pq.push(Node(1,0,0)); Node tmp; int h_,e_,d_,v_,c_; while(!pq.empty())&#123; tmp=pq.top(),pq.pop(); if(tmp.dis&gt;F[tmp.h][tmp.e])continue; h_=tmp.h,e_=tmp.e,d_=tmp.dis; for(int i=at[h_];i;i=edge[i]._next)&#123; v_=edge[i].to,c_=edge[i].cost; if(F[v_][e_]&gt;F[h_][e_]+c_) F[v_][e_]=F[h_][e_]+c_, pq.push(Node(v_,e_,F[v_][e_])); if(e_&lt;k&amp;&amp;F[v_][e_+1]&gt;F[h_][e_]) F[v_][e_+1]=F[h_][e_], pq.push(Node(v_,e_+1,F[v_][e_+1])); &#125; &#125;&#125;void init()&#123; n=read(),m=read(),k=read(); int u,v,c; for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),c=read(); addedge(u,v,c),addedge(v,u,c); &#125;&#125;void solve()&#123; memset(F,0x3F,sizeof(F)); Dij(); int ans=INF*2; for(int i=0;i&lt;=k;i++)ans=min(ans,F[n][i]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08DEC Patting Heads]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2926%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力筛倍数即可。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,a[100005],cnt[1000005]=&#123;0&#125;,ans[1000005]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]),cnt[a[i]]++;&#125;void solve()&#123; for(int i=1;i&lt;=1000000;i++)&#123; if(cnt[i])&#123; for(int j=i;j&lt;=1000000;j+=i) ans[j]+=cnt[i]; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[a[i]]-1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08JAN Telephone Lines]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu1948%2F</url>
    <content type="text"><![CDATA[题目地址 题解一看就知道是二分答案的类型。二分最小费用$x$，然后看路上最少经过几条费用比他多的路。这题就一个地方有点绕：怎么求$1$-$n$之间路上有几条这样的路？要么边跑最短路边特判，要么把边分类，大于$x$的边权设$1$，小于的设$0$。这样就解决了这道题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next;&#125;;Edge edge[20005],_edge[20005];int V,E,K,at[1005],cnt=0,maxi=0;int d[1005],que[50005],f,r,in[1005]=&#123;0&#125;;void addedge(int _u,int _v,int _c)&#123; edge[cnt].v=_v, edge[cnt].cost=_c, edge[cnt]._next=at[_u], at[_u]=cnt++; &#125;void spfa_bfs(int S)&#123; fill(d,d+V,INF); d[S]=0; f=r=0,que[r++]=S,in[S]=1; while(r-f)&#123; int h=que[f++],_v,_c; for(int i=at[h];i!=-1;i=_edge[i]._next)&#123; _v=_edge[i].v,_c=_edge[i].cost; if(d[_v]&gt;d[h]+_c)&#123; d[_v]=d[h]+_c; if(!in[_v]) in[_v]=1,que[r++]=_v; &#125; &#125; in[h]=0; &#125;&#125;void init()&#123; scanf("%d%d%d",&amp;V,&amp;E,&amp;K); memset(at,-1,sizeof(at)); int u,v,c; for(int i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;c), addedge(u-1,v-1,c), addedge(v-1,u-1,c), maxi=max(maxi,c);&#125;void solve()&#123; int L=0,R=maxi,M; memcpy(_edge,edge,sizeof(edge)); while(R-L)&#123; int M=(R+L)/2; for(int i=0;i&lt;cnt;i++) _edge[i].cost=(edge[i].cost&gt;M); spfa_bfs(0); if(d[V-1]==INF)&#123; printf("-1\n"); return ; &#125; if(d[V-1]&gt;K)L=M+1; else R=M; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Time Management]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2920%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分+贪心每次优先完成期限最短且时间最短的任务。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,t[1005],s[1005],mini=INF;pair&lt;int,int&gt; P[1005];bool judge(int M)&#123; for(int i=0;i&lt;n;i++)&#123; if(M+P[i].second&lt;=P[i].first) M+=P[i].second; else return 0; &#125; return 1;&#125;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;t[i],&amp;s[i]), P[i].first=s[i],P[i].second=t[i], mini=min(mini,s[i]); sort(P,P+n);&#125;void solve()&#123; int L=0,R=mini,M; while(R-L)&#123; M=(R+L+1)/2; if(judge(M)) L=M; else R=M-1; &#125; if(!judge(0))L=-1; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR River Crossing]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2904%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP注意划船回来的时间12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int sum[2505],n,f[2505]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%d",&amp;n,&amp;sum[0]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;sum[i]), sum[i]+=sum[i-1];&#125;void solve()&#123; fill(f,f+n+1,INF); f[0]=0; for(int i=1;i&lt;=n;i++) for(int j=i-1;j&gt;=0;j--) f[i]=min(f[i],f[j]+sum[i-j]+sum[0]); printf("%d\n",f[n]-sum[0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OPEN Cow Neighborhoods]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2906%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个绝对值很难搞啊。拆开来试试看？ |x_1-x_2|+|y_1-y_2|=x_1-x_2+y_1-y_2或x_2-x_1+y_1-y_2或x_1-x_2+y_2-y_1或x_2-x_1+y_2-y_1发现前两个是相反数，中间俩也是。原式=|x_1+y_1-(x_ 2+y_2)|或|(x_1-y_1)-(x_2-y_2)|。这时候发现两个式子里面都是只与下标有关值的差，就设xx_i=x_i+y_i,yy_i=x_i-y_i。原式=|xx_1-xx_2|或|yy_1-yy_2|。我怎么知道取哪个?不知道，就让他们都满足。即使\max \left\{|xx_1-xx_2|,|yy_1-yy_2|\right\}\le c。之后就是乱搞了，维护一下差即可，用并查集合并可行部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,C,x[100005],y[100005],xx[100005],yy[100005],rk[100005];int par[100005],cnt[100005],ans1=0,ans2=0,S=0,ans,loc;int que[100005],f,r;struct Tr&#123; Tr *ch[2]; int r,v,id; int cmp(int w,int z) const &#123; if(w==v&amp;&amp;z==id)return -1; return w&gt;v||(w==v&amp;&amp;z&gt;id); &#125;&#125;;Tr tree[400005],*root=NULL;void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr,tr=k;&#125;void insert_tr(Tr* &amp;tr,int _v,int _id)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;v=_v,tr-&gt;id=_id; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); return ; &#125; int d=tr-&gt;cmp(_v,_id); insert_tr(tr-&gt;ch[d],_v,_id); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1);&#125;void delete_tr(Tr* &amp;tr,int _v,int _id)&#123; int d=tr-&gt;cmp(_v,_id); if(d==-1)&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),delete_tr(tr-&gt;ch[d_],_v,_id); &#125; &#125;else delete_tr(tr-&gt;ch[d],_v,_id);&#125; void previous(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&gt;=tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,previous(tr-&gt;ch[1],_v); else previous(tr-&gt;ch[0],_v);&#125;void success(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&lt;tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,success(tr-&gt;ch[0],_v); else success(tr-&gt;ch[1],_v);&#125;int Find(int k)&#123; if(k==par[k])return k; return (par[k]=(Find(par[k])));&#125;void Unite(int u,int v)&#123; if(Find(u)==Find(v))return; par[Find(u)]=Find(v);&#125;bool cmp(int ia,int ib)&#123; return xx[ia]&lt;xx[ib]||(xx[ia]==xx[ib]&amp;&amp;yy[ia]&lt;yy[ib]);&#125;void init()&#123; srand(21451); n=read(),C=read(); for(int i=1;i&lt;=n;i++) x[i]=read(),y[i]=read(),xx[i]=x[i]+y[i],yy[i]=x[i]-y[i],rk[i]=par[i]=i; sort(rk+1,rk+1+n,cmp);&#125;void solve()&#123; f=r=0,que[r++]=rk[1],insert_tr(root,yy[rk[1]],rk[1]); for(int i=2;i&lt;=n;i++)&#123; int index=rk[i]; while(r&gt;f&amp;&amp;xx[index]-xx[que[f]]&gt;C) delete_tr(root,yy[que[f]],que[f]),f++; ans=-INF,success(root,yy[index]);//查后缀 if(ans&gt;-INF&amp;&amp;ans-yy[index]&lt;=C)Unite(loc,index); ans=INF,previous(root,yy[index]);//查前缀 if(ans&lt;INF&amp;&amp;yy[index]-ans&lt;=C)Unite(loc,index); insert_tr(root,yy[index],index); que[r++]=index; &#125; for(int i=1;i&lt;=n;i++)cnt[Find(i)]++; for(int i=1;i&lt;=n;i++)ans1+=(cnt[i]!=0),ans2=max(ans2,cnt[i]); printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Eating Together]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2896%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一大力$O(nlogn)LIS$。优点：不容易错，缺点：时间复杂度高。 方法二运用特殊性质，分段$DP$，分别用$f(x),g(x),h(x)$表示以$1,2,3$为结尾的一段的最小修改次数。优点：时间复杂度线性缺点：容易错容易错容易错难调难调难调123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[30005],f[30005],g[30005],h[30005];void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();&#125;int dp()&#123; int mini,dif=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=1),f[i]=dif; dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=2),g[i]=mini+dif,mini=min(mini,f[i]-dif); dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=3),h[i]=mini+dif,mini=min(mini,min(g[i]-dif,f[i]-dif)); return min(f[n],min(g[n],h[n]));&#125;void solve()&#123; int ans=dp(); reverse(a+1,a+n+1); ans=min(ans,dp()); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Game of Lines]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2665%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力统计即可。wa了2次的我就是sb啊12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,x[205],y[205],tot=0;double lis[40005],eps=1e-8;double slope(int a,int b)&#123; if(x[a]==x[b])return 1e9; return (double)(y[b]-y[a])/(x[b]-x[a]);&#125;int cmp(double a,double b)&#123; return (a-b)&gt;-eps&amp;&amp;(a-b)&lt;eps;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)x[i]=read(),y[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;i;j++) lis[++tot]=slope(i,j); sort(lis+1,lis+tot+1); int ans=0; for(int i=2;i&lt;=tot;i++)&#123; while(cmp(lis[i],lis[i-1])&amp;&amp;i&lt;=tot) i++; ans++; &#125; if(!cmp(lis[tot],lis[tot-1]))ans++; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Watering Hole]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1550%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果没说全部连通的话就会形成一个特殊的局面：森林。把一个无向森林结合起来的常用方法就是加点。加一个超级源，使打井变成这个源到节点的边权，再MST即可。数据小，貌似暴力也行？12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int mat[405][405],w[405],n;int vis[405],mini[405];int prim(int S)&#123; memset(mini,0x3f,sizeof(mini)); mini[S]=0; int i,j,_min,at,ans=0; for(i=0;i&lt;n;i++)&#123; for(at=-1,j=0;j&lt;n;j++) if(!vis[j]&amp;&amp;(at&lt;0||mini[j]&lt;mini[at])) at=j; vis[at]=1,ans+=mini[at]; for(j=0;j&lt;n;j++) mini[j]=min(mini[j],mat[at][j]); &#125; return ans; &#125;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;w[i]); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(int i=0;i&lt;n;i++) mat[i][n]=mat[n][i]=w[i]; mat[n][n]=0; n++; printf("%d\n",prim(n-1)); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR Land Acquisition]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2900%2F</url>
    <content type="text"><![CDATA[题目地址 题解斜率优化。 合并部分土地，使$y$递减，$x$递增 注意单调队列的增减性。 决策的单调性… 凸壳的中间点在什么情况下一定不优？考虑不同的限定条件，可以证明两端分别在2种情况下都更优。这是单调队列单调的理由。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; P;P a[50005],b[50005];int n,cnt=0,que[50005]=&#123;0&#125;,l=1,r=1; ll f[50005];double slope(int j,int k)&#123; return (f[k]-f[j])/(b[j+1].second-b[k+1].second);&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i].first=read(),a[i].second=read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; //printf("%d %d\n",a[i].first,a[i].second); while(cnt&amp;&amp;a[i].second&gt;=b[cnt].second) cnt--; b[++cnt]=a[i]; &#125;&#125;void solve()&#123; que[r++]=0; for(int i=1;i&lt;=cnt;i++)&#123; while(r-l&gt;1&amp;&amp;slope(que[l],que[l+1])&lt;b[i].first) l++; f[i]=f[que[l]]+b[que[l]+1].second*b[i].first; while(r-l&gt;1&amp;&amp;slope(que[r-2],que[r-1])&gt;slope(que[r-1],i)) r--; que[r++]=i; &#125; printf("%lld\n",f[cnt]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OPEN Cheapest Palindrome]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2890%2F</url>
    <content type="text"><![CDATA[题目地址 题解区间DP没想出来的我该去看脑科12345678910111213141516171819202122232425262728293031323334353637 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,add[30],rem[30],dp[2005][2005];char s[2005],ord[3],is[2005][2005]=&#123;0&#125;;void init()&#123; scanf("%d%d%s",&amp;n,&amp;m,s); for(int i=0;i&lt;n;i++)&#123; scanf("%s",ord); scanf("%d%d",&amp;add[ord[0]-'a'],&amp;rem[ord[0]-'a']); &#125; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) dp[i][j]=(i&lt;j)?INF:0;&#125;void solve()&#123; for(int j=0;j&lt;m;j++) for(int i=0;i+j&lt;m;i++) if(s[i]==s[i+j])dp[i][i+j]=dp[i+1][i+j-1]; else&#123; dp[i][i+j]=min(dp[i+1][i+j]+rem[s[i]-'a'], min(dp[i+1][i+j]+add[s[i]-'a'], min(dp[i][i+j-1]+rem[s[i+j]-'a'], dp[i][i+j-1]+add[s[i+j]-'a']))); &#125; printf("%d\n",dp[0][m-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Protecting the Flowers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2878%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设牛$i$和牛$j$相邻，那么比较他们谁先送走更划算的依据是$T_iD_j$和$T_jD_i$。$T_iD_j&gt;T_jD_i$那么$j$先走，否则$i$先走。由此得判断依据：$\frac {T_i}{D_i}$与$\frac {T_j}{D_j}$。小的先走。之后排序贪心即可。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll n,t[100005],d[100005],ans=0,sum=0;pair&lt;double,ll&gt; P[100005];void init()&#123; scanf("%lld",&amp;n); for(ll i=0;i&lt;n;i++) scanf("%lld%lld",&amp;t[i],&amp;d[i]), P[i].first=(double)t[i]/d[i], P[i].second=i; sort(P,P+n); for(ll i=0;i&lt;n;i++) sum+=d[i];&#125;void solve()&#123; for(ll i=0;i&lt;n;i++)&#123; ll id=P[i].second; sum-=d[id]; ans+=2*t[id]*sum; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待考察 USACO07JAN Problem Solving]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2876%2F</url>
    <content type="text"><![CDATA[题目地址 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,b,f[605][305],A[305],B[305],sum[305],sumb[305],ans;void init()&#123; b=read(),n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(),B[i]=read(),sum[i]=sum[i-1]+A[i],sumb[i]=sumb[i-1]+B[i];&#125;void solve()&#123; f[2][0]=b; for(int i=1;i&lt;=n;i++) if(b&gt;=sum[i]&amp;&amp;b&gt;=sumb[i])f[2][i]=b-sumb[i]; else f[2][i]=-INF; for(int i=3;i&lt;=2*n;i++)&#123; f[i][0]=b; for(int j=1;j&lt;=n;j++)&#123; f[i][j]=-INF; for(int k=0;k&lt;=j;k++) if(f[i-1][k]-(sum[j]-sum[k])&gt;=0) f[i][j]=max(f[i][j],b-(sumb[j]-sumb[k])); &#125; if(f[i][n]&gt;=0)&#123; ans=i;break; &#125; &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OCT Obstacle Course]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1649%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力建图跑SPFA即可。就是要注意建图的方式：一个点拆成4个。同时注意输入，有坑！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[2000005];int cnt=0,at[40005],n,V;int d[40005],in[40005],que[500005],f=0,r=0;void spfa_bfs(int s)&#123; fill(d+1,d+4*V+1,INF); for(int i=0;i&lt;4;i++) d[s+i*V]=0,in[s+i*V]=1,que[r++]=s+i*V; int i,_u,_v,_co; while(r-f)&#123; _u=que[f++],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r++]=_v; &#125; &#125; &#125; &#125;&#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int xa,xb,ya,yb;char mat[105][105];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); char ord[1005]; int tot,len; for(int i=1;i&lt;=n;i++)&#123; fgets(ord,300,stdin); len=strlen(ord),tot=1; for(int j=0;j&lt;len;j++) if(!isspace(ord[j]))mat[i][tot++]=ord[j]; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(mat[i][j]=='A')xa=i,ya=j; else if(mat[i][j]=='B')xb=i,yb=j; V=n*n; memset(at,-1,sizeof(at)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(mat[i][j]=='x') continue; //1上2下3左4右 int id=(i-1)*n+j; addedge(id,2*V+id,1),addedge(2*V+id,id,1), addedge(id,V+id,2),addedge(V+id,id,2), addedge(id,3*V+id,1),addedge(3*V+id,id,1), addedge(2*V+id,V+id,1),addedge(V+id,2*V+id,1), addedge(3*V+id,V+id,1),addedge(V+id,3*V+id,1), addedge(2*V+id,3*V+id,2),addedge(3*V+id,2*V+id,2); if(i!=1&amp;&amp;mat[i-1][j]!='x')addedge(id,id-n,0); if(i!=n&amp;&amp;mat[i+1][j]!='x')addedge(V+id,V+(id+n),0); if(j!=1&amp;&amp;mat[i][j-1]!='x')addedge(2*V+id,2*V+(id-1),0); if(j!=n&amp;&amp;mat[i][j+1]!='x')addedge(3*V+id,3*V+(id+1),0); &#125;&#125;void solve()&#123; int id=(xa-1)*n+ya; spfa_bfs(id); id=(xb-1)*n+yb; int ans=min(min(min(d[id],d[V+id]),d[2*V+id]),d[3*V+id]); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07DEC Gourmet Grazers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2869%2F</url>
    <content type="text"><![CDATA[题目地址 题解STL大法好multiset水题按照贪心的思想，每次给牛中对草的质量最高的安排一个草的质量比他高的，且最便宜的。用平衡树维护即可。时限宽松，所以用multiset暴力水过123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;multiset&lt;int&gt; s;pair&lt;int,int&gt; P[100005],C[100005];ll ans=0; int n,m;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)C[i].second=read(),C[i].first=read(); for(int i=1;i&lt;=m;i++)P[i].second=read(),P[i].first=read(); sort(P+1,P+m+1); sort(C+1,C+n+1);&#125;void solve()&#123; for(int i=n,j=m;i&gt;=1;i--)&#123; while(j&gt;=1&amp;&amp;P[j].first&gt;=C[i].first) s.insert(P[j].second),j--; if(s.empty())&#123; printf("-1\n"); return ; &#125;else&#123; int ans_=*s.lower_bound(C[i].second); ans+=ans_,s.erase(s.find(ans_)); &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06FEB Treats for the Cows]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2858%2F</url>
    <content type="text"><![CDATA[题目地址 题解傻DP…区间转移形式12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,v[2005],f[2005][2005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=0;i&lt;n;i++) v[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;n;i++) f[i][i]=v[i]*n; for(int j=1;j&lt;n;j++) for(int i=0;i+j&lt;n;i++)&#123; f[i][i+j]=max(f[i+1][i+j]+v[i]*(n-j),f[i][i+j-1]+v[i+j]*(n-j)); &#125; printf("%d\n",f[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06NOV Bad Hair Day]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2866%2F</url>
    <content type="text"><![CDATA[题目地址 题解单调栈模板题。从右到左记录一个递减的序列即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; #include &lt;cstdlib&gt;using namespace std;int st[80005][2],top=0,n,h[80005];long long ans=0;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;h[i]); st[top][0]=h[n-1],st[top++][1]=n-1; for(i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;h[i]&gt;st[top-1][0]) top--; if(!top) ans+=(n-1-i); else ans+=(st[top-1][1]-i-1); st[top][0]=h[i],st[top++][1]=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06DEC Cow Roller Coaster]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2854%2F</url>
    <content type="text"><![CDATA[题目地址 题解先排序，把整个轨道考虑的顺序弄起来，再做01背包。注意状态的可行性。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,B,dp[1005][1005];struct C&#123; int l,r,fun,cost; bool operator &lt;(C &amp;a)&#123; return l&lt;a.l||(l==a.l&amp;&amp;r&lt;a.r); &#125;&#125;comp[10005];void init()&#123; L=read(),n=read(),B=read(); for(int i=1;i&lt;=n;i++) comp[i].l=read(),comp[i].r=read()+comp[i].l, comp[i].fun=read(),comp[i].cost=read(); sort(comp+1,comp+1+n);&#125;void solve()&#123; int c_,l_,r_,f_; memset(dp,-1,sizeof(dp)); for(int i=0;i&lt;=B;i++)dp[i][0]=0; for(int i=1;i&lt;=n;i++)&#123; c_=comp[i].cost,l_=comp[i].l,r_=comp[i].r,f_=comp[i].fun; for(int j=B;j&gt;=c_;j--) if(dp[j-c_][l_]&gt;=0) dp[j][r_]=max(dp[j][r_],dp[j-c_][l_]+f_); &#125; printf("%d\n",dp[B][L]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI1998 个人所得税]]></title>
    <url>%2F2018%2F08%2F02%2Fnoi1998t1%2F</url>
    <content type="text"><![CDATA[暂无题目地址！ 题解模拟即可。开数组存每个员工每个月的收入，最后再计算；遇到单个的就直接计算。本题读入很神奇，需注意。还有就是负数的处理问题，应交税的部分不能为负。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int m,money[50005][20]=&#123;0&#125;;char typ[10],tim[10],PAY[]="PAY",INC[]="INCOME";double ans=0,pay_l[]=&#123;0,500,2000,5000,20000,40000,60000,80000,100000,999999999&#125;,inc_l[]=&#123;0,20000,50000,999999999&#125;;void init()&#123; scanf("%d",&amp;m);&#125;double Count_pay(int pr)&#123; double left=max(0,pr-800),_ans=0; for(int i=1;i&lt;=9;i++) if(left&lt;pay_l[i])&#123; _ans+=i*0.05*(left-pay_l[i-1]); break; &#125;else _ans+=i*0.05*(pay_l[i]-pay_l[i-1]); return _ans;&#125;double Count_income(int pr)&#123; double left,_ans=0; left=(pr&gt;4000)?(pr*0.8):(max(0,pr-800)); for(int i=1;i&lt;=3;i++)&#123; if(left&lt;inc_l[i])&#123; _ans+=(i+1)*0.1*(left-inc_l[i-1]); break; &#125;else _ans+=(i+1)*0.1*(inc_l[i]-inc_l[i-1]); &#125; return _ans;&#125;void solve()&#123; int id,pr,mon; for(;;)&#123; scanf("%s",typ); if(typ[0]=='#')break; scanf("%d%s%d",&amp;id,tim,&amp;pr); if(!strcmp(PAY,typ))&#123; if(tim[1]=='/')mon=tim[0]-'0'; else mon=10*(tim[0]-'0')+tim[1]-'0'; money[id][mon]+=pr; &#125;else&#123; ans+=Count_income(pr); &#125; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=12;j++) if(money[i][j]) ans+=Count_pay(money[i][j]); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI1998</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2012 随机数生成器]]></title>
    <url>%2F2018%2F08%2F02%2Fnoi2012t1%2F</url>
    <content type="text"><![CDATA[题目地址 题解水矩乘。唯一要注意的是爆炸的乘法运算。快速乘解决即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;typedef struct&#123; ll dat[3][3]; int r,c;&#125;Mat;ll M,A,C,x0,n,G;Mat mid,tmp;ll mulll(ll a,ll b)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%M; a=(a+a)%M;b&gt;&gt;=1; &#125; return res;&#125; void mul(Mat &amp;a,Mat &amp;b,Mat *to)&#123; to-&gt;r=a.r,to-&gt;c=b.c; int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; t=0;for(k=0;k&lt;a.c;k++)t+=mulll(a.dat[i][k],b.dat[k][j]),t%=M; to-&gt;dat[i][j]=t%M; &#125;&#125;Mat pow(Mat a,ll p)&#123; Mat E,F; E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)mul(E,a,&amp;F),E=F; mul(a,a,&amp;F),a=F;p&gt;&gt;=1; &#125;return E;&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;M,&amp;A,&amp;C,&amp;x0,&amp;n,&amp;G); Mat fib,d,u,v; fib.r=fib.c=2; fib.dat[0][0]=A%M; fib.dat[0][1]=fib.dat[1][1]=1; fib.dat[1][0]=0; u=pow(fib,n); d.r=2,d.c=1; d.dat[0][0]=x0%M,d.dat[1][0]=C%M; mul(u,d,&amp;v); printf("%lld\n",v.dat[0][0]%G); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI2012</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>快速乘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014普及 子矩阵]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2014pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题一脸不可做。是吗？我们先尝试搜索，按照计算，我们最多搜索$(C_{16}^8)^2$次。这样会$TLE$。别急，先搜出我们当前选取的行。然后问题就转化为了求这些行中某些列产生的最小的分数。这个问题我们就很熟悉了，这不是一个$O(m^2)$的$DP$么？设$f(i,j)$为选了$i$列，当前在第$j$列时最小的分数，则状态转移方程易导出。综上，我们使用搜索和$DP$相结合的方法解决了本题。实际上，这样的搜索和高效算法结合的思想早在许多年前就已经用到（即$NOI2003$智破连环阵），在这里出现着实很妙。而在$NOIP2015$中也有这样的思想。时间复杂度：$O(C_n^mm^2)$（近似）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,r,c,mat[20][20],ans=1000000000;int cur_r[20],cur_c[20],v_c[20]=&#123;0&#125;,w[20][20],dp[20][20]=&#123;0&#125;;void dfs_c(int at,int cur)&#123; int fm=cur_c[at-1],val,pos; cur+=v_c[fm]; if(cur&gt;=ans)return; if(at==c)&#123; ans=min(ans,cur);return ; &#125; for(int i=fm+1;i&lt;=m-c+at;i++)&#123; cur_c[at]=i; if(cur&gt;=ans)return ; else dfs_c(at+1,cur); for(int j=0;j&lt;r;j++)&#123; pos=cur_r[j]; val=mat[pos][i]-mat[pos][fm]; if(val&lt;0)val=-val; cur-=val; &#125; &#125;&#125;void solve_()&#123; int pos; memset(v_c,0,sizeof(v_c)); memset(w,0,sizeof(w)); memset(dp,0,sizeof(dp)); for(int i=0;i&lt;m;i++) for(int j=1;j&lt;r;j++) v_c[i]+=abs(mat[cur_r[j]][i]-mat[cur_r[j-1]][i]); for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=0;k&lt;r;k++) pos=cur_r[k], w[i][j]+=abs(mat[pos][i]-mat[pos][j]); for(int i=0;i&lt;m;i++) dp[1][i]=v_c[i]; for(int i=2;i&lt;=c;i++)&#123; for(int j=0;j&lt;m;j++)&#123; pos=1000000000; for(int k=0;k&lt;j;k++) if(dp[i-1][k]+w[k][j]&lt;pos) pos=dp[i-1][k]+w[k][j]; dp[i][j]=pos+v_c[j]; &#125; &#125; for(int i=c-1;i&lt;m;i++) ans=min(ans,dp[c][i]);&#125;void dfs_r(int at)&#123; int fm=cur_r[at-1],val; for(int i=fm+1;i&lt;=n-r+at;i++)&#123; cur_r[at]=i; for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]+=val; &#125; if(at==r-1)solve_(); else dfs_r(at+1); for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]-=val; &#125; &#125;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;r,&amp;c); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;mat[i][j]);&#125;void solve()&#123; for(int i=0;i&lt;=n-r;i++)&#123; cur_r[0]=i; dfs_r(1); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>部分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014普及 螺旋矩阵]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2014pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解观察发现这个结构很有规律，因为螺旋矩阵是一层一层螺旋的，所以考虑一层一层递进求解。我们每一次去掉矩阵最外面的一层，如12341 2 3 4 12 13 14 5 ---&gt; 13 1411 16 15 6 ---&gt; 16 1510 9 8 7 这样里面还是一个螺旋矩阵，但由$n\times n$变为了$(n-2)\times (n-2)$。最后到了要求的数的那一层的时候采用模拟算法，算出那个数即可。时间复杂度：$O(n)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n,x,y,tot=0;int main()&#123; scanf("%d%d%d",&amp;n,&amp;x,&amp;y); for(;x!=1&amp;&amp;y!=1&amp;&amp;x!=n&amp;&amp;y!=n;) tot+=4*n-4,n-=2,x--,y--; if(x==1)tot+=y; else&#123; tot+=n-1; if(y==n)tot+=x; else&#123; tot+=n-1; if(x==n)tot+=(n-y+1); else&#123; tot+=n-1; if(y==1)tot+=(n-x+1); &#125; &#125; &#125; printf("%d\n",tot); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014普及 比例简化]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2014pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一模拟即可，注意简化后分数和原分数的比较，涉及浮点数的运算。时间复杂度$O(L^2)$。123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int a,b,lim,fz,fm;double bi,mini=1e9,cur;int gcd(int a,int b)&#123; return (!b)?a:gcd(b,a%b);&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;lim); bi=(double)a/b,cur=1e9; for(int i=1;i&lt;=lim;i++) for(int j=1;j&lt;=lim;j++)&#123; double t=(double)i/j; if(t-bi&gt;0&amp;&amp;t-bi&lt;cur) cur=t-bi,fz=i,fm=j; else if(fabs(t-bi)&lt;1e-8)&#123; fz=i,fm=j;break; &#125; &#125; int g=gcd(fz,fm); fz/=g,fm/=g; printf("%d %d\n",fz,fm); return 0;&#125; 方法二对每一个不大于$L$的数进行一次二分，找出以此数为分母时最接近$\frac {A}{B}$的分数的分子。时间复杂度：$O(LlogL)$。]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014普及 珠心算测验]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2014pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解没读懂题目就会被坑。模拟即可，但是要注意先去重，不然会多次统计。另外还要注意整数对的无序性。也就是说，两个数$a+b=c$和$b+a=c$不能算$2$遍。在找到这个数$c$后，还要及时把他删除，以免多次统计。所以，$O(n^2)$扫一遍即可。12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int a[104],n,ans=0;char vis[20004]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); sort(a,a+n); n=unique(a,a+n)-a; for(int i=0;i&lt;n;i++)vis[a[i]]=1; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) if(vis[a[i]+a[j]])ans++,vis[a[i]+a[j]]=0; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010提高 引水入城]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解先搜索，搜出每一个出水站能最多支援几个国家。然后会发现每一个国家能支援到的国家一定是一段一段存在的。如果不是，那么会形成一些国家无法被到达的局面，就输出$0$，然后统计。否则对每段区间排序后贪心选择即可。可以用一些手段加速，如对在第一行的国家，只选取相对周围的国家更高一些的国家来搜索，因为这个国家肯定可以向两侧扩展。时间复杂度：$O(nm)$（近似）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;bool dp[505][505],able[505][505]=&#123;0&#125;;int n,m,h[505][505],par[505],res,ans,dx[]=&#123;-1,0,0,1&#125;,dy[]=&#123;0,-1,1,0&#125;;int stack[250005][2],top=0;void dfs(int x,int y)&#123; int nx,ny,i; stack[top][0]=x,stack[top++][1]=y; while(top)&#123; x=stack[--top][0],y=stack[top][1]; for(i=0;i&lt;4;i++)&#123; nx=x+dx[i],ny=y+dy[i]; if(nx&gt;=0&amp;&amp;ny&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&lt;m&amp;&amp; h[nx][ny]&lt;h[x][y]&amp;&amp;!dp[nx][ny]) dp[nx][ny]=1,stack[top][0]=nx,stack[top++][1]=ny; &#125; &#125;&#125;void _solve()&#123; int i,j,p,k,rec[505][2],tot=0,l,r; for(ans=1,i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; p=par[i-1],k=0; while(k&lt;m&amp;&amp;!able[p][k])k++; rec[tot][0]=k; if(tot&amp;&amp;rec[tot-1][0]==k)tot--; while(k&lt;m&amp;&amp;able[p][k])k++; rec[tot++][1]=k-1; if(k-1&lt;rec[tot-1][0])tot--; j=i-1; &#125; for(l=rec[0][0],r=rec[0][1],i=1;i&lt;tot;i++)&#123; while(i&lt;tot&amp;&amp;rec[i][0]&lt;=r+1)i++; if(r==m-1)break; i--,r=rec[i][1],ans++; &#125;&#125;void solve()&#123; int i,j,k; for(i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; memset(dp,0,sizeof(dp)); dp[0][par[i-1]]=1,dfs(0,par[i-1]); memcpy(able[par[i-1]],dp[n-1],sizeof(bool)*m); j=i-1; &#125; bool cnt[505]=&#123;0&#125;; for(k=i=0;i&lt;m;i++) for(j=0;j&lt;m;j++) if(able[par[i]][j]&amp;&amp;!cnt[j])cnt[j]=1,k++; res=(k==m)?1:0; if(res)_solve(); else ans=m-k; printf("%d\n%d\n",res,ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,maxi,lst; for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++) scanf("%d",&amp;h[i][j]); for(i=0;i&lt;m;i++)&#123; while(i&lt;m-1&amp;&amp;h[0][i+1]&gt;h[0][i])i++; for(j=i-1;j&gt;=0&amp;&amp;h[0][j]&lt;h[0][j+1];j--) par[j]=i; par[i]=i; for(j=i+1;j&lt;m&amp;&amp;h[0][j]&lt;h[0][j-1];j++) par[j]=i; while(i&lt;m-1&amp;&amp;h[0][i+1]&lt;h[0][i])i++; &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待修正 NOIP2010提高 关押罪犯]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。将仇恨值从大到小排序，从仇恨最大的一对人开始处理起。记录每一个人的“对手”，看作是这个人和“对手”必须处在不同监狱。如果两人所处监狱相同那就表示分配到此为止，输出答案。然后分类讨论，假设两人都还没有对手就互相记为对手，表示两人不会在一个监狱；只有一个人有对手，那就另一个人把这个人记为对手，并且把这个人的对手收为己方（用并查集实现）；两个人都有，那就收各自的对手为己方。讨论完之后，处理下一对罪犯，如此反复。这样就可以在$O(mlogm)$的时间复杂度内解决这个问题。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int parent[20005],riv[20005]=&#123;0&#125;,m,n,re[100005][3];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;&#125;void init(int k)&#123; for(int i=1;i&lt;=k;i++)parent[i]=i;&#125;int Find(int a)&#123; if(parent[a]==a)return a; return (parent[a]=Find(parent[a]));&#125;void joint(int x,int y)&#123; int a=Find(x),b=Find(y); if(a==b)return; parent[b]=a;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(n);int i,k1,k2,t1,t2; for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;re[i][1],&amp;re[i][2],&amp;re[i][0]); qsort(re,m,sizeof(re[0]),cmp); for(i=0;i&lt;m;i++)&#123; t1=re[i][1],t2=re[i][2]; if(Find(t1)==Find(t2))break; if(riv[t2]&amp;&amp;!riv[t1])swap(t1,t2); if(!riv[t2])&#123; if(!riv[t1])riv[t1]=t2,riv[t2]=t1; else riv[t2]=t1,joint(t2,riv[t1]); &#125;else joint(t2,riv[t1]),joint(t1,riv[t2]); &#125; if(i==m)printf("0\n"); else printf("%d\n",re[i][0]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010提高 乌龟棋]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解按卡片数$DP$即可。只要知道每一种卡片的使用情况就可以推知当前所处位置，从而进行状态转移。设$f(i,j,k,l)$表示用了$i$张$1$，$j$张$2$，$k$张$3$，$l$张$4$的最大得分，则状态转移方程容易导出。1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define dis(a,b,c,d) score[1+a+(b&lt;&lt;1)+(d&lt;&lt;2)+(c&lt;&lt;2)-c]#define fep(a,b) for(a=0;a&lt;=cnt[b];a++)using namespace std;int dp[41][41][41][41]=&#123;0&#125;,n,m,cnt[4]=&#123;0&#125;,score[353];int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v,d; for(i=1;i&lt;=n;i++) scanf("%d",&amp;score[i]); for(i=0;i&lt;m;i++) scanf("%d",&amp;j),cnt[j-1]++; dp[0][0][0][0]=score[1]; fep(i,0)fep(j,1)fep(u,2)fep(v,3)&#123; d=dis(i,j,u,v); if(i)dp[i][j][u][v]=max(dp[i-1][j][u][v]+d,dp[i][j][u][v]); if(j)dp[i][j][u][v]=max(dp[i][j-1][u][v]+d,dp[i][j][u][v]); if(u)dp[i][j][u][v]=max(dp[i][j][u-1][v]+d,dp[i][j][u][v]); if(v)dp[i][j][u][v]=max(dp[i][j][u][v-1]+d,dp[i][j][u][v]); &#125; printf("%d\n",dp[cnt[0]][cnt[1]][cnt[2]][cnt[3]]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010提高 机器翻译]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解用队列模拟即可。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool vis[1005];int w,m,n,que[100005],f=0,r=0;void init()&#123; m=read(),n=read();&#125;void solve()&#123; int ans=0; while(n--)&#123; w=read(); if(!vis[w])&#123; vis[w]=1,que[r++]=w,ans++; if(r-f==m+1)vis[que[f++]]=0; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010普及 导弹拦截]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解此题致敬了11年前的那道经典题目。我们希望这个工作半径最小，直觉上就要让这两个系统都被充分利用。也就是让第一套拦截一部分，第二套拦截另一部分。我们先对所有导弹到第一套系统的距离从近到远排一个序，企图把这个序列切成$2$份，将前半部分给第一个系统，将后半部分（远的）给第二个系统。枚举切开的部位，找到第二套系统应该有的工作半径，也就是分配给第二套系统的最远导弹到他的距离。这里用各种方法实现，我用的是对所有导弹到第二套系统的距离从远到近排一个序，然后用一个指针扫的方法。综上，解决本题的时间复杂度为$O(nlogn)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int id,dis;&#125;Mis;Mis mis[200005];bool operator&lt;(Mis a,Mis b)&#123;return a.dis&lt;b.dis;&#125;int p1[2],p2[2],n,at;//p1 x p2 ybool vis[100005]=&#123;0&#125;;int ask()&#123;//找第二套应该有的工作半径 while(vis[mis[at].id]&amp;&amp;at&lt;2*n) at++; if(at==2*n)return 0; else return mis[at].dis;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;p1[0],&amp;p2[0],&amp;p1[1],&amp;p2[1],&amp;n); int i,j,l1,l2,ans=2000000000; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;l1,&amp;l2), mis[i].dis=(p1[0]-l1)*(p1[0]-l1)+ (p2[0]-l2)*(p2[0]-l2), mis[i+n].dis=-(p1[1]-l1)*(p1[1]-l1)- (p2[1]-l2)*(p2[1]-l2), mis[i].id=mis[i+n].id=i; sort(mis,mis+n), sort(mis+n,mis+n+n), at=n; ans=min(ans,-ask());//全部分配给第二套 for(i=0;i&lt;n;i++) vis[mis[i].id]=1, ans=min(ans,(mis[i].dis-ask())); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010普及 接水问题]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。可以用堆加速，但我的代码里没用。不用堆的时间复杂度是$O(nm)$，用的话是$O(nlogm)$。12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int n,m,at[105],w[10005],f=0,ans=0; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d",&amp;at[i]); for(int i=m;i&lt;n;i++) scanf("%d",&amp;w[i-m]); for(;;)&#123; int mini=INF; for(int i=0;i&lt;m;i++) if(at[i]&gt;0&amp;&amp;at[i]&lt;mini)mini=at[i]; if(mini==INF)break; ans+=mini; for(int i=0;i&lt;m;i++) if(at[i]&gt;0)&#123; at[i]-=mini; if(!at[i])&#123; if(f!=n-m)at[i]=w[f++]; else at[i]=-1; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010普及 数字统计]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解某一道普及的弱化版。模拟即可。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int l,r,ans=0;int main()&#123; scanf("%d%d",&amp;l,&amp;r); for(int i=l;i&lt;=r;i++)&#123; int t=i; while(t)ans+=(t%10==2),t/=10; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010普及 三国游戏]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2010pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个人肯定不会输给电脑。因为计算机的选将是完全根据这个人的选法来的，也就是说，这个人自己是一定有把握选中更好的策略的。然后具体选法，非常简单：最大的一定被拆，所以我们矮子里拔高个儿，选默契值排第二且是所有第二中最高的一对将。这样就做完了。时间复杂度：$O(n^2)$。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,mat[505][505]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) scanf("%d",&amp;mat[i][j]), mat[j][i]=mat[i][j];&#125;void solve()&#123; int max1=0,max2=0,ans=0; for(int i=0;i&lt;n;i++)&#123; max1=max2=0; for(int j=0;j&lt;n;j++)&#123; if(mat[i][j]&gt;max1)max2=max1,max1=mat[i][j]; else if(mat[i][j]&gt;max2)max2=mat[i][j]; &#125; ans=max(ans,max2); &#125; printf("1\n%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2010</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待修正 NOIP2011提高 观光公交]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011tgt6%2F</url>
    <content type="text"><![CDATA[题目地址 题解题目的意思就是选择若干条路，修改他们的长度，使得总的旅行时间最少。具体的做法就是贪心，找省时间最多的路段用。我们把道路分块，为什么要这么做呢？我们把本题第一个数据画成图。123456710 5 05 7 2 4 8 2 8 3 110 3 41 1 333 6 914 4 81 1 4 上面的竖线表示到站的人的到站时间，点表示时间点。虚线部分是指车子到站之后还要等待虚线的时间才能等到人全部上齐。虚线左端是到站时间点，右端是发车时间点。设一个站i中，来的最晚的人到达时间是$latest[i]$。然后，我们手算后可以发现一些性质：性质1.如果车子到达i站的时间是$curt$，并且$curt\le latest[i]$，那么$i$前面和$i$后面，两个路段相互独立。什么意思呢？我们可以感性地这么想：让一段路的长度减少，就相当于把这段路以及其后面的到站时间点往前拉。但是第i站的点永远不会动，因为他的到站时间点和发车时间点是用虚线连接着的，发车时间一定不变。所以对i前面的路修改，$i$后面的就不会受影响；同理对$i$后面的路修改，$i$前面的路也不会受影响。我们称呼到达这样的站的路为隔离路。上图中，$5\rightarrow 6$就是隔离路。根据这个性质，我们可以很方便的把路分块，分割成几个相互不影响的路块以及分隔他们的隔离路。分完了块就可以计算优化一条路能节省的时间了。下面我们对一个路块进行探究：设一个块中开头的站编号为$belong$，末尾的站是$tail$。显然，由上文，$tail\rightarrow tail+1$的路是隔离路。性质2.一个块中，如果优化$i\rightarrow i+1$站的路，使其长度$-1$，可以节省的时间是在$i+1,i+2,…tail,tail+1$这些站下车的人数的总和。这个性质很容易证明，由于这些人都已经上了车，所以优化这段路就相当于把后面站的到站时间点都$-1$，每一个人的到达时间就$-1$，所以省下的时间是人数的和，证毕。根据这个性质，我们可以用后缀和计算出省下的时间，找到在块中最优的那段路。不在块中的隔离路也能优化，优化一次节省的时间是在隔离路通向的下一站下车的人数。接下来的问题是一段路最多可以优化多少次。根据上图可以发现，一段路被优化一定次数，前面的某一段路就会变成隔离路。比如优化$1\rightarrow 2$的路后，$3\rightarrow 4$就变成了隔离路。所以在分块时还要对每一段路统计一个$mingap$，表示一段路最多优化几次就会导致后面的某段路变为隔离路。优化$mingap$次数之后，原来的块就失效了，需要对当前操作块进行重构。如果一段路的长度变成了$0$，或者$mingap$为$0$，就称这一段路是无效路，在寻找最大值时忽略。之后重复以上步骤即可。分析一下时间复杂度：每一轮我们找出一段可以修改的路，修改完成后，至少会使得一段路变为隔离路，或者使得一条隔离路变为无效路。所以每一条路最多被修改$2$次。一共有$O(n)$条路，所以最多做$O(n)$次，所有的路就被修改完了。每一轮我们需要$O(n)$的时间找到省时间最多的路段，并且至多用$O(n)$的时间更新块的情况，结合上面可知，最多做$O(n)$轮，所以该算法的理论时间复杂度为$O(n^2)$。贪心的正确性比较显然，在此不证明。存在$O(nk)$的编程复杂度更低，但是可能会超时的做法。很可惜，本题数据太水，根本卡不掉。事实上，本题存在时间运行上比本题解程序实现更优的程序实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,K,dis[1005],latest[1005],dec[1005],cost[1005],cnt[1005],cnt2[1005];int belong[1005],mingap[1005],tail[1005],ans=0;void build_block(int l,int r)&#123; int bid=l,curt=latest[l]; for(int i=l+1;i&lt;=r;i++)&#123; curt+=dis[i-1]; if(curt&gt;latest[i])belong[i-1]=bid; else&#123; belong[i-1]=-1,mingap[i-1]=INF; int tmp=curt-dis[i-1]; for(int j=i-2;j&gt;=bid;j--) mingap[j]=min(min(tmp-latest[j+1],dis[j]),mingap[j+1]), tmp-=dis[j]; curt=latest[i],tail[bid]=i-1,bid=i; &#125; &#125; if(bid!=r)&#123; int bef=INF; for(int j=r-1;j&gt;=bid;j--) mingap[j]=min(bef,min(dis[j],curt-latest[j+1])), bef=min(bef,mingap[j]),curt-=dis[j]; tail[bid]=r; &#125;&#125;void init()&#123; n=read(),m=read(),K=read(); for(int i=1;i&lt;n;i++)dis[i]=read(); for(int i=1;i&lt;=m;i++)&#123; int Ti=read(),Ai=read(),Bi=read(); latest[Ai]=max(latest[Ai],Ti); cost[Ai]+=Ti; dec[Ai]++,dec[Bi]--,cnt[Ai]++,cnt2[Bi]++; &#125; for(int i=2;i&lt;=n+1;i++)dec[i]+=dec[i-1]; int curt=latest[1]; ans+=cnt[1]*latest[1]-cost[1]; for(int i=1;i&lt;n;i++)&#123; if(latest[i+1]&gt;curt+dis[i])&#123; ans+=cnt2[i+1]*dis[i]+(dec[i]-cnt2[i+1])*(latest[i+1]-curt); ans+=cnt[i+1]*latest[i+1]-cost[i+1]; curt=latest[i+1]; &#125;else&#123; ans+=dec[i]*dis[i],curt+=dis[i]; ans+=cnt[i+1]*curt-cost[i+1]; &#125; &#125; //每一段路上坐车人数 &#125;void solve()&#123; build_block(1,n); for(;K;)&#123; int maxi=0,maxid=-1,curb=0,bid,sum; for(int i=1;i&lt;n;i++)&#123; bid=belong[i]; if(bid&lt;0)&#123; if(dis[i]&amp;&amp;cnt2[i+1]&gt;maxi)maxi=cnt2[i+1],maxid=i; &#125;else&#123; if(curb!=bid)&#123; curb=bid,sum=0; for(int j=tail[bid]+1;j&gt;=i+1;j--)sum+=cnt2[j]; &#125; if(mingap[i]&amp;&amp;sum&gt;maxi)maxi=sum,maxid=i; sum-=cnt2[i+1]; &#125; &#125; if(maxid&lt;0)break; bid=belong[maxid]; if(bid&lt;0)&#123; if(K&gt;dis[maxid]) ans-=maxi*dis[maxid],K-=dis[maxid],dis[maxid]=0; else &#123; ans-=maxi*K; break; &#125; &#125;else&#123; if(K&gt;mingap[maxid])&#123; ans-=maxi*mingap[maxid],K-=mingap[maxid],dis[maxid]-=mingap[maxid]; &#125;else &#123; ans-=maxi*K; break; &#125; build_block(bid,tail[bid]); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011提高 聪明的质监员]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011tgt5%2F</url>
    <content type="text"><![CDATA[题目地址 题解较为明显的二分。二分一个$x$，然后扫一遍表，看看哪些$w$大于等于$x$，然后用前缀和存一下符合条件的$w$前缀和与$w$的数量前缀和，最后$m$个区间算一遍加起来即可。时间复杂度：$O((n+m)logn)$123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;ll S,tot,v[200005],ans,sum[200005],cnt[200005];int w[200005],n,m,ev[200005][2];void solve(int r)&#123; int i; sum[0]=cnt[0]=0; for(i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1], cnt[i]=cnt[i-1]; if(w[i-1]&gt;=r)sum[i]+=v[i-1],cnt[i]++; &#125; for(i=0;i&lt;m;i++) tot+=(cnt[ev[i][1]]-cnt[ev[i][0]-1])* (sum[ev[i][1]]-sum[ev[i][0]-1]);&#125;int main()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;S); int i,j,lb=0,rb=1000000,md; ans=S; for(i=0;i&lt;n;i++) scanf("%d%lld",&amp;w[i],&amp;v[i]); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;ev[i][0],&amp;ev[i][1]); while(rb-lb)&#123; md=(rb+lb)/2,tot=0; solve(md); if(tot==S)&#123;ans=0;break;&#125; else if(tot&gt;S)ans=min(ans,tot-S),lb=md+1; else ans=min(ans,S-tot),rb=md; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011提高 计算系数]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解套用二项式定理和组合数取模即可。$x^ny^m$的系数是$C_n^k \times a^n\times b^m$。时间复杂度：$O(k^2)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define M 10007using namespace std; int dp[1005]=&#123;0&#125;,a,b,k,m,n,ans; int Pow(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125;return res;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;k,&amp;n,&amp;m); a%=M,b%=M,dp[0]=1; for(int i=1;i&lt;=k;i++) for(int j=i;j&gt;=1;j--) dp[j]+=dp[j-1],dp[j]%=M; //计算组合数 ans=(dp[n]*Pow(a,n))%M, ans=(ans*Pow(b,m))%M; printf("%d\n",ans); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011提高 Mayan游戏]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解本题模拟的成分远大于搜索。由于步数已经确定，所以只要采用最简单的$DFS$即可求出结果。当然，我们需要一些必要的剪枝和优化： 列表内容最优化剪枝：按照$x,y$的顺序遍历方块，保证第一个找到的可行方案一定是最优方案。 最优化剪枝：只有当左边是空的时候才左移，否则等价于左边的右移。 最优化剪枝：不移动同色方块。 可行性剪枝：有某种方块个数$\le 2$直接退出，因为不可能消除。 程序上的优化：用$2$个队列处理事件，一个处理掉落，一个处理消除。这样就可以跑的非常快了。理论上还可以加一个估价的优化，就是通过同色方块的连接情况判断至少还要走几步，但实际上以上的优化已经足够了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//交换2个方块后要处理影响//1.掉落 2.消除 //可行性剪枝：同颜色&lt;=2个退出//设置一个掉落队列和一个事件队列//事件队列检查是否有可以消除的方块，有的话就把最上面一层得上一个加入掉落队列 //在掉落队列里检查上方是否有方块，有的话将上方的方块下降后全部加入事件队列 //两者需要交替进行。int pz[10][5][7];int n,ans[10][3],movement[10][3],cnt[11],flag=0;int dque[10005][2],dr,df;//掉落队列 int eque[10005][2],er,ef;//事件队列 int visx[10],visy[10],vis[5][7];void solve_clear(int cur)&#123; int dx,dy,col,len; for(int i=0;i&lt;5;i++)visx[i]=0; for(int i=0;i&lt;7;i++)visy[i]=0; memset(vis,0,sizeof(vis)); while(er&gt;ef)&#123; dx=eque[ef][0],dy=eque[ef++][1]; if(!visx[dx])&#123;//同一个x visx[dx]=1; col=pz[cur][dx][0],len=1; for(int i=1;i&lt;7;i++)&#123; if(pz[cur][dx][i]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[dx][j]=1; &#125; col=pz[cur][dx][i],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=6;7-j&lt;=len;j--)vis[dx][j]=1; &#125; &#125; if(!visy[dy])&#123; visy[dy]=1; col=pz[cur][0][dy],len=1; for(int i=1;i&lt;5;i++)&#123; if(pz[cur][i][dy]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[j][dy]=1; &#125; col=pz[cur][i][dy],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=4;5-j&lt;=len;j--)vis[j][dy]=1; &#125; &#125; &#125; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) if(vis[i][j])&#123; pz[cur][i][j]=0; if(j!=6) dque[dr][0]=i,dque[dr++][1]=j+1; &#125; &#125;void solve_drop(int cur)&#123; int dx,dy,des; while(dr&gt;df)&#123; dx=dque[df][0],dy=dque[df++][1]; for(des=dy-1;des&gt;=0&amp;&amp;!pz[cur][dx][des];des--); des++; for(int i=dy;i&lt;7;i++) if(pz[cur][dx][i]) pz[cur][dx][des++]=pz[cur][dx][i], eque[er][0]=dx,eque[er++][1]=des-1; for(int i=des;i&lt;7;i++) pz[cur][dx][i]=0; &#125;&#125;void dfs(int cur)&#123; if(flag)return ; if(cur==n)&#123; for(int i=0;i&lt;5;i++) if(pz[cur][i][0])return ; memcpy(ans,movement,sizeof(ans)); flag=1; return ; &#125; for(int i=1;i&lt;=10;i++)cnt[i]=0; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) cnt[pz[cur][i][j]]++; for(int i=1;i&lt;=10;i++) if(cnt[i]&amp;&amp;cnt[i]&lt;3)return ; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(!pz[cur][i][j])continue; if(i!=4&amp;&amp;pz[cur][i+1][j]!=pz[cur][i][j])&#123; //向右移动 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i+1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i+1,dque[dr++][1]=j; while(dr&gt;df) solve_drop(cur+1),solve_clear(cur+1); movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=1; dfs(cur+1); &#125; if(i&amp;&amp;!pz[cur][i-1][j]&amp;&amp;pz[cur][i-1][j]!=pz[cur][i][j])&#123;//向左边 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i-1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i-1,dque[dr++][1]=j; while(dr&gt;df)&#123; solve_drop(cur+1),solve_clear(cur+1); &#125; movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=-1; dfs(cur+1); &#125; &#125; &#125;&#125;void init()&#123; n=read(); int t; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;8;j++)&#123; t=read(); if(!t)break; pz[0][i][j]=t; &#125;&#125;void solve()&#123; dfs(0); if(!flag)printf("-1\n"); else &#123; for(int i=0;i&lt;n;i++) printf("%d %d %d\n",ans[i][0],ans[i][1],ans[i][2]); &#125;&#125;int main()&#123; freopen("a.in","r",stdin); init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待修正 NOIP2011提高 选择客栈]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解直接枚举是$O(n^2)$的，不够优秀。考虑这么一种做法：我们分颜色考虑，对于一种颜色$col$，用某个数据结构按距离从大到小存一 下客栈的编号（其实从小到大还是从大到小不重要），然后按顺序枚举每一个客栈，统计一下它的贡献。（也就是有几种方案，他被住下了）贡献怎么算呢？我们画个图 $cur$表示我们找到的离当前枚举到的客栈最近的合法（指最低消费$\le p$）客栈的编号，那么由乘法原理，这个时候$cur$左边的颜色为$col$的客栈数乘上右边颜色为$col$的客栈数就是可行的贡献。诶，刚才不是说算每一个客栈的贡献么？对的。这里由于$cur$右边的$col$颜色客栈之间没有合法客栈，所以把右边的一起算。这里还有一个问题：如果$cur$的颜色是$col$怎么办？如果$cur$右边的客栈全被统计过了，就把他划分到右边，否则划分到左边，这样可以保证正确性。计算完后继续看下一个客栈，这里有一个优化：如果客栈编号大于$cur$就直接跳过，因为他的贡献算过了。综上，使用以上算法的时间复杂度为$O(nk)$。由于数据的原因，实际时间复杂度远小于该值。本题还存在一个时间复杂度仅为$O(n)$的算法，可根据以上算法优化而来，各位不妨自行思考。提示：如果我们边读入数据，边动态更新$cur$会怎么样呢？123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,p,col[200005],cost[200005];int at[55],id[200005],nex[200005],cnt=0,tot[55];void init()&#123; n=read(),k=read(),p=read(); for(int i=1;i&lt;=n;i++)&#123; col[i]=read(),cost[i]=read(); id[++cnt]=i,nex[cnt]=at[col[i]],at[col[i]]=cnt,tot[col[i]]++; &#125; //链式前向星 &#125;void solve()&#123; int ans=0; for(int i=0;i&lt;k;i++)&#123; if(!at[i])continue ; int lf=tot[i],cur=id[at[i]]+1; //lf 左端 rt 右端 for(int j=at[i];j;j=nex[j])&#123; if(id[j]&gt;cur)continue;//优化，该客栈被统计过就跳过 int rt=0;//一开始cur右边没被统计过的客栈数是0 for(cur=id[j];cur&amp;&amp;cost[cur]&gt;p;cur--)//更新cur if(col[cur]==i)rt++,lf--;//遇到一个客栈在cur右边 if(!cur)break;//找不到这样的合法客栈 if(col[cur]==i&amp;&amp;!rt)rt=1,lf--;//对应右边无客栈被统计的情况 ans+=rt*lf;//计算贡献 &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011提高 铺地毯]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。注意判断矩形和无解条件。1234567891011121314#include &lt;bits/stdc++.h&gt;int x[10002],y[10002],l[10002],w[10002],n,dx,dy;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d%d%d",&amp;x[i],&amp;y[i],&amp;l[i],&amp;w[i]); scanf("%d%d",&amp;dx,&amp;dy); int at=-1; for(int i=0;i&lt;n;i++) if((dx&lt;=x[i]+l[i]&amp;&amp;dx&gt;=x[i])&amp;&amp;(dy&lt;=y[i]+w[i]&amp;&amp;dy&gt;=y[i])) at=i+1; printf("%d\n",at); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011普及 表达式的值]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解$DP$。实际上那两个运算就是与和或，所以直接用栈来模拟一下运算过程即可。按运算数来$DP$，记录一下当前编号为$id$的运算数取$0$和$1$时的方案数，这样做法就比较显然了，在模拟的时候计数即可。时间复杂度为$O(n)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;int s1[100005][2]=&#123;0&#125;,s2[100005]=&#123;0&#125;,t1=0,t2=0,pro[300],lim,M=10007;char _exp[100005];void opr()&#123; int a1,a2,b1,b2,o; a1=s1[--t1][0],a2=s1[t1][1], b1=s1[--t1][0],b2=s1[t1][1], o=s2[--t2]; if(o=='+') s1[t1][0]=(a1*b1)%M, s1[t1++][1]=(a1*b2+a2*b1+a2*b2)%M; if(o=='*')&#123; s1[t1][1]=(a2*b2)%M, s1[t1++][0]=(a1*b1+a1*b2+a2*b1)%M; &#125;&#125;void calc()&#123; int i,j; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='(') s2[t2++]='('; else if(_exp[i]==')')&#123; while(s2[t2-1]!='(') opr(); t2--; &#125;else&#123; if(_exp[i-1]!=')') s1[t1][0]=1, s1[t1++][1]=1; while(t2&amp;&amp;s2[t2-1]!='('&amp;&amp; pro[s2[t2-1]]&gt;=pro[_exp[i]]) opr(); s2[t2++]=_exp[i]; if(_exp[i+1]==')') s1[t1][0]=1, s1[t1++][1]=1; &#125; &#125;&#125;void init()&#123; pro['+']=1,pro['*']=2; scanf("%d%s",&amp;lim,&amp;_exp[1]); lim++; _exp[0]='('; _exp[lim++]=')';&#125;void solve()&#123; calc(); printf("%d\n",s1[0][0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>字符串DP</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011普及 瑞士轮]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟+归并。直接模拟的话是$O(nqlogn)$的时间复杂度，会超时。发现每次比完赛之后赢的人和输的人各自的相对排名不变，所以将胜者和败者归并起来，时间复杂度为$O(nq)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[200005],pp[200005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,r,q,w[200005],q1[200005],q2[200005],r1,r2;//q1胜者 q2败者 void Merge()&#123; int tot=0,lb=1,rb=1; while(lb&lt;=r1&amp;&amp;rb&lt;=r2)&#123; int L=q1[lb],R=q2[rb]; if(p[L]&lt;p[R])pp[++tot]=p[L],lb++; else pp[++tot]=p[R],rb++; &#125; while(lb&lt;=r1)pp[++tot]=p[q1[lb]],lb++; while(rb&lt;=r2)pp[++tot]=p[q2[rb]],rb++; memcpy(p+1,pp+1,sizeof(P)*n);&#125;void init()&#123; n=read()&lt;&lt;1,r=read(),q=read(); for(int i=1;i&lt;=n;i++) p[i].first=-read(),p[i].second=i; for(int i=1;i&lt;=n;i++)w[i]=read(); sort(p+1,p+n+1); &#125;void solve()&#123; while(r--)&#123; r1=r2=0; for(int i=1;i&lt;=n;i+=2)&#123; q1[++r1]=i,q2[++r2]=i+1; if(w[p[i].second]&lt;w[p[i+1].second]) swap(q1[r1],q2[r2]),p[i+1].first--; else p[i].first--; &#125; Merge(); &#125; printf("%d\n",p[q].second);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二路归并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011普及 统计单词数]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解本题不需要使用字符串匹配的高级算法，模拟即可。注意单词必须完全匹配，即匹配时两个单词长度要一样。123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;char w[20],s[1000005];int ans1=-1,ans2=0,l1,l2;bool judge(int t)&#123; for(int i=0;i&lt;l1;i++) if(w[i]!=s[t+i])return 0; if(t+l1==l2||s[t+l1]==' ')return 1; return 0;&#125;int main()&#123; scanf("%s",w); while(getchar()!='\n'); fgets(s,1000003,stdin); l1=strlen(w),l2=strlen(s); for(int i=0;i&lt;l1;i++)if(isupper(w[i]))w[i]+='a'-'A'; for(int i=0;i&lt;l2;i++)if(isupper(s[i]))s[i]+='a'-'A'; for(int i=0;i&lt;l2;i++) if(s[i]!=' '&amp;&amp;(!i||s[i-1]==' ')&amp;&amp;i+l1-1&lt;l2) if(judge(i))&#123; if(ans1&lt;0)ans1=i; ans2++; &#125; if(ans1&lt;0)printf("%d\n",ans1); else printf("%d %d\n",ans2,ans1); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011普及 数字反转]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2011pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;char num[15];int main()&#123; scanf("%s",num); int f=(num[0]=='-'),len=strlen(num),cur=0; reverse(num,num+len); while(num[cur]=='0')cur++; if(f)putchar('-'); if(!num[cur]||num[cur]=='-')printf("0\n"); else&#123; while(isdigit(num[cur]))putchar(num[cur]),cur++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2011</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012提高 同余方程]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解就是让你求一个逆元。用快速幂+欧拉函数或者扩欧都行。我只写了扩欧，但是前者应该好写一点。时间复杂度：$O(logn)$12345678910111213141516171819#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; ll d=a; if(b)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125;else x=1,y=0; return d; &#125;int main()&#123; ll a,m,x,y; scanf("%lld%lld",&amp;a,&amp;m); extgcd(a,m,x,y); x=(x%m+m)%m; printf("%lld\n",x); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012提高 疫情控制]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012tgt6%2F</url>
    <content type="text"><![CDATA[题目地址 题解容易发现时间越多，控制疫情的任务越有可能完成。所以先二分一个答案$x$，然后判断他可不可行。显然，一个军队走的越高，他能控制的就越多，所以让军队尽量向上走，直到走到根或者时间不够为止。如果可以走到根就记录一下走到根的时候剩余的时间，走不到就给最后到的点打一个标记，这个向上走可以用倍增实现。还可以发现的是，与根直接相连的点很重要，我们称呼他们为关键点，只要全部控制了他们就完成了任务。而判断一个关键点是否被控制可以用一遍$DFS$实现。对于没被控制的关键点，我们把他们到根的路径长记录下来。我们要让可以到根的军队发配到相应的关键点，并且使得这个分配尽可能合理。怎么做呢？考虑贪心，让剩余时间少的军队去占领最近的关键点，时间多的去占领远的。所以给军队剩余时间和关键点的距离分别排序，做一个贪心即可。注意，如果当前扫到的军队无法前往最近的关键点，那就让他回到他之前到根的路上经过的关键点。这样可以最大程度的利用军队。综上，我们在$O(nlogn+mlognlogw)$的时间复杂度内完成了本题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 10000000000000ll#define LOG 17using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P left[50005],city[50005];int to[100005],nex[100005],at[50005],cnt=0;int n,m,p[100005],par[50005][20],secfa[50005];int cost[100005],depth[50005],maxd=0,dis[50005][20];int tot=0,totc=0;bool vis[50005];int query(int u,int t)&#123; if(depth[u]&lt;=t)return 1; for(int i=LOG;i&gt;=0;i--) if(par[u][i]&amp;&amp;dis[u][i]&lt;=t) t-=dis[u][i],u=par[u][i]; return u;&#125;void dfs2(int cur,int fa)&#123; if(vis[cur])return ; bool flag=1,isleaf=1; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; dfs2(to[i],cur),flag&amp;=vis[to[i]]; isleaf=0; &#125; if(!isleaf)vis[cur]=flag;&#125;bool C(int x)&#123; tot=totc=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=m;i++)&#123; int goal=query(p[i],x); if(goal==1)left[++tot].first=x-depth[p[i]],left[tot].second=p[i]; else vis[goal]=1; //打标记 &#125; dfs2(1,0); if(vis[1])return 1;//根节点的子树全部被覆盖了 for(int i=at[1];i;i=nex[i]) if(!vis[to[i]])city[++totc].second=to[i],city[totc].first=cost[i]; sort(left+1,left+tot+1); sort(city+1,city+totc+1); int r=1,fr; for(int i=1;r&lt;=totc&amp;&amp;i&lt;=tot;i++)&#123; fr=left[i].second; if(left[i].first&lt;city[r].first)&#123; vis[secfa[fr]]=1; &#125;else&#123; vis[city[r].second]=1,r++; &#125; while(vis[city[r].second]&amp;&amp;r&lt;=totc)r++; &#125; if(r==totc+1)return 1; return 0;&#125;void addedge(int _u,int _v,int _c)&#123; to[++cnt]=_v,cost[cnt]=_c,nex[cnt]=at[_u],at[_u]=cnt;&#125;void dfs(int cur,int fa)&#123; par[cur][0]=fa,maxd=max(maxd,depth[cur]); for(int j=1;j&lt;=LOG;j++) if(par[cur][j-1]) par[cur][j]=par[par[cur][j-1]][j-1], dis[cur][j]=dis[cur][j-1]+dis[par[cur][j-1]][j-1]; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; int _v=to[i],_c=cost[i]; depth[_v]=depth[cur]+_c, dis[_v][0]=_c; if(cur==1)secfa[_v]=_v; else secfa[_v]=secfa[cur]; dfs(_v,cur); &#125;&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); m=read(); for(int i=1;i&lt;=m;i++)p[i]=read(); dfs(1,0);&#125;void solve()&#123; int son=0; for(int i=at[1];i;i=nex[i])son++; if(son&gt;m)&#123; printf("-1\n"); return ; &#125; int L=0,R=2*maxd,M; while(R&gt;L)&#123; M=(L+R)&gt;&gt;1; if(C(M))R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012提高 借教室]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012tgt5%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一维护一种数据结构，它支持:1.区间减法2.检查最小值的正负性线段树即可。这种方法常数很大。时间复杂度：$O((n+m)logn)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int seg[2200000],tag[2200000]=&#123;0&#125;;int n,size,_a,_b,m,rec[3][1000005],_v;int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar(); return x;&#125;void pushdown(int id)&#123; if(tag[id]&amp;&amp;id&lt;size) tag[id&lt;&lt;1]+=tag[id],tag[id&lt;&lt;1|1]+=tag[id], seg[id&lt;&lt;1]+=tag[id],seg[id&lt;&lt;1|1]+=tag[id], tag[id]=0; &#125;void init()&#123; int i; for(size=1;size&lt;n;size&lt;&lt;=1); for(i=size;i-size&lt;n;i++)seg[i]=read(); for(;i&lt;(size&lt;&lt;1);i++)seg[i]=INF; for(i=size-1;i&gt;=1;i--) seg[i]=min(seg[i&lt;&lt;1],seg[i&lt;&lt;1|1]);&#125;void minus(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(_a&lt;=l&amp;&amp;r&lt;=_b)&#123; tag[id]+=_v,seg[id]+=_v; return ; &#125; pushdown(id); minus(id&lt;&lt;1,l,(l+r)&gt;&gt;1); minus(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); seg[id]=min(seg[id&lt;&lt;1],seg[id&lt;&lt;1|1]);&#125;int solve()&#123; for(int i=0;i&lt;m;i++)&#123; _v=-rec[0][i],_a=rec[1][i],_b=rec[2][i], minus(1,1,size); if(seg[1]&lt;0)return i+1; &#125; return -1;&#125;int main()&#123; n=read(),m=read(); init(); for(int i=0;i&lt;m;i++) rec[0][i]=read(),rec[1][i]=read(),rec[2][i]=read(); int ans=solve(); if(ans&lt;0)printf("0\n"); else printf("-1\n%d\n",ans); return 0;&#125; 方法二我们发现随着订单的增多，可用教室的数量是只减不增的，所以我们尝试二分。二分一个最大订单量，然后区间减法用差分实现，最后扫一遍，看看是否存在负值即可。（差分：假设我们有一个数列:a_1,a_2,a_3,...,a_n 定义它的差分数列是a_1,a_2-a_1,a_3-a_2,...a_n-a_{n-1} 这样可以发现差分数列中前$n$个元素的和就是原来数列当前位置元素的值。然后为什么说他可以用来做区间减法呢？比方有$5$个数，$a_1,a_2,a_3,a_4,a_5$，差分数列就是$a_1,a_2-a_1,a_3-a_2,a_4-a_3,a_5-a_4$，然后第$2$到$4$个每一个减掉$p$，那么原数列就是 a_1,a_2-p,a_3-p,a_4-p,a_5新的差分数列就是 a_1,a_2-a_1-p,a_3-a_2,a_4-a_3,a_5-a_4+p可以发现，本来要修改多个元素，在差分数列里就只要修改$2$个元素。由于我们只要在处理完所有区间操作后再扫一遍查询负数，所以这么做能满足我们的需求。时间复杂度：$O((n+m)logn)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,d[N],q[N],s[N],e[N];int oold,nnew;void update()&#123; if(nnew&gt;oold)&#123; for(int i=oold+1;i&lt;=nnew;i++) d[s[i]]-=q[i],d[e[i]+1]+=q[i]; &#125;else&#123; for(int i=oold;i&gt;nnew;i--) d[s[i]]+=q[i],d[e[i]+1]-=q[i]; &#125;&#125;bool C()&#123; int flag=0,sum=0; update(); for(int i=1;i&lt;=n;i++)&#123; sum+=d[i]; if(sum&lt;0)&#123; flag=1; break; &#125; &#125; return flag;&#125;void init()&#123; n=read(),m=read(); int lst=read(); d[1]=lst; for(int i=2;i&lt;=n;i++) d[i]=read(),d[i]-=lst,lst+=d[i]; d[n+1]=-lst; for(int i=1;i&lt;=m;i++) q[i]=read(),s[i]=read(),e[i]=read();&#125;void solve()&#123; int L=1,R=m; oold=0; while(R&gt;L)&#123; nnew=(L+R)&gt;&gt;1; if(C())R=nnew; else L=nnew+1; oold=nnew; &#125; if(L==m)printf("0\n"); else printf("-1\n%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012提高 开车旅行]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解倍增。倍增出小A小B经过$2^k$个回合的情况，然后找最近的最小值用排序+双向链表或者$BST$即可。时间复杂度：$O((n+m)logn)$。边界的一些处理比较烦，需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2100000000using namespace std;typedef long long ll;int high[100005][2],_h[100005][2],lf[100005],rt[100005],n,lg,X,S;ll dis[100005][4],_dis[100005][18][4];//dis [0] 小A开距离 [1]小A开到 [2]小B开距离 [3]小B开到//_dis[i][j]过2^j个回合 [0]小a开距离 [1]小b开距离 [2]开到 [3]总路程 int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;void init()&#123; int i,j,lis[4],m1[2],m2[2],d; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;high[i][0]), high[i][1]=i; memcpy(_h,high,sizeof(high)); qsort(_h,n,sizeof(_h[0]),cmp); lf[_h[0][1]]=-1; for(i=1;i&lt;n;i++) lf[_h[i][1]]=_h[i-1][1]; rt[_h[n-1][1]]=-1; for(i=0;i&lt;n-1;i++) rt[_h[i][1]]=_h[i+1][1]; for(i=0;i&lt;n;i++)&#123; lis[0]=lf[i],lis[1]=rt[i]; lis[2]=(lf[i]&lt;0)?-1:lf[lis[0]]; lis[3]=(rt[i]&lt;0)?-1:rt[lis[1]]; m1[0]=m2[0]=INF; m1[1]=m2[1]=-1; //m1：最小 m2：第二小 [0]距离 [1]位置 for(j=0;j&lt;4;j++) if(lis[j]&gt;=0)&#123; d=abs(high[lis[j]][0]-high[i][0]); if(d&lt;m1[0]||(d==m1[0]&amp;&amp;high[lis[j]][0]&lt;high[m1[1]][0]))//lis[j]的海拔低 m2[0]=m1[0],m2[1]=m1[1], m1[0]=d,m1[1]=lis[j]; else if(d&lt;m2[0]||(d==m2[0]&amp;&amp;high[lis[j]][0]&lt;high[m2[1]][0])) m2[0]=d,m2[1]=lis[j]; &#125; if(m2[0]&gt;=INF)m2[0]=0; if(m1[0]&gt;=INF)m1[0]=0; dis[i][0]=m2[0], dis[i][1]=m2[1], dis[i][2]=m1[0], dis[i][3]=m1[1]; if(rt[i]&gt;=0)lf[rt[i]]=lf[i]; if(lf[i]&gt;=0)rt[lf[i]]=rt[i];//自我删除 &#125; for(i=1,d=0;i&lt;n;i&lt;&lt;=1,d++); lg=d; for(i=0;i&lt;n;i++)&#123; _dis[i][0][0]=dis[i][0]; if(dis[i][1]&gt;=0) _dis[i][0][1]=dis[dis[i][1]][2], _dis[i][0][2]=dis[dis[i][1]][3]; else _dis[i][0][1]=0,_dis[i][0][2]=-1; _dis[i][0][3]=_dis[i][0][0]+_dis[i][0][1]; &#125; for(j=1;j&lt;=lg;j++) for(i=0;i&lt;n;i++)&#123; _dis[i][j][0]=_dis[i][j-1][0], _dis[i][j][1]=_dis[i][j-1][1]; if(_dis[i][j-1][2]&gt;=0)//目的地存在 _dis[i][j][0]+=_dis[_dis[i][j-1][2]][j-1][0], _dis[i][j][1]+=_dis[_dis[i][j-1][2]][j-1][1], _dis[i][j][2]=_dis[_dis[i][j-1][2]][j-1][2]; else _dis[i][j][2]=-1; _dis[i][j][3]=_dis[i][j][0]+_dis[i][j][1]; &#125;&#125;void ask(int id,int &amp;a,int &amp;b)&#123; int i; for(i=lg;i&gt;=0;i-- ) if(_dis[id][i][3]+a+b&lt;=X&amp;&amp;_dis[id][i][2]&gt;=0)&#123; a+=_dis[id][i][0], b+=_dis[id][i][1], ask(_dis[id][i][2],a,b); break; &#125; if(i&lt;0) for(i=0;i&lt;=lg;i++) if(_dis[id][i][0]+a+b&lt;=X)&#123; a+=_dis[id][i][0]; break; &#125;&#125;void solve1()&#123; int i,_d[2],d_[2],ans; double bi=1e12,t1,t2; scanf("%d",&amp;X); for(i=0;i&lt;n;i++)&#123; d_[0]=d_[1]=0; ask(i,d_[0],d_[1]); t1=d_[0],t2=d_[1]; if(!t2)t1=1e11; else t1/=t2; if(bi&gt;t1||(abs(bi-t1)&lt;0.0000001&amp;&amp;high[i][0]&gt;high[ans][0])) bi=t1,_d[0]=d_[0],_d[1]=d_[1],ans=i; &#125; printf("%d\n",ans+1); &#125;void solve2()&#123; int m,i,u,v; scanf("%d",&amp;m); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;S,&amp;X), u=0,v=0, ask(S-1,u,v), printf("%d %d\n",u,v);&#125;int main()&#123; init(); solve1(); solve2(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012提高 国王游戏]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解考虑第$i$和第$i+1$个人，他们手上的数字分别为a_i,b_i,a_{i+1},b_{i+1}，第$i+1$个人站在第$i$个人身后。设第$i$个人前面所有人左手数字的积为$T$，那么这两个人拿到的金币数分别为\lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor如果两人交换顺序，那么两人拿到的金币数分别为\lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor为了让获得最多金币的人得到的金币尽量少，我们就需要根据\max \left \{ \lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor\right\}和\max \left \{ \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor\right\}判断是否该让两个人交换顺序。如果交换了顺序使得取得的$max$更小，那么就需要交换。而根据归纳法，对每一对人按这种方法排一个序，就可以求出正确的答案。此时排序的时间复杂度为$O(n^2)$。但仔细观察可以发现，\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor > \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor>\lfloor \frac{T}{b_i}\rfloor。因此只需要确定了\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor和\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor的大小关系，就可以根据不等号的传递性判断哪一种顺序产生的最大值更小。而对上面两个式子变形，消去$T$并且移项便可以发现：只要比较a_ib_i和a_{i+1}b_{i+1}的大小就可判断。于是可以以a_ib_i为关键字排序，来确定整个队伍的顺序。此时，时间复杂度为$O(nlogn+$高精度运算需要的时间$)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; using namespace std;typedef long long ll;struct P&#123; int a,b,t;&#125;;bool operator&lt;(const P &amp;u,const P &amp;v)&#123; return (u.t&lt;v.t);&#125;P p[1005];int d1[3]=&#123;0&#125;,d2[5000]=&#123;0&#125;,d3[5000],ans[5000]=&#123;0&#125;,n;void mul(int s1[],int s2[],int to[])&#123; to[0]=s1[0]+s2[0]; for(int i=1;i&lt;=s1[0];i++)&#123; int x=0; for(int j=1;j&lt;=s2[0];j++) x=s1[i]*s2[j]+x+to[i+j-1],to[i+j-1]=x%10000,x/=10000; to[i+s2[0]]=x; &#125; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void div(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=s1[0];i&gt;=1;i--) to[i]=(x*10000+s1[i])/s2,x=x*10000+s1[i]-to[i]*s2; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;int smaller(int n1[],int n2[])&#123;//&lt;0 ：小于 if(n1[0]!=n2[0])return n1[0]-n2[0]; else&#123; for(int i=n1[0];i&gt;=1;i--) if(n1[i]!=n2[i])return n1[i]-n2[i]; return 0; &#125;&#125;void output(int s[])&#123; printf("%d",s[s[0]]); for(int i=s[0]-1;i&gt;=1;i--) printf("%04d",s[i]); printf("\n");&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;=n;i++) scanf("%d%d",&amp;p[i].a,&amp;p[i].b),p[i].t=p[i].a*p[i].b; sort(p+1,p+1+n); d1[0]=d2[0]=d2[1]=1; for(int i=0;i&lt;n;i++)&#123; memset(d3,0,sizeof(d3)); d1[1]=p[i].a,mul(d1,d2,d3),memcpy(d2,d3,sizeof(d3)); div(d2,p[i+1].b,d3); if(smaller(ans,d3)&lt;0) memcpy(ans,d3,sizeof(d3)); &#125; output(ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012提高 Vigenère密码]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个加密运算其实就是循环移位。密文是循环进位，我们倒着做就行了。12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char key[1005],tex[1005];int get(char a,char b)&#123; return (b-'a'-(a-'a')+26)%26;&#125;int main()&#123; scanf("%s%s",key,tex); int l1=strlen(key),l2=strlen(tex); for(int i=0;i&lt;l1;i++) key[i]=tolower(key[i]); for(int i=0;i&lt;l2;i++)&#123; if(isupper(tex[i])) putchar('A'+get(key[i%l1],tolower(tex[i]))); else putchar('a'+get(key[i%l1],tex[i])); &#125; return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012普及 文化之旅]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解不正确，但却能快速通过本题的方法是$SPFA$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 1000000000using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[20005];int cnt=0,at[105],n,k,m,s,t;int que[10005][105],f,r,c[105],mat[105][105],d[105],in[105]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125;void spfa_bfs()&#123; fill(d+1,d+n+1,INF); d[s]=0; que[r][0]=s,que[r++][c[s]]=1,in[s]=1; int i,_u,_v,_co,j,ok,cul; while(r-f)&#123; _u=que[f++][0],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost,cul=c[_v]; for(ok=1,j=1;j&lt;=k;j++) if(mat[cul][que[f-1][j]])&#123; ok=0;break; &#125; if(!ok)continue; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r][0]=_v; for(j=1;j&lt;=k;j++) que[r][j]=que[f-1][j]; r++; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;k,&amp;m,&amp;s,&amp;t); int i,j,u,v,_c; for(i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(i=1;i&lt;=k;i++) for(j=1;j&lt;=k;j++) scanf("%d",&amp;mat[i][j]); memset(at,-1,sizeof(at)); for(i=0;i&lt;m;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;_c), addedge(u,v,_c), addedge(v,u,_c); spfa_bfs(); printf("%d\n",d[t]&gt;=INF-100?-1:d[t]); return 0;&#125; 正解是搜索。考虑使用高效算法进行优化，那么先以$T$为起点跑$SPFA$，然后从起点搜索的时候，如果不考虑文化的容斥关系都有“当前点到$T$最短路长$+$当前已走距离$\ge ans$”的话就停止搜索。用$DFS$，跑的还比较快。upd:上述的做法是正确的，但是这题数据很恶，所以要调整搜索顺序，倒着搜。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int to[20005],at[105],nex[20005],cnt=0;int V,E,K,S,T,mat[105][105],c[105],dis[105][105];int que[10005],f,r,dist[105],in[105];int vis[105],ans=1000000000;void spfa()&#123; fill(dist+1,dist+V+1,INF); f=r=0,que[r++]=S,in[S]=1,dist[S]=0; int h,v; while(r&gt;f)&#123; h=que[f++],in[h]=0; for(int i=at[h];i;i=nex[i])&#123; v=to[i]; if(dist[v]&gt;dist[h]+dis[h][v])&#123; dist[v]=dist[h]+dis[h][v]; if(!in[v]) in[v]=1,que[r++]=v; &#125; &#125; &#125;&#125;void dfs(int cur,int d)&#123; if(cur==S)&#123; ans=min(ans,d); return ; &#125; if(d+dist[cur]&gt;=ans)return ; vis[c[cur]]=1; for(int i=at[cur];i;i=nex[i])&#123; int v=to[i],flag=0; if(vis[c[v]])continue; for(int j=1;j&lt;=K;j++) if(vis[j]&amp;&amp;mat[c[v]][j])&#123; flag=1; break; &#125; if(flag)continue; dfs(v,d+dis[cur][v]); &#125; vis[c[cur]]=0;&#125; void init()&#123; V=read(),K=read(),E=read(),S=read(),T=read(); for(int i=1;i&lt;=V;i++)c[i]=read(); for(int i=1;i&lt;=K;i++) for(int j=1;j&lt;=K;j++) mat[i][j]=read(); for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) dis[i][j]=INF; for(int i=1;i&lt;=E;i++)&#123; int u=read(),v=read(),co=read(); if(dis[u][v]&lt;co)continue; dis[u][v]=dis[v][u]=co; to[++cnt]=v,nex[cnt]=at[u],at[u]=cnt; to[++cnt]=u,nex[cnt]=at[v],at[v]=cnt; &#125; spfa();&#125;void solve()&#123; dfs(T,0); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012普及 摆花]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解很容易看出来这是一个$DP$。设$f(i,j)$为摆到第i种花，共有$j$盆的方案数。那么 f(i,j)=\sum_{k=0}^{\min(j,a[i])}f(i-1,j-k)时间复杂度：$O(nm^2)$。12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;int n,m,a[105],dp[105][105]=&#123;0&#125;,p=1000007;int main()&#123; int i,j,k; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(i=0;i&lt;=a[0];i++) dp[1][i]=1; for(i=2;i&lt;=n;i++) for(j=0;j&lt;=m;j++) for(k=0;k&lt;=a[i-1];k++) if(j-k&gt;=0)dp[i][j]+=dp[i-1][j-k],dp[i][j]%=p; else break; printf("%d\n",dp[n][m]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012普及 寻宝]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟，时间复杂度$O(nm)$。每一层记录一下有楼梯的房间数，找房间用一个循环实现。1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,sum=0,p=20123,at[10005][105][2],access[10005]=&#123;0&#125;,st;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int tmp=0,lf; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; scanf("%d%d",&amp;at[i][j][0],&amp;at[i][j][1]); if(at[i][j][0])access[i]++; &#125; scanf("%d",&amp;st); for(int i=0;i&lt;n;i++)&#123; lf=at[i][st][1]; sum+=lf,lf%=access[i],tmp=st; if(!lf)lf=access[i]; for(;;)&#123; if(at[i][tmp][0])lf--; if(!lf)break; tmp=(tmp+1)%m; &#125; st=tmp,sum%=p; &#125; printf("%d\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012普及 质因数分解]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2012pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); for(int i=2;i*i&lt;=n;i++) if(n%i==0)&#123; printf("%d\n",n/i); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2012</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待修正 NOIP2013提高 华容道]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2013tgt6%2F</url>
    <content type="text"><![CDATA[题目地址 题解容易发现一个棋子移动的必要条件是它的四个方向上有空白格子。容易观察到，所谓的棋子的移动，等价于空白格子的移动。我们会想到求出一个格子到其他所有格子的最短步数，但这时我们会发现：空方格不能经过指定棋子，否则不符合条件。强行这么做的时间复杂度是$O(V^3)$的，显然不行。但这时可以发现，对于一个可能的位置$(x,y)$而言，所以，一开始先把空白格子移到指定棋子的周围，并且算出这个步数。然后以指定棋子的坐标和空格的相对位置所构成的三元组跑$SPFA$即可，时间复杂度$O(nmq+n^2m^2)$。（近似）如果没看懂我上面在说什么可以看代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Pos&#123; int x,y,d;//空格在指定棋子周围的位置 0上 1下 2左 3右 &#125;;Pos que[1000005];struct Dis&#123; int ddis[32][32]; Dis()&#123; memset(ddis,0x3f,sizeof(ddis)); &#125;&#125;;Dis D[32][32][4];int dis[32][32][5],n,m,q,f,r;int bdis[32][32];int ex,ey,sx,sy,tx,ty,dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,-1,1&#125;;bool mp[32][32],in[32][32][5];void bfs(int xx,int yy,Dis *dist)&#123; f=r=0; que[r].x=xx,que[r++].y=yy,dist-&gt;ddis[xx][yy]=0; int cx,cy,px,py,_dis; while(r&gt;f)&#123; cx=que[f].x,cy=que[f++].y; _dis=dist-&gt;ddis[cx][cy]; //printf("%d %d\n",cx,cy); for(int i=0;i&lt;4;i++)&#123; px=cx+dx[i],py=cy+dy[i]; if(!mp[px][py]||dist-&gt;ddis[px][py]&lt;=_dis+1)continue; dist-&gt;ddis[px][py]=_dis+1; que[r].x=px,que[r++].y=py; &#125; &#125; &#125;void bfs1()&#123; memset(bdis,-1,sizeof(bdis)); f=r=0; que[r].x=ex,que[r++].y=ey,bdis[ex][ey]=0; int cx,cy,px,py; while(r&gt;f)&#123; cx=que[f].x,cy=que[f++].y; for(int i=0;i&lt;4;i++)&#123; px=cx+dx[i],py=cy+dy[i]; if(!mp[px][py])continue; if(px==sx&amp;&amp;py==sy)continue; if(bdis[px][py]&gt;=0)continue; bdis[px][py]=bdis[cx][cy]+1; que[r].x=px,que[r++].y=py; &#125; &#125; f=r=0; for(int i=0;i&lt;4;i++)&#123; px=sx+dx[i],py=sy+dy[i]; if(!mp[px][py]||bdis[px][py]&lt;0)continue; dis[sx][sy][i]=bdis[px][py], que[r].x=sx,que[r].y=sy,que[r++].d=i, in[sx][sy][i]=1; &#125;&#125;inline void update(int cx,int cy,int dd,int _dis)&#123; if(dis[cx][cy][dd]&gt;_dis)&#123; dis[cx][cy][dd]=_dis; if(!in[cx][cy][dd]) in[cx][cy][dd]=1, que[r].x=cx,que[r].y=cy,que[r++].d=dd; &#125;&#125;void bfs2()&#123; int cx,cy,dd,px,py,_dis; Dis *dist; while(r&gt;f)&#123; cx=que[f].x,cy=que[f].y,dd=que[f++].d; _dis=dis[cx][cy][dd],dist=&amp;D[cx][cy][dd]; in[cx][cy][dd]=0; for(int i=0;i&lt;4;i++)&#123; if(i==dd)continue; update(cx,cy,i,_dis+dist-&gt;ddis[cx+dx[i]][cy+dy[i]]); &#125; if(dd==0)&#123; update(cx-1,cy,1,_dis+1); &#125;else if(dd==1)&#123; update(cx+1,cy,0,_dis+1); &#125;else if(dd==2)&#123; update(cx,cy-1,3,_dis+1); &#125;else &#123; update(cx,cy+1,2,_dis+1); &#125; &#125;&#125;void init()&#123; n=read(),m=read(),q=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) mp[i][j]=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(mp[i][j])&#123; mp[i][j]=0; for(int k=0;k&lt;4;k++)&#123; int px=i+dx[k],py=j+dy[k]; if(!mp[px][py])continue; bfs(px,py,&amp;D[i][j][k]); &#125; mp[i][j]=1; &#125; &#125;void solve()&#123; ex=read(),ey=read(),sx=read(),sy=read(), tx=read(),ty=read(); if(sx==tx&amp;&amp;sy==ty)&#123; printf("0\n"); return ; &#125; memset(dis,0x3f,sizeof(dis)); memset(in,0,sizeof(in)); bfs1(); bfs2(); int ans=0x3f3f3f3f; for(int i=0;i&lt;4;i++) ans=min(ans,dis[tx][ty][i]); if(ans==0x3f3f3f3f)printf("-1\n"); else printf("%d\n",ans);&#125;int main()&#123; init(); while(q--)solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013提高 花匠]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2013tgt5%2F</url>
    <content type="text"><![CDATA[题目地址 题解好迷啊这题，可以贪心也可以DP。。。DP：保存2个dp值，记录最后一次是上升时/下降时的长度以及花的高度。然后两个DP值之间相互转移。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int d[100005],n,f1[2],f2[2]; int main()&#123; scanf("%d",&amp;n); int i,j,t,ans=1; for(i=0;i&lt;n;i++) scanf("%d",&amp;d[i]); f1[0]=f2[0]=1,f1[1]=f2[1]=d[0]; for(i=1;i&lt;n;i++)&#123; if(d[i]&gt;=f1[1]&amp;&amp;d[i]&gt;=f2[1])&#123; if(f1[0]&gt;f2[0])f1[1]=max(f1[1],d[i]); else f1[1]=d[i],f1[0]=f2[0]+1; &#125;else if(d[i]&lt;f1[1]&amp;&amp;d[i]&gt;f2[1])&#123; if(f1[0]&gt;=f2[0])f2[1]=d[i],f2[0]=f1[0]+1; else f1[1]=d[i],f1[0]=f2[0]+1; &#125;else&#123; if(f2[0]&gt;f1[0])f2[1]=min(f2[1],d[i]); else f2[1]=d[i],f2[0]=f1[0]+1; &#125; &#125; printf("%d\n",max(f1[0],f2[0])); return 0;&#125; 贪心：类似于模拟？直接记录当前要找的是波峰还是波谷，然后可以从波峰到波谷或者可以从波谷到波峰的话就计数器+1，然后更新下一个要找的波形。波峰波谷判断不需要记录什么特别的变量，只要看当前高度比之前高还是比之前低即可。具体代码参考洛谷题解，我只在此解释一下。]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013提高 积木大赛]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2013tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解$O(n)$做法：发现对于一个不递减的区间，它的搭建次数为最高的那个的高度。所以把整个积木序列拆成尽量多的不递减段即可。具体做法是从左到右遍历，每次记录当前段最高点，如果这个位置上的积木比前面的高就加上搭建当前高度所需要的次数（即当前高度-最大高度），并且直接更新最高点，否则更新最高点，因为此时已经开始了新的一个段，当前积木就是新段的开头。1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int h,maxi,n,ans=0;int main()&#123; scanf("%d%d",&amp;n,&amp;maxi); ans+=maxi; for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;h); if(h&gt;maxi)ans+=h-maxi; maxi=h; &#125; printf("%d\n",ans); return 0; &#125; $O(nlogn)$做法：把搭积木想象成拆积木，一次拆一层，从低往高拆。所以把积木按高度排序，每一次把最低的一层积木全部弹掉，然后动态维护一下段数即可。123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;pair&lt;int,int&gt; high[100005];int n,ans=0,l=1;char destroyed[100005]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;high[i].first),high[i].second=i; sort(high+1,high+1+n); int low=high[1].first,last=0,loc; destroyed[0]=destroyed[n+1]=1; for(int i=1;i&lt;=n;i++)&#123; ans+=(low-last)*l; while(i&lt;=n&amp;&amp;high[i].first==low)&#123; loc=high[i].second, destroyed[loc]=1; if(destroyed[loc-1]||destroyed[loc+1])&#123; if(destroyed[loc-1]&amp;&amp;destroyed[loc+1])l--; &#125;else l++; i++; &#125; last=low,low=high[i--].first; &#125; printf("%d\n",ans); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013提高 货车运输]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2013tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解我们希望每一个点到其他点的路上的限重的最小值都尽量大。有一种叫最大瓶颈生成树的东西可以满足你的需求。怎么求他？求一个最大生成树，完。怎么求两点间路上限重的最小值？求一个LCA，记录一下，完。细节很多，但不难。使用$kruskal$和倍增求$LCA$的话，时间复杂度为$O(mlogm+qlogn)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;struct Edge&#123; int u,v,cost,nex;&#125;;Edge edge[110005];int cmp(const void *a,const void *b)&#123; int *c=(int*)a,*d=(int*)b; return edge[*c].cost-edge[*d].cost;&#125;int n,m,q,par[10005],at[10005],cnt=0,_par[10005][15];int son[10005],bro[10005],depth[10005],que[10005],f,r;int id[100005],dis[10005][15];char vis[100005]=&#123;0&#125;,_vis[10005]=&#123;0&#125;;//1.dfs出每个点所在集合并用id表示//2.求出每一个集合的最小生成树//3.大力lca，求最短容量 void addedge(int _u,int _v,int _c)&#123; edge[cnt].u=_u, edge[cnt].v=_v, edge[cnt].cost=_c, edge[cnt].nex=at[_u], at[_u]=cnt++; &#125;void _init(int S)&#123; int i,j,h,u,v,c; f=r=0; que[r++]=S,_vis[S]=1; depth[S]=1; while(r-f)&#123; h=que[f++]; for(i=at[h];i!=-1;i=edge[i].nex)&#123; v=edge[i].v,c=edge[i].cost; if(vis[i]&amp;&amp;!_vis[v])&#123;//这条边和这个点都访问过 _par[v][0]=h,dis[v][0]=c, bro[v]=son[h],son[h]=v, depth[v]=depth[h]+1, _vis[v]=1,que[r++]=v; &#125; &#125; for(i=1;i&lt;=14;i++) if(_par[h][i-1]&gt;=0) _par[h][i]=_par[_par[h][i-1]][i-1], dis[h][i]=max(dis[h][i-1],dis[_par[h][i-1]][i-1]); else break; &#125;&#125;int query(int u,int v)&#123; int i,j,d,ans=-999999; if(depth[u]&lt;depth[v]) swap(u,v); for(d=depth[u]-depth[v],i=0;(1&lt;&lt;i)&lt;=d;i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) ans=max(ans,dis[u][i]), u=_par[u][i]; if(u==v)return -ans; for(i=14;i&gt;=0;i--) if(_par[u][i]&gt;=0&amp;&amp;_par[u][i]!=_par[v][i]) ans=max(ans,max(dis[u][i],dis[v][i])), u=_par[u][i],v=_par[v][i]; ans=max(ans,max(dis[u][0],dis[v][0])); return -ans;&#125;void init()&#123; for(int i=1;i&lt;=n;i++) par[i]=i;&#125;int Find(int x)&#123; if(par[x]==x)return x; return (par[x]=Find(par[x]));&#125;void unite(int x,int y)&#123; par[Find(x)]=Find(y);&#125;void kruskal()&#123; qsort(id,cnt,sizeof(id[0]),cmp); int Cnt=n,cur=0,_u,_v,i; while(cur&lt;cnt)&#123; _u=edge[id[cur]].u,_v=edge[id[cur]].v; if(Find(_u)!=Find(_v))&#123; unite(_v,_u),Cnt--; if(id[cur]&amp;1) vis[id[cur]]=vis[id[cur]-1]=1; else vis[id[cur]]=vis[id[cur]+1]=1; &#125; cur++; &#125; //在这里建树，求出_par for(i=1;i&lt;=n;i++) if(!_vis[Find(i)]) _init(par[i]);&#125;void read()&#123; scanf("%d%d",&amp;n,&amp;m); int i,x,y,z; memset(at,-1,sizeof(at)); for(i=0;i&lt;m;i++) scanf("%d%d%d",&amp;x,&amp;y,&amp;z), addedge(x,y,-z), addedge(y,x,-z); for(i=0;i&lt;cnt;i++) id[i]=i;&#125;void solve()&#123; init(); memset(son,-1,sizeof(son)); memset(bro,-1,sizeof(bro)); memset(_par,-1,sizeof(_par)); kruskal();&#125;void answer()&#123; scanf("%d",&amp;q); int u,v,ans; while(q--)&#123; scanf("%d%d",&amp;u,&amp;v); if(Find(u)==Find(v)) printf("%d\n",query(u,v)); else printf("-1\n"); &#125;&#125;int main()&#123; read(); solve(); answer(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>MST</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013提高 火柴排队]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2013tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果你知道什么叫排序不等式，这题就是道裸题。如果你不知道，额，你也可以自己证明：当a_1]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013提高 转圈游戏]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2013tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解相当于每一次对编号加一个$m$，然后对$n$取模，如此做$10^k$次。所以答案就是$(m+m+m+…+m+x)\mod n=(m\times 10^k+x)\mod n$。使用快速幂即可，时间复杂度$O(logk)$。1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll n,m,k,x;int main()&#123; scanf("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;x); printf("%lld\n",((Pow(10%n,k,n))*m+x)%n); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013普及 表达式求值]]></title>
    <url>%2F2018%2F08%2F02%2Fnoip2013pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解简单而又基础的表达式计算的题目。连括号都没有，只要注意取模即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;char k[1200005]=&#123;0&#125;;int len,st[2][100005]=&#123;0&#125;,top[2]=&#123;0&#125;,pro[255];void push(int a,int to)&#123; st[to][top[to]++]=a;&#125;int pop(int to)&#123; top[to]--; return st[to][top[to]];&#125;void opr()&#123; int a1,a2,p; a2=pop(1),a1=pop(1),p=pop(0); if(p=='+')push((a1+a2)%10000,1); if(p=='*')push((a1%10000)*(a2%10000)%10000,1);&#125;int main()&#123; fgets(&amp;k[1],1200000,stdin); k[0]='(',len=strlen(k); while(isspace(k[len-1])) k[--len]='\0'; k[len++]=')'; pro['+']=pro['-']=1; pro['*']=pro['/']=2; int sum=-1; for(int i=0;i&lt;len;i++)&#123; if(isdigit(k[i]))&#123; if(sum==-1)sum=k[i]-'0'; else sum=sum*10+k[i]-'0'; &#125;else&#123; if(sum&gt;-1) push(sum,1),sum=-1; if(k[i]=='(') push('(',0); else if(k[i]==')')&#123; while(st[0][top[0]-1]!='(') opr(); pop(0); &#125;else&#123; while(st[0][top[0]-1]!='('&amp;&amp;pro[st[0][top[0]-1]]&gt;=pro[k[i]]) opr(); push(k[i],0); &#125; &#125; &#125; printf("%d\n",pop(1)%10000); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013普及 计数问题]]></title>
    <url>%2F2018%2F08%2F01%2Fnoip2013pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解某一道著名数位DP的弱化版。模拟即可，时间复杂度为$O(n)$。1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans=0,x;int main()&#123; scanf("%d%d",&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) for(int j=i;j;j/=10) ans+=(j%10==x); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013普及 车站分级]]></title>
    <url>%2F2018%2F08%2F01%2Fnoip2013pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解一眼看出来是差分约束，后来发现这个图是一个$DAG$（题目保证存在这么一个方案，就不会有环的存在），求最长路可以直接跑拓扑排序，所以就做完了。时间复杂度为$O(n^2m)$，理论上如此，但实际操作中还行。（主要花在建图上）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,cnt[1005]=&#123;0&#125;,to[1005][1005],lis[1005];int vis[1005],d[1005]=&#123;0&#125;,que[1005],f,r,du[1005]=&#123;0&#125;;bool mat[1005][1005]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; memset(vis,0,sizeof(vis)); int u,v,k,fi,en; scanf("%d",&amp;k); for(int j=0;j&lt;k;j++) scanf("%d",&amp;lis[j]),vis[lis[j]]=1; fi=lis[0],en=lis[k-1]; //有无人向我连边？ for(int j=fi+1;j&lt;en;j++)&#123; if(vis[j])continue; for(u=0;u&lt;k;u++) if(!mat[j][lis[u]]) mat[j][lis[u]]=1, to[j][cnt[j]++]=lis[u], du[lis[u]]++; &#125; &#125;&#125;void solve()&#123; int i,j,lst,at,ans=0; memset(vis,0,sizeof(vis)); fill(d+1,d+n+1,-1); f=r=0; for(i=1;i&lt;=n;i++) if(!du[i]) d[i]=0,que[r++]=i; while(r-f)&#123; int h=que[f++],v; for(int i=0;i&lt;cnt[h];i++)&#123; v=to[h][i]; d[v]=max(d[v],d[h]+1); du[v]--; if(!du[v])que[r++]=v; &#125; ans=max(ans,d[h]); &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013普及 小朋友的数字]]></title>
    <url>%2F2018%2F08%2F01%2Fnoip2013pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解容易看出这是一个最大子段和的问题。我们知道小朋友的分数是不递减的，所以边算便取模即可。 完了吗？没有。相信很多人都挂在了第一个点。这个点很有意思，因为通过它，我们发现上文的一个重要结论是错的。小朋友的分数在第2-n个是不递减的。但第一个不是。所以要加上对第一个的特判，方法就是：如果当前记录的（分数+特征值）的最大值还是负数，答案就取第一个分数和当前分数的较大值，否则直接取当前分数。因为如果（分数+特征值）的最大值还是负数，那么他一定还有可能小于第一个的分数。时间复杂度：$O(n)$。本题代码可能有疏漏，如果能hack掉请告诉我一声，谢谢！12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 2100000000000000llusing namespace std;typedef long long ll;ll d,maxspc=-INF,sum=0,ans,maxi=-INF,mini=INF,p,sc,beg; int n;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;p,&amp;d); mini=0,sum=d,maxi=d,maxspc=2*d,sc=maxi%p,ans=maxi%p; beg=d; for(int i=2;i&lt;=n;i++)&#123; mini=min(mini,sum), scanf("%lld",&amp;d),sum+=d, maxi=max(maxi,sum-mini);//sp[i] sc=maxspc%p; if(maxi&gt;0)&#123; maxspc=(maxi+sc)%p; if(maxspc&lt;0)ans=max(sc,beg); else ans=sc; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2013</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014提高 解方程]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2014tgt6%2F</url>
    <content type="text"><![CDATA[题目地址 题解高精大概可以做到$50$分。想一想，带进去一个$x$，怎么判断左边是否是$0$呢？可不可以避免计算这个准确值呢？学过哈希，我们知道可以把字符串映射到一个值上，值相等那么认为两个字符串相等。但是这个数一般而言很大，所以要对素数取模，来缩小这个值。（虽然哈希跟这题没什么关系）我们也可以用这种类似的做法。对于一个$x$，只要把左边的值模一下一个质数$p$，如果答案是$0$，那么左边的值就很有可能是$0$。为了提高准确程度，我们多模几个质数，如果得到的结果都是$0$，就认为$x$是一个根。这么做可以拿$70$分，因为判断一个解的时间复杂度是$O(n\times $质数个数$)$的，总时间复杂度是$O(m\times n\times $质数个数$)$。然后发现其实没必要全部枚举$m$，因为只要几个$x$模$p$的余数相同，左边的值都是相同的。所以只要保存$x=0,1,…p-1$的取模结果即可，时间复杂度是$O(n\times p_{max}\times $质数个数$+m)$。质数选几个不大不小的即可，推荐选$5$~$6$个。当然如果你幸运EX的话模一两个也是能A掉的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int p[]=&#123;9973,10723,10937,11161,13337&#125;;int n,m,a[5][105]=&#123;0&#125;,fx[5][20000];char s[100005];bool ans[1000005];int read_(int M)&#123;; int f=1,x=0; if(s[0]=='-')f=-f; for(char *t=(s[0]=='-'?s+1:s);*t;t++)x=(x*10+*t-'0')%M; return f*x;&#125;void init()&#123; n=read(),m=read(); for(int i=0;i&lt;=n;i++)&#123; scanf("%s",s); for(int j=0;j&lt;5;j++)a[j][i]=read_(p[j]); &#125; for(int i=0;i&lt;5;i++) for(int j=1;j&lt;=p[i];j++)&#123; int res=0; for(int k=n;k&gt;=0;k--) res=(res*j+a[i][k])%p[i]; fx[i][j]=res; &#125;&#125;void solve()&#123; int cnt=0,flag; for(int i=1;i&lt;=m;i++)&#123; flag=0; for(int j=0;j&lt;5;j++) if(fx[j][i%p[j]])&#123; flag=1; break; &#125; if(!flag)cnt++,ans[i]=1; &#125; printf("%d\n",cnt); for(int i=1;i&lt;=m;i++) if(ans[i])printf("%d\n",i);&#125;int main()&#123; init(); solve(); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>非完美算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014提高 寻找道路]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2014tgt5%2F</url>
    <content type="text"><![CDATA[题目地址 题解考虑先删不合法的点，再跑一遍BFS找到最短路。首先把边反向，从终点跑一下，看看哪些点是合法的。遍历到的点都是和终点直接或者间接连通着的。对于没有被遍历到的点，就要取消它和它连着的点的合法性。这一步可以直接在下一步跑最短路的时候做。时间复杂度：$O(n)$。注意判断起点的合法性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;typedef long long ll;typedef struct&#123; int v,_nex;&#125;Edge;Edge edge[400005];char vis[10005]=&#123;0&#125;;int n,m,que[20005],f,r,at[10005],cnt=0,S,T,d[10005];int at_[10005];void bfs1()&#123; f=r=0; que[r++]=T,vis[T]=1; int h,i,j,v; while(r-f)&#123; h=que[f++]; for(i=at[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!vis[v]) vis[v]=1,que[r++]=v; &#125; &#125;&#125;bool judge(int u)&#123; for(int i=at_[u];i;i=edge[i]._nex) if(!vis[edge[i].v])return 0; return 1;&#125;void bfs2()&#123; if(!judge(S))return ; d[S]=0,f=r=0; que[r++]=S; int i,j,h,v,st; while(r-f)&#123; h=que[f++]; for(i=at_[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!judge(v))continue; if(d[v]&gt;d[h]+1) d[v]=d[h]+1,que[r++]=v; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v; for(i=0;i&lt;m;i++) scanf("%d%d",&amp;u,&amp;v), edge[++cnt].v=u,edge[cnt]._nex=at[v],at[v]=cnt; scanf("%d%d",&amp;S,&amp;T); fill(d+1,d+n+1,INF); bfs1(); for(i=1;i&lt;=n;i++) for(j=at[i];j;j=edge[j]._nex) edge[++cnt].v=i,edge[cnt]._nex=at_[edge[j].v],at_[edge[j].v]=cnt; bfs2(); if(d[T]==INF)printf("-1\n"); else printf("%d\n",d[T]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014提高 无线网络发射器选址]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2014tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解枚举一下路口即可。或者玩矩阵前缀和。时间复杂度：$O(128^2 n)$或者$O(d^2)$（理论上）12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int d,R,n,sum[1000][1000],cnt=0,ans=0;void init()&#123; d=read(),n=read(),R=(d&lt;&lt;1|1); for(int i=1;i&lt;=n;i++) sum[read()+R][read()+R]=read(); for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i][j-1]; for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i-1][j];&#125;void solve()&#123; for(int i=R+d;i&lt;=128+R+d;i++) for(int j=R+d;j&lt;=128+R+d;j++)&#123; int val=sum[i][j]-sum[i-R][j]-sum[i][j-R]+sum[i-R][j-R]; if(val&gt;ans)ans=val,cnt=1; else if(val==ans)cnt++; &#125; printf("%d %d\n",cnt,ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014提高 飞扬的小鸟]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2014tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解一个背包DP的模型。按$x$坐标划分阶段，状态是坐标，决策有：1.点若干次屏幕；2.不点屏幕。发现决策$1$对应无限背包，决策$2$对应$01$背包。所以做一次DP。设$f(i,j,l)$表示到了点$(i,j)$最少需要点击屏幕的次数，其中$l=0$表示本次不点击屏幕，$l=1$表示本次点击。则状态转移方程容易导出，在此就不列出了。在转移的时候注意之前转移而来的状态和当前转移的合法性，以及一个细节：在最高处，小鸟可以平移飞行。时间复杂度：$O(nm)$（近似，因为在最高点有一次枚举）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 2000000000using namespace std;int dp[2][1005][2],n,m,k,up[10005],down[10005],rec[10005][2];void input()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int i,j; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;up[i],&amp;down[i]), rec[i][0]=-1,rec[i][1]=m+3; rec[n][0]=-1,rec[n][1]=m+3; for(i=0;i&lt;k;i++) scanf("%d",&amp;j), scanf("%d%d",&amp;rec[j][0],&amp;rec[j][1]);&#125;void solve()&#123; int res,ans,i,j,t,u,v,o,l,p,q; for(i=0;i&lt;=m;i++) dp[0][i][0]=dp[0][i][1]=0; for(i=1;i&lt;=n;i++)&#123; for(o=0,j=1;j&lt;=m;j++)&#123; dp[i&amp;1][j][0]=dp[i&amp;1][j][1]=INF; if(j+down[i-1]&lt;=m) p=(j+down[i-1]&lt;rec[i-1][1])&amp;&amp;(j+down[i-1]&gt;rec[i-1][0]), q=(j&lt;rec[i][1])&amp;&amp;(j&gt;rec[i][0]), u=(p)?dp[1^(i&amp;1)][j+down[i-1]][0]:INF, v=(p)?dp[1^(i&amp;1)][j+down[i-1]][1]:INF, dp[i&amp;1][j][0]=(q)?min(u,v):INF; if(j-up[i-1]&gt;0) for(l=(j==m)?0:up[i-1];l&lt;=up[i-1];l++) p=(j-l&lt;rec[i-1][1])&amp;&amp;(j-l&gt;rec[i-1][0]), t=dp[i&amp;1][j-l][1], u=(p)?dp[1^(i&amp;1)][j-l][0]:INF, v=(p)?dp[1^(i&amp;1)][j-l][1]:INF, t=min(min(u,v),t), dp[i&amp;1][j][1]=min(dp[i&amp;1][j][1],t+1); if(j&lt;rec[i][1]&amp;&amp;j&gt;rec[i][0]&amp;&amp;(dp[i&amp;1][j][0]&lt;INF|| dp[i&amp;1][j][1]&lt;INF))o=1; &#125; if(!o)&#123;res=0;break;&#125; &#125; if(i==n+1)res=1; printf("%d\n",res); if(res) for(ans=INF,j=n,i=1;i&lt;=m;i++) ans=min(ans,min(dp[j&amp;1][i][0],dp[j&amp;1][i][1])); else for(ans=0,j=0;j&lt;i;j++) if(rec[j][0]!=-1)ans++; printf("%d\n",ans);&#125;int main()&#123; input(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014提高 联合权值]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2014tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解这是一棵树，同时点对距离为$2$这个条件也很微妙，所以先把他转化为一棵有根树，再利用父子关系求解。距离为$2$，我们可以枚举中心点。对于树上的一个点来说，这意味着以他为中心点的点对是由它的父亲与儿子，儿子与儿子构成的。这样最大的权值好做了，记录儿子中的最大权值和次大权值，比较父亲的权值和儿子中最大权值的积以及儿子中最大、次大权值的积，以此更新答案即可。但是权值的和就比较麻烦，儿子和父亲形成的点对的权值和好算，但儿子之间相互的乘积是相互乘的，一次要花费$O(儿子数^2)$的时间计算。最坏情况下是$O(n^2)$的。如何优化？这需要一些数学知识。设儿子的权值为a_1,a_2,a_3,...,a_m,那么儿子们的联合权值之和就是a_1a_2+a_1a_3+...+a_1a_m+a_2a_3+...+a_2a_m+...+a_{m-1}a_m。这里不加证明的给出$2$种在$O(n)$时间计算该值的方法：1.设f(i)=a_1+a_2+...+a_i，g(i)=a_1a_2+a_1a_3+...+a_1a_i+a_2a_3+...+a_2a_i+...+a_{i-1}a_i。更新$g(i)$需要$f(i)$。步骤如下：初始$f(0)=g(0)=0$，$i=1$。（1：g(i)=g(i-1)+a_i\times f(i-1)（2：f(i)=f(i-1)+a_i（3：$i=i+1$2.展开(a_1+a_2+a_3+...+a_m)^2可知维护儿子的权值和和权值平方和就可以算出联合权值之和。代码用的是方法2.综上所述，在使用$DFS/BFS$对树进行遍历的情况下，以上算法的时间复杂度是$O(n)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt; using namespace std;typedef struct&#123; int w,par,son,bro;&#125;Tree;Tree tr[200005];int n,q[200005],f=0,r=0,M=10007,ans=0,ans2=0;void prepare()&#123; int i,h,sum,sum2,mx,mx2,e; for(i=0;i&lt;n;i++) if(tr[i].par&lt;0)&#123;q[r++]=i;break;&#125; while(r-f)&#123; h=q[f++],sum=sum2=mx=mx2=0; for(i=tr[h].son;i!=-1;i=tr[i].bro)&#123; e=tr[i].w, sum=(sum+e)%M, sum2=(sum2+(e*e)%M)%M; if(e&gt;mx)mx2=mx,mx=e; else if(e&gt;mx2)mx2=e; q[r++]=i; &#125; ans2=max(ans2,max(mx*mx2,mx*tr[tr[h].par].w)), ans=(ans+(tr[tr[h].par].w*sum*2)%M)%M, ans=(ans+(sum*sum-sum2)%M+M)%M; &#125;&#125;int main()&#123; scanf("%d",&amp;n); int i,u,v; for(i=0;i&lt;n;i++) tr[i].par=tr[i].son=tr[i].bro=-1; for(i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v), u--,v--; if(tr[v].par&gt;=0)swap(u,v); tr[v].par=u,tr[v].bro=tr[u].son,tr[u].son=v; &#125; for(i=0;i&lt;n;i++) scanf("%d",&amp;tr[i].w); prepare(); printf("%d %d\n",ans2,ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014提高 生活大爆炸版石头剪刀布]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2014tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解判断胜负你可以用一堆if else 或者 switch case，但最简便的还是打表计算。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int tab[5][5]=&#123;//A打B &#123;0,0,1,1,0&#125;, &#123;1,0,0,1,0&#125;, &#123;0,1,0,0,1&#125;, &#123;0,0,1,0,1&#125;, &#123;1,1,0,0,0&#125;&#125;;int n,na,nb,a[205],b[205],ans1=0,ans2=0;void init()&#123; n=read(),na=read(),nb=read(); for(int i=0;i&lt;na;i++)a[i]=read(); for(int i=0;i&lt;nb;i++)b[i]=read();&#125;void solve()&#123; int ra,rb; for(int i=0;i&lt;n;i++) ra=i%na,rb=i%nb, ans1+=tab[a[ra]][b[rb]],ans2+=tab[b[rb]][a[ra]]; printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2014</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015普及 推销员]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解一道贪心。我们可以先算出总的疲劳值，然后每一次选择哪一户人家再也不去。这个时候，我们要保证减少的疲劳值最少。我们可以发现一次只有$2$种删去住户的决策：如图，$head$表示当前疲劳值消耗最小的住户编号，$last$表示最低端的住户编号，$front$是$last$前一个住户的编号。每一次可以去掉$head$，也可以去掉$last$。而去掉$last$就没必要走$front$到$last$的路了，所以第二种决策会减少$(dis[last]-dis[front])\times 2+last$需要的疲劳值。对住户的(疲劳值,编号)二元组按疲劳值排个序，然后维护以上3个量即可：$last$,$front$和$head$。注意，还需要维护每一个住户是否已经被清除，是的话要打标记，否则$head$指向的住户可能会是$last$，这样就不合法。时间复杂度：$O(nlogn)$1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define M 100005using namespace std;int dis[M],cost[M][2],ans[M],tmp[M],front,t,n,last,head;bool vis[M]=&#123;0&#125;;int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;int main()&#123; scanf("%d",&amp;n); int i; for(i=0;i&lt;n;i++) scanf("%d",&amp;dis[i]); ans[n-1]=dis[n-1]*2; for(i=0;i&lt;n;i++) scanf("%d",&amp;tmp[i]), cost[i][1]=i, cost[i][0]=tmp[i], ans[n-1]+=cost[i][0]; qsort(cost,n,sizeof(cost[0]),cmp); last=n-1,front=n-2,head=0; vis[last]=true; for(i=n-2;i&gt;=0;i--)&#123; ans[i]=ans[i+1]; while(head&lt;n&amp;&amp;(vis[cost[head][1]]))head++; t=(dis[last]-dis[front])*2+tmp[last]; if(t&lt;cost[head][0]) vis[last]=vis[front]=1, ans[i]-=t, last=front--; else vis[cost[head][1]]=1, ans[i]-=cost[head][0], head++; while(vis[front])front--; &#125; for(i=0;i&lt;n;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015普及 求和]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解我们挖掘条件的性质可以发现：$y$无关紧要，当$x$和$z$的奇偶性相同时，他们之间旧就会产生分数。所以每一种颜色分奇偶计数，然后一种颜色一个奇偶性产生的分数为 score=(s_4-2)\times s_1+s_2\times s_3其中$s_4$为该种颜色该种奇偶性的格子数，$s_1$为这些格子$x\times num_x$的和，$s_2$和$s_3$分别为这些格子$x$和$num_x$的和。其中$x$指编号，$num_x$指编号为$x$的格子上的数。证明过程略，可以自己手动推导。综上，这个算法的时间复杂度是$O(n+m)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define INF 2000000000#define M 10007using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,num[100005],col[100005],ans=0;int s1[100005][2],s2[100005][2],s3[100005][2],s4[100005][2];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)num[i]=read()%M; for(int i=1;i&lt;=n;i++)col[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; int c=col[i],B=i&amp;1; s1[c][B]+=i*num[i],s1[c][B]%=M; s2[c][B]+=i,s2[c][B]%=M; s3[c][B]+=num[i],s3[c][B]%=M; s4[c][B]++; &#125; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;2;j++) ans+=(s4[i][j]-2)*s1[i][j]%M, ans+=s2[i][j]*s3[i][j]%M, ans%=M; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015普及 扫雷游戏]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,mat[105][105],dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;char s[105];void get(int x,int y)&#123; int res=0; for(int i=0;i&lt;8;i++) res+=(mat[x+dx[i]][y+dy[i]]==-1); mat[x][y]=res; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) mat[i][j]-=(s[j]=='*'); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) if(!mat[i][j])get(i,j),printf("%d",mat[i][j]); else putchar('*'); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015普及 金币]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int k,ans=0; scanf("%d",&amp;k); for(int i=1,j=1;i&lt;=k;i++)&#123; ans+=j; if(j*(j+1)/2==i)j++; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015提高 运输计划]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015tgt6%2F</url>
    <content type="text"><![CDATA[题目地址 题解直接求解显然很困难，考虑转化为判定性问题，二分一个答案$x$，判定他是否可行。完成一次运输的时间取决于最长路的大小，也就是保证所有路径的长度都小于$x$。考虑大于$x$的路径，在他们的公共路上删掉一段路才可以使他们一起变小。理所当然的，这段路必须是他们的公共路径中最长的一段。怎么找这条最长的公共路呢？我们可以玩一玩区间加法，给每一个在$(u,v)$两点上的路径打一个标记，这样就说明这些点在$(u,v)$路径上。如果两点的标记数都等于长度大于$x$的路径总数，呢么两点间的这段路就是他们的公共路径。区间加法有$2$种实现方式：一种是树剖/$LCT$，一种是树上差分（和序列上的没区别）。由于只需要查询一遍，没必要用什么奇奇怪怪的数据结构，所以用差分，在$x$和$y$上打一个$+1$标记，在$LCA$处打一个$-2$标记。由于是对点操作，所以要把边和点捆绑起来。具体不难实现。时间复杂度取决于求解$LCA$时所用算法的时间复杂度。用倍增的时间复杂度是$O((n+m)logn)$。注意卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXN 300005using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[MAXN*2];int n,m,par[MAXN][20]=&#123;0&#125;,dis[MAXN]=&#123;0&#125;,cnt=0,at[MAXN];int son[MAXN]=&#123;0&#125;,bro[MAXN]=&#123;0&#125;,depth[MAXN];int bus[MAXN][4],_dis[MAXN];// 0 路径长 1 _dis 到父亲的路径长 int dec[MAXN]=&#123;0&#125;,que[MAXN],f,r,sum[MAXN];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;//从大到小 &#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;int bs(int lth)&#123; int s=0,len=m,md,pos; while(len)&#123; md=s+(len&gt;&gt;1); if(lth&lt;bus[md][0]) s=md+1,len=len-(len&gt;&gt;1)-1; else len&gt;&gt;=1; &#125; return s;&#125;void _init()&#123; int i,j,h,u,v,c; f=r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; h=que[f++]; for(i=at[h];i!=-1;i=edge[i]._next)&#123; v=edge[i].v; if(v==par[h][0])continue; que[r++]=v, depth[v]=depth[h]+1, par[v][0]=h, bro[v]=son[h],son[h]=v, _dis[v]=edge[i].cost, dis[v]=dis[h]+_dis[v]; &#125; for(i=1;i&lt;=19;i++) if(par[h][i-1]) par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j; if(depth[u]&lt;depth[v]) swap(u,v); for(i=0;(1&lt;&lt;i)&lt;=depth[u]-depth[v];i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=19;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;int C(int tot)&#123; int i,j,h,maxi=0,_max=0; for(i=r-1;i&gt;=0;i--)&#123; h=que[i]; for(sum[h]=dec[h],j=son[h];j;j=bro[j]) sum[h]+=sum[j]; if(sum[h]&gt;maxi) maxi=sum[h],_max=_dis[h]; else if(sum[h]==maxi) _max=max(_max,_dis[h]); &#125; return maxi==tot?_max:0; &#125;void prepare()&#123; n=read(),m=read(); int i,j,u,v,c; memset(at,-1,sizeof(at)); for(i=0;i&lt;n-1;i++) u=read(),v=read(),c=read(), addedge(u,v,c), addedge(v,u,c); _init(); for(i=0;i&lt;m;i++) u=read(),v=read(), bus[i][1]=u,bus[i][2]=v, bus[i][3]=query(u,v), bus[i][0]=dis[u]+dis[v]-2*dis[bus[i][3]];&#125;void solve()&#123; qsort(bus,m,sizeof(bus[0]),cmp); int s=max(0,bus[m-1][0]-1001),t=bus[0][0],md,i,w; while(t-s)&#123; md=(t+s)/2; memset(dec,0,sizeof(dec)); for(i=0;i&lt;m&amp;&amp;bus[i][0]&gt;md;i++) dec[bus[i][1]]++, dec[bus[i][2]]++, dec[bus[i][3]]-=2; w=C(i); if(bus[0][0]-w&lt;=md)t=md; else s=md+1; &#125; printf("%d\n",s);&#125;int main()&#123; prepare(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>DFS</tag>
        <tag>差分</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015提高 子串]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015tgt5%2F</url>
    <content type="text"><![CDATA[题目地址 题解看数据范围猜算法系列时间复杂度相信各位都看的出来：$O(nmk)$怎么刻画状态呢？首先有$2$维必不可缺：$i$表示$A$前$i$个字符，$j$表示$B$前$j$个字符。这里指的是用前$i$个$A$的字符来匹配$B$的前$j$个字符，串$A$的前$i$个不一定要严格匹配，但串$B$的前$j$个必须严格匹配上。之后，段也要表示：$t$表示现在做了$t$段。看到这些段不是连续的，所以使用情况也要表示出来，设一个布尔变量$l$表示串$A$的这个字符是不是被使用了，是为$1$，不是为$0$。够了，用$f(i,j,t,l)$来表示。不使用这个字符，就继承串$A$上一位的状态。使用的话，必须匹配成功，然后有$2$个决策：开启新的一段（前一个字符没用的话就默认开启新的一段了），或者接上前一段。得到状态转移方程： f(i,j,t,0)=f(i-1,j,t,0)+f(i-1,j,t,1) \\ f(i,j,t,1)= \begin{cases} f(i-1,j-1,t,1)+f(i-1,j-1,t-1,0)+f(i-1,j-1,t-1,1) \quad (a[i]=b[j]) \\0\quad (a[i] \neq b[j]) \end{cases}初始是$f(i,0,0,0)=1$。要用滚动数组，不然MLE。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,k,dp[2][205][205][2]=&#123;0&#125;,ans=0,M=1000000007;char a[1005]=&#123;0&#125;,b[205]=&#123;0&#125;;int main()&#123; scanf("%d%d%d%s%s",&amp;n,&amp;m,&amp;k,&amp;a[1],&amp;b[1]); int i,j,o,p,t; dp[0][0][0][0]=dp[1][0][0][0]=1; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; for(o=1;o&lt;=k;o++)&#123; if(a[i]==b[j]) dp[i&amp;1][j][o][1]=(( dp[1^(i&amp;1)][j-1][o-1][0]+ dp[1^(i&amp;1)][j-1][o][1])%M+ dp[1^(i&amp;1)][j-1][o-1][1])%M; else dp[i&amp;1][j][o][1]=0; dp[i&amp;1][j][o][0]=( dp[1^(i&amp;1)][j][o][0]+// dp[1^(i&amp;1)][j][o][1])%M; &#125; &#125; &#125; printf("%d\n",(dp[n&amp;1][m][k][0]+dp[n&amp;1][m][k][1])%M); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>字符串DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015提高 跳石头]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解看到描述就看的出是二分答案。二分答案，设为$x$，把石头排序之后扫一遍，看看是否有石头与前一个石头的间隔小于$x$，有的话拆掉该石头，否则把这个石头作为“前一个石头”，再看下一个。如果拆的次数大于$M$就判定失败，否则判定成功。时间复杂度$O(NlogL)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,m,at[50005];bool C(int x)&#123; int left=m,lst=0; for(int i=2;i&lt;=n+2;i++)&#123; if(at[i]-lst&lt;x)left--; else lst=at[i]; if(left&lt;0)return 0; &#125; return 1;&#125;void init()&#123; L=read(),n=read(),m=read(); at[1]=0,at[n+2]=L; for(int i=2;i&lt;=n+1;i++) at[i]=read(); sort(at+2,at+n+2);&#125;void solve()&#123; int l=0,r=L,mid; while(r&gt;l)&#123; mid=(l+r+1)&gt;&gt;1; if(C(mid))l=mid; else r=mid-1; &#125; printf("%d\n",l);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015提高 斗地主]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解部分搜索。先搞掉所有顺子，然后问题转化为一个简单的最优化问题，dp可解。设$f(i,j,k,l)$为一副牌，有$i$份4张，$j$份3张，$k$份2张，$l$份1张，最少打几次。这个最开始就可以做。然后搜索即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//剪枝:出牌数递减，（牌大小递增） //贪心：5个直接搞 int n,cnt[20],ans;int f[7][9][13][24],pat[5];void dp()&#123;//与顺子无关的dp memset(f,0x3f,sizeof(f)); f[0][0][0][0]=0; int xa=n/4,xb=n/3,xc=n/2; for(int i=0;i&lt;=xa;i++) for(int j=0;j&lt;=xb;j++) for(int k=0;k&lt;=xc;k++) for(int l=0;l&lt;=n;l++)&#123; int &amp;t=f[i][j][k][l]; if(i)&#123; t=min(t,f[i-1][j][k][l]+1); if(l&gt;=2)t=min(t,f[i-1][j][k][l-2]+1); if(k&gt;=2)t=min(t,f[i-1][j][k-2][l]+1); &#125; if(j)&#123; t=min(t,f[i][j-1][k][l]+1); if(l)t=min(t,f[i][j-1][k][l-1]+1); if(k)t=min(t,f[i][j-1][k-1][l]+1); &#125; if(k)t=min(t,f[i][j][k-1][l]+1); if(l)t=min(t,f[i][j][k][l-1]+1); &#125;&#125;int small_solve()&#123; for(int i=0;i&lt;=4;i++)pat[i]=0; for(int i=0;i&lt;=13;i++)pat[cnt[i]]++; return f[pat[4]][pat[3]][pat[2]][pat[1]];&#125;void dfs(int cd,int st)&#123; if(st+1&gt;=ans&amp;&amp;cd!=0)return ; if(cd==0)&#123; ans=min(ans,st); return ; &#125; int flag=0; //只搜索顺子 for(int k=1;k&lt;=12;k++)&#123; if(cnt[k]&gt;=3)&#123; if(k&lt;=11)&#123; for(int i=k+1;i&lt;=12&amp;&amp;cnt[i]&gt;=3;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=3; dfs(cd-(i-k+1)*3,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=3; &#125; &#125; &#125; if(cnt[k]&gt;=2)&#123; if(k&lt;=10&amp;&amp;cnt[k+1]&gt;=2)&#123; for(int i=k+2;i&lt;=12&amp;&amp;cnt[i]&gt;=2;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=2; dfs(cd-(i-k+1)*2,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=2; &#125; &#125; &#125; if(cnt[k])&#123; if(k&lt;=8&amp;&amp;cnt[k+1]&amp;&amp;cnt[k+2]&amp;&amp;cnt[k+3])&#123; for(int i=k+4;i&lt;=12&amp;&amp;cnt[i];i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]--; dfs(cd-(i-k+1),st+1); for(int j=k;j&lt;=i;j++)cnt[j]++; &#125; &#125; &#125; &#125; ans=min(ans,st+small_solve());&#125;void init()&#123; ans=n; memset(cnt,0,sizeof(cnt)); int u; for(int i=1;i&lt;=n;i++)&#123; u=read(); if(!u)cnt[u]++; else if(u&lt;=2)cnt[u+11]++; else cnt[u-2]++; read(); &#125;&#125;void solve()&#123; dfs(n,0); printf("%d\n",ans);&#125;int main()&#123; int T=read(); n=read(); dp(); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015提高 信息传递]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解乱搞。题目：求最小环。解：爆搜/tarjan。能用tarjan是因为这里面的强连通分量只能是简单环。 DFS：123456789101112131415161718192021222324#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int n,to[200005],vis[200005]=&#123;0&#125;,ans=INF;void dfs(int cur,int st)&#123; if(vis[cur]==-1)return ; if(vis[cur])&#123; ans=min(ans,st-vis[cur]); vis[cur]=-1; return ; &#125; vis[cur]=st; dfs(to[cur],st+1),vis[cur]=-1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;to[i]); for(int i=1;i&lt;=n;i++) dfs(to[i],1); printf("%d\n",ans); return 0; &#125; tarjan：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define addedge(_u,_v) edge[cnt].v=_v,edge[cnt].next=at[_u],at[_u]=cnt,cnt++using namespace std;typedef struct &#123; int v,next;&#125;Edge;Edge edge[200105];int at[200005],VNum,mini,D=0;int dfn[200005]=&#123;0&#125;,low[200005],stack[200005],top=0;bool in[200005];void init()&#123; int i,cnt=0,a,b,t; memset(at,-1,sizeof(at)); for(i=0;i&lt;VNum;i++) scanf("%d",&amp;a),addedge(i,a-1);&#125;void tarjan_scc(int id)&#123; dfn[id]=low[id]=++D; in[id]=true;stack[top++]=id; int i=at[id],vv;while(i!=-1)&#123;vv=edge[i].v; if(!dfn[vv])tarjan_scc(vv),low[id]=min(low[id],low[vv]); else if(in[vv])low[id]=min(low[id],dfn[vv]); i=edge[i].next; &#125; if(dfn[id]==low[id])&#123; i=0; do in[stack[--top]]=false,i++; while(stack[top]!=id); if(i!=1)mini=min(mini,i); &#125;&#125;int main()&#123; scanf("%d",&amp;VNum); init(); mini=VNum; for(int i=0;i&lt;VNum;i++)if(!dfn[i])tarjan_scc(i); printf("%d\n",mini); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015提高 神奇的幻方]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2015tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int n,ans[50][50]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); int i,j,x,y; for(i=2,x=0,y=n/2,ans[x][y]=1;i&lt;=n*n;i++)&#123; if(!x)&#123; if(y==n-1)x++; else x=n-1,y++; &#125;else&#123; if(y==n-1)y=0,x--; else &#123; if(!ans[x-1][y+1]) x--,y++; else x++; &#125; &#125; ans[x][y]=i; &#125; for(i=0;i&lt;n;i++,printf("\n")) for(j=0;j&lt;n;j++,(j&lt;n)?printf(" "):0) printf("%d",ans[i][j]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2015</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016提高 愤怒的小鸟]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016tgt6%2F</url>
    <content type="text"><![CDATA[题目地址 题解状压搜索/DP枚举抛物线，看一次抛物线能砸死哪些猪，然后跑DP搜索过不去？那就卡时呗。DP？设$f(i,S)$表示解决了前i头猪，正在解决第$i+1$头，猪被打死的情况为$S$的最小方案数。那么先算出以包含第$i$头猪在内的所有抛物线能砸死的猪的情况（压位表示），然后跑记忆化搜索即可。时间复杂度：搜索：$O($你卡时就能过$)$DP：$O($你不卡时也能过$)$实际检验发现，搜索效率很高，对于小数据非常轻松。但DP的发挥更加稳定，不会被奇奇怪怪的东西卡死。在洛谷上，搜索不卡时95分，花费254ms；DP花费2154ms。DP：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,tag,tab[20][500];int in[20][1&lt;&lt;19];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1;//x坐标相同 a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1;//a必须&lt;0 b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;//解方程void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=((1&lt;&lt;i)|(1&lt;&lt;j)); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]-_a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;int dfs(int at,int S)&#123; if(in[at][S]&lt;0x3f3f3f3f)return in[at][S]; int st=0x3f3f3f3f,i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; st=min(st,1+dfs(j,_S)); &#125; return (in[at][S]=st);&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); memset(in,0x3f,sizeof(in)); tag=(1&lt;&lt;n); for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); in[n][tag-1]=0; printf("%d\n",dfs(0,0)); &#125; return 0;&#125; 搜索：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,ans,tag,tab[20][500];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1; a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1; b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=0;S|=(1&lt;&lt;i);S|=(1&lt;&lt;j); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]- _a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;void dfs(int at,int st,int S)&#123; if(S!=tag-1&amp;&amp;st&gt;=ans-1)return ; if(S==tag-1)&#123;ans=min(ans,st);return ;&#125; int i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; dfs(j,st+1,_S); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); tag=(1&lt;&lt;n),ans=n; for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); dfs(0,0,0); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016提高 蚯蚓]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016tgt5%2F</url>
    <content type="text"><![CDATA[题目地址 题解考场上我想到了这个方法，但因为没证明所以不敢用。。。结果一看题解就吓傻了。可以证明同一种切法下，先切割的比后切割的长度会更长，所以维护$3$个递减队列，然后先把所有初始蚯蚓放在队列$1$，然后不断取出，把$\lfloor px\rfloor$的放在队列$2$中，$x-\lfloor px\rfloor $放在队列$3$中，每一次取$1,2,3$中最大值出来切。注意：1.维护下标（切的时间）很麻烦，不妨直接先减去当前时间和$q$的乘积，然后到了它在加上。为什么可以这么做？因为一条蚯蚓的实际长度是len+(t_{当前}-t_{被切})*q，展开得(len-t_{被切}\times q)+q\times t_{当前}，所以队列里只需要维护前面括号里的元素即可。相应的，在求最大值时，初始最大值要取很小，因为要维护的值可能是个很小的负数。2.要卡常，STL慢的飞起。时间复杂度$O(n+m)$。update：补充证明上面那个性质。假设有$2$条蚯蚓长度分别是$a,b(a&gt;b)$，那么$a$会比$b$先被切。设两个蚯蚓被切得时间点分别是t_a,t_b(t_a \lfloor p\times b\rfloor和a-\lfloor p\times a\rfloor +(t_b-t_a)\times q>b-\lfloor p\times b\rfloor。所以上面的命题成立，证毕。大家都看的出来好嘛1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int q1[100005]=&#123;0&#125;,q2[7000005],q3[7000005],n,m,q,u,v,t;int f1=0,f2=0,f3=0,r1=0,r2=0,r3=0;double xs,tmp;int main()&#123; scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t); xs=u,xs/=(double)v; int i,j,k,maxi,_max,fi,se,ok=0; for(i=0;i&lt;n;i++) scanf("%d",&amp;q1[i]); sort(q1,q1+n); r1=n,reverse(q1,q1+n); for(i=0;i&lt;m;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=i*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; tmp=_max,tmp*=xs; fi=(int)floor(tmp),se=_max-fi; q2[r2++]=fi-(i+1)*q, q3[r3++]=se-(i+1)*q; &#125; printf("\n"); for(ok=i=0;i&lt;m+n;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=m*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016提高 组合数问题]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题给你公式就是给你坑。（如果你不会求逆元的话）实际上没有必要求逆元，直接拿组合数经典公式就可以做了。我们知道：C_n^m=C_{n-1}^{m-1}+C_{n-1}^m。同时，如果一个组合数是$k$的倍数，那么C_n^m \mod k =0。所以就$O(nm)$递推一下，在递推的过程中让C_n^m对$k$取模，如果结果为$0$就在当前位置记录一下。这样可以解决一次回答，但时间复杂度不够优，每次都这么做是O(n_{max}\times m_{max}\times t)的，可能只能过70%左右的数据。发现$k$不变，所以考虑预处理再回答。这里使用前缀和思想。设$ans(n,m)$表示所有$0\le i\le n,0\le j \le m$中，有多少C_i^j是$k$的倍数，即C_i^j \mod k =0。先求出每一行的前缀和，再求一次每一列的前缀和就可得到所有的$ans(n,m)$。（详见代码）这样回答一个询问的时间是$O(1)$，总时间复杂度是O(n_{max}\times m_{max} +t)。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int T,k,C[2005][2005],sum[2005][2005]=&#123;0&#125;,maxn=0,maxm=0,n[10005],m[10005];void init()&#123; int i,j,v; for(i=0;i&lt;=maxn;i++) C[i][0]=1; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%k; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++)&#123; if(j&lt;=i&amp;&amp;C[i][j]==0)v=1;else v=0; sum[i][j]=sum[i-1][j]+v; &#125; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++) sum[i][j]+=sum[i][j-1];&#125;int main()&#123; scanf("%d%d",&amp;T,&amp;k); for(int i=1;i&lt;=T;i++) scanf("%d%d",&amp;n[i],&amp;m[i]),maxn=max(maxn,n[i]),maxm=max(maxm,m[i]); init(); for(int i=1;i&lt;=T;i++) printf("%d\n",sum[n[i]][m[i]]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016提高 换教室]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解很水的期望DP，但是对于第一次写的人有点难度。（比方说我） 题目说要求最小的体力消耗期望值，并给出了地图，说明肯定先要求一次多源最短路。然后在现实意义上理解一下这里期望的意义。在这里，期望是概率和权值的乘积之和。并且每一次是否选课和其他几次都是没有关系的。会对权值造成影响的是这一次和前一次的申请情况。比如第$i$次申请了，第$i-1$次没申请，那么有两种情况：一是申请通过，本次体力消耗是c_{i-1}到d_i的最短路长；二是没有通过，本次体力消耗是c_{i-1}到c_i的最短路长。那么期望体力就是 E=k_i*d[c_{i-1},d_i]+(1-k_i)\times d[c_{i-1},c_i]以此类推，都申请有4种情况，一个申请一个不申请有2种情况，都不申请有1种情况，每种情况对应的期望体力是不变的。这样就转化为了一个类似背包的问题。设$f(i,j,k)$表示对于前$i$节课，使用了$j$次机会时需要的最小期望体力，$k=0$表示此次不申请，$k=1$表示此次不申请，分类讨论即可写出状态转移方程。具体见代码。时间复杂度：$O(nm+V^3)$注意，由于涉及了浮点数运算，该题的代码如果写的常数太大的话就会在最后一个点TLE。所以要适度卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,V,E,INF=1000000000;int d[305][305];int p1[2005],p2[2005];double f[2005][2005][2],p[2005],inf=1e9;void floyd()&#123; for(int k=0;k&lt;V;k++) for(int i=0;i&lt;V;i++) for(int j=0;j&lt;V;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;V,&amp;E); int i,j,u,v,c; for(i=0;i&lt;n;i++) scanf("%d",&amp;p1[i]),p1[i]--; for(i=0;i&lt;n;i++) scanf("%d",&amp;p2[i]),p2[i]--; for(i=0;i&lt;n;i++) scanf("%lf",&amp;p[i]); for(i=0;i&lt;V;i++) for(j=0;j&lt;V;j++) d[i][j]=(i==j)?0:INF; for(i=0;i&lt;E;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); if(d[u-1][v-1]&gt;c) d[u-1][v-1]=d[v-1][u-1]=c; &#125; floyd();&#125;void solve()&#123; int i,j,A,B,C,D; double choice,ans=inf; for(i=0;i&lt;n;i++) for(j=0;j&lt;=m;j++) f[i][j][0]=f[i][j][1]=inf; f[0][0][0]=f[0][1][1]=0; for(i=1;i&lt;n;i++)&#123; A=d[p1[i-1]][p1[i]], B=d[p1[i-1]][p2[i]], C=d[p2[i-1]][p1[i]], D=d[p2[i-1]][p2[i]]; f[i][0][0]=f[i-1][0][0]+A; for(j=1;j&lt;=m;j++)&#123; choice=min(f[i-1][j][0]+A, f[i-1][j][1]+p[i-1]*C+(1-p[i-1])*A); f[i][j][0]=min(f[i][j][0],choice); choice=min(f[i-1][j-1][0]+p[i]*B+ (1-p[i])*A, f[i-1][j-1][1]+p[i-1]*p[i]*D+ (1-p[i-1])*p[i]*B+ p[i-1]*(1-p[i])*C+ (1-p[i-1])*(1-p[i])*A); f[i][j][1]=min(f[i][j][1],choice); &#125; &#125; for(i=0;i&lt;=m;i++) ans=min(ans,min(f[n-1][i][0],f[n-1][i][1])); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>期望DP</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016提高 天天爱跑步]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解当初比赛的时候连暴力都没写对orz暴力的话，直接上$LCA$，大力模拟即可，大概可以拿25分。。。满分做法是从链状做法中过渡而来的。我们发现，从$S$到$T$总是经过他们的$LCA$的（废话），也就是说，可以从$LCA$的角度入手。然后考虑把树问题变成链问题，只要把$LCA$两边的链扯出来即可。对于一条链，一个点$S$可以给另一个点$i$贡献的情况只有从$S$到$i$走的步数=$W_i$。反映在链上，就是$|S-i|=W_i$。反映在树上，就是$depth[S]-depth[i]=W_i$，即$depth[S]=W_i+depth[i]$。这里假定$S$不是LCA，那么从$S$出发时不会往下面走的。我们显然希望对于$i$统计合法的对应$S$。那么就造一个数组，统计当前合法的$S$的个数，走到一个$i$上查一下即可。同理，另一边，有从LCA向下走到$T$，也是一样的道理，多开一个数组就行。（条件是$depth[i]-W_i=depth[T]-len(x,y)$）计算答案的顺序需要注意： 进入的时候先减掉答案，出去的时候再加上，才可以得到自身的贡献。（对于自己统计到的$S$和$T$） 由于$S$到$LCA$是向上，并且我们只希望在$S$到$LCA$的路径上查到我们想要的贡献，所以在向下DFS时添加自己作为$S$的信息，并在回到$LCA$时再减掉$S$的贡献；对$LCA$到$T$，我们只要它向上走的贡献，所以在回溯的时候在$T$处加上，再在$LCA$处减去。 负数下标。 总结一下，这道题有一个类似于差分的思想。。。在2015年应该有所领略。时间复杂度取决于你求$LCA$时算法的时间复杂度。为$O((n+m)logn)$或者$O(n+m)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define MAXN 300005#define MAXL 21using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,to[MAXN*2],_next[MAXN*2],at[MAXN]=&#123;0&#125;,Cnt=0;//树部分 int que[MAXN],depth[MAXN],par[MAXN][MAXL]=&#123;0&#125;,LOG;//LCA部分 int at2[MAXN]=&#123;0&#125;,to2[MAXN],_next2[MAXN],Cnt2=0;//存T的信息 int ats[MAXN]=&#123;0&#125;,tos[MAXN],_nexts[MAXN],Cnts=0;//自己是LCA时存S的深度 int att[MAXN]=&#123;0&#125;,tot[MAXN],_nextt[MAXN],Cntt=0;//自己是LCA时存T的深度 int m,ans[MAXN],w[MAXN],c[MAXN]=&#123;0&#125;;//ans答案 w出现时间 cS人数 int down[MAXN],up[MAXN*2]=&#123;0&#125;;//up S-&gt;LCA down LCA-&gt;T（可能有负数） void addedge(int _u,int _v)&#123; to[++Cnt]=_v,_next[Cnt]=at[_u],at[_u]=Cnt;&#125;void bfs()&#123; int f=0,r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; int h=que[f++]; for(int i=at[h];i;i=_next[i])&#123; int _v=to[i]; if(_v==par[h][0])continue; que[r++]=_v,depth[_v]=depth[h]+1,par[_v][0]=h; &#125; for(int i=1;i&lt;=LOG;i++) if(par[h][i-1])par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j,d; if(depth[u]&lt;depth[v]) swap(u,v); for(d=depth[u]-depth[v],i=0;(1&lt;&lt;i)&lt;=d;i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=LOG;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;//倍增求解LCAvoid dfs(int cur)&#123; //主要求解过程 int up_ans=up[depth[cur]+w[cur]], down_ans=down[depth[cur]-w[cur]+MAXN]; //旧的答案 up[depth[cur]]+=c[cur]; //作为S，添加自己 for(int i=at[cur];i;i=_next[i]) if(to[i]!=par[cur][0])dfs(to[i]); //搜索子树 for(int i=at2[cur];i;i=_next2[i]) down[to2[i]+MAXN]++; //作为T，添加自己的信息 ans[cur]=up[depth[cur]+w[cur]]+down[depth[cur]-w[cur]+MAXN]-up_ans-down_ans; //利用DFS性质计算自己的答案 for(int i=ats[cur];i;i=_nexts[i])&#123; up[tos[i]]--;//回溯时删去S if(tos[i]==depth[cur]+w[cur])ans[cur]--;//如果S就是LCA，那么答案重复，减掉1个 &#125; for(int i=att[cur];i;i=_nextt[i]) down[tot[i]+MAXN]--;//作为LCA，回溯时删去T&#125;void init()&#123; n=read(),m=read(); for(LOG=1;(1&lt;&lt;LOG)&lt;n;LOG++); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; bfs(); for(int i=1;i&lt;=n;i++)w[i]=read(); for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(); int lca=query(u,v),len=depth[u]+depth[v]-2*depth[lca]; c[u]++; tos[++Cnts]=depth[u],_nexts[Cnts]=ats[lca],ats[lca]=Cnts; tot[++Cntt]=depth[v]-len,_nextt[Cntt]=att[lca],att[lca]=Cntt; to2[++Cnt2]=depth[v]-len,_next2[Cnt2]=at2[v],at2[v]=Cnt2; &#125;&#125;void solve()&#123; dfs(1); for(int i=1;i&lt;n;i++) printf("%d ",ans[i]); printf("%d\n",ans[n]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016提高 玩具谜题]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解按照题意模拟即可。确定左右方向就用异或的方法。当然，多写几行判断也是可行的。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int in_or_out[100005],n,m;//in 0,out 1char job[100005][20];void init()&#123; n=read(),m=read(); for(int i=0;i&lt;n;i++) scanf("%d%s",&amp;in_or_out[i],job[i]);&#125;void solve()&#123; int opr,s,lst=0; while(m--)&#123; opr=read(),s=read(); int res=opr^in_or_out[lst]; if(!res)lst=(lst-s+n)%n; else lst=(lst+s)%n; &#125; printf("%s\n",job[lst]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016普及 魔法阵]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解不妨设x_a-x_b=len，那么对于每一个$i$，设i=x_b，枚举一次$len$。接下来的事情就很玄学了：$len$的限制是$len\le i-1$且$len\le 2\times\lfloor \frac{n-i-1}7 \rfloor$，算一下发现$len_{max}=\lfloor \frac{2n-4}9 \rfloor$，又由于$len$是偶数，所以每一次枚举的次数至多为$\lfloor \frac n 9 \rfloor$。这个常数很小，考虑暴力。总体上是枚举长度$len$，每一次枚举x_a，x_b，算出可行的x_c，x_d贡献，再对x_c，x_d做一遍。（当然也可以只做一遍，那样会很麻烦，见下面的下面的失败代码）这里可以发现随着x_c，x_d的递增x_a，x_b是递增的，所以可以用前缀和优化；对于x_c，x_d同理。时间复杂度$O(n^2)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],cnt[15005]=&#123;0&#125;;int ca[15005],cb[15005],cc[15005],cd[15005];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) a[i]=read(),cnt[a[i]]++;&#125;void solve()&#123; int hf_max=n/9,len,rp,xa,xb,xc,xd,sum; for(int hf=1;hf&lt;=hf_max;hf++)&#123;//长度的一半 len=hf&lt;&lt;1,sum=0; for(xc=4*len+2;xc&lt;=n-hf;xc++)&#123;//枚举xc xd=xc+hf,xa=xc-4*len-1,xb=xa+len; sum+=cnt[xa]*cnt[xb]; cc[xc]+=cnt[xd]*sum,cd[xd]+=cnt[xc]*sum; &#125; sum=0; for(xb=n-7*hf-1;xb&gt;=len+1;xb--)&#123;//枚举xb xa=xb-len,xd=7*hf+xb+1,xc=xd-hf; sum+=cnt[xc]*cnt[xd]; ca[xa]+=cnt[xb]*sum,cb[xb]+=cnt[xa]*sum; &#125; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]],cb[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125; 之前写了一个不够好，但是空间够大的情况下可以拿95分（大概）的程序。。。有兴趣的同学可以看看。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],ws[15005];int pre[2005][15005],dc[2005][15005],dd[2005][15005]; int ca[15005],cb[15005],cc[15005],cd[15005];bool calced[15005];void calc(int at,int len)&#123; int *cur=pre[len]; for(int i=at;i+len&lt;=n;i++) cur[i]=cur[i-1]+ws[i]*ws[i+len]; calced[len]=1;&#125;void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++)a[i]=read(),ws[a[i]]++;&#125;void solve()&#123; int xb,len,cnt,cnt_c,xs,hf; int lenmax=n/9,*tc,*td; for(int i=2;i&lt;=n;i++)&#123; if(!ws[i])continue; cnt=0; for(int len=2;len&lt;xb;len+=2)&#123; int rp=7*(len&gt;&gt;1)+i+1; if(rp&gt;n)break; if(!ws[i-len])continue; xs=ws[i-len]*ws[i],hf=(len&gt;&gt;1); dc[hf][rp-hf]+=xs,dc[hf][n-hf+1]-=xs; dd[hf][rp]+=xs,dd[hf][n+1]-=xs; if(!calced[hf])calc(rp-hf,hf); cnt_c=pre[hf][n-hf]-pre[hf][rp-hf-1]; cnt_c*=xs,cnt+=cnt_c,ca[i-len]+=cnt_c; &#125; cb[i]+=cnt; &#125; for(int i=1;i&lt;=lenmax;i++)&#123; tc=dc[i],td=dd[i]; for(int j=8*i+2;j&lt;=n-i;j++) tc[j]+=tc[j-1],td[j+i]+=td[j+i-1], cc[j]+=tc[j]*ws[j+i],cd[j+i]+=td[j+i]*ws[j]; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]]/ws[a[i]],cb[a[i]]/ws[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016普及 海港]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解统计？12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int t,k,st;&#125;D;D _q[100005];int n,cnt[100005]=&#123;0&#125;,_cnt=0,q[300005],f,r,cur=0;int main()&#123; scanf("%d",&amp;n); int t,m,i,j,l; f=r=0; for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;t,&amp;m); _q[r].t=t,_q[r++].k=m; while(r&gt;f&amp;&amp;_q[f].t&lt;=t-86400)&#123; for(j=_q[f].st,l=0;l&lt;_q[f].k;l++,j++)&#123; cnt[q[j]]--; if(!cnt[q[j]])_cnt--; &#125; f++; &#125; _q[r-1].st=cur; for(l=0;l&lt;m;l++,cur++)&#123; scanf("%d",&amp;q[cur]); cnt[q[cur]]++; if(cnt[q[cur]]==1)_cnt++; &#125; printf("%d\n",_cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016普及 回文日期]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解你可以估计一下年份的范围，然后直接暴力统计。使用字符串函数是基本功呢。（笑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;char a[10],b[10];int rs[]=&#123;1,3,5,7,8,10,12&#125;,ans=0,x1,x2,y1,y2,m1,m2,d1,d2;bool cmp(int ye,int mo,int da)&#123; if(ye&lt;y1||ye&gt;y2)return false; if(ye==y1)&#123; if(mo&lt;m1)return false; else if(mo==m1)&#123; if(da&lt;d1)return false; &#125; &#125;else if(ye==y2)&#123; if(mo&gt;m2)return false; else if(mo==m2)&#123; if(da&gt;d2)return false; &#125; &#125; return true;&#125;int main()&#123; scanf("%s%s",a,b); x1=atoi(a),x2=atoi(b); y1=x1/10000,y2=x2/10000; m1=(x1%10000)/100,m2=(x2%10000)/100; d1=x1%100,d2=x2%100; int i,j,k,l,t,ye,mo,da,ok; for(i=0;i&lt;=1;i++) for(j=0;j&lt;=9;j++)&#123; mo=i*10+j; if(mo&gt;12)break; if(!mo)continue; for(k=0;k&lt;=3;k++)&#123; if(k==3&amp;&amp;mo==2)break; for(l=0;l&lt;=9;l++)&#123; ye=l*1000+k*100+j*10+i, da=k*10+l; if(da&gt;31)break; if(!da)continue; if(da==31)&#123; for(ok=t=0;t&lt;7;t++) if(mo==rs[t])ok=1; if(!ok)break; &#125; if(ye%400==0||(ye%4==0&amp;&amp;ye%100!=0))&#123; if(mo==2&amp;&amp;da&gt;29)break; &#125;else if(mo==2&amp;&amp;da&gt;28)break; if(!cmp(ye,mo,da))continue; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016普及 买铅笔]]></title>
    <url>%2F2018%2F07%2F19%2Fnoip2016pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解对于每一种都判断一下，我要达到这个量最少要买几包铅笔。这是一个简单的除法和模运算。1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n,c,v,ans=2000000000;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;3;i++)&#123; scanf("%d%d",&amp;v,&amp;c); j=(n%v==0)?n/v:(n/v+1); j*=c,ans=min(ans,j); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009普及 分数线划定]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2009pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解根据题目描述来模拟和排序即可。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[10005];bool cmp(const P &amp;pa,const P &amp;pb)&#123; return pa.first&gt;pb.first||(pa.first==pb.first&amp;&amp;pa.second&lt;pb.second);&#125;int n,m,lim;int main()&#123; scanf("%d%d",&amp;n,&amp;m); lim=m*150/100; for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;p[i].second,&amp;p[i].first); sort(p,p+n,cmp); int sc=p[lim-1].first,extra=0; for(int i=lim;i&lt;n;i++) if(p[i].first==sc)extra++; else break; printf("%d %d\n",sc,lim+extra); for(int i=0;i&lt;lim+extra;i++) printf("%d %d\n",p[i].second,p[i].first); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009普及 多项式输出]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2009pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解只要读懂了题就不难了。模拟即可，代码可能有点长。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int n,xs;int main()&#123; scanf("%d",&amp;n); for(int i=n;i&gt;=0;i--)&#123; scanf("%d",&amp;xs); if(xs!=0)&#123; if(i==n)&#123; if(abs(xs)==1)&#123; if(xs==-1)putchar('-'); &#125;else printf("%d",xs); &#125;else if(i==1)&#123; if(xs==1)printf("+x"); else if(xs==-1)printf("-x"); else printf("%+dx",xs); continue; &#125;else if(i==0)&#123; printf("%+d",xs); break; &#125;else &#123; if(xs==1)printf("+"); else if(xs==-1)printf("-"); else printf("%+d",xs); &#125; printf("x^%d",i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009普及 细胞分裂]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2009pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解题意：找出某一个数$S_i$，使得$\mathcal S_i^T=M={m_1}^{m_2}$，且$T$最小。考虑$S_i$的唯一分解，只要使得每一个质因数对应的次数都能超过$M$的唯一分解中这个质因数对应的次数即可。这样就可以算出对应的时间$T$来。由于一个数的质因数个数大约是$O(logn)$级别的，使用以上算法的时间复杂度约为$O(nlogm_1)$。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll m1,m2,ans=-1,lis[10][2],a,tot,p,k;int n,t=0;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;m1,&amp;m2); ll e=m1; for(ll b=2;b&lt;=m1;b++) if(e%b==0)&#123; lis[t++][0]=b,lis[t-1][1]=0; while(e%b==0) lis[t-1][1]++,e/=b; lis[t-1][1]*=m2; &#125; for(int i=0;i&lt;n;i++)&#123; tot=0; scanf("%lld",&amp;a); int j; for(j=0;j&lt;t;j++) if(a%lis[j][0]==0)&#123; p=0; while(a%lis[j][0]==0) p++,a/=lis[j][0]; k=lis[j][1]/p; if(lis[j][1]%p)k++;tot=max(tot,k); &#125;else break; if(j!=t)continue; ans=(ans&lt;0)?tot:(ans&gt;tot?tot:ans); &#125; printf("%lld\n",ans); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009提高 靶形数独]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2009tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解爆搜95分。加优化满分。DLX乱搞。没什么好说的。这就是裸题。。。优化：选择选择余地最小的格子开始搜。还有倒着搜。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int maxi=-1,vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0;void get(int at)&#123; int mini=99,p,x,y,o; for(int i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(int j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini)mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1]; lis[at+1][0]=lis[p][0],lis[at+1][1]=lis[p][1]; lis[p][0]=x,lis[p][1]=y;&#125;int calc()&#123; int sum=0; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; if(i==4&amp;&amp;j==4)sum+=sd[i][j]*10; else if(i&gt;2&amp;&amp;j&gt;2&amp;&amp;i&lt;6&amp;&amp;j&lt;6)sum+=sd[i][j]*9; else if(i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;7&amp;&amp;j&lt;7)sum+=sd[i][j]*8; else if(i&gt;0&amp;&amp;j&gt;0&amp;&amp;i&lt;8&amp;&amp;j&lt;8)sum+=sd[i][j]*7; else sum+=sd[i][j]*6; &#125; maxi=max(maxi,sum);&#125;//计算分数void dfs(int at)&#123; int x=lis[at][0],y=lis[at][1]; for(int i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1,sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125;else calc(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0,sd[x][y]=0; &#125;&#125;//0 行 1 列 2 宫 int main()&#123; int tmp; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%d",&amp;tmp); if(tmp)&#123; sd[i][j]=tmp; vis[0][i][tmp]=vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; &#125;else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); printf("%d\n",maxi); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2009</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008普及 立体图]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008pjt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题目是不是一看就很恶劣啊？是的！但是只要知道构图的顺序就完成了一部分。我的构图顺序是从最底层构起，每一层按列构成，从远到近，从左到右，从下到上，这样就解决了图形覆盖的问题。然后就是坐标的计算以及图形具体元素坐标的计算，这里可以参考我的代码。时间复杂度：画一个正方体的时间是常数，所以是O(正方体数)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;char mp[20001][350];int n,m,mp2[55][55],BOT=20000;void lie(int x,int y)&#123; mp[x][y]=mp[x][y+4]='+', mp[x][y+1]=mp[x][y+2]=mp[x][y+3]='-';&#125;void build(int x,int y,int z)&#123; int dx=BOT,dy=0; dx-=(z-1)*3+3+2*(m-x+1);//yuanlaiwei x dy+=(m-x+1)*2+(y-1)*4; lie(dx,dy),lie(dx+2,dy-2),lie(dx+5,dy-2); mp[dx+3][dy+4]='+', mp[dx+1][dy-1]=mp[dx+1][dy+3]=mp[dx+4][dy+3]='/'; mp[dx+3][dy-2]=mp[dx+3][dy+2]= mp[dx+4][dy-2]=mp[dx+4][dy+2]= mp[dx+1][dy+4]=mp[dx+2][dy+4]='|', mp[dx+1][dy]=mp[dx+1][dy+1]=mp[dx+1][dy+2]= mp[dx+2][dy+3]=mp[dx+3][dy+3]= mp[dx+3][dy]=mp[dx+3][dy-1]=mp[dx+3][dy+1]= mp[dx+4][dy]=mp[dx+4][dy-1]=mp[dx+4][dy+1]=' ';&#125;void output()&#123; int s1=0,s2=0,i,j,ok; for(i=BOT;i&gt;=0;i--)&#123; for(j=0,ok=0;j&lt;350;j++) if(mp[i][j]!='.')ok=1; if(!ok)break; &#125; s1=i+1; for(i=349;i&gt;=0;i--)&#123; for(j=s1,ok=0;j&lt;=BOT;j++) if(mp[j][i]!='.')ok=1; if(ok)break; &#125; s2=i; //printf("%d %d\n",s1,s2); for(i=s1;i&lt;=BOT;i++)&#123; for(j=0;j&lt;=s2;j++) printf("%c",mp[i][j]); printf("\n"); &#125;&#125;int main()&#123; memset(mp,'.',sizeof(mp)); scanf("%d%d",&amp;m,&amp;n); int i,j,k; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mp2[i][j]); for(i=1;i&lt;=100;i++) for(k=0;k&lt;n;k++) for(j=0;j&lt;m;j++) if(mp2[j][k]&gt;=i) build(j+1,k+1,i); output(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008普及 传球游戏]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解数据怎么小，怎么玩？打表！123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt;int q[28][28]=&#123;&#123;2,6,10,22,42,86,170,342,682,1366,2730,5462,10922,21846,43690,87382,174762,349526,699050,1398102,2796202,5592406,11184810,22369622,44739242,89478486,178956970,357913942&#125;,&#123;0,8,0,32,0,128,0,512,0,2048,0,8192,0,32768,0,131072,0,524288,0,2097152,0,8388608,0,33554432,0,134217728,0,536870912&#125;,&#123;0,6,2,20,14,70,72,254,330,948,1430,3614,6008,13990,24786,54740,101118,215766,409640,854702,1652090,3396916,6643782,13530350,26667864,53971350,106914242,215492564&#125;,&#123;0,6,0,22,0,86,0,342,0,1366,0,5462,0,21846,0,87382,0,349526,0,1398102,0,5592406,0,22369622,0,89478486,0,357913942&#125;,&#123;0,6,0,20,2,70,18,252,110,924,572,3434,2730,12902,12376,48926,54264,187036,232562,720062,980674,2789164,4086550,10861060,16878420,42484682,69242082,166823430&#125;,&#123;0,6,0,20,0,72,0,272,0,1056,0,4160,0,16512,0,65792,0,262656,0,1049600,0,4196352,0,16781312,0,67117056,0,268451840&#125;,&#123;0,6,0,20,0,70,2,252,22,924,156,3432,910,12870,4760,48622,23256,184796,108528,705894,490314,2708204,2163150,10430500,9373652,40313160,40060078,156305070&#125;,&#123;0,6,0,20,0,70,0,254,0,948,0,3614,0,13990,0,54740,0,215766,0,854702,0,3396916,0,13530350,0,53971350,0,215492564&#125;,&#123;0,6,0,20,0,70,0,252,2,924,26,3432,210,12870,1360,48620,7752,184756,40698,705434,201894,2704204,961400,10401250,4440150,40123152,20030010,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,926,0,3460,0,13110,0,50252,0,194446,0,758100,0,2973350,0,11716252,0,46333566,0,183739940&#125;,&#123;0,6,0,20,0,70,0,252,0,924,2,3432,30,12870,272,48620,1938,184756,11970,705432,67298,2704156,354200,10400602,1776060,40116656,8584290,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3434,0,12902,0,48926,0,187036,0,720062,0,2789164,0,10861060,0,42484682,0,166823430&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,2,12870,34,48620,342,184756,2660,705432,17710,2704156,106260,10400600,592020,40116600,3121560,155117522&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12872,0,48656,0,185136,0,708512,0,2725408,0,10532160,0,40870080,0,159189120&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,2,48620,38,184756,420,705432,3542,2704156,25300,10400600,161460,40116600,950040,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48622,0,184796,0,705894,0,2708204,0,10430500,0,40313160,0,156305070&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,2,184756,42,705432,506,2704156,4600,10400600,35100,40116600,237510,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184758,0,705476,0,2704708,0,10405800,0,40157550,0,155402532&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,2,705432,46,2704156,600,10400600,5850,40116600,47502,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705434,0,2704204,0,10401250,0,40123152,0,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,2,2704156,50,10400600,702,40116600,7308,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704158,0,10400652,0,40117356,0,155125640&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,2,10400600,54,40116600,812,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400602,0,40116656,0,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,2,40116600,58,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116602,0,155117580&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,2,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,0,155117522&#125;&#125;;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m);printf("%d\n",q[n-3][m-3]); return 0; &#125; 实际上这个递推是很水，设$\mathcal f\left(i,j\right)$为当前球到了第$i$个人的时候是第$j$次的情况下，传球的方法数，则可以递推得 \mathcal f\left(i,j\right)=f\left(i-1,j-1\right)+f\left(i+1,j-1\right)其中$i-1$指$i$左边的人，$i+1$指$i$右边的人。假设开始的人是￥0￥号即可。时间复杂度：$\mathcal O\left(nm\right)$123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,f[35][35];int main()&#123; scanf("%d%d",&amp;n,&amp;m); f[0][0]=1; for(int j=1;j&lt;=m;j++)&#123; f[0][j]=f[n-1][j-1]+f[1][j-1]; f[n-1][j]=f[0][j-1]+f[n-2][j-1]; for(int i=1;i&lt;n-1;i++) f[i][j]=f[i-1][j-1]+f[i+1][j-1]; &#125; printf("%d\n",f[0][m]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008普及 排座椅]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解算一下选每一行或者每一列可以阻断的人数，然后排序贪心即可。注意行号和列号都要排序再输出。时间复杂度：$\mathcal O(nlogn+mlogm)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;struct Seat&#123; int id,tot;&#125;;Seat line[1005],row[1005];bool cmp(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.tot&gt;sb.tot;&#125;bool cmp2(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.id&lt;sb.id;&#125;int n,m,K,L,D;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;L,&amp;D); int x1,y1,x2,y2; for(int i=1;i&lt;=n;i++) line[i].tot=0,line[i].id=i;//该行上面 for(int i=1;i&lt;=m;i++) row[i].tot=0,row[i].id=i;//该列右边 for(int i=1;i&lt;=D;i++)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(x1==x2) row[min(y1,y2)].tot++; //同行记录列 else if(y1==y2) line[min(x1,x2)].tot++; &#125; sort(line+1,line+1+n,cmp),sort(line+1,line+K+1,cmp2); sort(row+1,row+1+m,cmp),sort(row+1,row+1+L,cmp2); for(int i=1;i&lt;K;i++) printf("%d ",line[i].id); printf("%d\n",line[K].id); for(int i=1;i&lt;L;i++) printf("%d ",row[i].id); printf("%d\n",row[L].id); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008普及 ISBN号码]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;char isbn[20];int last,sum=0,cnt=1;int main()&#123; scanf("%s",isbn); for(int i=0;i&lt;13;i++)&#123; if(isdigit(isbn[i])&amp;&amp;i!=12) sum+=(isbn[i]-'0')*cnt,cnt++; else if(isdigit(isbn[i])&amp;&amp;i==12) sum%=11,last=isbn[i]-'0'; else sum%=11,last=10; &#125; if(last==sum)&#123; printf("Right"); &#125;else&#123; for(int i=0;i&lt;12;i++) putchar(isbn[i]); printf("%c\n",sum==10?'X':sum+'0'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008提高 双栈排序]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解双栈排序=单栈排序*2。那我们探究一下单栈排序吧！显然，单栈排序中，如果有两个数$\mathcal a_i$和$\mathcal a_k$，其中$\mathcal a_k&lt;a_i$，那么显然$\mathcal a_k$先弹出，$\mathcal a_i$后弹出。什么时候一个序列无法被单栈排序呢？如果因为某个原因，上面的事情做不到，就说明无法单栈排序。换言之，我们假设$\mathcal i&lt;k$且$\mathcal a_k&lt;a_i$，那么如果两个数之间有一个碍事的：有元素$\mathcal i&lt;j&lt;k$，并且$\mathcal a_i&lt;a_j$，那么显然在弹出$\mathcal a_k$后必须要先弹掉$\mathcal a_j$才能弹出$\mathcal a_i$，这不符合条件。所以无法单栈排序。一个栈做不成，那就两个。考虑把这些碍事的元素放到另一个栈里，这样就不矛盾了。问题是如何分配呢？我们知道，根据上述条件，$\mathcal a_i$和$\mathcal a_j$必然无法在同一个栈中。根据这种”二分“的性质，我们想到了二分图。把下标看做结点，然后不能在一个栈里的点对间连一条边，判断这个图是否是二分图即可。这一步可以直接用DFS实现。之后就比较简单了，输出排序过程即可。 还有一个瓶颈：怎么求这样的点对？直接枚举会带来$\mathcal O\left(n^3\right)$的时间复杂度，我们承受不住。观察到$\mathcal a_k$具体是多少不重要，只要有一个$\mathcal k$满足\mathcal j]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008提高 传纸条]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$\mathcal f\left( k,i,j\right) \left( i \le j \right)$为走了$\mathcal k$步，第一条路径当前在第$\mathcal i$列，第二条在第$\mathcal j$列时的最大的爱心值。则转移方程为 \mathcal f\left( k,i,j\right) = \max \left\{ f\left( k-1,i,j\right) , f\left( k-1,i-1,j\right) , f\left( k-1,i,j-1\right),f\left( k-1,i-1,j-1\right) \right\} + \begin{cases} data[k-i][i] \quad \left(i=j\right)\\ data[k-i][i]+data[k-j][j] \quad \left(i \neq j\right) \\ \end{cases}1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][51][51]=&#123;0&#125;,m,n,mat[51][51];int main()&#123; int i,j,k;scanf("%d%d",&amp;m,&amp;n); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(k=1;k&lt;m+n-1;k++) for(j=0;j&lt;n;j++) for(i=0;i&lt;=j;i++)&#123; if(k-i&lt;0||k-i&gt;=m||k-j&lt;0||k-j&gt;=m)continue; dp[k][i][j]=max(dp[k-1][i][j],dp[k][i][j]); if(i)dp[k][i][j]=max(dp[k-1][i-1][j],dp[k][i][j]); if(j)dp[k][i][j]=max(dp[k-1][i][j-1],dp[k][i][j]); if(i&amp;&amp;j)dp[k][i][j]=max(dp[k-1][i-1][j-1],dp[k][i][j]); dp[k][i][j]+=mat[k-i][i]; if(i!=j)dp[k][i][j]+=mat[k-j][j]; &#125; printf("%d\n",dp[m+n-2][n-1][n-1]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>多线程DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008提高 笨小猴]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。注意0和1都不是质数。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;bool judge(int x)&#123; if(!x||x==1)return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0)return 0; return 1;&#125;char s[1005];int cnt[27],len;int main()&#123; scanf("%s",s); len=strlen(s); for(int i=0;i&lt;len;i++) cnt[s[i]-'a']++; int maxi=0,mini=1000; for(int i=0;i&lt;26;i++)&#123; if(!cnt[i])continue; maxi=max(maxi,cnt[i]),mini=min(mini,cnt[i]); &#125; if(judge(maxi-mini)) printf("Lucky Word\n%d\n",maxi-mini); else printf("No Answer\n0\n"); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008提高 火柴棒等式]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2008tgt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解大概划定一下加数的范围，然后暴力枚举即可。1是最少的，所以以他为标准，大概左右两边的加数是在2000左右。（实际上试验后发现在1000左右）1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int cnt[]=&#123;6,2,5,5,4,5,6,3,7,6&#125;,n,ans=0;int table[2005];int get(int a)&#123; int res=0; while(a)res+=cnt[a%10],a/=10; return res;&#125;int main()&#123; scanf("%d",&amp;n),n-=4; table[0]=6; for(int i=1;i&lt;=2000;i++) table[i]=get(i); for(int i=0;i&lt;=1000;i++) for(int j=0;j&lt;=1000;j++) if(table[i]+table[j]+table[i+j]==n)ans++; printf("%d\n",ans); return 0;&#125; 不过题目是死的，人是活的。打表也是好手段。1int ans[]=&#123;0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128&#125;;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2008</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2006提高 2^k进制数]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2006tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解组合数问题。数码递增视为一个组合。这样一个数，数码只有$\mathcal 2^k-1$个，故长度至多为$\mathcal 2^k-1$。因此当$\mathcal w \ge \left(2^k-1\right) \times k $的时候，多出的那部分没有意义。此时令$\mathcal w = \left(2^k-1\right) \times k $。对于一个$\mathcal w$，一个$\mathcal 2^k$进制数除去最高位至多有$\mathcal \lfloor \frac {w}{k} \rfloor$位。考虑$\mathcal 2$到$\mathcal \lfloor \frac {w}{k} \rfloor$位，由于数码有$\mathcal 2^k-1$个，故此部分答案为 \mathcal \sum_{i=2}^{ \lfloor \frac {w}{k} \rfloor} C_{2^k-1}^{i}考虑最高位，由于最高位可能的最大数我们可以算出，设其为$\mathcal u$，则 \mathcal u=2^{w \mod k}-1最高位已经确定，剩下的只有$\mathcal \lfloor \frac {w}{k} \rfloor$个数字要选，备选的数字有$\mathcal 2^k-1-o \left( 1\le o \le u\right)$个，故此部分答案为 \mathcal \sum_{o=1}^u C_{2^k-1-o}^{\lfloor \frac {w}{k} \rfloor}两部分相加即为本题答案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define p 10000using namespace std;int c[520][25],ans[56]=&#123;0&#125;,k,w,k1,k2;void mul(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=1;i&lt;=s1[0];i++) x+=s1[i]*s2,to[i]=x%p,x/=p; for(;x&gt;0;)to[++to[0]]=x%p,x/=p; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void add(int s1[],int s2[])&#123; s2[0]=max(s1[0],s2[0]); int x=0; for(int i=1;i&lt;=s2[0];i++) x+=s1[i]+s2[i],s2[i]=x%p,x/=p; for(;x!=0;)s2[++s2[0]]=x%p,x/=p;&#125;void divide(int s1[],int s2)&#123; int x=0; for(int i=s1[0];i&gt;=1;i--)&#123; x=x*p+s1[i],s1[i]=x/s2,x%=s2; &#125; for(;s1[0]&gt;1&amp;&amp;s1[s1[0]]==0;)s1[0]--;&#125;void C(int m,int n)&#123; c[0][0]=c[0][1]=1; for(int i=1;i&lt;=m;i++) mul(c[i-1],n-i+1,c[i]),divide(c[i],i);&#125;int output(int big[])&#123; printf("%d",big[big[0]]); for(int i=big[0]-1;i&gt;=1;i--) printf("%04d",big[i]); printf("\n");&#125;int main()&#123; scanf("%d%d",&amp;k,&amp;w); k1=1&lt;&lt;k; if(w&gt;k*(k1-1))w=k*(k1-1); C(w/k,k1-1); for(int i=2;i&lt;=w/k;i++)add(c[i],ans); k2=1&lt;&lt;(w%k); for(int i=1;i&lt;k2;i++) C(w/k,k1-1-i),add(c[w/k],ans); output(ans); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2006</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2005提高 等价表达式]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2005tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解表达式求值。然而数据可以很大，直接比较答案和原式的做法不大现实。所以我们可以采用NOIP2014解方程的做法，把a带入一个数，再模一个质数，看结果是不是相同的。实际上为了保证准确性是可以模多个质数的，但这题数据很水，就没有这么做。最好还是多模几个质数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define A 1189using namespace std;int stack[2][10005],top[2]=&#123;0&#125;,pro[300],lim,targ,M=10009;char _exp[10000];int poww(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125; return res; &#125;void opr()&#123; int a1,a2,b; a2=stack[0][--top[0]], a1=stack[0][--top[0]], b=stack[1][--top[1]]; if(b=='+')stack[0][top[0]++]=(a1+a2)%M; if(b=='-')stack[0][top[0]++]=(a1-a2+M)%M; if(b=='*')stack[0][top[0]++]=(a1*a2)%M; if(b=='^')stack[0][top[0]++]=poww(a1,a2);&#125;void calc()&#123; int i,j,t=-1,cnt=0; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='a') stack[0][top[0]++]=A; else if(isdigit(_exp[i]))&#123; if(t&lt;0)t=_exp[i]-'0'; else t=t*10+_exp[i]-'0'; &#125;else if(_exp[i]!=' ')&#123; if(t!=-1) stack[0][top[0]++]=t, t=-1; if(_exp[i]=='(') stack[1][top[1]++]='(',cnt++; else if(_exp[i]==')')&#123; if(!cnt)continue; while(stack[1][top[1]-1]!='(') opr(); top[1]--,cnt--; &#125;else&#123; while(top[1]&amp;&amp;stack[1][top[1]-1]!='('&amp;&amp; pro[stack[1][top[1]-1]]&gt;=pro[_exp[i]]) opr(); stack[1][top[1]++]=_exp[i]; &#125; &#125; &#125;&#125;void init()&#123; pro['+']=pro['-']=1, pro['*']=2, pro['^']=3; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; calc(); targ=stack[0][0];&#125;void solve()&#123; int m,i; fgets(_exp,99,stdin); sscanf(_exp,"%d",&amp;m); for(i=0;i&lt;m;i++)&#123; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; top[0]=top[1]=0; memset(stack,0,sizeof(stack)); calc(); if(stack[0][0]==targ) printf("%c",'A'+i); &#125; printf("\n");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2005</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2002普及 选数]]></title>
    <url>%2F2018%2F07%2F18%2Fnoip2002pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解用DFS构造出所有的组合即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,x[24],ans=0;bool isPrime(int t)&#123; if(t&amp;1)&#123; if(t==1)return false; else&#123; for(int i=3;i*i&lt;=t;i+=2) if(t%i==0)return false; return true; &#125; &#125;else return t==2;&#125;void dfs(int index,int used,int sum)&#123; sum+=x[index]; if(used==k)&#123; if(isPrime(sum))ans++; return ; &#125; for(int i=index+1;i&lt;=n-k+used;i++) dfs(i,used+1,sum);&#125;void init()&#123; n=read(),k=read(); for(int i=0;i&lt;n;i++) x[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;=n-k;i++) dfs(i,1,0); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2002</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2004提高 津津的储蓄计划]]></title>
    <url>%2F2018%2F07%2F17%2Fnoip2004tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟神题。12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define money 300int main()&#123; int a[12]; int b1,b2,b3; int nowmoney=0; int saved=0; int i_f=0; for(b1=0;b1&lt;=11;b1++) scanf("%d",&amp;a[b1]); for(b1=0;b1&lt;=11;b1++)&#123; nowmoney+=money; if(nowmoney&lt;a[b1])&#123;i_f=!i_f;break;&#125;//预算不够 //月初 if ((nowmoney-a[b1])/100&gt;=1) &#123; saved=saved+((nowmoney-a[b1])/100)*100; nowmoney-=((nowmoney-a[b1])/100)*100; &#125; //月末 nowmoney-=a[b1]; &#125; if(i_f)printf("-%d",b1+1); else printf("%d",nowmoney+(int)(saved*1.2)); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2004</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2003提高 神经网络]]></title>
    <url>%2F2018%2F07%2F16%2Fnoip2003tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解拓扑排序。按照题意模拟即可。注意，只有一个神经元的情况要特判。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int mp[105][105],c[105]=&#123;0&#125;,u[105],V,E,d[105]=&#123;0&#125;;int que[105],f=0,r=0,vis[105]=&#123;0&#125;,mat[105][105]=&#123;0&#125;;void topo()&#123; int du[105]=&#123;0&#125;,i,j,o=0; for(i=1;i&lt;=V;i++)&#123; for(j=1;j&lt;=V;j++) if(mat[j][i])du[i]++,d[j]++; if(!du[i])vis[i]=1,que[r++]=i; &#125; while(r-f)&#123; i=que[f++]; if(du[i])c[i]-=u[i]; if(c[i]&gt;0)&#123; for(j=1;j&lt;=V;j++) if(mat[i][j])&#123; c[j]+=mp[i][j]*c[i]; if(!vis[j]) vis[j]=1,que[r++]=j; &#125; &#125; &#125; for(i=1;i&lt;=V;i++) if(!d[i]&amp;&amp;c[i]&gt;0) o=1,printf("%d %d\n",i,c[i]); if(!o)printf("NULL\n");&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,_u,v,_c; for(i=1;i&lt;=V;i++) scanf("%d%d",&amp;c[i],&amp;u[i]); for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;_u,&amp;v,&amp;_c), mat[_u][v]=1, mp[_u][v]=_c; if(V==1&amp;&amp;c[1]&gt;0) printf("%d %d\n",1,c[1]); else topo(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2003</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001普及 最大公约数与最小公倍数问题]]></title>
    <url>%2F2018%2F07%2F16%2Fnoip2001pjt2%2F</url>
    <content type="text"><![CDATA[题目地址 题解我们知道$\mathcal x_0$必须是$\mathcal y_0$的约数。所以记$\mathcal t=\frac{y_0}{x_0}$，则$\mathcal 2^u$（$\mathcal u$为$\mathcal t$不同质因子的个数）即为答案。（集合划分）很巧妙的数学方法。爆搜会TLE来着。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int isP(int a)&#123;for(int i=2;i*i&lt;=a;i++)if(a%i==0)return 0;return 1;&#125;int main()&#123; int x0,y0,i,ans=1; scanf("%d%d",&amp;x0,&amp;y0); if(y0%x0)&#123;printf("0\n");return 0;&#125; for(i=2,y0/=x0;i&lt;=y0;i++) if(y0%i==0&amp;&amp;isP(i))ans&lt;&lt;=1; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2001</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001提高 Car的旅行路线]]></title>
    <url>%2F2018%2F07%2F16%2Fnoip2001tgt4%2F</url>
    <content type="text"><![CDATA[题目地址 题解非常简单的最短路，非常难的建图。出发地和到达地每个机场间道路权值设为0即可。建图就是暴力用勾股求矩形顶点。在下面的代码中，我将顶点拆成了4个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#define rep(e) for(e=0;e&lt;4;e++)using namespace std;typedef double db;int T,s,t,A,B,rec[405][2],pr[105],vis[405];db ds[405][405],d[405][405],l[405];db dis(int a,int b)&#123; return (rec[a][0]-rec[b][0])*(rec[a][0]-rec[b][0])+ (rec[a][1]-rec[b][1])*(rec[a][1]-rec[b][1]);&#125;bool eq(db a,db b)&#123;return a-b&gt;(-1e-6)&amp;&amp;a-b&lt;(1e-6);&#125;void make(int i)&#123; db q1=dis(i,i+2),q2=dis(i,i+1),q3=dis(i+1,i+2); if(eq(q1+q2,q3))rec[i+3][0]=rec[i+2][0]+rec[i+1][0]-rec[i][0], rec[i+3][1]=rec[i+2][1]+rec[i+1][1]-rec[i][1]; else if(eq(q2+q3,q1))rec[i+3][0]=rec[i+2][0]+rec[i][0]-rec[i+1][0], rec[i+3][1]=rec[i+2][1]+rec[i][1]-rec[i+1][1]; else if(eq(q1+q3,q2))rec[i+3][0]=rec[i+1][0]+rec[i][0]-rec[i+2][0], rec[i+3][1]=rec[i+1][1]+rec[i][1]-rec[i+2][1];&#125;void dijkstra()&#123; int at,i=A&lt;&lt;2,j;db lst; fill(l,l+s,1e10); fill(vis,vis+s,0); l[i]=l[i+1]=l[i+2]=l[i+3]=0.0; for(i=0;i&lt;s;i++)&#123; for(lst=1e10,j=0;j&lt;s;j++) if(!vis[j]&amp;&amp;l[j]&lt;lst)at=j,lst=l[j]; vis[at]=1; for(j=0;j&lt;s;j++) l[j]=min(l[at]+d[at][j],l[j]); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v;db price; while(T--)&#123; scanf("%d%d%d%d",&amp;s,&amp;t,&amp;A,&amp;B); A--,B--,s&lt;&lt;=2; for(i=0;i&lt;s;i+=4)&#123; scanf("%d%d%d%d%d%d%d",&amp;rec[i][0],&amp;rec[i][1],&amp; rec[i+1][0],&amp;rec[i+1][1],&amp;rec[i+2][0],&amp; rec[i+2][1],&amp;pr[i]),make(i); if(i/4==A||i/4==B)pr[i]=0; &#125; for(i=0;i&lt;s;i+=4)&#123; for(j=0;j&lt;s;j+=4)&#123; price=(i!=j)?t:pr[i]; rep(u)rep(v) ds[i+u][j+v]=sqrt(dis(i+u,j+v)), d[i+u][j+v]=price*ds[i+u][j+v]; &#125; &#125; dijkstra(); printf("%.1lf\n",l[B&lt;&lt;2]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2001</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001普及 求先序排列]]></title>
    <url>%2F2018%2F07%2F16%2Fnoip2001pjt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解由后序得根，然后中序的两半继续分治。递归建立一颗树。具体过程是，在中序中找到根，然后由于左右子树分别在其左右，故可以再为左右子树建树。如果到了树为空的情况就返回。123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; #include &lt;math.h&gt; char po[10],ino[10];int left[100]=&#123;0&#125;,right[100]=&#123;0&#125;,n;int maketree(int inf,int inl,int pof,int pol);int maketree(int inf,int inl,int pof,int pol)&#123; if(inf&gt;inl)return 0; int root=po[pol],p=inf; while(ino[p]!=root)p++; left[root]=maketree(inf,p-1,pof,pof+p-inf-1); right[root]=maketree(p+1,inl,pof+p-inf,pol-1); return root;&#125;void pre(int at)&#123; printf("%c",at); if(left[at])pre(left[at]); if(right[at])pre(right[at]);&#125;int main()&#123; scanf("%s%s",ino,po);n=strlen(po); maketree(0,n-1,0,n-1); pre(po[n-1]); return 0; &#125; ​]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2001</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001普及 数的计算]]></title>
    <url>%2F2018%2F07%2F15%2Fnoip2001pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解\mathcal dp\left(i\right) = 1+ \sum_{j=1}^{\lfloor i/2\rfloor} dp\left(j\right) (i>1) \\ dp\left(1\right) = 11234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;typedef long long ll;int dp[1005]=&#123;0&#125;,n;int main()&#123; dp[2]=2,dp[1]=1; scanf("%d",&amp;n); int i,j; for(i=3;i&lt;=n;i++)&#123; for(j=i/2;j&gt;=1;j--) dp[i]+=dp[j]; dp[i]++; &#125; printf("%d\n",dp[n]); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2001</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001提高 一元三次方程求解]]></title>
    <url>%2F2018%2F07%2F15%2Fnoip2001tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解有4种方法：1.暴力，按0.01步长枚举2.二分，按照单调性求解3.数学公式4.导数这里用的是二分，感觉还不错。1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef double D;D a,b,c,d,t1,t2,epi=0.01;D get(D k)&#123; return k*a*k*k+b*k*k+c*k+d;&#125;D C(int ll,int rr)&#123; D tmp,mid,l=(D)ll,r=(D)rr; int i=(get(l)&gt;get(r))?1:0; for(;;)&#123; mid=(l+r)/2.0; tmp=get(mid); if(r-l&lt;epi&amp;&amp;r-l&gt;-epi)break; if(tmp&gt;0)&#123; if(i)l=mid; else r=mid; &#125;else&#123; if(i)r=mid; else l=mid; &#125; &#125; printf("%.2lf ",mid);&#125;int main()&#123; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); int i;for(i=-100;i&lt;=100;i++)&#123; t1=(D)i,t2=t1+0.99; t1=get(t1),t2=get(t2); if(t1*t2&lt;0)C(i,i+1); else if(t1&lt;epi&amp;&amp;t1&gt;-epi)printf("%.2lf ",(D)i); &#125; return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP2001</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1999普及 Cantor表]]></title>
    <url>%2F2018%2F07%2F15%2Fnoip1999pjt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解找规律，分奇偶讨论，最后$ \mathcal O(1)$计算。12345678#include &lt;cstdio&gt;using namespace std;int main()&#123; int n,i;scanf("%d",&amp;n); for(i=1;n&gt;(i*i+i)/2;i++); if(i%2==0)n=i*i+1-n; printf("%d/%d\n",i+(i*i-i)/2+1-n,n-(i*i-i)/2);&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1999</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1999提高 旅行家的预算]]></title>
    <url>%2F2018%2F07%2F15%2Fnoip1999tgt3%2F</url>
    <content type="text"><![CDATA[题目地址 题解尽量选最便宜的，如果油满了就换次便宜的，这样递归（循环下去）。最后油全满了就No solution。这里使用了优先队列来取最优值。只是懒得手写堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;typedef double db;typedef struct&#123; int id;db count,dis,pri;&#125;Pp;bool operator&lt;(Pp a,Pp b)&#123;return a.pri&gt;b.pri;&#125;Pp dat[105];int n;db ans=0,C,D,per;priority_queue&lt;Pp&gt; pq;void solve()&#123; pq.push(dat[0]); int i,j,k; Pp tmp; for(i=1;i&lt;=n;i++)&#123; db need=(dat[i].dis-dat[i-1].dis)/per,mini; for(;!pq.empty();)&#123; tmp=pq.top(); for(mini=need,j=tmp.id;j&lt;i;j++) mini=min(C-dat[j].count,mini); for(j=tmp.id;j&lt;i;j++) dat[j].count+=mini; ans+=mini*tmp.pri; if(mini&lt;need) need-=mini,pq.pop(); else break; &#125; if(pq.empty())&#123;ans=-1;return ;&#125; pq.push(dat[i]); &#125; &#125;int main()&#123; int i,j; scanf("%lf%lf%lf%lf%d",&amp;D,&amp;C,&amp;per,&amp;dat[0].pri,&amp;n); for(i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;dat[i].dis,&amp;dat[i].pri); dat[0].dis=0; for(n++,i=0;i&lt;=n;i++) dat[i].count=0,dat[i].id=i; dat[n].dis=D; solve(); if(ans&lt;0)printf("No Solution\n"); else printf("%.2lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1999</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1999提高 导弹拦截]]></title>
    <url>%2F2018%2F07%2F15%2Fnoip1999tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解先求最长不上升子序列，再求最长上升子序列。（Dilworth定理，最长链和最长反链）或者因为数据小，贪心的做法也能接受。所以我无聊的写了三个版本：$\mathcal O(nlogn)$动态规划123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int high[50],tot=0,ans=0,dp[50]=&#123;0&#125;,tmp; int main()&#123; int i,j; while(scanf("%d",&amp;high[tot])==1)tot++; for(i=0;i&lt;tot;i++)&#123; for(tmp=1,j=0;j&lt;i;j++)&#123; if(high[j]&gt;=high[i])tmp=max(tmp,dp[j]+1); &#125;dp[i]=tmp; &#125;for(i=0;i&lt;tot;i++)ans=max(ans,dp[i]); fill(dp,dp+tot,0x7FFFFFFF);for(i=0;i&lt;tot;i++) *lower_bound(dp,dp+tot,high[i])=high[i]; tmp=lower_bound(dp,dp+tot,0x7FFFFFFF)-dp; printf("%d\n%d\n",ans,tmp); return 0; &#125; $\mathcal O(n^2)$动态规划12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dat[55],n;int dp(int o)&#123; int dpp[55],ans=1; fill(dpp,dpp+n,1); for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++) if(o&amp;&amp;dat[j]&lt;=dat[i])dpp[i]=max(dpp[i],dpp[j]+1); else if(dat[j]&lt;dat[i])dpp[i]=max(dpp[i],dpp[j]+1); ans=max(ans,dpp[i]); &#125;return ans;&#125;int main()&#123; n=0;while(~scanf("%d",&amp;dat[n]))n++; reverse(dat,dat+n); printf("%d\n",dp(1)); reverse(dat,dat+n); printf("%d\n",dp(0)); return 0;&#125; $\mathcal O(n^2)$贪心123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int h[25],low[25],n=0,ans,f[25];int main()&#123; int i,j,t; while(~scanf("%d",&amp;h[n]))n++; for(f[0]=1,ans=i=1;i&lt;n;i++)&#123; f[i]=1; for(j=0;j&lt;i;j++) if(h[j]&gt;=h[i])f[i]=max(f[i],f[j]+1); ans=max(ans,f[i]); &#125; printf("%d\n",ans); for(low[0]=h[0],ans=0,i=1;i&lt;n;i++)&#123; for(j=0;j&lt;=ans;j++) if(low[j]&gt;=h[i])&#123;low[j]=h[i];break;&#125; if(j&gt;ans)low[++ans]=h[i]; &#125; printf("%d\n",ans+1); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1999</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1998普及 寻找三位数]]></title>
    <url>%2F2018%2F07%2F15%2Fnoip1998pjt1%2F</url>
    <content type="text"><![CDATA[试题来源 NOIP1998 普及组 问题描述 将1，2，…，9共9个数分成三组，分别组成三个三位数，且使这三个三位数构成 1：2：3的比例，试求出所有满足条件的三个三位数。 例如：三个三位数192，384，576满足以上条件。 输入格式 无输入 输出格式 输出每行有三个数，为满足题设三位数。各行为满足要求的不同解。 题解很简单的枚举。只要从101枚举到333即可，然后记录每一位。可以采用特殊策略优化，比如当前数字必须不是5的倍数。1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char k[10];int main()&#123; int a,b,c,d,fl,i; for(a=101;a&lt;=333;a++)&#123; if(a%5==0)continue; memset(k,0,sizeof(k)); fl=1,b=a,c=a*2,d=a*3; k[b%10]++,k[c%10]++,k[d%10]++; k[(b/10)%10]++,k[(c/10)%10]++,k[(d/10)%10]++; k[b/100]++,k[c/100]++,k[d/100]++; for(i=1;i&lt;=9;i++) if(k[i]!=1) fl=0; if(fl)printf("%d %d %d\n",b,c,d); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1998</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1997普及 棋盘]]></title>
    <url>%2F2018%2F07%2F15%2Fnoip1997pjt1%2F</url>
    <content type="text"><![CDATA[试题来源 NOIP1997 普及组 问题描述 1．设有一个nm方格的棋盘（1≤m,n≤100）。 求出该棋盘中包含多少个正方形、多少个长方形（不包括正方形）。 例如：当n=2，m=3时 正方形的个数有8个；即边长为1的正方形有6个； 边长为2的正方形有2个。 长方形的个数有10个； 即21的长方形有4个； 12的长方形有3个； 31的长方形有2个； 3*2的长方形有1个。 程序要求：输入：n和m 输出：正方形的个数与长方形的个数 输入格式 一行两个数N,M 输出格式 一行两个数，分别为正方形个数和长方形个数。 样例输入12 3 样例输出18 10 数据规模和约定 1≤m,n≤100 题解自己推一下就行了。长方形（含正方形）个数为 \frac {nm(n+1)(m+1) }{4}正方形个数为 \mathcal \sum_{i=1}^m {i \left( n-m+i \right) \left( m \le n \right)}1234567891011121314#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll n,m,a1=0,a2=0;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(n&lt;m)swap(n,m); a1=m*n*(n+1)*(m+1)/4; for(int i=1;i&lt;=m;i++) a2+=(n-m+i)*i; printf("%lld %lld\n",a2,a1-a2); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1997</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>奥数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1997普及 三角形]]></title>
    <url>%2F2018%2F07%2F14%2Fnoip1997pjt2%2F</url>
    <content type="text"><![CDATA[试题来源 NOIP1997 普及组 问题描述 将1，2，······,9共9个数排成下列形态的三角形。 a b c d e f g h i 其中：a～i分别表示1，2，······,9中的一个数字，并要求同时满足下列条件： （1）a&lt;f&lt;i; （2）b&lt;d, g&lt;h, c&lt;e （3）a+b+d+f=f+g+h+i=i+e+c+a=P 程序要求： 根据输入的边长之和P 输出所有满足上述条件的三角形的个数以及其中的一种方案。 若有多种方案输出字典序最小的那种。若无解输出NO。 输入格式 输入一行一个数表示P。 输出格式 无解输出一行NO，否则第一行是方案数，接下来是字典序最小的方案。 每行的数之间用一个空格隔开。具体见样例。 样例输入123 样例输出12345272 36 48 1 5 9 数据规模和约定 无。 题解暴力枚举即可。用了全排列。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int ans=0,p,rec[20],now[20]=&#123;1,2,3,4,5,6,7,8,9&#125;;void cmp()&#123; if(!ans||memcmp(now,rec,sizeof(int)*9)&lt;0) memcpy(rec,now,sizeof(rec)); ans++;&#125;int ok()&#123; return ((now[0]&lt;now[5]&amp;&amp;now[5]&lt;now[8]) &amp;&amp;(now[1]&lt;now[3]&amp;&amp;now[6]&lt;now[7]&amp;&amp;now[2]&lt;now[4]) &amp;&amp;(now[0]+now[1]+now[3]+now[5]==p) &amp;&amp;(now[6]+now[7]+now[8]+now[5]==p) &amp;&amp;(now[0]+now[2]+now[4]+now[8]==p));&#125;int main()&#123; scanf("%d",&amp;p); do&#123; if(ok())cmp(); &#125;while(next_permutation(now,now+9)); if(!ans)&#123; printf("NO\n"); return 0; &#125; printf("%d\n",ans); printf("%d\n%d %d\n%d %d\n%d %d %d %d\n",rec[0], rec[1],rec[2],rec[3],rec[4],rec[5],rec[6], rec[7],rec[8]); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1997</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1997普及 街道]]></title>
    <url>%2F2018%2F07%2F14%2Fnoip1997pjt3%2F</url>
    <content type="text"><![CDATA[试题来源 NOIP1997 普及组 问题描述 设有一个N＊M（1≤ N≤50， 1≤ M≤ 50）的街道。n和m表示横竖街道数。 规定行人从A(1,1)出发，在街道上只能向东或北方向行走。 N＝3，M=3的街道图，从A出发到达B共有6条可供行走的路。 若在N＊M的街道中，设置一个矩形障碍区域（包括围住该区域的街道和点）不让行人通行。 此矩形障碍区域用2对顶点坐标给出,前图中的2对顶点坐标为:(2，2),(8，4),此时从 A出发到达B的路径仅有两条。 程序要求： 任务一：给出N，M后，求出所有从A出发到达B的路径的条数。 任务二：给出N，M，同时再给出此街道中的矩形障碍区域的2对顶点坐标(x1,y1), （x2,y2），然后求出此种情况下所有从A出发到达B的路径的条数。 如果答案太大，输出最后20位。 输入格式 第一行两个数n和m。 第二行为X1,Y1,X2,Y2.如果是任务一，则第二行为4个0. 输出格式 输出走路方案数。 样例输入123 30 0 0 0 样例输出16 样例输入1250 502 2 49 49 样例输出12 数据规模和约定 1&lt;=N,M&lt;=50 题解就是非常正常的DP。递推式 \mathcal dp(i,j) = dp(i-1,j)+dp(i,j-1)之后再用一个简单的高精度就可以了。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll M=1000000000000000,dp[55][55][2]=&#123;0&#125;,n,m,x1,x2,y1,y2,ok=1;void add(ll u1,ll v1,ll u2,ll v2)&#123; ll a=dp[u1][v1][0]+dp[u2][v2][0]; dp[u2][v2][0]=a%M,a/=M; a+=dp[u1][v1][1]+dp[u2][v2][1]; dp[u2][v2][1]=a%M;//简单的高精度&#125;void solve()&#123; dp[1][1][0]=1; for(ll i=1;i&lt;=n;i++) for(ll j=1;j&lt;=m;j++) if((ok&amp;&amp;(i&lt;x1||i&gt;x2||j&lt;y1||j&gt;y2))||(!ok)) add(i-1,j,i,j), add(i,j-1,i,j); //递推过程 dp[n][m][1]%=100000; if(dp[n][m][1]&gt;0)printf("%lld%015lld\n",dp[n][m][1],dp[n][m][0]); else printf("%lld\n",dp[n][m][0]);&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(!x1&amp;&amp;!x2&amp;&amp;!y1&amp;&amp;!y2)ok=0; else&#123; if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1997</category>
      </categories>
      <tags>
        <tag>棋盘DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1997提高 骑士]]></title>
    <url>%2F2018%2F07%2F09%2Fnoip1997tgt3%2F</url>
    <content type="text"><![CDATA[试题来源 NOIP1997 提高组 问题描述如果有多条路径，则输出字典序最小的那一条。路径数目取10^18的模输出。 输入格式 第一行两个数N和M。第二行4个数x1,y1,x2,y2. 如果为任务一则第二行为4个0. 输出格式 输出一行答案。 样例输入124 40 0 0 0 样例输出1(1,1)-(2,3)-(4,4) 数据规模和约定1&lt;=n,m&lt;=50 题解任务1的话DFS任务2DP]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1997</category>
      </categories>
      <tags>
        <tag>棋盘DP</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1998提高 火车站]]></title>
    <url>%2F2018%2F07%2F09%2Fnoip1998tgt1%2F</url>
    <content type="text"><![CDATA[题目地址 题解设第二站上的人数是$p$，则：容易看出每一站上下车的人都等于$fib[i]a+fib[j]p$，其中$i$和$j$为相邻正整数。那么只需要算出最终车上的人等于多少$a$加多少$p$，解出$p$，然后带入第$x$站的数据即可。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int a,n,m,x,fib[25],xs1[25],xs2[25];void init()&#123; a=read(),n=read(),m=read(),x=read(); fib[0]=0,fib[1]=1; for(int i=2;i&lt;=24;i++) fib[i]=fib[i-1]+fib[i-2];&#125;void solve()&#123; xs1[1]=xs1[2]=1,xs2[1]=xs2[2]=0; for(int i=3;i&lt;n;i++) xs1[i]=xs1[i-1]+fib[i-2]-fib[i-3], xs2[i]=xs2[i-1]+fib[i-1]-fib[i-2]; printf("%d\n",xs1[x]*a+xs2[x]*(m-xs1[n-1]*a)/xs2[n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1998</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1996提高 砝码称重]]></title>
    <url>%2F2018%2F07%2F08%2Fnoip1996tgt4%2F</url>
    <content type="text"><![CDATA[试题来源 NOIP1996 提高组 问题描述 设有1g、2g、3g、5g、10g、20g的砝码各若干枚（其总重&lt;=1000） 输入格式 a1 a2 a3 a4 a5 a6 （表示1g砝码有a1个，2g砝码有a2个，…，20g砝码有a6个） 输出格式 Total=N （N表示用这些砝码能称出的不同重量的个数，但不包括一个砝码也不用的情况） 样例输入11 1 0 0 0 0 样例输出1Total=3 数据规模和约定 总重&lt;=1000 题解用了完全背包，但是数据很弱，好像没有必要。可以暴力枚举。123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int f[1005]=&#123;0&#125;,n,v[6],ans=0;void packX(int vv)&#123;//二进制枚举版本 int p=1,vi=vv,j; while(n&gt;=p)&#123; for(j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); n-=p,p&lt;&lt;=1,vi&lt;&lt;=1; &#125; if(n)&#123; for(vi=n*vv,j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); &#125;&#125;int main()&#123; v[0]=1,v[1]=2,v[2]=3,v[3]=5,v[4]=10,v[5]=20; f[0]=1; for(int i=0;i&lt;6;i++)&#123; scanf("%d",&amp;n); if(n)packX(v[i]); &#125; for(int i=1;i&lt;=1000;i++) ans+=f[i]; printf("Total=%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1996</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1996提高 挖地雷]]></title>
    <url>%2F2018%2F07%2F08%2Fnoip1996tgt3%2F</url>
    <content type="text"><![CDATA[题目背景NOIp1996提高组第三题 题目描述在一个地图上有N个地窖（N&lt;=20），每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从第一个地窖开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。 输入输出格式输入格式：有若干行。第1行只有一个数字，表示地窖的个数N。第2行有N个数，分别表示每个地窖中的地雷个数。第3行至第N+1行表示地窖之间的连接情况：第3行有n-1个数（0或1），表示第一个地窖至第2个、第3个、…、第n个地窖有否路径连接。如第3行为1 1 0 0 0 … 0，则表示第1个地窖至第2个地窖有路径，至第3个地窖有路径，至第4个地窖、第5个、…、第n个地窖没有路径。第4行有n-2个数，表示第二个地窖至第3个、第4个、…、第n个地窖有否路径连接。… …第n+1行有1个数，表示第n-1个地窖至第n个地窖有否路径连接。（为0表示没有路径，为1表示有路径）。输出格式：有两行第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。第二行只有一个数，表示能挖到的最多地雷数。 输入输出样例样例输入 Sample Input123456510 8 4 7 61 1 1 00 0 01 11 样例输出 Sample Output121 3 4 527 数据范围及提示 Data Size &amp; Hint（N&lt;=20） 题解题目已经帮你拓扑排序完了，直接转移就可以。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,V,mp[25][25]=&#123;0&#125;,m[25],dp[25]=&#123;0&#125;,pre[25],ans[25],maxi=0,at;int main()&#123; scanf("%d",&amp;n); int i,j; fill(pre,pre+n,-1);//记录路径 for(i=0;i&lt;n;i++) scanf("%d",&amp;m[i]); for(i=0;i&lt;n-1;i++) for(j=i+1;j&lt;n;j++) scanf("%d",&amp;mp[i][j]); dp[0]=maxi=m[0],at=0; for(i=1;i&lt;n;i++)&#123; for(j=i-1;j&gt;=0;j--) if(mp[j][i]&amp;&amp;dp[j]&gt;=dp[i]) dp[i]=dp[j],pre[i]=j; dp[i]+=m[i]; if(dp[i]&gt;maxi) maxi=dp[i],at=i; &#125; for(j=0,i=at;i!=-1;i=pre[i]) ans[j++]=i+1; for(i=j-1;i&gt;=0;i--)&#123; printf("%d",ans[i]); if(i)printf(" "); &#125; printf("\n%d\n",maxi); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
        <category>NOIP1996</category>
      </categories>
      <tags>
        <tag>图上DP</tag>
      </tags>
  </entry>
</search>
