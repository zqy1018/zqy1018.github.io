<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round 536 (Div. 2) 题解]]></title>
    <url>%2F2019%2F02%2F03%2Fcontest-cf1106%2F</url>
    <content type="text"><![CDATA[学长出题orz，不过cf服务器炸了也是。。。 A题目大意：给定一个字符矩阵，如果某个字符及其左上，左下，右上，右下的临近字符都是X那么就说以该字符为中心构成一个“X”。求中心不同的“X”个数。 遍历找一遍就行了。1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;char mat[505][505] = &#123;0&#125;;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)&#123; scanf("%s", &amp;mat[i][1]); &#125; int ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; if(mat[i][j] == 'X' &amp;&amp; mat[i + 1][j + 1] == 'X' &amp;&amp; mat[i - 1][j - 1] == 'X' &amp;&amp; mat[i + 1][j - 1] == 'X' &amp;&amp; mat[i - 1][j + 1] == 'X') ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B题目链接 按照题目的意思进行模拟即可。因为不同菜品之间的价格不会变，所以可以直接在开始时对所有菜品排序，然后用一个指针指示当前最便宜的菜品的编号。之后就是按题意模拟了。本题有一个坑，就是如果菜没了cost就直接置为0了。。。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pp;int n, m;int a[100005], c[100005];ll ans[100005] = &#123;0&#125;;pp p[100005];int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;c[i]), p[i].first = c[i], p[i].second = i; sort(p + 1, p + n + 1); int cur = 1; for(int i = 1; i &lt;= m; ++i)&#123; int t, d; scanf("%d%d", &amp;t, &amp;d); if(a[t] &gt;= d) ans[i] += 1ll * d * c[t], a[t] -= d; else&#123; ans[i] += 1ll * a[t] * c[t], d -= a[t], a[t] = 0; while(d)&#123; while(cur &lt;= n &amp;&amp; a[p[cur].second] == 0) cur++; if(cur &gt; n) break; int id = p[cur].second; int bb = min(a[id], d); ans[i] += 1ll * bb * c[id]; a[id] -= bb, d -= bb; &#125; if(cur &gt; n) &#123; ans[i] = 0; break; &#125; &#125; &#125; for(int i = 1; i &lt;= m; ++i) printf("%I64d\n", ans[i]); return 0;&#125; C题目大意：给定$n$个数，求一种划分，将所有数分为若干组，每个组至少包含两个数，使得$\Sigma\text{每一个组内数的和的平方}$最小。 贪心。可以证明当每个组里只有2个元素的时候答案可以最小，然后组合方式就是当前最小元素搭配当前最大元素。123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[300005];ll ans = 0;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); sort(a + 1, a + n + 1); for(int i = 1; i &lt;= (n &gt;&gt; 1); ++i) ans += 1ll * (a[i] + a[n - i + 1]) * (a[i] + a[n - i + 1]); printf("%I64d\n", ans); return 0;&#125; D题目大意：给定一张无向图，起点在1处，每走过一个之前没有经过的顶点就会将这个顶点的编号写在之前顶点编号的后面，形成一个顶点编号序列。显然序列的开头是1。每一条边和每一个顶点都可以重复经过。求一个序列，使其字典序最小。 一开始以为是强连通分量分解，后来发现也是一个贪心。先把1放入小根堆，然后每次取出堆顶元素，设其为$v$，与$v$相邻的且未经过的点放进堆里，如此反复就可以得到答案。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Edge&#123; int v, nxt;&#125;;Edge e[200005];int at[100005], cnt = 0;int V, E;int in[100005] = &#123;0&#125;; int st[100005], top = 0;int ans[100005];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;void addEdge(int u, int v)&#123; e[++cnt].v = v, e[cnt].nxt = at[u], at[u] = cnt;&#125;int main()&#123; scanf("%d%d", &amp;V, &amp;E); for(int i = 1; i &lt;= E; ++i)&#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; in[1] = true, ans[1] = 1; for(int i = at[1]; i; i = e[i].nxt)&#123; if(in[e[i].v]) continue; pq.push(e[i].v), in[e[i].v] = true; &#125; for(int i = 2; i &lt;= V; ++i)&#123; int dd = pq.top(); pq.pop(); ans[i] = dd; for(int j = at[dd]; j; j = e[j].nxt)&#123; if(in[e[j].v]) continue; pq.push(e[j].v), in[e[j].v] = true; &#125; &#125; for(int i = 1; i &lt; V; ++i) printf("%d ", ans[i]); printf("%d\n", ans[V]); return 0;&#125; E题目链接 12 F题目大意：给定一个递推数列： f_i = (\prod_{j = 1}^{k} f_{i - j}^{b_j})\mod p其中$i&gt;k, p=998244353$。已知k, n, f_n, b_1, \cdots, b_k，且f_1=\cdots=f_{k-1}=1，求f_k的可能值。 由于$f$的前$k-1$项全部是$1$，所以可以只考察f_n中f_k的指数。这个可以用快速幂来做。已知指数和幂求底数，这就是一个经典的k次剩余问题，由于本题没有额外的限制，所以使用原根和BSGS算法解决。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int c[10005] = &#123;0&#125;, bb[10005] = &#123;0&#125;, tmp[20005] = &#123;0&#125;;int k, n, m, b[105];const int p = 998244353;void mul(int *a1, int *a2)&#123; for(int i = 0; i &lt;= (k &lt;&lt; 1); ++i) tmp[i] = 0; for(int i = 0; i &lt;= k; ++i)&#123; for(int j = 0; j &lt;= k; ++j)&#123; tmp[i + j] = (tmp[i + j] + 1ll * a1[i] * a2[j]) % (p - 1); &#125; &#125; for(int i = k &lt;&lt; 1; i &gt;= k; --i)&#123; for(int j = 0; j &lt; k; ++j)&#123; tmp[i - k + j] = (tmp[i - k + j] + 1ll * tmp[i] * b[k - j]) % (p - 1); &#125; tmp[i] = 0; &#125; for(int i = 0; i &lt; k; ++i) a1[i] = tmp[i];&#125;void poww(int *a1, int t, int *a2)&#123; while(t)&#123; if(t &amp; 1) mul(a2, a1); mul(a1, a1), t &gt;&gt;= 1; &#125;&#125;int poww_i(int a, int b, int c)&#123; a %= c; int res = 1; while(b)&#123; if(b &amp; 1) res = (1ll * res * a) % c; a = (1ll * a * a) % c, b &gt;&gt;= 1; &#125; return res;&#125;int extgcd(int a, int b, int &amp;x, int &amp;y)&#123; int d = a; if(b) d = extgcd(b, a % b, y, x), y = y - (a / b) * x; else x = 1, y = 0; return d;&#125;int inv(int x, int m)&#123; int u, v; if(extgcd(x, m, u, v) != 1) return -1; return u &lt; 0 ? u + m: u;&#125;int BSGS(int y, int z, int m)&#123; map&lt;int, int&gt; rec; int s = (int)floor(sqrt(m - 1) + 0.5), cur = 1; int v = inv(poww_i(y, s, m), m); if(v == -1) return -1; for(int i = 0; i &lt; s; ++i) rec[cur] = i, cur = 1ll * cur * y % m; for(int i = 0; i &lt;= s; ++i)&#123; if(rec.count(z)) return i * s + rec[z]; z = 1ll * z * v % m; &#125; return -1;&#125;int main()&#123; scanf("%d", &amp;k); for(int i = 1; i &lt;= k; ++i) scanf("%d", &amp;b[i]); scanf("%d%d", &amp;n, &amp;m); bb[1] = 1, c[0] = 1; if(k &gt; 1) poww(bb, n - 1, c); //c[k - 1] else c[k - 1] = poww_i(b[1], n - 1, p - 1); int exp1 = BSGS(3, m, p), u, v; int d = extgcd(c[k - 1], p - 1, u, v); if(exp1 % d) printf("-1\n"); else&#123; u = (u + p - 1) % (p - 1); u = 1ll * (exp1 / d) * u % (p - 1); printf("%d\n", poww_i(3, u, p)); &#125; return 0;&#125; 小结这次比赛相对而言比较看重基本功，并没有什么非常难的题目（然鹅我还是只A了4题orz）。不过这次比赛的失误比较多，先是在A和B上各贡献了一发WA，又是在F上把k次剩余看成了离散对数。。。导致排名比较难看。总之：线上比赛要拼手速，更要拼准确度；要巩固好数学基础；掌握更好的DP姿势。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4992 Primitive Roots]]></title>
    <url>%2F2019%2F02%2F02%2Fhdu4992%2F</url>
    <content type="text"><![CDATA[题目大意：给定正整数$n$，求出$n$的所有原根。多组数据。 题解模板题，但这个题卡时间卡的比较紧，所以要先用线性筛筛出质数，顺便预处理出每一个范围内的数的欧拉函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma G++ optimize(2)#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int p, pri[105], cnt, ans[1000005], len;int phi[1000005], prime[500005], tot = 0;bool vis[1000005] = &#123;0&#125;, ok[1000005] = &#123;0&#125;;void getPhi(int N)&#123; phi[1] = 1; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; prime[++tot] = i, phi[i] = i - 1; if(i &amp; 1)&#123; for(int j = i; ; j *= i)&#123; ok[j] = true; if(j + j &lt;= N) ok[j + j] = true; if(1ll * j * i &gt; N) break; &#125; &#125; &#125; for(int j = 1; j &lt;= tot; ++j)&#123; ll t = 1ll * i * prime[j]; if(t &gt; N) break; vis[t] = true, phi[t] = phi[i] * (prime[j] - 1); if(i % prime[j] == 0)&#123; phi[t] += phi[i]; break; &#125; &#125; &#125;&#125;int poww(int a, int b, int M)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (1ll * res * a) % M; a = (1ll * a * a) % M, b &gt;&gt;= 1; &#125; return res;&#125;void getFac(int x)&#123; cnt = 0; int t = x; for(int i = 1; i &lt;= 168; ++i)&#123; if(t % prime[i] == 0)&#123; do&#123; t /= prime[i]; &#125;while(t % prime[i] == 0); pri[++cnt] = prime[i]; &#125; if(t == 1) break; &#125; if(t != 1) pri[++cnt] = t;&#125;bool judge_pr(int x)&#123; if(poww(x, phi[p], p) != 1) return false; for(int i = 1; i &lt;= cnt; ++i) if(poww(x, phi[p] / pri[i], p) == 1) return false; return true;&#125;int get_pr(int p)&#123; for(int i = 2; i &lt;= p; ++i) if(judge_pr(i)) return i; return -1;&#125;int gcd(int a, int b)&#123; return (!b) ? a: gcd(b, a % b);&#125;void solve()&#123; if(p == 1 || p == 2) &#123; printf("1\n"); return ; &#125; if(p == 4) &#123; printf("3\n"); return ; &#125; if(!ok[p])&#123; printf("-1\n"); return ; &#125; getFac(phi[p]); int res = get_pr(p); len = 0, ans[++len] = res; for(int i = 2, j = 1ll * res * res % p; i &lt; phi[p]; ++i, j = 1ll * j * res % p)&#123; if(gcd(i, phi[p]) == 1) ans[++len] = j; &#125; sort(ans + 1, ans + len + 1); for(int i = 1; i &lt; len; ++i) printf("%d ", ans[i]); printf("%d\n", ans[len]);&#125;int main()&#123; getPhi(1000000); while(~scanf("%d", &amp;p))&#123; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa10559 Blocks]]></title>
    <url>%2F2019%2F01%2F28%2Fuva10559%2F</url>
    <content type="text"><![CDATA[题目大意：有$n$个带有颜色的方块，消除一段长度为$x$的连续的相同颜色的方块可以得到$x^2$的分数，求一种最优的消除顺序消除所有方块使得得分最多。 题解设$f(i, j, k)$为当前区间为$[i, j]$，且区间中消除到有$k$个和$i$处颜色相同的方块时，可以得到的最大分数。显然，答案为$f(1, n, 0)$。当$k\neq 0$时，要考虑从$k-1$转移过来。此时考虑从$[i, j]$中遍历$l$，当第$l$个方块颜色和第$i$个相同时，将从$l$左或者从$l$右开始的一部分作为从$k-1$转移过来的部分，另一部分消去。因为消去的顺序不影响结果，此处将右边一半消去。从而有： f(i, j, k) = \max_{i\le l\le j}\lbrace f(i, l - 1, k - 1) + f(l + 1, j, 0) \rbrace当$k=0$时，考虑将积累下来的方块消去，就有： f(i, j, 0) = \max\lbrace f(i, j, k) + k^2\rbrace12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[205] = &#123;0&#125;;int f[205][205][205] = &#123;0&#125;;int main()&#123; int T; scanf("%d", &amp;T); for(int TT = 1; TT &lt;= T; ++TT)&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i) f[i][i][1] = 0, f[i][i][0] = 1; for(int i = 0; i &lt;= n; ++i) for(int j = i - 1; j &gt;= 0; --j) f[i][j][0] = 0; f[n + 1][n][0] = 0; for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j + i &lt;= n; ++j)&#123; for(int k = 1; k &lt;= i + 1; ++k)&#123; for(int l = j; l &lt;= j + i; ++l)&#123; if(a[j] != a[l]) continue; if(f[j][l - 1][k - 1] &gt;= 0) f[j][j + i][k] = max(f[j][j + i][k], f[j][l - 1][k - 1] + f[l + 1][j + i][0]); &#125; &#125; for(int k = 1; k &lt;= i + 1; ++k)&#123; if(f[j][j + i][k] &gt;= 0) f[j][j + i][0] = max(f[j][j + i][0], f[j][j + i][k] + k * k); &#125; &#125; &#125; printf("Case %d: %d\n", TT, f[1][n][0]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nowcoder-hanjia]]></title>
    <url>%2F2019%2F01%2F28%2Fnowcoder-hanjia%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 10C Digital Root]]></title>
    <url>%2F2019%2F01%2F28%2Fcf10c%2F</url>
    <content type="text"><![CDATA[题目大意：定义$d(x)$为$x$的“数字根”，给定$N$，求三元组$(A, B, C)(A, B, C\in [1, N])$的个数，其中$d(d(A)d(B))=d(C)$且$AB\neq C$。 题解可以发现$d(xy)=d(d(x)y)=d(d(x)d(y))$。所以可以先求出所有不包含条件$AB\neq C$的三元组的数目N_1，然后减掉包含该条件的三元组的数目N_2。 N_2容易求出，等同于$1, \cdots, N$每一个数的约数的数目之和，即N_2=\sum_{i=1}^{N} \lfloor \frac{N}{i} \rfloor。 N_1也容易求，由$d(xy)=d(d(x)d(y))$可知对于不同的$A, B$，$d(AB)$具有周期性。故可以先求出$N=9$的情况，然后根据周期性算出N_1。（这里可以想象一个$N\times N$的棋盘上相邻的$9\times 9$宫格之间情况是相同的）答案就是N_1-N_2。12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int n, ss[10][10][10] = &#123;0&#125;;long long ans = 0, cnt[10] = &#123;0&#125;;int dr(int x)&#123; return (x % 9 ? x % 9: 9);&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= 9; ++i)&#123; for(int j = 1; j &lt;= 9; ++j)&#123; ss[i][j][dr(i * j)]++; for(int k = 1; k &lt;= 9; ++k) ss[i][j][k] += ss[i][j - 1][k]; &#125; &#125; for(int i = 1; i &lt;= 9; ++i) for(int j = 1; j &lt;= 9; ++j) for(int k = 1; k &lt;= 9; ++k) ss[i][j][k] += ss[i - 1][j][k]; long long res = 0; for(int i = 1; i &lt;= n; ++i)&#123; res += 1ll * (n / i); &#125; int kk = n / 9, r = n % 9; for(int i = 1; i &lt;= 9; ++i) cnt[i] += 1ll * kk * kk * ss[9][9][i], cnt[i] += 2ll * kk * ss[r][9][i], cnt[i] += 1ll * ss[r][r][i]; for(int i = 1; i &lt;= 9; ++i) ans += ((n + 9 - i) / 9) * cnt[i]; cout &lt;&lt; ans - res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 59 题解]]></title>
    <url>%2F2019%2F01%2F28%2Fcontest-cf1107%2F</url>
    <content type="text"><![CDATA[这场比赛区分度比较大。E，F，G题均比较难。 A题目大意：给定一个数字串，求一种方法将该串分割成至少两个非空部分，并且每个部分形成的数从左到右严格递增。如123456，可以分割成3个部分1，23，456。 由于没有更多的限制条件，所以可以直接把这个串分割成两个部分，前一部分只包含第一个数字。这样如果串长大于2就必然可行，否则需要特判。1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;char s[305];int main()&#123; int q; cin &gt;&gt; q; while(q--)&#123; cin &gt;&gt; n; scanf("%s", s); if(n == 2)&#123; if(s[1] &lt;= s[0]) printf("NO\n"); else printf("YES\n2\n%c %c\n", s[0], s[1]); &#125;else&#123; printf("YES\n2\n%c %s\n", s[0], s + 1); &#125; &#125; return 0;&#125; B题目大意：给定$k, x$，求第$k$个“数字根”为$x$的数。多组询问。 知道了数字根的性质这道题就会做了。答案就是$9(k-1)+x$。12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;ll q, x;int main()&#123; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; q &gt;&gt; x; cout &lt;&lt; (q - 1ll) * 9ll + x &lt;&lt; endl; &#125; return 0;&#125; C题目链接 可以发现我们只要对字符串分段处理即可，即对于每一个连续的相同字母构成的串，只要取其中能获得的分数最大的$k$个字母进行敲击即可。用排序或者堆都可以，时间复杂度$O(n\log n)$。1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, k;int a[200005];char s[200005];ll ans = 0;int tmp[200005], cnt = 0;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); scanf("%s", s + 1); for(int i = 1; i &lt;= n; )&#123; int j = i; ll sum = 0; while(j &lt;= n &amp;&amp; s[i] == s[j]) sum += 1ll * a[j], j++; if(j - i &lt;= k)&#123; ans += sum; &#125;else&#123; for(cnt = 0; cnt + i &lt; j; ++cnt) tmp[cnt] = a[i + cnt]; sort(tmp, tmp + cnt); for(int t = 0; t &lt; k; ++t) ans += 1ll * tmp[cnt - 1 - t]; &#125; i = j; &#125; printf("%I64d\n", ans); return 0;&#125; D题目大意：找到最大的$x$使得$n\times n$的01矩阵$A$能被压缩成为$\frac{n}{x} \times \frac{n}{x}$矩阵$B$，使得$\forall i \in [1, n], j \in [1, n], A[i][j] = B[\lceil \frac{n}{x} \rceil][\lceil \frac{n}{x} \rceil]$。 大暴力。枚举$n$的约数，从大到小判断即可。所谓判断，即判断每一个$x\times x$的矩阵中的数据是否完全相同。使用二维前缀和辅助判断过程。注意不要写成二分$x$，因为答案不一定有单调性。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;int ds[10005], cnt = 0;int ma[5205][5205], sum[5205][5205] = &#123;0&#125;;char s[1305];bool judge(int x)&#123; for(int i = x; i &lt;= n; i += x) for(int j = x; j &lt;= n; j += x)&#123; int res = sum[i][j] - sum[i - x][j] - sum[i][j - x] + sum[i - x][j - x]; if(res &gt; 0 &amp;&amp; res &lt; x * x) return false; &#125; return true;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) if(n % i == 0) ds[++cnt] = i; for(int i = 1; i &lt;= n; ++i)&#123; scanf("%s", s + 1); int tt = n &gt;&gt; 2; for(int j = 1; j &lt;= tt; ++j)&#123; int re = (isdigit(s[j]) ? s[j] - '0': s[j] - 'A' + 10); for(int k = 1, t = 4; k &lt;= 8; k &lt;&lt;= 1, --t) if(k &amp; re) ma[i][(j - 1) * 4 + t] = 1; else ma[i][(j - 1) * 4 + t] = 0; &#125; &#125; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) sum[i][j] = sum[i][j - 1] + ma[i][j]; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) sum[i][j] += sum[i - 1][j]; int ans = 1; for(int i = cnt; i &gt;= 2; --i)&#123; if(judge(ds[i]))&#123; ans = ds[i]; break; &#125; &#125; printf("%d\n", ans); return 0;&#125; E题目大意：给定一个01串，每次可以对一段0或者一段1进行消除，得到的分数和长度有关，消除之后被消除的段的两侧合并。求整个串被全部消除时最大的分数。 这道题的状态设计非常有意思。容易将当前区间的两端位置加入到状态中，但这还不够。设$f(dig, i, j, k)$为当前区间为$[i, j]$，且区间中消除到有$k$个$dig$时，可以得到的最大分数。显然，答案为$f(0, 1, n, 0)$。这样就能方便的转移了。当$k\neq 0$时，要考虑从$k-1$转移过来。此时考虑从$[i, j]$中遍历$l$，令$dig=s[l]$，并将从$l$左或者从$l$右开始的一部分作为从$k-1$转移过来的部分，另一部分消去。因为消去的顺序不影响结果，此处将左边一半消去。从而有： f(dig, i, j, k) = \max_{i\le l\le j, dig=s[l]}\lbrace f(0, i, l - 1, 0) + f(dig, l + 1, j, k - 1) \rbrace当$k=0$时，考虑将积累下来的数消去，就有： f(0, i, j, 0) = \max\lbrace f(dig, i, j, k) + a[k]\rbrace123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[105] = &#123;0&#125;;char s[105];int sum[105] = &#123;0&#125;;ll f[2][105][105][105] = &#123;0&#125;;int main()&#123; scanf("%d%s", &amp;n, s + 1); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + s[i] - '0'; memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i)&#123; if(s[i] == '0')&#123; f[0][i][i][1] = 0; &#125;else&#123; f[1][i][i][1] = 0; &#125; f[0][i][i][0] = f[1][i][i][0] = a[1]; &#125; for(int i = 1; i &lt;= n; ++i) for(int j = i - 1; j &gt;= 0; --j) f[0][i][j][0] = f[1][i][j][0] = 0; for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j + i &lt;= n; ++j)&#123; int lim = max(i + 1 - (sum[j + i] - sum[j - 1]), sum[j + i] - sum[j - 1]); for(int k = 1; k &lt;= lim; ++k)&#123; for(int l = j; l &lt; j + i; ++l)&#123; int sig = s[l] - '0'; ll &amp;dp = f[sig][j][j + i][k]; if(f[sig][l + 1][j + i][k - 1] &gt;= 0) dp = max(dp, f[0][j][l - 1][0] + f[sig][l + 1][j + i][k - 1]); &#125; &#125; int sig = s[j + i] - '0'; ll &amp;dp = f[sig][j][j + i][1]; dp = max(dp, f[0][j][j + i - 1][0]); for(int k = 1; k &lt;= lim; ++k)&#123; if(f[0][j][j + i][k] &gt;= 0) f[0][j][j + i][0] = max(f[0][j][j + i][k] + a[k], f[0][j][j + i][0]); if(f[1][j][j + i][k] &gt;= 0) f[0][j][j + i][0] = max(f[1][j][j + i][k] + a[k], f[0][j][j + i][0]); &#125; f[1][j][j + i][0] = f[0][j][j + i][0]; &#125; &#125; printf("%I64d\n", f[0][1][n][0]); return 0;&#125; 事实上，根据上面所述，可以将状态改设为$f(i, j, k)$，压掉$dig$一维，将$dig$锁定为$i$位置的数。这样也可以进行状态转移。转移方法和上面基本相同。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, a[105] = &#123;0&#125;;char s[105];int sum[105] = &#123;0&#125;;ll f[105][105][105] = &#123;0&#125;;int main()&#123; scanf("%d%s", &amp;n, s + 1); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + s[i] - '0'; memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i) f[i][i][1] = 0, f[i][i][0] = a[1]; for(int i = 0; i &lt;= n; ++i) for(int j = i - 1; j &gt;= 0; --j) f[i][j][0] = 0; f[n + 1][n][0] = 0; for(int i = 1; i &lt; n; ++i)&#123; for(int j = 1; j + i &lt;= n; ++j)&#123; int lim = max(i + 1 - (sum[j + i] - sum[j - 1]), sum[j + i] - sum[j - 1]); for(int k = 1; k &lt;= lim; ++k)&#123; for(int l = j; l &lt;= j + i; ++l)&#123; if(s[j] != s[l]) continue; if(f[j][l - 1][k - 1] &gt;= 0) f[j][j + i][k] = max(f[j][j + i][k], f[j][l - 1][k - 1] + f[l + 1][j + i][0]); &#125; &#125; for(int k = 1; k &lt;= lim; ++k)&#123; if(f[j][j + i][k] &gt;= 0) f[j][j + i][0] = max(f[j][j + i][0], f[j][j + i][k] + a[k]); &#125; &#125; &#125; printf("%I64d\n", f[1][n][0]); return 0;&#125; F题目大意：有$n$份贷款，每一份贷款有三个参数$a, b, k$，表示贷款当月可以获得$a$元，之后$k$个月每个月要还$b$元。一个月最多贷一次款，一种款只能贷一次。求某个月可能可以持有的金额的最大值。 建立矩阵A_{ij}=a_j-\min\lbrace i, b_j\rbrace \cdot k_j，每一列表示一种贷款带来的收益/负债。问题转化为从这$n\times n$矩阵中选出$n$个数，使得每个数所在行列均不相交，并且和最大。这是一个经典问题，用匈牙利算法可以解决。12]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>暴力</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 535 (Div. 3) 题解]]></title>
    <url>%2F2019%2F01%2F25%2Fcontest-cf1108%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 534 题解]]></title>
    <url>%2F2019%2F01%2F23%2Fcontest-cf1103and1104%2F</url>
    <content type="text"><![CDATA[我坑我自己本次比赛中有亮点的题目：Div2 D(Div1 B)。 Div2 A题目大意：给定一个数$n$，求出它的一种整数分拆a_1, \cdots, a_n，使得对于任何$i$有1\le a_i \le 9，且使得a_i中不同的数种数尽量少。 所以全输出1就行了。就一种数。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;int main()&#123; scanf("%d", &amp;n); printf("%d\n", n); for(int i = 0; i &lt; n - 1; ++i) printf("1 "); printf("1\n"); return 0;&#125; Div2 B题目大意：给定只包含小写字母的字符串$s$，两个人对串做操作，一个人可以选择串中任意一个相邻的相同字母对删去，然后另一个人操作，如此反复，最后无法操作的人输。假设两人足够聪明，判断输赢情况。 类似于括号序列，用一个栈处理消除事件，最后根据总共消去的对数的奇偶性判断即可。123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[100005];int n, cnt = 0, top = 0;char st[100005] = &#123;0&#125;;int main()&#123; scanf("%s", s); n = strlen(s); for(int i = 0; i &lt; n; ++i)&#123; if(top &amp;&amp; st[top - 1] == s[i]) top--, cnt++; else st[top++] = s[i]; &#125; printf("%s\n", cnt % 2 == 0 ? "No" : "Yes"); return 0;&#125; Div2 C(Div1 A)题目大意：（太长不说，看这里） 只要找到一种可行性方案即可，一种简单的做法是把最左边一列专门用来放竖直的牌，中间两列用来放横着的牌。另外一种是仿照样例构造模式，具体见代码。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[10005];int main()&#123; scanf("%s", s); int len = strlen(s); int modee = 0; for(int i = 0; i &lt; len; i += 2)&#123; if(len - i == 1) break; if(s[i] == '0')&#123; if(s[i + 1] == '0')&#123; if(modee == 0) printf("1 1\n3 1\n"); else printf("3 1\n1 1\n"); &#125;else&#123; if(modee == 0) printf("1 1\n1 2\n"), modee = 1; else printf("1 4\n2 2\n"), modee = 0; &#125; &#125;else&#123; if(s[i + 1] == '0')&#123; if(modee == 0) printf("1 2\n1 1\n"), modee = 1; else printf("2 2\n1 4\n"), modee = 0; &#125;else&#123; if(modee == 0) printf("1 1\n1 3\n"); else printf("3 1\n3 3\n"); &#125; &#125; &#125; if(len % 2 == 1) printf("3 3\n"); return 0;&#125; Div2 D(Div1 B)题目大意：根据提问结果猜一个数$a$，每次提问给出2个数$x, y$，返回x（或y），表示$x \mod a \ge y \mod a$（或$x \mod a &lt; y \mod a$）。至多提问60次。 很少见的一个交互题。这道题基于一个倍增的想法：首先询问$(0, 1)$，如果答案在$(0, 1]$上那么就会返回x，否则再询问$(1, 2)$，如果答案在$(1, 2]$上就返回x，否则再询问$(2, 4)$…如此反复，根据归纳法，询问到$(n, 2n)$的时候，已经能够确认$a$不在$[1, n]$上了，因此如果返回值是x就可以判断$a$落在当前区间上。依照此法找到$a$所在区间之后，按照上面的方法再对所在区间二分即可。由于$\log n \approx 30$，因此询问在60次内可以完成。1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[105];int main()&#123; for(; ; )&#123; scanf("%s", s); if(s[0] == 'e') break; int l = 0, r = 1; for(; ; )&#123; printf("? %d %d\n", l, r); fflush(stdout); scanf("%s", s); if(s[0] == 'x') break; l = r, r &lt;&lt;= 1; &#125; while(r - 1 &gt; l)&#123; int mid = (r + l) &gt;&gt; 1; printf("? %d %d\n", l, mid); fflush(stdout); scanf("%s", s); if(s[0] == 'x') r = mid; else l = mid; &#125; printf("! %d\n", r); fflush(stdout); &#125; return 0;&#125; Div2 E(Div1 C)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>数论</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 533 (Div. 2) 题解]]></title>
    <url>%2F2019%2F01%2F21%2Fcontest-cf1105%2F</url>
    <content type="text"><![CDATA[感觉这次比较简单…?本次比赛中有亮点的题目：E。 A题目链接 一个简单的贪心。对每一个棍子，设其长度为$k$，分别选取$k+1,k,k-1$作为$t$，然后求出总代价，选总代价最小的方案即可。123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[1005], ans = 2000000000, t = 0;int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; n; ++i)&#123; for(int j = max(1, a[i] - 1); j &lt;= a[i] + 1; ++j)&#123; int s = 0; for(int k = 0; k &lt; n; ++k)&#123; if(abs(a[k] - j) &lt;= 1) continue; if(a[k] &gt; j) s += a[k] - j - 1; else s += j - a[k] - 1; &#125; if(s &lt; ans) ans = s, t = j; &#125; &#125; printf("%d %d\n", t, ans); return 0;&#125; B题目链接 先用类似滑动窗口的方法找到这些子串并在相应子串的末尾处打上标记，然后DP即可。设$f(i, j)$表示到第$i$位为止，所有已选择的子串均包含字母$j$+&#39;a&#39;的情况下，不相交子串的最大数目，则： f(i, j) = max\lbrace f(i-1, j), f(i-k, j)+a(i, j)\rbrace其中$a(i, j)$表示以下标为$i$的字符为结尾的子串是否存在，存在为$1$，不存在为$0$。1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;char s[200005];int n, k, f[200005][27] = &#123;0&#125;;int cnt[27] = &#123;0&#125;;int main()&#123; scanf("%d%d%s", &amp;n, &amp;k, s); for(int i = 0; i &lt; k; ++i) cnt[s[i] - 'a']++; if(cnt[s[0] - 'a'] == k) f[k - 1][s[0] - 'a']++; for(int i = k; i &lt; n; ++i)&#123; cnt[s[i - k] - 'a']--, cnt[s[i] - 'a']++; if(cnt[s[i] - 'a'] == k) f[i][s[i] - 'a']++; &#125; int ans = 0; for(int i = 0; i &lt; 26; ++i) ans = max(ans, f[k - 1][i]); for(int i = k; i &lt; n; ++i) for(int j = 0; j &lt; 26; ++j) f[i][j] = max(f[i][j] + f[i - k][j], f[i - 1][j]), ans = max(ans, f[i][j]); printf("%d\n", ans); return 0;&#125; C题目链接 分别算出$l$和$r$之间有多少模$3$余$0, 1, 2$的数，然后按数列的每一位，根据到这一位为止的数列之和的模$3$余数DP。具体见代码。123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, l, r, c1, c2, c3;ll f[200005][4] = &#123;0&#125;, M = 1000000007;int main()&#123; scanf("%d%d%d", &amp;n, &amp;l, &amp;r); int t1, t2; t1 = (l - 2) / 3, t2 = (r - 1) / 3; c1 = t2 - t1; if(l == 1) c1++;//特判1 f[0][1] = c1; t1 = (l - 3) / 3, t2 = (r - 2) / 3; c2 = t2 - t1; if(l &lt;= 2 &amp;&amp; r &gt;= 2) c2++;//特判2 f[0][2] = c2; t1 = (l - 1) / 3, t2 = r / 3; c3 = t2 - t1, f[0][0] = c3; //printf("%d %d %d\n", c1, c2, c3); for(int i = 1; i &lt; n; ++i)&#123; f[i][0] = ((f[i - 1][1] * c2) % M + (f[i - 1][2] * c1) % M + (f[i - 1][0] * c3) % M) % M; f[i][1] = ((f[i - 1][2] * c2) % M + (f[i - 1][0] * c1) % M + (f[i - 1][1] * c3) % M) % M; f[i][2] = ((f[i - 1][0] * c2) % M + (f[i - 1][1] * c1) % M + (f[i - 1][2] * c3) % M) % M; &#125; printf("%I64d\n", f[n - 1][0]); return 0;&#125; D题目链接 一个大模拟，每一回合对每一个人做一次BFS即可。注意可能有格子被障碍围了起来，无法接触！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pp;int n, m, p, s[11], cur[11] = &#123;0&#125;;int grid[1005][1005] = &#123;0&#125;, cnt = 0;vector&lt;pp&gt; inte[11];char ss[1005];int que[2000005][3], hd = 0, ra = 0;int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;;void expand(int id)&#123; for(int &amp;i = cur[id]; i &lt; inte[id].size(); ++i) que[ra][0] = inte[id][i].first, que[ra][1] = inte[id][i].second, que[ra++][2] = 0; while(ra &gt; hd)&#123; int xx, yy, step; xx = que[hd][0], yy = que[hd][1], step = que[hd++][2]; if(step == s[id]) continue; for(int i = 0; i &lt; 4; ++i)&#123; int cx = xx + dx[i], cy = yy + dy[i]; if(cx &lt; 0 || cx &gt;= n || cy &lt; 0 || cy &gt;= m) continue; if(grid[cx][cy] == 0) grid[cx][cy] = id + 1, cnt++, que[ra][0] = cx, que[ra][1] = cy, que[ra++][2] = step + 1, inte[id].push_back(make_pair(cx, cy)); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for(int i = 0; i &lt; p; ++i) scanf("%d", &amp;s[i]), s[i] = min(s[i], n + m); for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", ss); for(int j = 0; j &lt; m; ++j) if(isdigit(ss[j]))&#123; int id = ss[j] - '0' - 1; inte[id].push_back(make_pair(i, j)); grid[i][j] = id + 1; cnt++; &#125;else if(ss[j] == '#') grid[i][j] = -1, cnt++; &#125; while(cnt != n * m)&#123; int flag = 0; for(int i = 0; i &lt; p; ++i)&#123; int ori = inte[i].size(); expand(i); if(ori &lt; inte[i].size()) flag = 1; &#125; if(!flag) break; &#125; for(int i = 0; i &lt; p - 1; ++i) printf("%d ", inte[i].size()); printf("%d\n", inte[p - 1].size()); return 0;&#125; E题目链接 可以发现多个1事件连在一起时效果和只有一个1事件是一样的，所以在读入时可以做处理。考虑每一个1事件后跟着的一连串2事件。在这一连串2事件中，如果有两个不同的人，那么就出现“有我没他”的局面，选了一个人另一个人就不能选。因此可以考虑向图论问题转化，把人视作点，如果出现了上述局面就在两个人之间连一条边，然后问题变为求该图的最大独立集。用求补图最大团的方法解决。顺带一提，这题时限很紧，要用各种压位。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, m, tot = 0, lis[45], cnt = 0, ans = 0;map&lt;string, int&gt; mp;ll conn[45] = &#123;0&#125;;int count1(ll x)&#123; int res = 0; while(x)&#123; if(x &amp; 1) res++; x &gt;&gt;= 1; &#125; return res;&#125;void bron_kerbosch(ll R, ll P, ll X)&#123; if(!P &amp;&amp; !X)&#123; ans = max(ans, count1(R)); return ; &#125; ll pv = P | X, P_ = P; int id = 0; while(((1ll &lt;&lt; id) &amp; pv) == 0) id++; P_ -= (P_ &amp; conn[id]); for(ll i = 1, j = 0; i &lt;= P_; i &lt;&lt;= 1, ++j)&#123; if(!(i &amp; P)) continue; bron_kerbosch(R | i, P &amp; conn[j], X &amp; conn[j]); P ^= i, X |= i; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); char name[45]; int d; scanf("%d", &amp;d); for(int i = 1; i &lt; n; )&#123; int j = i, d; for(; j &lt; n; )&#123; scanf("%d", &amp;d); if(d == 1) j++; else break; &#125; if(j == n) break; cnt = 0; ll in = 0; for(; j &lt; n; )&#123; scanf("%s", name); string st(name); if(!mp.count(st)) mp[st] = ++tot; int id = mp[st] - 1; if(!((1ll &lt;&lt; id) &amp; in))&#123; in += (1ll &lt;&lt; id), lis[cnt] = id; for(int k = 0; k &lt; cnt; ++k) conn[id] |= (1ll &lt;&lt; lis[k]), conn[lis[k]] |= (1ll &lt;&lt; id); cnt++; &#125; if(j &lt; n - 1) scanf("%d", &amp;d); if(d == 2) j++; else break; &#125; i = j + 2; &#125; ll mask = (1ll &lt;&lt; m) - 1ll; for(int i = 0; i &lt; m; ++i) conn[i] ^= mask, conn[i] ^= (1ll &lt;&lt; i); bron_kerbosch(0, (1ll &lt;&lt; m) - 1, 0); printf("%d\n", ans); return 0;&#125; 小结时隔很长时间的一次CF，因为题目比较容易没有看起来太菜，但是E还是没有写出来。。。知识漏洞补全刻不容缓。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数论</tag>
        <tag>贪心</tag>
        <tag>线性DP</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（七） 进阶语法]]></title>
    <url>%2F2019%2F01%2F01%2Fpython-7%2F</url>
    <content type="text"><![CDATA[第七篇学习笔记，内容包含Python中一些进阶语法，如条件控制，循环控制等。 条件控制用if...elif...else语句进行条件控制。每一个条件之后都需要使用冒号，每一个代码块都要使用缩进来标志。如：123456if a == 1: b = 1elif a == 2: b = 2else a == 3: b = 3 python中没有switch...case型的语句。条件控制可以缩写在一行之中，形成所谓的“三目运算符”。其表达形式为val1 if exp else val2，即如果exp为True则运算结果为val1，exp为False则运算结果为val2。如：1234&gt;&gt;&gt; b = 9&gt;&gt;&gt; a = 1 if b &gt; 5 else 2&gt;&gt;&gt; a1 循环语句用while...或者for...来实现循环。 while语句在使用while语句时采用以下的格式：1234while &lt;judgement&gt;: &lt;statements&gt;else: &lt;statements&gt; 后面的else是在条件为False的时候执行的，相当于一个收尾语句，收完这个尾之后退出整个循环体。如：123456789&gt;&gt;&gt; a = 1&gt;&gt;&gt; while a == 1:... print("a is 1")... a = a + 1... else:... print("a is not 1")...a is 1a is not 1 要执行一个死循环的时候可以这么写：12while True: ... 使用break语句来终止一个循环。若使用break中止，则else部分不会执行。如果循环体只有一条语句，那么可以将while和这条语句写在一行。不过这一般没有什么用处。python中没有do...while循环。 for语句for结构的一般形式如下：1234for &lt;variable&gt; in &lt;seq&gt;: &lt;statements&gt;else: &lt;statements&gt; 当for循环到末尾时就执行else处的语句并退出整个循环体。如：1234567891011list1 = [1, 2, 3]for i in list1: passelse: print(i)# 输出为3for i in range(10): passelse: print(i)# 输出为9 使用break语句来终止一个循环。若使用break中止，则else部分不会执行。有一些函数经常会和for循环搭配使用。如：range()函数。该函数产生一系列等距的数。其语法为range(start, stop[, step])，三个参数均为整数，表示从start开始按step的步长到stop为止。如：123for i in range(0, 10, 4): print(i)# 输出为0 4 8 enumerate函数。该函数可以生成一系列的index-item对，即索引-元素对（为元组）。该函数一般需要传入2个参数，第一个参数为可迭代对象；第二个参数是下标的初始值，缺省值为0。一般的使用方法如下：12for index, item in enumerate(thelist, start): ... 注意，这个初始值并不是指从哪里开始，而是计数时从哪一个值开始计数。比如初始值为1，那么就按1, 2, 3, …的方式数数；初始值是0，就按照0, 1, 2, …的方式数数。 断言使用assert语句进行断言，如果断言失败就抛出AssertionError的异常。 try结构此部分在异常部分会进行介绍。 del语句可以使用del语句删除对象引用（即解除变量名称和具体数据之间的绑定），也可以移除数据结构中具体的某部分（如列表中的值，字典的键值对等）。它不直接删除值，因为值会通过垃圾回收的方式进行移除。 del语句的语法是del var1[,var2[,var3[....,varN]]]]，这意味着可以一次性删除多个目标。示例如下：1234567891011121314&gt;&gt;&gt; v = 1&gt;&gt;&gt; v1&gt;&gt;&gt; del v # 删去某个对象引用&gt;&gt;&gt; vTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'v' is not defined&gt;&gt;&gt; s = [1, 2, 3, 4, 5]&gt;&gt;&gt; del s[3: 5] # 删除切片的方式删除一整段&gt;&gt;&gt; s[1, 2, 3]&gt;&gt;&gt; u, v, w = 1, 2, 3&gt;&gt;&gt; del u, v, s[0: 1] # 删除多个目标]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（六） 数据结构]]></title>
    <url>%2F2019%2F01%2F01%2Fpython-6%2F</url>
    <content type="text"><![CDATA[第六篇学习笔记，内容包含Python中常用的数据结构：元组（tuple），列表（list），字典（dictionary），集合（set）四种。 元组元组是一种非常简单的结构，它类似于数学上的序对，属于不可变类型。它的优点在于运行效率比列表要高。 定义定义一个元组只需要在圆括号中添加元素，并使用逗号隔开即可（圆括号可以省略）。如：123456&gt;&gt;&gt; a = (1, 2, 3)&gt;&gt;&gt; type(a)&lt;class 'tuple'&gt;&gt;&gt;&gt; tp = 12, 3, 4&gt;&gt;&gt; tp(12, 3, 4) 空元组即为()。元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。如：123456789&gt;&gt;&gt; b = (50)&gt;&gt;&gt; type(b)&lt;class 'int'&gt;&gt;&gt;&gt; b = (50, )&gt;&gt;&gt; type(b)&lt;class 'tuple'&gt;&gt;&gt;&gt; tp = 12,&gt;&gt;&gt; tp(12,) 生成一个元组使用tuple()函数将一个列表或者一个字符串（一个可迭代结构也可以）转换成为一个元组。当参数是列表的时候，元组中包含的就是列表中的元素。参数是字符串的话字符串的每一位就会被拆开，放到列表中的每一位中去。 访问元组中的元素访问方式和字符串基本相同，可以使用下标也可以使用切片（切片得到的是元组）。如：12345&gt;&gt;&gt; tp1 = (1, 2, 3, 4)&gt;&gt;&gt; tp1[0]1&gt;&gt;&gt; tp1[2: 4](3, 4) 元组的运算元组的+，*运算方法和字符串相似，前者用于前后连接，后者用于重复。在此不赘述。使用in运算符可以获取一个元素是否在元组中。 元组的修改元组不允许修改，因此只能通过运算生成新元组或者使用del将整个元组删除。试图修改元组的元素会报错，如：12345678&gt;&gt;&gt; tp1[0] = 1Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment&gt;&gt;&gt; del tp1[0]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object doesn't support item deletion 元组在赋值中的应用事实上，同时赋值的基础就是元组。可以将同时赋值时右边的式子看作是一个元组，这样就可以理解为左边的被赋值对象和右边元组中的元素一一对应。提供以下例子用于理解：1234&gt;&gt;&gt; tp = 1, 2, 3&gt;&gt;&gt; a, b, c = tp&gt;&gt;&gt; print(a, b, c)1 2 3 但是右边不能有多个元组，如：123456&gt;&gt;&gt; tp = 1, 2, 3&gt;&gt;&gt; tp1 = 4, 5, 6&gt;&gt;&gt; a, b, c, d, e, f = tp, tp1Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: not enough values to unpack (expected 6, got 2) 这种方法称为packing（把元素打包）和unpacking（把元素解包）。 列表列表是一种类似于其他编程语言中数组的存在，但它的功能比数组更为强大。它的数据项不需要具有相同的数据类型。python中列表是链式储存的，这和数组有很大的不同。 定义列表的形式是用中括号括起来一些用逗号分隔开来的数据。空列表仅仅包含一对中括号。如：12list1 = [1, 2, 3]list_empty = [] 生成一个列表可以使用list()函数将一个元组或者一个字符串（一个可迭代结构也可以）转换成为一个列表。当参数是元组的时候，列表中包含的就是元组中的元素。参数是字符串的话字符串的每一位就会被拆开，放到列表中的每一位中去。生成一个列表还可以使用列表推导式（在后续笔记中提及）。 列表的嵌套列表可以层层嵌套，从而实现类似于多维数组（或者矩阵）的功能。如：1a = [[1, 2], [3, 4], [5, 6]] # (3*2)矩阵 访问列表中的元素访问方式和字符串基本相同，可以使用下标也可以使用切片（切片得到的是列表）。如：12345&gt;&gt;&gt; list1 = [1, 2, 3, 4]&gt;&gt;&gt; list1[0]1&gt;&gt;&gt; list1[2: 4][3, 4] 添加列表元素可以用列表的append(val)方法在列表的末尾添加一个元素val。也可以用列表的insert(index, val)方法在下标为index处添加一个元素val，然后将原来index处的元素以及其后面的元素都向后移动一位。使用extend(list)方法可以在列表的末尾一次性按顺序添加上一个另一个列表的全部元素。 删除列表元素使用del语句可以删除列表中若干个元素，如：1234&gt;&gt;&gt; list1 = [1, 2, 3, ]&gt;&gt;&gt; del list1[0], list1[1]&gt;&gt;&gt; list1[2] 可以使用列表的pop(index = -1)方法来删除列表的下标为index的元素，并且将这一个元素返回。index参数缺省时为-1，即为最后一个元素的下标。如：12345&gt;&gt;&gt; list1 = [1, 2, 3, ]&gt;&gt;&gt; print(list1.pop())3&gt;&gt;&gt; list1[1, 2] 也可以用remove(val)方法删除从前到后，列表中第一个值为val的元素。如果没有这样的元素就会报错。如：12345678&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; list1.remove(3)&gt;&gt;&gt; list1[1, 2, 4, 3]&gt;&gt;&gt; list1.remove(5)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list1.remove(x): x not in list1 列表的运算列表的+，*运算方法和字符串相似，前者用于前后连接，后者用于重复。在此不赘述。使用in运算符可以获取一个元素是否在列表中。 组织列表对列表排序使用sort(reverse = False)方法对列表进行永久性的排序，这个方法会改变列表中元素的顺序。其中缺少reverse参数时默认为升序排序，加上reverse = True时会降序排序。如：1234567&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; list1.sort()&gt;&gt;&gt; list1[1, 2, 3, 3, 4]&gt;&gt;&gt; list1.sort(reverse = True)&gt;&gt;&gt; list1[4, 3, 3, 2, 1] 使用sorted(list, reverse = False)函数可以将list进行临时的排序，这不会改变list内部数据的排列顺序。如：1234567&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; sorted(list1)[1, 2, 3, 3, 4]&gt;&gt;&gt; sorted(list1, reverse = True)[4, 3, 3, 2, 1]&gt;&gt;&gt; list1[1, 2, 3, 4, 3] 翻转列表使用reverse()方法永久性翻转列表。如：1234&gt;&gt;&gt; list1 = [1, 2, 3, 4, 3, ]&gt;&gt;&gt; list1.reverse()&gt;&gt;&gt; list1[3, 4, 3, 2, 1] 列表的其他实用方法查找使用count(val)方法可以查找列表中值为val的元素个数。不存在这样的元素的时候会简单地返回0。如：123&gt;&gt;&gt; list1 = [3, 4, 3, 2, 1]&gt;&gt;&gt; list1.count(0)0 使用index(val)方法可以查找从前到后，列表中第一个值为val的元素，并返回它的下标。如果没有这样的元素就会报错。如：1234567&gt;&gt;&gt; list1 = [3, 4, 3, 2, 1]&gt;&gt;&gt; list1.index(0)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 0 is not in list1&gt;&gt;&gt; list1.index(3)0 清除用clear()方法清除列表中的所有元素。 复制用切片操作或者copy()方法可以获得一份当前列表的副本。 字典字典保存的是对象间的映射关系，在python中用大括号表示。它是另一种可变容器模型，且可存储任意类型对象。字典和列表、元组不同，没有+和*运算符。字典在python3.6版本之后默认保持插入时的顺序。 创建一个字典字典中键-&gt;值的映射是通过冒号来表示的，按如下方式即可创建一个字典：1dict1 = &#123;1: 2, 2: 3&#125; 其中键必须是唯一而不可变的。但值没有这样的限制。使用dict()函数也可以创建一个字典。该函数的语法比较复杂，以下举一些例子： 不传入参数，返回一个空字典。如dict1 = dict()，得到{}。 传入的参数是一个字典，则返回该字典。如dict1 = dict({&#39;a&#39;: 1, &#39;b&#39;: 2})，得到{&#39;a&#39;: 1, &#39;b&#39;: 2}。 传入的参数是由二元组构成的列表，则返回由这些二元组构成的字典。若键发生重复则以后面出现的键值对为准。如dict1 = dict([(12, 25), (13, 14), (12, 28)])，得到{12: 28, 13: 14}。 按关键字形式传入参数，则返回由“关键字-参数”键值对构成的字典。如dict1 = dict(a = 1, b = 2)，得到{&#39;a&#39;: 1, &#39;b&#39;: 2}。 传入的参数是zip类型的对象，则和3的情况类似。如dict1 = dict(zip([1, 2, 3, 2], [4, 5, 6, 7]))，得到{1: 4, 2: 7, 3: 6}。 传入的参数是dict.items类型，则返回由该参数包含的键值对构成的字典（相当于将此字典还原）。如dict1 = dict({1: 2}.items())，得到{1: 2}。 也可以使用字典推导式创建字典（在后续笔记中提及）。也可以使用一些字典的方法实现字典的创建，具体见下。 访问一个字典将键作为索引可以得到键对应的值。如果没有这样的键就会报错。可以使用get()方法防止报错。该方法语法是dict.get(key, default = None)，可以获取key对应的值，如果这个值不存在就返回default。使用key in dict可以判断一个键是否在字典中，但不能判断值是否在字典中。使用for key in dict也是按照键对字典进行遍历。 修改一个字典修改键对应的值将键作为索引并赋值可以改变键对应的值。如果没有这样的键就会在字典中增加一个这样的键-值对。如：123dict1 = &#123;&#125; # 空字典dict1['a'] = 1 # 创建一个新键-值对dict1['a'] = 2 # 修改键对应的值 删除键-值对使用del可以删除键-值对。如：12dict1 = &#123;1: 2, 2: 3&#125;del dict1[1] # 删除这个键对应的键-值对 如果要删除的键不存在会报出KeyError异常。可以使用pop()方法防止报错。该方法语法是pop(key[, default])，key为要删除的键，如果key存在就返回被删除的值，不存在就返回default（此时如果省略default会报出KeyError异常）。使用popitem()方法可以删除字典中的某一个键值对。至于是哪一个就只有python知道。如果此时字典为空，则报错。 字典相关方法求字典的大小使用len()函数可以求出字典中键的数目。 求字典的键/值/键-值对方法keys()，values()，items()分别返回dict_keys，dict_values，dict_items类型的迭代器，它们分别含有字典的所有键，值和键-值对。可以使用list()方法将这些迭代器转换成为列表使用。可以使用for语句遍历这三种结构，如：1234for k in dict1.values(): passfor k, v in dict1.items(): pass 打印字典将字典作为str()函数的参数即可按照特定格式将字典输出。 清空字典使用clear()方法清空字典。 复制字典用copy()方法可以产生一个字典的副本。 创建字典使用fromkeys()方法可以创建一个新的字典。它的语法是dict.fromkeys(seq[, value])（fromkeys()是类方法），其中seq是键的列表（该列表中可以包含相同元素），value为新字典中所有键对应的初始值，缺省时为None。该方法返回一个字典。值得一提的是，在该方法中，初始值被“复制”了。而做实验可以发现该复制是浅复制。如下程序：1234&gt;&gt;&gt; dict1 = dict.fromkeys([1, 2], [2, 3])&gt;&gt;&gt; dict1[1][0] = 0&gt;&gt;&gt; dict1&#123;1: [0, 3], 2: [0, 3]&#125; # 列表全部被改变了!!! 合并字典字典合并有多种方法。以下均以dict1和dict2合并为dict3来举例。方法一是使dict3 = dict(list(dict1.items()) + list(dict2.items()))。由此可看出，当dict1和dict2中有相同的键时，后者会覆盖前者。如：12345&gt;&gt;&gt; dict1 = &#123;1: 2, 2: 4&#125;&gt;&gt;&gt; dict2 = &#123;1: 3&#125;&gt;&gt;&gt; dict3 = dict(list(dict1.items()) + list(dict2.items()))&gt;&gt;&gt; dict3&#123;1: 3, 2: 4&#125; 方法二是使dict3 = dict(dict1, **dict2)。此时dict2中的键值对会覆盖dict1的。该方法容易扩展到多个字典合并到一个字典的情况，即dictn = dict(dict1, **dict2, **dict3, ...)。对于多合并的情况，要注意后面加了两个星号的字典两两不能有重复的键，且键必须为字符串。如：12345&gt;&gt;&gt; dict1 = &#123;'a': 1, 'b': 2&#125;&gt;&gt;&gt; dict2 = &#123;'c': 3, 'd': 4&#125;&gt;&gt;&gt; dict3 = dict(dict1, **dict2)&gt;&gt;&gt; dict3&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; 方法三是遍历字典并把键值对放入新字典中。该方法比较直观，不赘述。方法四是使用字典的update()方法。该方法将一个字典的键值对更新到调用方法的字典中，如有重复则覆盖。如：12345&gt;&gt;&gt; dict1 = &#123;1: 2, 3: 4&#125;&gt;&gt;&gt; dict2 = &#123;2: 5, 1: 6&#125;&gt;&gt;&gt; dict1.update(dict2)&gt;&gt;&gt; dict1&#123;1: 6, 3: 4, 2: 5&#125; 集合集合在数学上是一个包含无序的不重复元素的结构。在Python中也是如此。 定义集合的形式是用大括号括起来一些用逗号分隔开来的数据。如：123&gt;&gt;&gt; a = set((1, 2, 3, 4, 5, 5, 6))&gt;&gt;&gt; a&#123;1, 2, 3, 4, 5, 6&#125; 需要注意的是，空集合并不是一对大括号，而是这样的形式：123&gt;&gt;&gt; a = set()&gt;&gt;&gt; aset() 生成一个集合可以使用set()函数将一个可迭代结构/序列转换成为一个集合。参数是字符串的话字符串的每一位就会被拆开，去重后放入集合。生成一个集合还可以使用集合推导式（在后续笔记中提及）。 添加集合元素使用add()方法向集合内添加一个元素。如果该元素已经存在则不进行操作。如：123456&gt;&gt;&gt; a = set((1, 2, 3, 4))&gt;&gt;&gt; a&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; a.add(1)&gt;&gt;&gt; a&#123;1, 2, 3, 4&#125; 也可以使用update()方法一次性添加多个元素，只需要传入一个可迭代结构即可。如：1234&gt;&gt;&gt; a = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; a.update([5, 6, 7])&gt;&gt;&gt; a&#123;1, 2, 3, 4, 5, 6, 7&#125; 删除集合元素使用discard()或remove()方法移除某个指定的元素。如果该元素不存在，前者不会报错，后者会。如：123456789&gt;&gt;&gt; C = &#123;1, 2&#125;&gt;&gt;&gt; C.discard(1)&gt;&gt;&gt; C&#123;2&#125;&gt;&gt;&gt; C.discard(1)&gt;&gt;&gt; C.remove(1)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 1 集合相关操作基本运算设A, B为两个set。则A &amp; B，A | B，A ^ B，A - B分别返回A和B的交，并，对称差和差，分别对应的方法为intersection()，union()，symmetric_difference()和difference()。前两个方法可以传入多个集合作为参数，表示多个集合参与交/并运算。如：1234567891011121314151617&gt;&gt;&gt; A = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; B = &#123;2, 3, 4, 5&#125;&gt;&gt;&gt; C = &#123;3, 4, 5, 6&#125;&gt;&gt;&gt; A &amp; B&#123;2, 3, 4&#125;&gt;&gt;&gt; A | B&#123;1, 2, 3, 4, 5&#125;&gt;&gt;&gt; A ^ B&#123;1, 5&#125;&gt;&gt;&gt; A - B&#123;1&#125;&gt;&gt;&gt; A &amp; B &amp; C&#123;3, 4&#125;&gt;&gt;&gt; A.intersection(B, C)&#123;3, 4&#125;&gt;&gt;&gt; A.union(B, C)&#123;1, 2, 3, 4, 5, 6&#125; 如果在交/对称差/差运算对应的方法名后加入_update，则表示进行运算后把结果赋给调用该方法的集合。如：123456789&gt;&gt;&gt; A = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; B = &#123;2, 3, 4, 5&#125;&gt;&gt;&gt; C = &#123;3, 4, 5, 6&#125;&gt;&gt;&gt; A.intersection_update(B, C)&gt;&gt;&gt; A&#123;3, 4&#125;&gt;&gt;&gt; B.symmetric_difference_update(C)&gt;&gt;&gt; B&#123;2, 6&#125; 从属关系用in可以检查一个元素是否在一个集合中。 包含关系使用issubset()方法判断一个集合是否是另一个的子集，使用issuperset()方法判断一个集合是否是另一个的超集。如：123456&gt;&gt;&gt; A = &#123;1, 2, 3, 4&#125;&gt;&gt;&gt; B = &#123;1, 2, 3&#125;&gt;&gt;&gt; B.issubset(A)True&gt;&gt;&gt; A.issuperset(B)True 用&gt;=和&lt;=也可以判断包含关系。用&gt;和&lt;可以判断真包含关系。 相交关系使用isdisjoint()方法判断两个集合是否不相交，返回值为布尔类型。如：1234567&gt;&gt;&gt; A = set()&gt;&gt;&gt; B = &#123;1&#125;&gt;&gt;&gt; C = &#123;1, 2&#125;&gt;&gt;&gt; C.isdisjoint(B)False&gt;&gt;&gt; C.isdisjoint(A)True 复制集合使用copy()方法产生一个集合的副本。 清空集合使用clear()方法清空集合中所有的元素。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（五） 字符串]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-5%2F</url>
    <content type="text"><![CDATA[第五篇学习笔记，内容和Python的字符串类型相关。 概述python中的字符串是一种包含了一串字符的基本数据结构。字符串可以使用一对单引号或者双引号括起来。当字符串内含有单引号或者双引号时，要用另外一种引号。而当单引号和双引号全都有的时候，需要使用三单引号或者三双引号。其中使用三单引号或者三双引号可以创建字面引用，即按照原样处理三引号里面的所有字符。需要注意的是，python中没有字符的概念，单个字符也是用字符串来实现的。 访问字符串访问字符串中的某一个字符（当然，得到的不是字符而是字符串）可以使用一般访问数组的形式，如:123456&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; a[0]'a'&gt;&gt;&gt; a[-1]'c'&gt;&gt;&gt; python中支持负数下标，下标-1表示最后一个字符，以此类推。访问字符串中的一段字符则需要使用切片（在后续笔记中会提到）。 打印字符串使用print函数可以打印字符串。在字符串前面加上一个r可以输出未转义的转义字符（即输出原始字符串），如:12&gt;&gt;&gt; print(r"a \t b \n c")a \t b \n c 要打印一些特殊的字符需要使用一些转义字符。常用的转义字符如下： 转义字符 作用（真实值） \（在行尾时） 续行符 \\ 反斜杠符\ \&#39; 单引号&#39; \&quot; 双引号&quot; \0, \000 空字符 \a 响铃 \b 退格 \f 换页 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符 \ooo 某个字符，其ascii码在八进制下为ooo \xhh 某个字符，其ascii码在十六进制下为hh 作为特殊情况，\other输出\other，其中other是某个没有转义意义的字符，如p。 拆分字符串可以对字符串类型使用list()函数，从而将字符串中的每一个字符都拆出来，并且放置在一个序列之中。如：123&gt;&gt;&gt; str1 = "abcabc"&gt;&gt;&gt; list(str1)['a', 'b', 'c', 'a', 'b', 'c'] 转换成字符串可以使用str()或者repr()函数将某一个对象转换成为一个字符串。其中str()函数将对象转换成为一个用户容易读的形式，而repr()将对象转换成为python解释器容易理解的形式。需要根据用途使用这两个函数。一般情况下，这两个函数的返回值并没有区别。但在某一些情况下会有一些不同。下举一例：12345&gt;&gt;&gt; dict = &#123;'runoob': 'runoob.com', 'google': 'google.com'&#125;&gt;&gt;&gt; str(dict)"&#123;'runoob': 'runoob.com', 'google': 'google.com'&#125;"&gt;&gt;&gt; repr(dict)"&#123;'google': 'google.com', 'runoob': 'runoob.com'&#125;" 字符串的运算使用+可以将字符串连接起来。如：1234&gt;&gt;&gt; name = 'Abc'&gt;&gt;&gt; age = '123'&gt;&gt;&gt; name + age'Abc123' 使用*可以重复输出字符串，如：1234567891011&gt;&gt;&gt; age = '123'&gt;&gt;&gt; age * 2'123123'&gt;&gt;&gt; age * 0.5Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: can't multiply sequence by non-int of type 'float'&gt;&gt;&gt; age * -3''&gt;&gt;&gt; age * 0'' 可知，当乘的数是负数或者0时，字符串为空。并且不能乘小数。字符串之间的比较运算基于字符串的字典序。这里的字典序是在ASCII码（或unicode码）语境下。如：123456&gt;&gt;&gt; '11' &gt; '2'False&gt;&gt;&gt; 'abc' &gt; '123'True&gt;&gt;&gt; '啊' &gt; 'zzzzzzzzzzzzzzzzzzzzz'True 字符串的格式化python中的字符串可以做到像c/c++中一样的格式化。格式化的方式一般为2种。 怀旧方式：标识符形式字符串支持标识符方式的填充，如：1234567&gt;&gt;&gt; msg = "I am %s." %("huyutou")&gt;&gt;&gt; msg'I am huyutou.'&gt;&gt;&gt; a, b = 10, 1.0&gt;&gt;&gt; msg = "get %d and %f." %(a, b)&gt;&gt;&gt; msg'get 10 and 1.000000.' 标识符的使用方式几乎和c语言相同，下面列出一些主要的标识符： 标识符 对应替换目标 %s 字符串 (采用str()的显示) %r 字符串 (采用repr()的显示) %c 单个字符 %b 二进制整数 %d 十进制整数 %i 十进制整数 %o 八进制整数 %x 十六进制整数 %e 指数 (基底写为e) %E 指数 (基底写为E) %f 浮点数 %F 浮点数，与上相同 %g 指数(e)或浮点数 (根据显示长度) %G 指数(E)或浮点数 (根据显示长度) %% 字符% 对于标识符还可以追加一些额外的参数，如：%[(name)][flags][width][.precision]type其中(name)表示当使用字典来匹配模板时，要匹配的键的名称。如：123&gt;&gt;&gt; dict = &#123;"zqy":"nb", "is":"is not"&#125;&gt;&gt;&gt; print("zqy %(is)s %(zqy)s." % (dict))zqy is not nb. flag可以为+,-,`,0，分别表示加上一个正号（字符串是向右对齐），加上一个负号（字符串是向左对齐），前导部分用空格填充，前导部分用0填充。width表示输出的宽度，当实际宽度小于width时根据数据类型采用不同的字符填充前导部分。（字符串是不会填充前导0的）。.precision用于控制小数点后的位数。type`即为表中列出的一系列标识符。 新方式：format函数使用字符串对象的format函数可以容易地实现字符串中对应内容的填充。format函数可以接受不限个参数，并且填充的时候可以不按照顺序填充。如：12&gt;&gt;&gt; "&#123;1&#125; &#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置'world hello world' 可以看出，只要在对应的大括号里面写上format内参数的下标，就可以输出对应的参数。也可以传入一个元组，一次性按顺序填入多个值。如：12345&gt;&gt;&gt; tp = (1, 2, 3, 4)&gt;&gt;&gt; print("&#123;&#125; &#123;&#125; &#123;&#125;".format(*tp))1 2 3&gt;&gt;&gt; print("&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;".format(*tp))1 2 3 4 还可以在format函数里面对参数进行命名，并且在大括号里面使用参数的名称，这样就可以像使用字典一样根据参数的名称填入对应的参数。如：12&gt;&gt;&gt; print("&#123;name&#125; &#123;P&#125;".format(name = 2, P = 1))2 1 使用字典做类似的事情也是可以的，但是要在字典之前加入两个*号。如：123&gt;&gt;&gt; dict = &#123;"zqy":"nb", "is":"is not"&#125;&gt;&gt;&gt; print("zqy &#123;is&#125; &#123;zqy&#125;.".format(**dict))zqy is not nb. 或者使用如下的方法：12dict1 = &#123;'name': 1, 'age': 2&#125;print("&#123;0[name]&#125; &#123;0[age]&#125;".format(dict1)) #输出为1 2 甚至还可以做到用列表来索引参数。如：1234&gt;&gt;&gt; list = ["nb", "is not"]&gt;&gt;&gt; list2 = ["Why"]&gt;&gt;&gt; &gt;&gt;&gt; print("zqy &#123;0[1]&#125; &#123;0[0]&#125;. &#123;1[0]&#125;?".format(list, list2)) zqy is not nb. Why? 中括号里面的就是列表中要填充元素的下标了。还可以向str.format()中传入对象，如：12345class A: passa = A()a.b = 1print('&#123;0.b&#125;'.format(a)) # 输出1 可以看出，一般来说可以使用传入参数的索引来指向某个参数，如上述在列表的中括号前面加上0和1表示是第几个列表。以上这些可以任意的组合使用。如：12345678dict1 = &#123;'name': 1, 'age': 2&#125;list1 = [3, 4, 5]class A: passa = A()a.pp = 6print("&#123;0&#125; &#123;1[2]&#125; &#123;2[name]&#125; &#123;3.pp&#125; &#123;other&#125;".format(8, list1, dict1, a, other = 10))# 输出为8 5 1 6 10 除了填充之外，还有格式化的多种方式，以下以公式形式列出：（冒号放在与填充相关的之后，如{0:.2f}）:[[fill]align][sign][#][0][width][,][.precision][type]fill为空白处填充的字符，align为对齐方式（一般配合width使用，width意义见下），用一个字符表示：左对齐为&lt;，右对齐（默认情况）为&gt;，居中为^，=为右对齐，并将符号放置在填充字符的左侧，且只对数字类型有效，即符号+填充符+数字。以下举一些例子：12345678&gt;&gt;&gt; '&#123;:&gt;10&#125;'.format(4)' 4'&gt;&gt;&gt; '&#123;:q&gt;10&#125;'.format(4)'qqqqqqqqq4'&gt;&gt;&gt; '&#123;:q^10&#125;'.format(4)'qqqq4qqqqq'&gt;&gt;&gt; '&#123;:q=10&#125;'.format(-4)'-qqqqqqqq4' sign表示是否显示符号，用一个字符表示：为+时正负数都显示符号，为-时仅负数显示符号，为空格时正数加空格，负数加负号。如：12345678&gt;&gt;&gt; '&#123;:&lt; 10&#125;'.format(4)' 4 '&gt;&gt;&gt; '&#123;:&lt;+10&#125;'.format(4)'+4 '&gt;&gt;&gt; '&#123;:&gt;-10&#125;'.format(4)' 4'&gt;&gt;&gt; '&#123;:=-10&#125;'.format(-4)'- 4' #为一个开关，如果该位置有#号则对于某些特殊的数，会显示某种特殊形式，如二/八/十六进制会显示0b/0o/0x的前缀。如：1234&gt;&gt;&gt; '&#123;:#b&#125;'.format(0b0101001)'0b101001'&gt;&gt;&gt; '&#123;:#x&#125;'.format(0x0122FFFF01001)'0x122ffff01001' 0为一个开关，如果该位置有0对于长度不足width的数会在前面补足前导0。如：12&gt;&gt;&gt; '&#123;:09&#125;'.format(1223)'000001223' width表示格式化位所占用的宽度，当总长度不足宽度的时候采用各种填充方法使总长度达到宽度，总长度大于宽度时按原样输出。如：1234&gt;&gt;&gt; '&#123;:9&#125;'.format(1223)' 1223'&gt;&gt;&gt; '&#123;:9&#125;'.format(121111111111111111111123)'121111111111111111111123' ,为一个开关，如果该位置有,对于数字会增加分割符。如：12&gt;&gt;&gt; '&#123;:,&#125;'.format(1000000000)'1,000,000,000' .precision和type的意义和旧版相似，在此不赘述。一个特殊情况是type为%时显示百分比（默认为小数点后6位），如：12&gt;&gt;&gt; '&#123;:%&#125;'.format(1000000000)'100000000000.000000%' 需要额外注意的是，使用了format()函数，要在字符串中输出大括号需要用转义字符，即&#123;&#123;（输出&#123;）和&#125;&#125;（输出&#125;）。 与单个字符有关的函数ord()和chr()是两个和字符使用有关的函数。前者可以返回一个字符的ASCII码（或unicode码），后者可以返回一个ASCII码（或unicode码）对应的字符。如：12345678&gt;&gt;&gt; ord("a")97&gt;&gt;&gt; chr(95)'_'&gt;&gt;&gt; ord('上')19978&gt;&gt;&gt; chr(19978)'上' ord()只能接受一个字符，否则报错。chr()同理。 字符串的大小写的修改title()输入为123name = 'abc'name = 'aBc'name = 'ABC' 对于任意一种，输出name.title()都是1'Abc' 并且有：123456789&gt;&gt;&gt; name = 'abc123'&gt;&gt;&gt; name.title()'Abc123'&gt;&gt;&gt; name = '123abc'&gt;&gt;&gt; name.title()'123Abc'&gt;&gt;&gt; name = 'aBc123abC'&gt;&gt;&gt; name.title()'Abc123Abc' 说明该函数作用是将一段英文的开头字母变为大写，其余均变为小写。对每一段英文字母（即每一个单词）都进行这样的变换。当分隔符是其他符号，如下划线的时候亦如此。 capitalize()capitalize的使用可以使字符串的第一个英文字符变为大写，而对其他的英文字符不产生影响。如：123&gt;&gt;&gt; a = "it is good."&gt;&gt;&gt; a.capitalize()'It is good.' lower(),upper()有如下输入输出：1234567&gt;&gt;&gt; name = 'aBcD'&gt;&gt;&gt; name.upper()'ABCD'&gt;&gt;&gt; name.lower()'abcd'&gt;&gt;&gt; name'aBcD' 说明这两个函数和c++的tolower(),toupper()意义相似，都可以将字母格式化为大/小写。 swapcase()使用swapcase()交换整个字符串中大小写的格式。如：123&gt;&gt;&gt; a = 'aBcDeFg'&gt;&gt;&gt; a.swapcase()'AbCdEfG' 字符串的判断isalnum()用于判断一个字符串非空并且字符全部是字母或阿拉伯数字。isalpha()和isdigit()则分别用来检测对应的全为字母/阿拉伯数字的情况。检测数字的情况分为多种，其中isdigit()最为万能，可以检测包含阿拉伯数字在内的多种数字，但是检测不了汉字数字。使用isnumeric()可以检测汉字数字。islower(),isupper(),isspace()同理。istitle()可以判断字符串是不是标题格式。isdemical()可以判断字符串是否仅包含十进制字符。以上函数都是作为字符串对象的方法存在的。 字符串的相关操作以下操作均为字符串对象的方法。 查找某一个字符串是否出现使用in或者not in判断一个字符串在整个字符串中出现/不出现。如：12345&gt;&gt;&gt; a = "abcde"&gt;&gt;&gt; "bc" in aTrue&gt;&gt;&gt; "efg" not in aTrue 使用find(pattern, begin = 0, end = len(str))可以在指定区间内从左到右寻找要匹配的字符串，并且返回该字符串第一个字符的下标。使用index(pattern, begin = 0, end = len(str))函数也可以，但是前者找不到会返回-1，后者会报错。类似的有rfind和rindex，这两个寻找的时候是从右到左。如：1234567891011&gt;&gt;&gt; a = "abcabcabc"&gt;&gt;&gt; a.rfind("abc", 0)6&gt;&gt;&gt; a.find("abc", 0)0&gt;&gt;&gt; a.index("abc", 0)0&gt;&gt;&gt; a.index("aaa", 0)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found 数一个字符串出现了几次使用count()方法数一个字符串在另一个串内出现了几次。该方法的语法为str.count(sub, start = 0, end = len(string))，其中sub为要查找的字串。如：123456&gt;&gt;&gt; 'aaaaa'.count('aa')2&gt;&gt;&gt; 'excite'.count('e', 1, 4)0&gt;&gt;&gt; 'excite'.count('e', 1, 11)1 可以看出，count()查找的字串是不相互重叠的。 分割和连成字符串使用split()方法把一个字符串分割，得到一个列表。该方法语法为str.split(str = &quot;&quot;, num = string.count(str))。其中str参数默认为所有的空字符，包括空格、换行、制表符等。num参数表示最终从前到后分割出num+1个字符串，默认为全部分割。如：12345678910&gt;&gt;&gt; 'a#b#c#d'.split('#', 0)['a#b#c#d']&gt;&gt;&gt; 'a#b#c#d'.split('#', 1)['a', 'b#c#d']&gt;&gt;&gt; 'a#b#c#d'.split('#', 2)['a', 'b', 'c#d']&gt;&gt;&gt; 'a#b#c#d'.split('#', 3)['a', 'b', 'c', 'd']&gt;&gt;&gt; 'a#b#c#d'.split('#', -1)['a', 'b', 'c', 'd'] 使用splitlines()方法把一个字符串按照行分割，即按照换行符，回车符分割。该方法语法为str.splitlines([keepends])，其中keepends为布尔值，默认为False，表示分割后行末不保留换行符号。若为True则保留。使用join()方法把一个包含字符串的序列连成一个字符串。该方法语法为str.join(sequence)，其中sequence为某个序列结构。该方法可视为split()的逆方法，因为它连成的字符串之间的分割符即为str。如：1234&gt;&gt;&gt; ' '.join(('a', 'b'))'a b'&gt;&gt;&gt; '#'.join(['a', 'b', 'c', 'd'])'a#b#c#d' 判断一个字符串是否为前/后缀使用startswith()方法判断一个字符串是否是另一个的前缀。该方法语法为str.startswith(substr, beg = 0, end = len(string))，意义和前几个方法基本相同。使用endswith()方法判断一个字符串是否是另一个的后缀。语法和startswith()基本相同。如：12345678&gt;&gt;&gt; 'ssss'.startswith('ss')True&gt;&gt;&gt; 'ssss'.startswith('sa')False&gt;&gt;&gt; 'ssss'.endswith('ss')True&gt;&gt;&gt; 'ssss'.endswith('as')False 替换字符串使用replace()方法替换一个字符串中的某些模式串。该方法语法为str.replace(old, new[, max])，old表示被替换的串，new表示新串，max表示最多替换次数，省略表示全部替换。如：1234&gt;&gt;&gt; 'aaaaa'.replace('a', 'b', 3)'bbbaa'&gt;&gt;&gt; 'aaaaa'.replace('aa', 'b')'bba' 字符串的样式调整使用zfill(width)可以返回长度为width的字符串，其中原字符串向右对其，前面不足的部分使用0填充。如：123&gt;&gt;&gt; a = "123z"&gt;&gt;&gt; a.zfill(6)'00123z' 使用strip()去除字符串两端的空白字符。特别的，使用lstrip()仅去除字符串左端的空白字符，使用rstrip()仅去除字符串右端的空白字符。使用center()方法可以使字符串居中。该方法的语法为str.center(width[, fillchar])，其中width为总宽度，fillchar为填充到总宽度所用的字符。如：12&gt;&gt;&gt; s.center(10, '0')'000aaa0000' 使用ljust()和rjust()方法分别可以使字符串左居中和右居中，语法和center()相同。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（四） 其他类型运算]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-4%2F</url>
    <content type="text"><![CDATA[第四篇学习笔记，内容围绕Python除数学运算外的其他运算。 比较运算比较运算符包括==，!=，&gt;，&lt;，&gt;=，&lt;=。比较运算符和大多数编程语言一样，和数学上的意义也相近，在此不做过多的解释。但python中比较运算符的连接则和大多数语言不同，python支持多个比较运算符之间的多次连接，如：1234&gt;&gt;&gt; 1 &lt; 2 &gt; 1 &lt; 2 &gt; 1 &lt; 2 &gt; 1True&gt;&gt;&gt; 3 &gt;= 2 &gt;= 1 &gt;= 0True 位运算位运算对数字的二进制位进行计算。python中位运算包含&amp;，|，~，^，&gt;&gt;，&lt;&lt;六种，分别对应与，或，取反，异或，右移和左移。具体在此不做介绍。python中的移位是算术移位。如：1234&gt;&gt;&gt; (-1) &gt;&gt; 10-1&gt;&gt;&gt; (-1) &lt;&lt; 10-1024 逻辑运算逻辑运算符包含and, or和not三个。 逻辑值python中任何数据类型都有对应的逻辑值。只要数据类型非零（非空）就是True，否则就是False。可以使用bool()函数取得某一个对象的逻辑值。如：123456&gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool(123)True&gt;&gt;&gt; bool(&#123;1: 2&#125;)True 逻辑值参与数值运算的时候，True视作1，False视作0。如True * True + False - True为1。 逻辑运算符一般情况下，python中逻辑运算符都对逻辑值进行运算，但运算结果不仅限于True和False。 and运算and运算返回的值以运算时出现的第一个逻辑值为False的对象为主。如果两个运算数都不是False那么就返回最后那个对象。如：123456789101112&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 20&gt;&gt;&gt; a and b20&gt;&gt;&gt; a = 0&gt;&gt;&gt; a and b0&gt;&gt;&gt; a, b = 10, 0&gt;&gt;&gt; a and b0&gt;&gt;&gt; [1, 2, 3] and &#123;1: 2&#125;&#123;1: 2&#125; or运算or运算返回的值以运算时出现的第一个逻辑值为True的对象为主。如果两个运算数都是False那么就返回最后那个对象。如：123456789101112&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 20&gt;&gt;&gt; a or b10&gt;&gt;&gt; a = 0&gt;&gt;&gt; a or b20&gt;&gt;&gt; a, b = 10, 0&gt;&gt;&gt; a or b10&gt;&gt;&gt; [1, 2, 3] or &#123;1: 2&#125;[1, 2, 3] not运算not运算返回的值只是逻辑值，也即，它仅对运算数的逻辑值进行取反的操作。如：123&gt;&gt;&gt; a = 10&gt;&gt;&gt; not aFalse 成员运算符成员运算符用于测试给定的一个对象是否是另一个对象的“成员”，即，是否包含在另一个对象之中。成员运算符只有两种：in和not in。对于x in y，如果y包含x则返回True，否则返回False。not in与in刚好相反。 身份运算符身份运算符用于比较两个对象的存储单元（内存地址）是否同一，可以理解为“本质是否相同”。身份运算符只有两种：is和is not。x is y类似id(x) == id(y)，如果x和y引用的对象相同（即两者指向同一储存单元）则返回True，否则返回False。is not与is刚好相反。 运算优先级根据python官方文档，python的运算符优先级如下：（从高到低优先级递减） 运算符 描述 ** 乘方运算 +, -, ~ 加减法（一元），按位取反 *, /, //, % 乘除法类（含取余） +, - 加减法（二元） &lt;&lt;, &gt;&gt; 左移，右移 &amp; 按位与 ^ 按位异或 &#124; 按位或 in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == 比较运算符，身份运算符，成员运算符 not 逻辑非 and 逻辑与 or 逻辑或 if-else 三目运算符（在后续笔记中提及） lambda lambda运算（在后续笔记中提及） = 赋值运算]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（三） 数字类型和数学运算]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-3%2F</url>
    <content type="text"><![CDATA[第三篇学习笔记，内容和Python的数字类型相关。 类型python3中支持int，float和complex三种，其中int支持任意长度的运算，float实现的是小数的运算，complex支持了复数的运算。 整数整数没有长度的限制，同时可以使用十六进制，八进制或者二进制的整数，对应的前缀分别是0x，0o和0b。例如：12345678&gt;&gt;&gt; 0b101011086&gt;&gt;&gt; 0xFFFF65535&gt;&gt;&gt; 0xffff65535&gt;&gt;&gt; 0o7654332099 浮点数浮点数可以用小数来表示，也可以用2.5e2之类的科学计数法来表示。 复数复数的表示和数学上稍微有一些不同，在python中复数的虚部使用的是字母j而不是i。同时复数的实部和虚部都是浮点数类型。 表示时可以用a+bj的形式也可以用complex(a, b)。 表示复数的时候虚部和j不能分开，否则报错。如果虚部为$1$，仍然不能省略虚部，否则会报错。 类型转换只需要将类型名称作为函数名就可以实现数据类型之间的转换。如： 整数的转换使用int()函数。该函数的使用方法有两种： 对数字类型使用，则括号内只能接受整数或者浮点数，其中浮点数的转换规则是向原点靠近。如int(3.5) = 3, int(-3.1) = -3。括号内数字缺省时返回$0$。 对字符串使用，则括号内第一个参数是字符串，第二个参数是指定你要转换的字符串的进制。如int(&#39;23&#39;, 16) = 35。字符串必须要是符合该进制的，否则会报错。转换的结果是字符串在该进制下对应的十进制整数。 浮点数的转换使用float()函数，括号内可以接受数或者字符串，数不能为复数。 字符串也必须是可以正确转为浮点数的字符串，比如有多个小数点的就不能正常转换，会报错。字符串内最多包含一个+或者-，否则报错。符号和数字之间不能有空格，否则报错。 有一些特殊的字符串可以转换为一些特殊的浮点类型，如&#39;infinity&#39;，&#39;inf&#39;（不区分大小写），转换后就是inf。在前面加上一个减号可以变成负无穷。还有&#39;nan&#39;也会被转换成nan。 复数的转换使用complex(x[, y])可以生成一个复数。其中实部为x，而虚部为y（可缺省，此时虚部为0）。前一个参数可以为字符串，此时括号内只能有这一个参数，并且字符串中的复数必须是紧凑的，即数和符号间不能有空格，如1+2j，而不能是1 + 2j。 运算具体运算python中数的运算大体和其他编程语言相似，其中加，减，乘都没有什么区别，对于除法，python中/除法得到的总是一个浮点数，而要丢弃余数则需要用//。//除法得到的也不总是整数，这与被除数和除数的数据类型有关。如：1234567891011121314&gt;&gt;&gt; 15 // 43&gt;&gt;&gt; 15.0 // 43.0&gt;&gt;&gt; 15 // 4.03.0&gt;&gt;&gt; 15.0 // 4.03.0&gt;&gt;&gt; 15.2 // 3.44.0&gt;&gt;&gt; -15.2 // 3.4-5.0&gt;&gt;&gt; 15.0 // (-4.0)-4.0 可见//运算不仅丢弃了余数，取商的方向也是严格按照小于原来商的方向取的。 python中的乘方运算符时**，如：12345678&gt;&gt;&gt; 5 ** 225&gt;&gt;&gt; 5.0 ** 8390625.0&gt;&gt;&gt; 9 ** 0.53.0&gt;&gt;&gt; 9 ** -10.1111111111111111 不同的数混合处理时，会一并转换为浮点数。 使用%可以求得余数。如：12345678&gt;&gt;&gt; 5 % 32&gt;&gt;&gt; 5.0 % 1.60.19999999999999973&gt;&gt;&gt; 5.0 % (-1.6)-1.4000000000000004&gt;&gt;&gt; -5.0 % 1.61.4000000000000004 可以看出，//和%对于整除的理解是相同的。 赋值运算符除了最基本的=之外，其他和c++类似，如乘方a = a ** b可以简写为a **= b，加法a = a + b可以简写为a += b。需要注意的是，python中没有++，--之类的自增自减操作。只能通过+= 1和-= 1实现类似的自增自减操作。 运算优先级python中运算的优先级和正常的数学运算差别不大。都是乘方最先，乘除（含取余）其次，加减最后。事实上，python中有一点稍显不同，那就是当+和-是一元运算符时，两者的优先级位于乘方和乘除之间。 和数字操作有关的函数绝对值和绝对值相关的有abs(x)和fabs(x)两个函数。 abs(x)是内置函数，而fabs(x)是在math模块中定义的，两者的区别还在于fabs(x)适用于整数和浮点数，而abs(x)还适用于复数。复数的abs就是复数的模。 取整和取整相关的有ceil(x)和floor(x)两个函数。 ceil(x)是向上取整，floor(x)是向下取整。两者返回的都是整数。 两者都定义在math模块中。 指数和对数和指数与对数相关的函数有exp(x)，log(x)和log10(x)。 exp(x)返回$e^x$，log(x)返回$\ln x$，log10(x)返回$\lg x$。三者返回的都是浮点数。 三者都定义在math模块中。 求幂可以使用pow(x, y[, z])函数求$x^y \mod z$（如果省略$z$则只计算$x^y$，此时$x, y$可以为浮点数；而若要使用$z$则$x, y, z$必须均为整数）。 该函数为内建函数，可以不导入模块，直接调用。函数返回值类型与结果有关，结果是整数则返回值为整数，否则为浮点数。 实际上在math模块中也存在一个pow(x, y)函数，但该函数只接受2个参数（均可为浮点数），并且只返回浮点数。 求算术平方根使用math模块中的sqrt(x)求$x$的算术平方根。$x$需要是非负实数。 该函数作用不大。 分离整数和小数部分使用math模块中的modf(x)函数以二元组形式得到$x$的整数部分与小数部分，两部分的数值符号与$x$相同，整数部分以浮点型表示。如：12&gt;&gt;&gt; math.modf(123.45)(0.45000000000000284, 123.0) 四舍五入使用math模块中的round(x[, n])函数对浮点数进行四舍五入，其中$n$是四舍五入到哪一位，默认为0（个位）。返回值是浮点数。 应该说，该函数的效果并不理想，一是因为它在python2.x版本和python3.x版本中有着不同的实现，导致两个版本对于同一个数的处理结果可能不同；二是该函数因为受计算机浮点数表示精度的影响，可能会产生误差，如round(2.355, 2)会得到2.35的神奇结果。所以如果要追求精确性，就最好别用它。 三角函数math模块中定义了sin(x)，cos(x)，tan(x)，asin(x)，acos(x)，atan(x)等三角函数。 此外，还定义了degrees(x)和radians(x)这两个函数，分别用于弧度转角度和角度转弧度，如：1234&gt;&gt;&gt; math.degrees(math.pi/2)90.0&gt;&gt;&gt; math.radians(90.0)1.5707963267948966 与输出数有关的函数bin(x)，oct(x)和hex(x)分别可以输出int类型数的二进制，八进制，十六进制的表示。如：123456&gt;&gt;&gt; bin(123)'0b1111011'&gt;&gt;&gt; oct(123)'0o173'&gt;&gt;&gt; hex(123)'0x7b']]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（二） 变量]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-2%2F</url>
    <content type="text"><![CDATA[第二篇学习笔记，内容包含了Python变量使用和命名的要点。 变量的使用python是一个动态类型语言，它在创建一个变量的时候不需要事先声明变量的类型。如1message = 2 但是变量如果在定义的时候不赋一个值则会报错。同时变量的类型可以随时切换，如12message = 2message = 'abc' # 合法 可以一时间给多个变量赋值，如1a = b = c = 2 或者给多个变量一次性赋上不同的值，如1a, b, c = 1, 2, 3 变量的命名python中变量的命名原则和c++相似，必须满足以下条件： 变量名仅能包含数字，字母和下划线，不能含有空格，且不以数字开头。 变量名不能为关键字。如不能把list作为关键字。 变量的命名原则同样适于函数，类，模块的命名等。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python入门笔记（一） 基本语法]]></title>
    <url>%2F2018%2F12%2F29%2Fpython-1%2F</url>
    <content type="text"><![CDATA[第一篇学习笔记，内容包含了Python的一些基本语法和基本内容。 缩进python用缩进表示一个代码块。一般的缩进都必须要是4个空格。缩进相同的一组语句构成一个代码块，我们称之代码组。复合语句中，冒号后面的缩进相同的一组语句构成一个代码块。不同的代码块之间有着不同的从属关系，这种从属关系对于理解代码逻辑非常必要。 多语句python用反斜杠支持多行语句，如下：12age = 1 + \2 在各种括号中的多行语句不需要用反斜杠。如列表中：12items = ['a', 'ab'] 在一行中使用多个语句可以像c系列语言一样用分号隔开。 交互界面python的命令行交互界面中，输入一个表达式可以返回一个结果，这个结果被储存在变量_中。应当在使用交互界面时将_视为一个只读的变量。在将交互界面当作一个计算器使用的时候可以将_看作是lastans之类的值。如果尝试改变_的值会导致_的值不再根据最后的运算结果而变化，如：123456789101112&gt;&gt;&gt; a = 1&gt;&gt;&gt; a1&gt;&gt;&gt; a + _2&gt;&gt;&gt; _ = 12&gt;&gt;&gt; a + _13&gt;&gt;&gt; a1&gt;&gt;&gt; a + _13 除非使用del _，否则这样的情况不会改变。 同时赋值使用如下格式可以执行同时赋值： var_1, var_2, var_3, ..., var_n = exp_1, exp_2, exp_3, ..., exp_n因此python中可以用非常简单的语法实现两个变量的交换。如：1a, b = b, a 逗号的使用python中不强制要求在某些地方，最后一个参数之后不能有逗号。因此print(1, 2,)是合法的。（事实上python自己在一些地方就是这么做的） 注释一般的注释的格式如下：1# 注释 多行注释使用三引号，用两对三个单引号或者两对三个双引号将所要注释的内容框起来即可。如：1234567891011'''注释11231233'''"""注释12344321""" 要用中文的话貌似要加上这两行在最顶上。因为python一般只支持ASCII码。（不过一般情况下用中文好像也没有出什么事情…?）12#!/usr/bin/python # -*- coding: utf-8 -*- 顺带一提，这两行代码中，第一行指定了该代码使用python解释器来运行，第二行指定了代码的编码格式。 pass语句这是个空语句，它只有占位子的作用，本身什么也不做。 寻求帮助使用help()函数获取相关类型或者函数的信息。对某个实例使用help()函数可以得到其所属类的相关信息。如：1234class A: passa = A()print(help(a)) 可以得到：12345678910Help on A in module __main__ object:class A(builtins.object) | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined)]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4699 Editor]]></title>
    <url>%2F2018%2F12%2F23%2Fhdu4699%2F</url>
    <content type="text"><![CDATA[题目链接 题解 本题的特殊性在于，四种操作均在光标位置发生，并且发生完操作之后光标至多移动一个位置。根据这种始终在序列中间某个指定位置进行修改的性质，可以使用“对顶栈”算法。————《算法竞赛进阶指南》 有这种思想这道题就很好做了。实际上题目中的“最大前缀和”和求栈中最小值有点像，也算是使用栈的一个提示？1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int Q, stf[1000005], tf, str[1000005], tr, st[1000005], t, sum = 0;int main()&#123; while(scanf("%d", &amp;Q) == 1)&#123; tf = tr = t = 0, sum = 0, st[0] = -2000000000; char ord[3]; int opr = 0; while(Q--)&#123; scanf("%s", ord); if(ord[0] == 'I')&#123; scanf("%d", &amp;opr); stf[++tf] = opr, t++, sum += opr; st[t] = max(st[t - 1], sum); &#125; if(ord[0] == 'D') t--, sum -= stf[tf--]; if(ord[0] == 'L' &amp;&amp; tf) sum -= stf[tf], str[++tr] = stf[tf--], t--; if(ord[0] == 'R' &amp;&amp; tr) &#123; stf[++tf] = str[tr--], t++, sum += stf[tf]; st[t] = max(st[t - 1], sum); &#125; if(ord[0] == 'Q') scanf("%d", &amp;opr), printf("%d\n", st[opr]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO18JAN Rental Service]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu4181%2F</url>
    <content type="text"><![CDATA[题目链接 题解贪心，把产奶量，商店给出的收购价和村民给的租金均降序排序，然后遍历每一种方案，把牛分成两部分，使得一部分产奶，一部分卖出，看哪一种总收益最大。代码稍微复杂，但思维难度不大。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Sp&#123; int req, p1;&#125;;struct cmp&#123; inline bool operator() (const Sp &amp;s1, const Sp &amp;s2)&#123; return s1.p1 &gt; s2.p1; &#125;&#125;;struct cmp2&#123; inline bool operator() (const int &amp;i1, const int &amp;i2)&#123; return i1 &gt; i2; &#125;&#125;;Sp sp[100005];int n, m, r, otp[100005], p2[100005];ll totp[100005] = &#123;0&#125;, tmon[100005] = &#123;0&#125;;ll tr[100005] = &#123;0&#125;;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;r); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;otp[i]); for(int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;sp[i].req, &amp;sp[i].p1); for(int i = 0; i &lt; r; ++i) scanf("%d", &amp;p2[i]); sort(sp, sp + m, cmp()); sort(p2, p2 + r, cmp2()); sort(otp, otp + n, cmp2()); totp[0] = 0, tmon[0] = 0; for(int i = 1; i &lt;= m; ++i) totp[i] = totp[i - 1] + sp[i - 1].req, tmon[i] = tmon[i - 1] + 1ll * sp[i - 1].p1 * sp[i - 1].req; tr[0] = 0; for(int i = 1; i &lt;= r; ++i) tr[i] = tr[i - 1] + 1ll * p2[i - 1]; ll ans = tr[min(n, r)], curotp = 0; for(int i = 0; i &lt; n; ++i)&#123; curotp += otp[i]; int ind = lower_bound(totp, totp + m + 1, curotp) - totp; ans = max(ans, tmon[ind - 1] + (curotp - totp[ind - 1]) * sp[ind - 1].p1 + tr[min(n - i - 1, r)]); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO18OPEN Lemonade Line]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu4379%2F</url>
    <content type="text"><![CDATA[题目链接 题解对w_i降序排序之后模拟即可。这是贪心。123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int n, w[100005];int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;w[i]); sort(w, w + n); int cnt = 0; for(int i = n - 1; i &gt;= 0; --i)&#123; if(cnt &lt;= w[i]) cnt++; else break; &#125; printf("%d\n", cnt); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10JAN Tea Time]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu2978%2F</url>
    <content type="text"><![CDATA[题目链接 题解并查集模板（？）题。1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int fa[1005], rk[1005], n, m, q;void init()&#123; for(int i = 1; i &lt;= n; ++i) fa[i] = i, rk[i] = 1;&#125;int Find(int x)&#123; if(x == fa[x]) return x; return (fa[x] = Find(fa[x]));&#125;void joint(int x, int y)&#123; int xa = Find(x), ya = Find(y); if(xa == ya) return ; if(rk[xa] &gt; rk[ya]) fa[ya] = xa, rk[xa] += rk[ya]; else fa[xa] = ya, rk[ya] += rk[xa];&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); init(); int u, v; for(int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;u, &amp;v), joint(u, v); for(int i = 0; i &lt; q; ++i) scanf("%d%d", &amp;u, &amp;v), printf("%s\n", Find(u) == Find(v) ? "Y" : "N"); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1468 派对灯]]></title>
    <url>%2F2018%2F12%2F19%2Fluogu1468%2F</url>
    <content type="text"><![CDATA[题目链接 题解和leetcode上面某题几乎一样。注意排序就行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt = 0, op[105] = &#123;0&#125;;int res[105], ans[10][105], tot = 0;int ori[10], b[2][10], c[3], to[10];void ssort()&#123; for(int i = 0; i &lt; tot; ++i) ori[i] = i; for(int i = n - 1; i &gt;= 0; --i)&#123; c[0] = c[1] = 0; for(int j = 0; j &lt; tot; ++j)&#123; int curbit = ans[ori[j]][i]; b[curbit][c[curbit]++] = ori[j]; &#125; c[1] += c[0]; for(int j = tot - 1; j &gt;= 0; --j)&#123; int curbit = ans[ori[j]][i]; to[--c[curbit]] = ori[j]; &#125; for(int j = 0; j &lt; tot; ++j) ori[j] = to[j]; &#125;&#125;bool judge()&#123; for(int i = 0; i &lt; n; ++i) if((op[i] == 1 &amp;&amp; res[i] == 0) || (op[i] == -1 &amp;&amp; res[i] == 1)) return false; memcpy(ans[tot], res, sizeof(res)), tot++; return true;&#125;inline void reset()&#123; fill(res, res + n, 1);&#125;void process(int x)&#123; if(x == 1)&#123; for(int i = 0; i &lt; n; ++i) res[i] ^= 1; &#125;else if(x == 2)&#123; for(int i = 0; i &lt; n; i += 2) res[i] ^= 1; &#125;else if(x == 3)&#123; for(int i = 1; i &lt; n; i += 2) res[i] ^= 1; &#125;else if(x == 4)&#123; for(int i = 0; i &lt; n; i += 3) res[i] ^= 1; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); int t; while(scanf("%d", &amp;t), t &gt; 0) op[t - 1] = 1; while(scanf("%d", &amp;t), t &gt; 0)&#123; if(op[t - 1] == 1)&#123; printf("IMPOSSIBLE\n"); return 0; &#125; op[t - 1] = -1, cnt++; &#125; bool flag = false; if(m == 0)&#123; if(cnt &gt; 0) &#123; printf("IMPOSSIBLE\n"); return 0; &#125; else&#123; for(int i = 0; i &lt; n; ++i) printf("1"); putchar('\n'); return 0; &#125; &#125;else if(m &amp; 1)&#123; reset(); if(m &gt; 1) flag |= judge();//0 process(1), flag |= judge();//1 process(2), flag |= judge();//3 process(1), flag |= judge();//2 reset(), process(4), flag |= judge();//4 if(m &gt; 1)&#123; process(2), flag |= judge();//24 process(1), flag |= judge();//34 process(2), flag |= judge();//14 &#125; &#125;else&#123; reset(), flag |= judge();//0 process(1), flag |= judge();//1 process(2), flag |= judge();//3 process(4), flag |= judge();//34 process(1), flag |= judge();//24 process(3), flag |= judge();//14 reset(), process(2), flag |= judge();//2 if(m &gt; 2) reset(), process(4), flag |= judge();//4 &#125; if(!flag)&#123; printf("IMPOSSIBLE\n"); return 0; &#125; ssort(); for(int i = 0; i &lt; tot; ++i)&#123; for(int j = 0; j &lt; n; ++j) printf("%d", ans[ori[i]][j]); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 卷积变换]]></title>
    <url>%2F2018%2F12%2F17%2Ftemplate-fft%2F</url>
    <content type="text"><![CDATA[本文主要讨论三个算法：FFT，NTT和FWT。 基础知识卷积 在泛函分析中，卷积、叠积（convolution）、摺积或旋积，是通过两个函数$f$和$g$生成第三个函数的一种数学算子，表征函数$f$与经过翻转和平移的$g$的乘积函数所围成的曲边梯形的面积。如果将参加卷积的一个函数看作区间的指示函数，卷积还可以被看作是“移动平均”的推广。————维基百科 事实上，在这里我们主要讨论的是定义在数列上的卷积。最基本的一个问题是：给定两个长度有限的序列\left\{a_i\right\}, \left\{b_i\right\}，求出序列\left\{c_i\right\}，使得c_i = \sum_{j + k = i} a_j \oplus b_k，其中$\oplus$是某个满足交换律的二元运算。 复数单位根根据代数基本定理，复数方程$z^n = 1$有$n$个根，这些根互不相同，可以表示为$e^{\frac{2\pi k i}{n}} = \cos(\frac{2\pi k }{n})+i\sin(\frac{2\pi k }{n})\quad (k\in \lbrace 0, 1, \cdots, n- 1 \rbrace)$。一般记作w_n^k = e^{\frac{2\pi k i}{n}}。单位根具有一些很神奇的性质： w_n^0 = w_n^n = 1。 w_n^0, w_n^1, \cdots, w_n^{n - 1}各不相同。 w_{tn}^{tk} = w_n^k(t \ge 1), w_n^{k + \frac{n}{2}} = -w_n^k。这一个性质有着很强的几何意义。 w_n^{jk} = w_n^{jk \mod n}。 原根和阶FFT（快速傅里叶变换）基础：离散傅里叶变换]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hihocoder1384]]></title>
    <url>%2F2018%2F12%2F16%2Fhihocoder1384%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数论复习笔记-1]]></title>
    <url>%2F2018%2F12%2F12%2Fnumber-theory-1%2F</url>
    <content type="text"><![CDATA[（这里大概不会涉及代码） 同余关系算术基本定理表述对于任何一个大于$1$的正整数$n$，$n$都能被唯一分解为有限个质数的乘积，写作： n = p_1^{c_1} p_2^{c_2} \cdots p_m^{c_m}其中c_i \ge 1、p_i是质数$(\forall i)$，且p_1]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1019 Number Sequence]]></title>
    <url>%2F2018%2F12%2F12%2Fpoj1019%2F</url>
    <content type="text"><![CDATA[题目链接 题解二分出答案要求的数字出现在$1234\cdots n$里面的$n$的值，然后计算具体是这一串数里面的哪一个数的哪一位。后面这个子问题在leetcode 400上有。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;int s[10], cnt;unsigned int get(int t)&#123; int pst = 0, u = 9, res = 0, a1 = 0; for(int i = 1; ; ++i)&#123;//d = i a1 += i; int terms = min(u, t) - pst; res += terms * a1 + (terms * (terms - 1) / 2) * i; if(t &lt;= u) break; a1 += i * (u - pst - 1); pst = u, u = 10 * u + 9; &#125; return res;&#125; int solve(unsigned int n)&#123; int l = 1, r = 35000; while(l &lt; r)&#123; int mid = (l + r) &gt;&gt; 1; if(get(mid) &gt;= n) r = mid; else l = mid + 1; &#125; int gap = n - get(r - 1); if(gap &lt;= 9) return gap; int i = 1, u = 9; while(gap &gt; u)&#123; gap += u, u = u * 10 + 9, ++i; if(gap &lt;= i * u)&#123; int res = (gap + i - 1) / i; cnt = 0; while(res) s[cnt++] = res % 10, res /= 10; return s[cnt - 1 - ((gap + i - 1) % i)]; &#125; &#125;&#125;int main()&#123; int T; unsigned int n; scanf("%d", &amp;T); while(T--)&#123; scanf("%u", &amp;n); printf("%d\n", solve(n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uva756]]></title>
    <url>%2F2018%2F12%2F11%2Fuva756%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2134 单选错位]]></title>
    <url>%2F2018%2F12%2F11%2Fbzoj2134%2F</url>
    <content type="text"><![CDATA[题目地址 题解考虑每一道题对答案的贡献。容易发现当一道题的选项数目是$a$，而错填到这道题的答案所属的原来那道题目有$b$个选项时，这道题目对的概率是$\frac{1}{\max\left{a, b\right}}$（可以画格子图，看对角线来考虑）。然后这道题对的期望就是概率$\times 1$。所以对每一个题目都这么跑一遍就可以了。12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n, A, B, C, a1, a2, a3;int main()&#123; double ans = 0; scanf("%d%d%d%d%d", &amp;n, &amp;A, &amp;B, &amp;C, &amp;a1); a2 = a1; int pst = a2 % C + 1, real; for(int i = 2; i &lt;= n; ++i)&#123; a3 = ((long long)a2 * A + B) % 100000001; real = a3 % C + 1; ans += 1.0 / max(pst, real); pst = real, a2 = a3; &#125; real = a1 % C + 1; ans += 1.0 / max(pst, real); printf("%.3lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算的运用]]></title>
    <url>%2F2018%2F12%2F06%2Fbit-operation-applications%2F</url>
    <content type="text"><![CDATA[位运算可以用来做什么？ 位运算众所周知，常用的位运算有&amp;（与），|（或），^（异或），&lt;&lt;（左移），&gt;&gt;（右移），~（取反）几种。 位运算虽然简单，但是在应用上有很多技巧。 基础：位的访问和修改位的访问位的访问可以简单的使用一个移位操作和一个与操作来实现。下面的程序就演示了检测第$pos$位上是不是$1$：123bool getPos(unsigned int x, int pos)&#123; return (x &gt;&gt; pos) &amp; 1;&#125; 而要访问第$pos$位开始向后的连续$t$位，就要使用一个“遮罩”来捕获后面的那些位。使用与运算就可以做到这一点。如下面代码所示：123int getPosT(unsigned int x, int pos, int t)&#123; return (x &gt;&gt; pos) &amp; ((1u &lt;&lt; t) - 1);&#125; 位的修改要将第$pos$位修改为$1$可以使用或运算。如下面的演示程序：123unsigned int setPos(unsigned int x, int pos)&#123; return x | (1u &lt;&lt; pos);&#125; 要将第$pos$位修改为$0$可以将原数与一个只有$pos$位上是$0$，其余位均为$1$的数相与，如下程序所示。123unsigned int delPos(unsigned int x, int pos)&#123; return x &amp; ~(1u &lt;&lt; pos);&#125; 要将第$pos$位取反可以将原数与一个只有$pos$位上是$1$，其余位均为$1$的数相异或，如下程序所示。123unsigned int flipPos(unsigned int x, int pos)&#123; return x ^ (1u &lt;&lt; pos);&#125; 进阶：求某些特殊的值求最低位的bit这个是经典的lowbit方法。代码如下：123unsigned int lowbit(unsigned int x)&#123; return x &amp; (-x);&#125; 原理是补码为反码$+1$。 参考资料： 《回归本源————位运算及其应用》，2014年信息学奥林匹克国家集训队论文]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode近期做题 简要题解]]></title>
    <url>%2F2018%2F11%2F24%2Fleetcode-easy-100%2F</url>
    <content type="text"><![CDATA[记录一点简要题解。个人认为一下题目中比较好的：11，96，137，189，258，290，326，400，438，448，453，458，459，479，633，754，877，932，939185是SQL题，没法做。 1水 2水 3统计字符，维护桶。 7基本上和翻转字符串相同。特判负数和溢出。 9用字符串。 11方法一排序，找周围比自己高的，进而找最远的。123456789101112131415161718class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ len1 = len(height) h = list(zip(height, range(0, len1))) h.sort(key = lambda x: x[0]) ans = 0 hd, tl = 0, len1 - 1 for i in h: hh, idx = i[0], i[1] ans = max(ans, max(idx - hd, tl - idx) * hh) height[idx] = -1 while hd &lt; tl and height[hd] == -1: hd += 1 while hd &lt; tl and height[tl] == -1: tl -= 1 return ans 方法二使用两个分别指向头和尾的指针，每次比较两个指针所指的木板的长度，将指向较小者的指针向中间地区移动，这样就可以保证能找到最大的解。这样做是线性的时间复杂度。123456789101112131415class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ len1 = len(height) i, j, ans = 0, len1 - 1, 0 while i &lt; j: ans = max(ans, min(height[i], height[j]) * (j - i)) if height[i] &lt; height[j]: i += 1 else: j -= 1 return ans 12模拟 14二分最长前缀长度。可以用startswith()。 15基本同18，不过简单很多 18折半搜索 20水栈。 26可以用双指针法。 27遍历。 281str.find() 34二分。等同于实现lower_bound()和upper_bound()。 35二分。基本等同于34题。 38容易 41基本同448 46简单全排列构造 501return x ** n 52用py写就是拼时间 53我觉得$O(n)$更精妙来着… 58水 63简单递推。 64DP 65睿智题 66水 671return bin(int(a, 2) + int(b, 2))[2: ] 69二分or函数。 70递推。斐波那契数列。 88从尾部开始合并有序队列。 94, 144, 145水迭代应该是指用栈记录上一次访问了什么，然后遇到这个节点更新，如果全部弄完了就出栈。 96经典问题。答案是Catalan数。 100水 104水 112水 118水 119利用组合数公式 121维护当前所遇到的最小数$mini$，然后从左向右扫，每遇到一个数就尝试更新答案和$mini$。 125正规化字符串之后直接判定。 136异或 137方法一基本做法是统计每一位的1数目，看看哪一位的次数模$3$余$1$，然后把这些位或起来。12345678910111213141516171819202122class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ ans, j, cnt1, cnt2 = 0, 1, 0, 0 for i in range(0, 32): for t in nums: if t &gt;= 0: if t &amp; j: cnt1 += 1 else: if (-t) &amp; j: cnt2 += 1 if cnt1 % 3 == 1: ans += j elif cnt2 % 3 == 1: ans += -j j &lt;&lt;= 1 cnt1, cnt2 = 0, 0 return ans 方法二对于这道题而言，我们寄希望于能找到一种方法，利用位运算，来实现三进制的无进位加法。换言之，有没有什么方法可以实现某些位上出现00-&gt;01-&gt;10-&gt;00的循环呢？答案是有的。因为是二进制，所以我们可以考虑用两个二进制数表示一个三进制的数。这里直接给出这种运算方法。手算可以发现它实现了b，a上同一位00-&gt;01-&gt;10-&gt;00的变化（因为我也不知道这是怎么想到的，代码来自中文leetcode本题评论区）事实上，利用逻辑运算规则可以构造出这样一个真值函数，来实现三进制的运算。1234567891011class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ a, b = 0, 0 for num in nums: b = ~a &amp; (b ^ num) a = ~b &amp; (a ^ num) return b 155单调栈 167双指针 169摩尔投票法，经典问题。 172统计这个阶乘中因子$2$和$5$的次数，取其较小者。但显然后者更少，所以只要统计后者。 189方法一根据$k$把原序列切分成两段，然后递归交换这两段。123456789101112131415161718192021222324252627class Solution: def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ len1 = len(nums) k %= len1 if k == 0 or len1 == 1: return a1, b1, a2, b2 = 0, len1 - 1 - k, len1 - k, len1 - 1 # 均以下标为准 while b2 - a2 != b1 - a1: if b2 - a2 &gt; b1 - a1: len2 = (b1 - a1 + 1) else: len2 = (b2 - a2 + 1) for i in range(0, len2): nums[a1 + i], nums[b2 - len2 + 1 + i] = nums[b2 - len2 + 1 + i], nums[a1 + i] if b2 - a2 &gt; b1 - a1: b2 -= len2 else: a1 += len2 len2 = b1 - a1 + 1 for i in range(0, len2): nums[a1 + i], nums[a2 + i] = nums[a2 + i], nums[a1 + i] 方法二采取类似于非旋转treap的方法，按照$k$把序列切分成为两段，然后分别逆序两段，再将一整段逆序就可以得到答案。123456789101112131415161718class Solution: def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ def rev(a, b): mid = (a + b) &gt;&gt; 1 for i in range(a, mid + 1): nums[i], nums[b + a - i] = nums[b + a - i], nums[i] len1 = len(nums) k %= len1 if k != 0: rev(0, len1 - k - 1) rev(len1 - k, len1 - 1) rev(0, len1 - 1) 方法三我猜是暴力移动…? 190用bin()，但也可以用位运算。 191位运算 202循环。 204用埃氏筛，欧拉筛会被卡。 205用一个dict记录映射，一个set判断重复映射。 2171return len(set(nums)) &lt; len(nums) 219开一个dict记录一个数最后出现的位置，边遍历边更新。 226同非旋转treap。 231判断n == lowbit(n)。 239经典单调队列 242对字符串内字符排序后比较。也可以统计字符，比较各种字符数目。 258观察可以发现答案和$n \mod 9$相关，实际也是。详细参见Digital Root1234567class Solution: def addDigits(self, num): """ :type num: int :rtype: int """ return (num - 1) % 9 + 1 if num != 0 else 0 263看除掉所有$2, 3, 5$之后是不是$1$。注意条件是正整数。 268根据列表长度判断$n$然后用$0+1+\cdots+n$减列表中数。 283看到$0$就删，末尾加回来。 290用两个dict同时记录原像和像。或者用一个dict记录双向。以下代码采用了前者。123456789101112131415161718class Solution: def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ domain, rng = &#123;&#125;, &#123;&#125; list1 = str.split() if len(list1) != len(pattern): return False for i, ch in enumerate(pattern): img, inv_img = rng.get(ch), domain.get(list1[i]) if img or inv_img: if img != list1[i] or inv_img != ch: return False domain[list1[i]] = ch rng[ch] = list1[i] return True 292观察发现$4 \mid n$时先手必败，其余情况下必胜。 315经典逆序对。 319大力推公式1return int(n ** 0.5) 326方法一循环。 方法二对数。1234567891011class Solution: def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n == 1: return True if n &lt;= 0 or n % 3 != 0: return False from math import log k = log(n) / log(3) return abs(k - round(k)) &lt; 1e-9 方法三如果不知道数据大小要用对数或者循环，知道的话判断$3^p \mod n$是否为$0$即可（因为$3$是质数），其中$\forall n, 3^p &gt; n$。1234567class Solution: def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ return n &gt; 0 and 1162261467 % n == 0 342先判断是不是$2$的幂，再开方看看开不开得出。或者判断n &amp; 0x55555555 == n。 344切片or函数。 345双指针法，类似快排。注意大小写。 349set.intersection 350用Counter或者dict之类。 367循环or二分or看开方是不是整数。 371我用了+好像也没WA…? 383统计字符数，看看magazine中的字符够不够。 387统计字符数，找最靠前的只出现一次的字符。 389统计字符数，作差。 400方法一先找最高位然后一位一位向下找。推公式。1234567891011121314151617181920212223242526272829class Solution: def findNthDigit(self, n): """ :type n: int :rtype: int """ i, t, ten = 9, 1, 1 while n &gt; i * t: n -= i * t i *= 10 t += 1 ten *= 10 # 寻找所在数字的位数 ans = (1 + (n - 1) // (ten * t)) * ten n -= t * ten * (ans // ten - 1) ten //= 10 for j in range(t - 1, 0, -1): i = 0 while n &gt; (i + 1) * t * ten: i += 1 n -= i * t * ten ans += i * ten ten //= 10 for j in range(0, t - n): ans //= 10 return ans % 10 方法二可以在做完一层就补上前面一层缺少的位数，然后直接找到第$n$位属于哪一个数字。12345678910111213141516171819202122class Solution: def findNthDigit(self, n): """ :type n: int :rtype: int """ if n &lt; 10: return n i, p = 1, 9 while True: n += p p = p * 10 + 9 i += 1 if n &lt; i * p: return int(str((n + i - 1) // i)[(n + i - 1) % i]) """ 核心思想是补余。 寻找的顺序如下： 1 2 3 4 ... 9 -&gt; 01 02 03 ... 99 -&gt; 001 002 003 ... 999 所以n加的是p而不是i*p。只补上了前面的位数，与后面相齐。 """ 409统计字符数，对于一种字符，如果有$2k+1$个就取$2k$个，否则全取。最后如果存在某种字符是奇数个就令其在中间，并且补上之前这种字符没取的那个。 414维护第一，第二，第三大数。 4341return len(s.split()) 438维护一个值$a$表示当前一个区间内有多少种字符数目和模板内该字符数目不同，然后移动更新$a$。类似滑动窗口。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findAnagrams(self, s, p): """ :type s: str :type p: str :rtype: List[int] """ def oord(x): return ord(x) - 97 list1, num = [0] * 26, 0 for i in p: idx = oord(i) list1[idx] += 1 if list1[idx] == 1: num += 1 list2, cnt = [0] * 26, 0 def calc(o, x): nonlocal cnt, list2 idx = oord(x) if list2[idx] == list1[idx]: cnt = cnt - 1 list2[idx] += o if list2[idx] == list1[idx]: cnt = cnt + 1 len1, len2, ans = len(p), len(s), [] if len1 &gt; len2: return ans for i in range(0, len1): calc(1, s[i]) if cnt == num: ans.append(0) for i in range(len1, len2): calc(-1, s[i - len1]) calc(1, s[i]) if cnt == num: ans.append(i - len1 + 1) return ans 441二分。 443算出每一段相同字符的数目然后在原列表中加上去（用切片插入，否则报错）。本地修改也是可以的，稍微麻烦，可以参考下面的代码（来自这里）。12345678910111213class Solution(object): def compress(self, chars): anchor = write = 0 for read, c in enumerate(chars): if read + 1 == len(chars) or chars[read + 1] != c: chars[write] = chars[anchor] write += 1 if read &gt; anchor: for digit in str(read - anchor + 1): chars[write] = digit write += 1 anchor = read + 1 return write 448由于一个数只可能出现一或两次，一个性质成立：当第$i$个位置上的数不是$i$的时候，这个位置上的数就缺失了。所以构造一个“排序”：对每一个$i$，如果$i$位置上的数不是$i$，而是$k$，就将$i$与$k$位置的数交换，直到这两个要交换的数相同为止。可以看出这个算法是线性的，因为一次交换就会导致一个数回到原来的位置，而只有$n$个位置，所以至多交换$n$次。1234567891011121314151617class Solution: def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ len1 = len(nums) for i in range(0, len1): while nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] lst = [] for i in range(0, len(nums)): if nums[i] != i + 1: lst.append(i + 1) return lst 453$n-1$个元素同时增相当于剩下一个元素自己相对其他减，当每一个数相对大小相等就停止。因此可以统计所有元素的和$sum$和找出最小元素$mini$，那么$sum-mini$就是答案。这是所有非最小元素“减到”和最小元素相同的次数。123456789101112class Solution: def minMoves(self, nums): """ :type nums: List[int] :rtype: int """ sum, mini = 0, 3000000000 for i in nums: sum += i if i &lt; mini: mini = i return sum - mini * len(nums) 455排序之后贪心，尽量给完。 458本质是进制问题，或者状态空间之类的。可以归纳。12345678910111213class Solution(object): def poorPigs(self, buckets, minutesToDie, minutesToTest): """ :type buckets: int :type minutesToDie: int :type minutesToTest: int :rtype: int """ if buckets == 1: return 0 tot, ans = minutesToTest // minutesToDie, 1 while (tot + 1) ** ans &lt; 1.0 * buckets: ans += 1 return ans 459可以枚举总长度的倍数然后看子串是不是能拼出总串。更快的方法是看原串是否可以通过循环移位得到。具体写法是：1return s in (s + s)[1: -1] 461异或然后统计1的个数。 475排序后贪心or二分。 476利用反码=补码-1。 479伪·正解直接输出答案。12345678class Solution: def largestPalindrome(self, n): """ :type n: int :rtype: int """ ans = [9, 987, 123, 597, 677, 1218, 877, 475] return ans[n - 1] 正解（这种方法来自这里） 可以发现，当$n&gt;1$的时候最大的回文乘积都是偶数长度的（因为最高位都可以是$9$）。设最大的回文乘积为$U\times 10 ^ n + D = M\times L$。那么可以看出$U$和$D$是顺序恰好相反的两个数。设$M = 10^n - i$，$L = 10^n - j$，那么$M\times L = 10^{2n} - (i + j) \times 10^n + ij$。如果$i\times j &lt; 10^n$（这表明$i$和$j$可以很小，而这个结论适用于$n&gt;1$），那么可以得到$U = 10^n - (i + j)$，$D = i \times j$。这样我们设$a = i + j$，然后求出$U$，再根据$D = i \times (a - i)$解出整数$i$，解出来就成功了！实际上这还不是最优的。通过实验可以发现当$n$是偶数的时候有确定的解，其中$i = 1, j = 10^{\frac{n}{2}} +1$。所以只要对$n$为奇数的情况求解即可。1234567891011121314151617181920class Solution: def largestPalindrome(self, n): """ :type n: int :rtype: int """ if n == 1: return 9 p = 1 for i in range(0, n): p *= 10 if n &amp; 1 == 0: return (p - 1) * (p - int(p ** 0.5) + 1) % 1337 for a in range(2, p): u = p - a l = int(str(u)[: : -1]) if a ** 2 - 4 * l &gt;= 0: i = a + (a ** 2 - 4 * l) ** 0.5 if i // 2 == i / 2: return (u * p + l) % 1337 482字符串模拟。 485水 496排序后从小到大，寻找每一个数$x$在原数组中右边的第一个元素，然后把$x$从原数组删去，如此反复。也可以维护一个递减的单调栈，从而得到答案。 507简单质因数分解。 617简单的递归合并。速度有点慢？ 628找最大的三个数和最小的两个数，取最大数和最小两数积与最大三数积更大者。 633方法一查表。12345678910111213141516class Solution: def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ list1 = [i * i for i in range(0, 65536)] i, j = 0, 65535 while 2 * i * i &lt;= c: while list1[j] &gt; c - i * i: j -= 1 if i * i + list1[j] == c: return True i += 1 return False 方法二双指针$l, r$，分别从$0$和$\sqrt{c}$向中间逼近。12345678910111213141516class Solution: def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ i, j = 0, int(c ** 0.5) + 1 while i &lt;= j: res = i * i + j * j if res == c: return True elif res &lt; c: i += 1 elif res &gt; c: j -= 1 return False 672找规律。本质是异或操作的叠加。 728一一判断。 746DP 754按奇偶性找规律，本质解方程。1234567891011121314151617181920class Solution: def reachNumber(self, target): """ :type target: int :rtype: int """ if target == 0: return 0 if target &lt; 0: target = -target l, r = 1, target while l &lt; r: mid = (l + r) &gt;&gt; 1 if target &lt;= mid * (mid + 1) // 2: r = mid else: l = mid + 1 return ((l + 1) &gt;&gt; 1) &lt;&lt; 1 | 1 if (((l + 1) &gt;&gt; 1) - target) &amp; 1 else l 829手推公式，发现可以做到$O(\sqrt{N})$。 867模拟 868水，可以看出python字符串很慢？ 877DP或者数学。因为先手必然可以取走所有编号奇偶性相同的堆，而编号全为奇数的堆总和和编号全为偶数的堆总和中必然有一个相对更大的，因此先手必胜。1return True # 就是这么自信。 884用Counter 888只要找一组解就很简单 893按下标奇偶性拆分字符串，排序后重组，再用set去重。 896水，可以遍历两遍或一遍，这取决于写法。 905双指针交换或者新开两个数组。 908找最小值$+K$和最大值$-K$之间关系。 914最大公约数。 917双指针 921直接对右括号进行匹配，然后剩余的左括号和右括号数目和就是答案。 922水 925字符串分段，比较段长。 932构造层级结构。可以发现一个数列A_n保持了这个性质，那么对A_n的每一项加（或者减）去一个定值或者乘上一个非零数也会保持这样一个性质。从而构造递归结构：基础：$n=2$，答案是$1, 2$。向上：$n=2^k\rightarrow n=2^{k+1}$，$n=2^k$时答案是A_k，$n=2^{k+1}$时答案是2A_k-1和2A_k相连接。1234567891011class Solution: def beautifulArray(self, N): """ :type N: int :rtype: List[int] """ lst, len1 = [1], 1 while len1 &lt; N: lst = [(i &lt;&lt; 1) - 1 for i in lst] + [i &lt;&lt; 1 for i in lst] len1 &lt;&lt;= 1 return [i for i in lst if i &lt;= N] 933模拟 937注意字母排序指的是对每一个字形成的列表进行字典序排序。 939暴力枚举矩阵的对角上两个点，然后查找能不能找到另外两个点。 941注意边界 942一种做法是求出相对高度数组。设第一个数的高度为$0$，维护当前最大上升量$up$和最大下降量$down$，遇到I则该位相对高度为$up$，并上升量$+1$，遇到D则该位相对高度为$down$，并下降量$-1$，如此可以保证每一位上的相对高度都不同，然后按照相对高度分配$0, 1, \cdots, n$即可。 944简单比较，注意这个题目中的有序指的是字母的ASCII码不递减。 946模拟出栈即可。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板 生成树]]></title>
    <url>%2F2018%2F11%2F15%2Ftemplate-spanning-tree%2F</url>
    <content type="text"><![CDATA[本文主要讨论生成树相关的算法。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU1686 Oulipo]]></title>
    <url>%2F2018%2F11%2F12%2Fhdu1686%2F</url>
    <content type="text"><![CDATA[题目链接 题解KMP模板题…1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;void build_fail(char *pat, int len, int *fail)&#123; fail[0] = -1; for(int i = 1, j = -1; i &lt; len; ++i)&#123; while(j &gt; -1 &amp;&amp; pat[i] != pat[j + 1]) j = fail[j]; if(pat[i] == pat[j + 1]) fail[i] = ++j; else fail[i] = -1; &#125;&#125;int KMP_match(char *text, int l1, char *pat, int l2, int *fail)&#123; int cnt = 0; for(int i = 0, j = -1; i &lt; l1; ++i)&#123; while(j &gt; -1 &amp;&amp; text[i] != pat[j + 1]) j = fail[j]; if(text[i] == pat[j + 1]) j++; if(j == l2 - 1) j = fail[j], cnt++; &#125; return cnt;&#125;int n, m, fail[10005] = &#123;0&#125;;char a[10005], b[1000005];int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%s%s", a, b); m = strlen(a), n = strlen(b); build_fail(a, m, fail); printf("%d\n", KMP_match(b, n, a, m, fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1711 Number Sequence]]></title>
    <url>%2F2018%2F11%2F12%2Fhdu1711%2F</url>
    <content type="text"><![CDATA[题目链接 题解对数字序列做一次KMP即可。12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;void build_fail(int *pat, int len, int *fail)&#123; fail[0] = -1; for(int i = 1, j = -1; i &lt; len; ++i)&#123; while(j &gt; -1 &amp;&amp; pat[i] != pat[j + 1]) j = fail[j]; if(pat[i] == pat[j + 1]) fail[i] = ++j; else fail[i] = -1; &#125;&#125;int KMP_match(int *text, int l1, int *pat, int l2, int *fail)&#123; for(int i = 0, j = -1; i &lt; l1; ++i)&#123; while(j &gt; -1 &amp;&amp; text[i] != pat[j + 1]) j = fail[j]; if(text[i] == pat[j + 1]) j++; if(j == l2 - 1) return i - l2 + 2; &#125; return -1;&#125;int n, m, a[1000005], b[10005], fail[10005] = &#123;0&#125;;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; m; ++i) scanf("%d", &amp;b[i]); build_fail(b, m, fail); printf("%d\n", KMP_match(a, n, b, m, fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 字符串]]></title>
    <url>%2F2018%2F11%2F11%2Ftemplate-string%2F</url>
    <content type="text"><![CDATA[字符串相关算法的模板。 KMP算法KMP算法的核心是后缀配对前缀，从而可以在配对失败的时候不用总是从头开始，而是从可以成功匹配的某一个前缀开始继续匹配。 KMP算法的匹配方式非常容易，但是需要预处理出一个next（或称fail）数组，表示匹配失败的时候跳转的位置。 若$m$是模板的长度，$n$是文本串的长度，那么时间复杂度：$O(m+n)$，空间复杂度：$O(m)$。123456789101112131415161718192021222324//构建fail数组void build_fail(char *pat, int len, int *fail)&#123; fail[0] = -1; for(int i = 1, j = -1; i &lt; len; ++i)&#123; while(j &gt; -1 &amp;&amp; pat[i] != pat[j + 1])//j+1表示当前模板串内要匹配的前缀的字符 j = fail[j]; if(pat[i] == pat[j + 1]) fail[i] = ++j; else fail[i] = -1; &#125;&#125;//匹配过程void KMP_match(char *text, int l1, char *pat, int l2, int *fail)&#123; for(int i = 0, j = -1; i &lt; l1; ++i)&#123; while(j &gt; -1 &amp;&amp; text[i] != pat[j + 1]) j = fail[j]; if(text[i] == pat[j + 1]) j++; if(j == l2 - 1)&#123; //do something... 因为你已经匹配到了。 &#125; &#125;&#125; 扩展KMP算法扩展KMP算法用于解决这样的问题：给定两个字符串$S$和$T$（长度分别为$n$和$m$），下标从$0$开始，定义$extend[i]$等$S[i…n-1]$与$T$的最长相同前缀的长度，求出所有的$extend[i]$。 解决这个问题需要引入一个额外的数组：$next[0…m-1]$，其中$next[i]$表示$T[i…m-1]$和$T$的最长公共前缀的长度。这个数组的用途先不说明，先直接考虑$extend$的求解过程。 假设$extend[0…i-1]$已经解决完成，那么现在考虑求出$extend[i]$。令$p = \max_\limits{1\le j &lt;i} {j + extend[j]}$，即为之前在$S$中已经匹配完成的最右边界。设$a$为取这个最大值的$j$，那么按照题目要求，有$T[0…p-a) = S[a…p)$。之后按照两种情况进行讨论： 如果$p - i &gt; next[i - a]$，那么由于$next$中保存的都是最长的长度，$extend[i]$不可能超过$next[i-a]$，故此时令$extend[i] = next[i - a]$。 如果$p - i = next[i - a]$，那么只能保证$S[i…p)$这一部分是$T$的前缀，这个时候需要暴力匹配。此时可以看出，在$extend[i]$被求出来之后，$p$和$a$的值都会被更新。 如果$p - i &lt; next[i - a]$，那么在2的基础上追加了$T[0…p-i]=T[i-a…p-a]$的条件，即得到$S[p] \neq T[p-a] \implies S[p]\neq T[p-i]$，此时令$extend[i] = p - i$即可。 这样我们就得到了$extend$数组的求解过程。而求解$next$数组的过程就是对$T$求$extend$的过程。 由于$p$是不降的，所以在匹配的时候最多会遍历一次$S$和$T$串，因此算法的时间复杂度是$O(m+n)$。 可以说这个算法虽然被称为扩展KMP算法，但内核思想却和manacher算法相近，都是利用了在特定情况下的重复信息。12]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板 线性基]]></title>
    <url>%2F2018%2F11%2F08%2Ftemplate-linear-basis%2F</url>
    <content type="text"><![CDATA[对线性基的一些认识。与线性代数不同的是，在这里，我们一般只研究异或这一运算。 概念]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 511 (Div. 2) 题解]]></title>
    <url>%2F2018%2F09%2F22%2Fcontest-cf1047%2F</url>
    <content type="text"><![CDATA[人傻题不会.jpg A题目链接 分类讨论。可以分成$(a, a, b)$的形式，但是实际上还是分成$(1, 1, n-2)$或者$(1, 2, n-3)$更快。我是很蠢的选了前者。12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int k = n / 3, p = n - k - k; if(k % 3 == 0) &#123; if(p % 3 == 1) k++, p -= 2; else k--, p += 2; &#125;else if(p % 3 == 0) &#123; if(k % 3 == 1) k++, p -= 2; else k--, p += 2; &#125; printf("%d %d %d\n", k, k, p); return 0;&#125; B题目链接 观察可以发现，直线方程可以写成$y=-x+d$。而直线过点的时候可以保证答案最小，所以只要计算所有点中横纵坐标和的最大值即可。12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int n, ans = 0;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)&#123; int x, y; scanf("%d%d", &amp;x, &amp;y); ans = max(ans, x + y); &#125; printf("%d\n", ans); return 0;&#125; C题目链接 先求出这个GCD，然后： 方法一对每一个数除掉GCD，这样新的GCD就变成了$1$。我们只要让去掉一些数之后GCD大于$1$即可。可以枚举小于等于N=\sqrt{\max \left\{a_n\right\} }的质数，然后对每一个数判断是不是这个质数的倍数。保证尽量多的数是某一个质数的倍数即可。本质上是做质因数分解。这么做会超时。 方法二在方法一的基础上变换思路，考虑所有大于GCD的数，利用埃氏筛法求出其倍数的个数，和答案比较。 方法三在方法一的基础上用线性筛优化质因数分解的过程。 在这一题中我们可以看出筛法和质因数分解之间的紧密联系，这对于某一类的数论题目很有启发意义。以下代码基于方法二。1234567891011121314151617181920212223242526272829303132#pragma G++ optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;int n, maxi = 0, mk[15000005] = &#123;0&#125;;bool vd[15000005] = &#123;0&#125;;int gcd(int x, int y)&#123; return (!y) ? x : gcd(y, x % y);&#125;int main()&#123; int g; scanf("%d%d", &amp;n, &amp;g); maxi = g, mk[g]++; for(int i = 2; i &lt;= n; ++i) &#123; int t; scanf("%d", &amp;t); if(g != 1) g = gcd(t, g); maxi = max(maxi, t); mk[t]++; &#125; int ans = n; for(int i = g + 1; i &lt;= maxi; ++i)&#123; if(!vd[i])&#123; int cnt = 0; for(int j = i; j &lt;= maxi; j += i) vd[j] = 1, cnt += mk[j]; ans = min(ans, n - cnt); &#125; &#125; if(ans == n) printf("-1\n"); else printf("%d\n", ans); return 0;&#125; D题目链接 可以发现在格子处于一定大小，如$1\times 6$和$2\times 4$$的时候是可以做到基本填满的。所以我们就可以把整个棋盘切成多个小格，用这些小格的答案作为基去凑出整个棋盘的答案。我用的$7\times 7$以下所有格子的答案作为基，用这个应该就够了。12]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块学习记录]]></title>
    <url>%2F2018%2F09%2F15%2Fwriting%2Fbuildblock%2F</url>
    <content type="text"><![CDATA[本文主要记录了我做题时对分块算法的一些感觉。分块在处理一些奇奇怪怪的区间处理问题时常常十分有用。 普通线性分块——以区间加法为例问题1：给出一个长度为$N$的序列，共有$M$个操作，操作为区间加法或者区间求和。 考虑将序列分成$T$块，每一块长均为$S = \frac{N}{T}$，然后处理一系列的操作。对于区间加法，我们分两种情况： 若目标区间长度不足一个块，则对区间内每一个元素进行暴力修改。 若区间跨了多个块，那么对区间内的所有完整的块进行遍历，依次打上加法标记；对于区间端点所在的两个块，只对其中在区间内的元素进行暴力修改，换言之，对左右两端两个不完整的块进行暴力修改。对于区间求和，同样分两种情况： 若目标区间长度不足一个块，则对区间内每一个元素进行暴力统计。 若区间跨了多个块，那么对区间内的所有完整的块进行遍历，依次累加上它们的和；对于区间端点所在的两个块，只对其中在区间内的元素进行暴力统计，换言之，对左右两端两个不完整的块进行暴力统计。 这么做的时间复杂度是$O(M(S+T))$。根据均值不等式，当$S=T=\sqrt{N}$时括号内的值最小。因此选择的块数和块长都为$\sqrt{N}$时可以做到理论上的时间复杂度最优。打标记的做法和线段树相似，因此扩展到区间乘法，区间赋值的时候可以依照线段树的规则进行扩展，原理则基本相同。事实上，这种分块方式是最常见的。有时会根据具体的算法调整块的大小已达到理论最优时间复杂度。 特殊线性分块1——使用特殊方法（数据结构）维护块问题2：题目链接 考虑分块，发现区间加法虽然好做，但是求区间有多少个满足条件的人是不好办的，只有序列有序的时候才可以用二分这样时间复杂度稍低的方法求出答案，但在执行了区间加法后有序性就有可能被破坏。继续观察可以发现，分块后区间加法导致有序性被破坏的情况只有“区间加法没有覆盖完整的一块”这一种情况。因此事先对每一个块内部排序，区间加法除按照之前所述方法进行外，还要对不完整的块打上一个“有序性破坏”的标记。区间查询时，对有序性存在的完整块直接二分出答案，对有序性被破坏的完整块先排序再求解，对不完整的块暴力统计。因为一个区间加法最多导致2个块的有序性被破坏，所以排序的总次数为$O(\sqrt{N} + Q)$，总时间复杂度为$O(n\log n + q \sqrt{N} \log n)$。 在这类问题中，某些操作不能使用打标记之类的简单，普适的方法去解决时，就可以考虑用其他一些高明的方法（在本题中表现为排序，有时也表现为用数据结构维护块）——毕竟分块本身就算的上是一种相当高明的暴力方法嘛。（当然，要看数据规模） 特殊线性分块2——块状链表和暴力重构问题3：题目链接 这个题目像是NOI2003 文本编辑器的弱化。事实上这个题目是可以用块状链表实现的，但因为这里是分块的讲解，所以还是考虑分块。由于本题的操作比较简单，就只有插入，所以可以直接用一个链表来模拟。将链表分成$O(\sqrt {N})$段，每一段都保存段的长度（因为段会因为插入而变长）和段的开头，在理想情况下可以利用长度在$O(\sqrt {N})$时间内找到插入的位置并且完成插入。询问同理。这样总时间复杂度就是$O(N\sqrt {N})$。但是数据经过特殊构造后可以形成一个段特别长的情况，此时分块链表退化成为普通链表，时间复杂度最坏会达到$O(N^2)$。为了避免这种情况，需要在插入达到一定次数之后及时对链表进行重构，即重新分块。令插入次数的限制为$O(\sqrt {N})$，因为重构花费的时间是$O(n)$，而每次重构之后插入的时间复杂度都会恢复为原来水平，因此重构+插入+询问的总时间复杂度就是$O(N\sqrt {N})$。 这类问题一般有着大量的插入和删除操作，对应的是链表这样能够快速执行插入和删除的链状结构，因此使用有着分块思想的块状链表可以快速准确的完成这些操作。同时当操作简单时直接对所有的块进行重构也是一个不错的选择。 特殊线性分块3——以区间众数为例特殊线性分块4——带修改分块]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国家集训队2009 小Z的袜子]]></title>
    <url>%2F2018%2F09%2F15%2Fluogu1494%2F</url>
    <content type="text"><![CDATA[题目链接 题解莫队算法的一个典型应用。对所有询问的左端点所在块的编号排序，块内对右端点排序，然后按顺序处理所有询问。由于$(l, r)$的情况可以在$O(1)$的情况下转移到$(l, r + 1), (l, r - 1), (l - 1, r), (l + 1, r)$的情况，因此根据一定的复杂度分析，该算法的时间复杂度是$O(n \sqrt{n})$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1e9using namespace std;typedef long long ll;struct Q&#123; ll l,r,sqi,id;&#125;;bool cmp(Q u,Q v)&#123; if(u.sqi==v.sqi)return u.r&lt;v.r; return u.sqi&lt;v.sqi;&#125;Q query[50005];ll a[50005],ans[50005][2],n,m,size;ll cnt[50005]=&#123;0&#125;,tot=0;ll sqr(ll t)&#123;return t*t;&#125; void update(ll o,ll id)&#123; tot-=sqr(cnt[a[id]]), cnt[a[id]]+=o, tot+=sqr(cnt[a[id]]);&#125;ll gcd(ll a,ll b)&#123; return (!b)?a:gcd(b,a%b);&#125;void init()&#123; ll i,j; scanf("%lld%lld",&amp;n,&amp;m); for(size=1;size*size&lt;n;size++); for(i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(i=1;i&lt;=m;i++) scanf("%lld%lld",&amp;query[i].l,&amp;query[i].r), query[i].sqi=(query[i].l-1)/size, query[i].id=i; sort(query+1,query+m+1,cmp);&#125;void solve()&#123; ll L=1,R=0,_l,_r,_id,fz,fm,p; for(int i=1;i&lt;=m;i++)&#123; _l=query[i].l,_r=query[i].r; _id=query[i].id; for(;R&lt;_r;R++) update(1,R+1); for(;R&gt;_r;R--) update(-1,R); for(;L&lt;_l;L++) update(-1,L); for(;L&gt;_l;L--) update(1,L-1); if(_l==_r)&#123; ans[_id][0]=0,ans[_id][1]=1; continue; &#125; fz=tot-(_r-_l+1),fm=(_r-_l+1)*(_r-_l); p=gcd(fm,fz); fz/=p,fm/=p; ans[_id][0]=fz,ans[_id][1]=fm; &#125; for(int i=1;i&lt;=m;i++) printf("%lld/%lld\n",ans[i][0],ans[i][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 教主的魔法]]></title>
    <url>%2F2018%2F09%2F15%2Fluogu2801%2F</url>
    <content type="text"><![CDATA[题目链接 题解分块。先分块，然后对每一个块内排序。修改时对于处于一个块内的暴力修改后重新排序，对于处于不同块的把最左最右两个不完整的块暴力修改，然后对中间的块打标记。查询时对整个块直接二分查询，对不完整的块就暴力查询。时间复杂度：$O(Q\sqrt{N} \log N)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,h[1000005],bid[1000005],siz;//偷懒的做法。int t[1005][1005],add[1005],vis[1005],S[1005]=&#123;0&#125;; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int query(int L,int R,int C)&#123; int ans=0; for(;bid[L]==bid[L-1];L++) if(h[L]&gt;=C-add[bid[L]])ans++; for(;bid[R]==bid[R+1];R--) if(h[R]&gt;=C-add[bid[R]])ans++; for(int i=bid[L];i&lt;=bid[R];i++)&#123; if(vis[i])&#123; for(int j=0;bid[L]==i;L++) t[i][j++]=h[L]; sort(t[i],t[i]+S[i]); ans+=(t[i]+S[i])-lower_bound(t[i],t[i]+S[i],C-add[i]); vis[i]=0; &#125;else ans+=(t[i]+S[i])-lower_bound(t[i],t[i]+S[i],C-add[i]); &#125; return ans;&#125;void update(int L,int R,int W)&#123; for(;bid[L]==bid[L-1];L++)h[L]+=W; vis[bid[L-1]]=1; for(;bid[R]==bid[R+1];R--)h[R]+=W; vis[bid[R+1]]=1; for(int i=bid[L];i&lt;=bid[R];i++) add[i]+=W;&#125;void init()&#123; n=read(),m=read(); for(siz=1;siz*siz&lt;n;siz++); for(int i=1;i&lt;=n;i++) h[i]=read(), bid[i]=(i-1)/siz+1, S[bid[i]]++; bid[n+1]=siz+1;&#125;void solve()&#123; int x,y,z; char ord[3]; fill(vis+1,vis+siz+1,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%s%d%d%d",ord,&amp;x,&amp;y,&amp;z); if(ord[0]=='A') printf("%d\n",query(x,y,z)); else update(x,y,z); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨氏矩阵和勾长公式]]></title>
    <url>%2F2018%2F09%2F11%2Fyoung-tableau%2F</url>
    <content type="text"><![CDATA[本文讨论杨氏矩阵以及和其密切相关的勾长公式。 杨氏矩阵]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ2279 Mr. Young's Picture Permutations]]></title>
    <url>%2F2018%2F09%2F11%2Fpoj2279%2F</url>
    <content type="text"><![CDATA[题目链接 题解容易发现最高的人只能站在最左上角，然后后面的人从高到低必须要站在已经有的人的附近，不然就不合法。以此为依据，以人数为阶段，每一排的人数为状态转移即可。可以使用队列保证状态转移顺序正确。事实上这个题考的是一个叫做杨氏矩阵的数据结构，另外一篇文章里会介绍。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef unsigned int ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int k, n[6], g;ll f[32][32][32][32][32];int que[500000][5], l, r, cur[6];bool vis[32][32][32][32][32];void init()&#123; g = 0; for(int i = 0; i &lt; k; ++i) n[i] = read(), g += n[i]; for(int i = k; i &lt; 5; ++i) n[i] = 0; sort(n, n + 5); reverse(n, n + 5);&#125;void solve()&#123; memset(vis, 0, sizeof(vis)); f[0][0][0][0][0] = 1; vis[0][0][0][0][0] = true; l = 0, r = 1; for(int i = 0; i &lt; 5; ++i) que[0][i] = 0; ll ans = 0; while(r - l)&#123; int sum = 0; for(int i = 0; i &lt; 5; ++i) cur[i] = que[l][i], sum += cur[i]; l++; if(sum == g)&#123; ans += f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]]; continue; &#125; for(int i = 0; i &lt; k; ++i)&#123; if(cur[i] &lt; n[i] &amp;&amp; (i == 0 || cur[i - 1] &gt; cur[i]))&#123; int addi = f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]]; cur[i]++; if(!vis[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]])&#123; f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] = 0; for(int j = 0; j &lt; k; ++j) que[r][j] = cur[j]; for(int j = k; j &lt; 5; ++j) que[r][j] = 0; r++; vis[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] = 1; &#125; f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] += addi; cur[i]--; &#125; &#125; &#125; printf("%u\n", ans);&#125;int main()&#123; while(k = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1434]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu1434%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[luogu2909]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2909%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[AHOI2005 矿藏编码]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2539%2F</url>
    <content type="text"><![CDATA[题目链接 题解标准的递归定义。按照递归定义处理即可。答案很大，要用int128或者double。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef __int128 ll;int n;ll ans = 0;void init()&#123; scanf("%d", &amp;n);&#125;void get(ll d)&#123; int p; scanf("%1d", &amp;p); if(p == 0) ans += d * d; else if(p == 2)&#123; for(int i = 0; i &lt; 4; ++i) get(d &gt;&gt; 1); &#125;&#125;void solve()&#123; ll a = 1; for(int i = 1; i &lt;= n; ++i) a *= 2ll; get(a); int num[50], len = 0; while(ans) num[++len] = ans % 10, ans /= 10; for(int i = len; i &gt;= 1; --i) printf("%d", num[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2005 位图]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2335%2F</url>
    <content type="text"><![CDATA[题目链接 题解从每一个白块周围扩展即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, mp[155][155], ans[155][155];int que[22505][2], r, l;int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;;void init()&#123; n = read(), m = read(); memset(ans, -1, sizeof(ans)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) mp[i][j] = read(); r = l = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j)&#123; if(mp[i][j]) ans[i][j] = 0; else&#123; for(int k = 0; k &lt; 4; ++k)&#123; int ex = i + dx[k], ey = j + dy[k]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; mp[ex][ey])&#123; que[r][0] = i, que[r++][1] = j; ans[i][j] = 1; break; &#125; &#125; &#125; &#125;&#125;void solve()&#123; while(r - l)&#123; int cx = que[l][0], cy = que[l++][1]; for(int i = 0; i &lt; 4; ++i)&#123; int ex = cx + dx[i], ey = cy + dy[i]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; ans[ex][ey] &lt; 0)&#123; ans[ex][ey] = ans[cx][cy] + 1; que[r][0] = ex, que[r++][1] = ey; &#125; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m - 1; ++j) printf("%d ", ans[i][j]); printf("%d\n", ans[i][m - 1]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06FEB Stall Reservations]]></title>
    <url>%2F2018%2F09%2F02%2Fluogu2859%2F</url>
    <content type="text"><![CDATA[题目链接 题解线段覆盖类型的题目。先对端点排序，然后从左到右扫描，对线段依次分配。用一个堆来管理空出来的牛棚。当端点重合时先分配再释放。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;struct Q&#123; int id, x;&#125;;struct cmp&#123; bool operator ()(const Q&amp; q1, const Q&amp; q2)&#123; return q1.x &lt; q2.x; &#125;&#125;;int n, l[50005], r[50005], ans[50005] = &#123;0&#125;;Q q[100005];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) l[i] = read(), r[i] = read(), q[i &lt;&lt; 1].id = q[i &lt;&lt; 1 | 1].id = i, q[i &lt;&lt; 1].x = l[i], q[i &lt;&lt; 1 | 1].x = r[i]; sort(q, q + n + n, cmp());&#125;void solve()&#123; int ans_ = 0; for(int i = 0; i &lt; n + n; )&#123; int j; for(j = i; j &lt; n + n &amp;&amp; q[j].x == q[i].x; ++j) if(!ans[q[j].id]) &#123; if(pq.empty()) ans_++, ans[q[j].id] = -ans_; else ans[q[j].id] = -pq.top(), pq.pop(); &#125; for(j = i; j &lt; n + n &amp;&amp; q[j].x == q[i].x; ++j)&#123; if(ans[q[j].id] &lt; 0) ans[q[j].id] = -ans[q[j].id]; else pq.push(ans[q[j].id]); &#125; i = j; &#125; printf("%d\n", ans_); for(int i = 0; i &lt; n; ++i) printf("%d\n", ans[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09DEC Selfish Grazing]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu2970%2F</url>
    <content type="text"><![CDATA[题目链接 题解贪心入门题。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[50005];int main()&#123; int n,i,j,u,v,ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d%d",&amp;u,&amp;v), p[i].first=v,p[i].second=u; sort(p,p+n); ans++,u=p[0].second,v=p[0].first; for(i=1;i&lt;n;)&#123; while(i&lt;n&amp;&amp;p[i].second&lt;v) i++; if(i==n)break; ans++,u=p[i].second,v=p[i].first; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12NOV Clumsy Cows]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu3056%2F</url>
    <content type="text"><![CDATA[题目链接 题解先把能配对的配掉，然后因为剩下的长度一定是偶数，所以可以根据左边)的数目和右边(的数目判断答案。当两者均为偶数时两边各改一半即可，均为奇数则分割处的)(要改成()，之后就转化为偶数的情况。123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[100005];void init()&#123; scanf("%s", s);&#125;void solve()&#123; int l = 0, r = 0, len = strlen(s); for(int i = 0; i &lt; len; ++i)&#123; if(s[i] == '(') l++; else&#123; if(l) l--; else r++; &#125; &#125; printf("%d\n", ((l + 1) &gt;&gt; 1) + ((r + 1) &gt;&gt; 1));&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17FEB Why Did the Cow Cross the Road II S]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu3662%2F</url>
    <content type="text"><![CDATA[题目链接 题解记录每一个长为$k$的一段中有几个坏灯，找出答案。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;bool vis[100005] = &#123;0&#125;;int n, k, b;void init()&#123; scanf("%d%d%d", &amp;n, &amp;k, &amp;b); for(int i = 0; i &lt; b; ++i)&#123; int t; scanf("%d", &amp;t); vis[t] = true; &#125;&#125;void solve()&#123; int cnt = 0, ans = n; for(int i = 1; i &lt;= k; ++i) if(vis[i]) cnt++; for(int i = k; i &lt;= n; ++i)&#123; ans = min(ans, cnt); if(!ans) break; if(vis[i - k + 1]) cnt--; if(vis[i + 1]) cnt++; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08JAN Cow Contest]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu2419%2F</url>
    <content type="text"><![CDATA[题目链接 题解用Floyd算法补全胜负关系，然后如果能够确定一个牛对所有其他牛的胜负关系就认为名次可确认。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, d[105][105];void init()&#123; memset(d, -1, sizeof(d)); n = read(), m = read(); for(int i = 0; i &lt; m; ++i)&#123; int u = read(), v = read(); d[u][v] = 1, d[v][u] = 0; &#125; for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) if(d[i][k] != -1 &amp;&amp; d[k][j] != -1 &amp;&amp; d[i][k] == d[k][j]) d[i][j] = d[i][k];&#125;void solve()&#123; int ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; int w = 0, f = 0; for(int j = 1; j &lt;= n; ++j) if(d[i][j] == 1) w++; else if(d[i][j] == 0) f++; if(w + f == n - 1) ans++; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1574]]></title>
    <url>%2F2018%2F08%2F31%2Fluogu1574%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[POJ2689 Prime Distance]]></title>
    <url>%2F2018%2F08%2F31%2Fpoj2689%2F</url>
    <content type="text"><![CDATA[题目链接 题解区间筛质数模板题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;unsigned int L, R, prime[35005], cnt = 0;bool vis1[70005] = &#123;0&#125;, vis2[1000005] = &#123;0&#125;;void getP()&#123; vis1[1] = true; for(int i = 2; i &lt;= 65536; ++i) if(!vis1[i])&#123; for(int j = i + i; j &lt;= 65536; j += i) vis1[j] = true; prime[++cnt] = i; &#125;&#125;void init()&#123; if(L &lt;= 1) L = 2; for(int i = 1; i &lt;= cnt; ++i)&#123; unsigned int p = prime[i]; if(R &lt; p) break; for(unsigned int j = max((L - 1 + p) / p, 2u); j &lt;= R / p; ++j) vis2[j * p - L] = 1; &#125;&#125;void solve()&#123; unsigned int lst = 0, mind = 1000001, maxd = 0; pair&lt;int, int&gt; ans1, ans2; for(unsigned int i = L; i &lt;= (unsigned int)R; ++i)&#123; if(!vis2[i - L])&#123; if(lst &gt; 0)&#123; if(i - lst &lt; mind)&#123; mind = i - lst; ans1.first = lst, ans1.second = i; &#125; if(i - lst &gt; maxd)&#123; maxd = i - lst; ans2.first = lst, ans2.second = i; &#125; &#125; lst = i; &#125; &#125; if(!maxd) printf("There are no adjacent primes.\n"); else printf("%d,%d are closest, %d,%d are most distant.\n", ans1.first, ans1.second, ans2.first, ans2.second); memset(vis2, 0, sizeof(vis2));&#125;int main()&#123; getP(); while(scanf("%d%d", &amp;L, &amp;R) == 2)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2005 午餐]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2577%2F</url>
    <content type="text"><![CDATA[题目链接 题解按时间DP。如果只有一个窗口那就是贪心了，按照吃饭时间从大到小排即可。两个窗口就DP，设$f[i][j]$表示前$i$个人在窗口1花了$j$时间打饭，最短的用餐时间。这样的话就可以转移了。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;pair&lt;int,int&gt; P[205];int n,A[205],B[205],f[205][40005],sum[205];int cmp(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b)&#123; return a.second&gt;b.second;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)P[i].first=read(),P[i].second=read(); sort(P+1,P+n+1,cmp); for(int i=1;i&lt;=n;i++)A[i]=P[i].first,B[i]=P[i].second; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+A[i];&#125;void solve()&#123; memset(f,0x3f,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;=sum[i-1];j++)&#123;//只有这段时间有意义 f[i][j]=min(f[i][j],max(f[i-1][j],sum[i-1]-j+A[i]+B[i])); f[i][j+A[i]]=min(f[i][j+A[i]],max(f[i-1][j],j+A[i]+B[i])); &#125; &#125; int ans=INF; for(int i=0;i&lt;=sum[n];i++)ans=min(ans,f[n][i]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI2016初中组 迷宫]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2778%2F</url>
    <content type="text"><![CDATA[题目链接 题解大部分人是用几何性质去枚举的。标算貌似用了线性求LCA，常数很大的样子。我是暴力建树，然后用了类似于LCA的方法求最长公共路径，然后再求不同的路。本质上可能是一样的，不过我这个居然更快？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,x_1,x_2,y_1,y_2,par[8005],son[8005],bro[8005];int cx,cy,rec[2][8005],tot[2]=&#123;0&#125;;struct C&#123; int id,x,y,r; bool operator&lt;(C c)&#123; return r&gt;c.r; &#125;&#125;;C cir[8005];void dfs(int id,int o)&#123; int dx,dy,dr; for(int i=son[id];i!=-1;i=bro[i])&#123; dx=cir[i-1].x,dy=cir[i-1].y,dr=cir[i-1].r; if((cx-dx)*(cx-dx)+(cy-dy)*(cy-dy)&lt;=dr*dr)&#123; rec[o][tot[o]++]=id; dfs(i,o); return ; &#125; &#125; rec[o][tot[o]++]=id; return ;&#125;void insert_(int cur,int id)&#123; int dx,dy,dr; for(int i=son[cur];i!=-1;i=bro[i])&#123; dx=cir[i-1].x,dy=cir[i-1].y,dr=cir[i-1].r; if((cx-dx)*(cx-dx)+(cy-dy)*(cy-dy)&lt;=dr*dr)&#123; insert_(i,id); return ; &#125; &#125; par[id]=cur,bro[id]=son[cur], son[cur]=id;&#125;void init()&#123; memset(son,-1,sizeof(son)); memset(par,-1,sizeof(par)); memset(bro,-1,sizeof(bro)); int i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d%d%d",&amp;cir[i].x,&amp;cir[i].y,&amp;cir[i].r); sort(cir,cir+n); scanf("%d",&amp;m); //建树 for(i=0;i&lt;n;i++) cx=cir[i].x,cy=cir[i].y, insert_(0,i+1);&#125;void solve()&#123; int i,j,lim,ans; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d",&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); tot[0]=tot[1]=0; cx=x_1,cy=y_1,dfs(0,0); cx=x_2,cy=y_2,dfs(0,1); lim=min(tot[0],tot[1]); for(j=0;j&lt;lim;j++) if(rec[0][j]!=rec[1][j])break; ans=tot[0]+tot[1]-2*j; printf("%d\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI2009 中国象棋]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2051%2F</url>
    <content type="text"><![CDATA[题目链接 题解不好形容的DP。设$f(i,j,k)$表示当前在第$i$行，有$j$列没炮，$k$列$1$个炮。就可以愉快的转移了。转移的时候注意系数。（也就是组合数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define Mod 9999973llusing namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll n,m,f[105][105][105]=&#123;0&#125;;//f(i,j,k) 第i行 j列0个 k列1个 void init()&#123; n=read(),m=read(); f[1][m][0]=1,f[1][m-1][1]=m; if(m!=1)f[1][m-2][2]=m*(m-1)/2;&#125;void solve()&#123; for(int i=2;i&lt;=n;i++) for(ll j=0;j&lt;=m;j++) for(ll k=0;k+j&lt;=m;k++)&#123; f[i][j][k]+=f[i-1][j][k]; if(k&gt;=2)f[i][j][k]+=f[i-1][j+2][k-2]*(j+2)*(j+1)/2; if(j+1&lt;=m)f[i][j][k]+=f[i-1][j+1][k]*(j+1)*k; if(k+2&lt;=m)f[i][j][k]+=f[i-1][j][k+2]*(k+2)*(k+1)/2; if(k&gt;=1)f[i][j][k]+=f[i-1][j+1][k-1]*(j+1); if(k+1&lt;=m)f[i][j][k]+=f[i-1][j][k+1]*(k+1); f[i][j][k]%=Mod; &#125; ll ans=0; for(int j=0;j&lt;=m;j++) for(int k=0;k+j&lt;=m;k++) ans=(ans+f[n][j][k])%Mod; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1984]]></title>
    <url>%2F2018%2F08%2F30%2Fwriting%2Fluogu1984%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[USACO13JAN Painting the Fence]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2205%2F</url>
    <content type="text"><![CDATA[题目地址 题解对线段左右端点坐标排序，模拟加入和删除线段，同时维护线段覆盖层数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;bool in[100005] = &#123;0&#125;;int n, k, ans = 0;pair&lt;int, int&gt; p[200005];void init()&#123; n = read(), k = read(); char ord[3]; for(int i = 0, cur = 0; i &lt; n; ++i)&#123; int st; scanf("%d%s", &amp;st, ord); if(ord[0] == 'R') p[i &lt;&lt; 1].first = cur, p[i &lt;&lt; 1 | 1].first = cur + st, cur += st; if(ord[0] == 'L') p[i &lt;&lt; 1].first = cur, p[i &lt;&lt; 1 | 1].first = cur - st, cur -= st; p[i &lt;&lt; 1].second = p[i &lt;&lt; 1 | 1].second = i; &#125; sort(p, p + n + n);&#125;void solve()&#123; int cnt = 1, lst = p[0].first; in[p[0].second] = 1; for(int i = 1; i &lt; n + n; ++i)&#123; int id = p[i].second; if(cnt &gt;= k) ans += p[i].first - lst; if(!in[id]) in[id] = 1, cnt++; else in[id] = 0, cnt--; lst = p[i].first; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI2009 中位数]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu1627%2F</url>
    <content type="text"><![CDATA[题目链接 题解设$b$所在位置是$k$，那么对于$k$及$b$左边的所有位置求一个$d[i]$，表示$i$到$k-1$有几个小于$b$的数。那么对于$k$及其右边的位置$j$我们定义$d[j]$为$k+1$到$j$有几个小于$b$的数，这样对于一个$j$我们想要找到所有的$i$，使得 d[j]+d[i]=j-k-d[j]+k-i-d[i]整理为 2d[j]-j=-i-2d[i]用map实现。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;map&lt;int, int&gt; mp;int n, a[100005], b, k, ans = 0;void init()&#123; n = read(), b = read(); for(int i = 1; i &lt;= n; ++i)&#123; a[i] = read(); if(a[i] == b) k = i; &#125;&#125;void solve()&#123; int cnt = 0; for(int i = k; i &gt;= 1; --i)&#123; if(a[i] &lt; b) cnt++; mp[0 - i - 2 * cnt]++; &#125; cnt = 0; for(int i = k; i &lt;= n; ++i)&#123; if(a[i] &lt; b) cnt++; ans += mp[2 * cnt - i]; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHOI2002 百事世界杯之旅]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu1291%2F</url>
    <content type="text"><![CDATA[题目地址 题解]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3917 异或序列]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu3917%2F</url>
    <content type="text"><![CDATA[题目链接 题解考虑每一位的贡献，发现每一个数包括它自己在内，向左不断异或得到的$1$的个数是可以递推的，而这个数这一位的贡献次数就等于它左边的数的个数$+1$，于是就可以做了。某种意义上的前缀和。事实上可以当作前缀和来做。一般这种奇怪的位运算题都要分别考虑贡献1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll sum = 0;int n, a[100005], cntl[100005];void init()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read();&#125;void solve()&#123; cntl[0] = 0; for(int i = 1, j = 0; j &lt; 30; i &lt;&lt;= 1, ++j)&#123; for(int k = 1; k &lt;= n; ++k) if(a[k] &amp; i) cntl[k] = k - cntl[k - 1], sum += 1ll * i * cntl[k]; else cntl[k] = cntl[k - 1], sum += 1ll * i * cntl[k]; &#125; printf("%lld\n", sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2016 食物链]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu3183%2F</url>
    <content type="text"><![CDATA[题目链接 题解拓扑排序即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;typedef struct&#123; int v,_next; &#125;Edge; Edge edge[200005];int cnt=0,at[100005],ru[100005]=&#123;0&#125;,V,E,ans[100005]=&#123;0&#125;;int q[100005],f=0,r=0;void addedge(int _u,int _v)&#123; edge[cnt].v=_v, ru[_v]++, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; void init()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,u,v; memset(at,-1,sizeof(at)); for(i=0;i&lt;E;i++) scanf("%d%d",&amp;u,&amp;v), addedge(u-1,v-1);&#125;void solve()&#123; int Ans=0; for(int i=0;i&lt;V;i++) if(!ru[i]&amp;&amp;at[i]!=-1) ans[i]=1,q[r++]=i; while(r-f)&#123; int h=q[f++],i,_v; for(i=at[h];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v; ru[_v]--; ans[_v]+=ans[h]; if(!ru[_v]) q[r++]=_v; &#125; &#125; for(int i=0;i&lt;V;i++) if(at[i]==-1) Ans+=ans[i]; printf("%d\n",Ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1724 Ellipse]]></title>
    <url>%2F2018%2F08%2F30%2Fhdu1724%2F</url>
    <content type="text"><![CDATA[题目链接 题解可以直接用数值积分，也可以查积分表。 (\frac {x}{2}\sqrt{a^2 - x ^2}+\frac {a^2}{2}\arcsin {\frac{x}{a}})' = \sqrt{a^2 - x^2}123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std; double a, b, L, R;void init()&#123; scanf("%lf%lf%lf%lf", &amp;a, &amp;b, &amp;L, &amp;R);&#125;double FF(double x)&#123; return b * (x * sqrt(a * a - x * x) / 2 + a * a * asin(x / a) / 2) / a;&#125;void solve()&#123; if(L &lt; -a) L = -a; if(R &gt; a) R = a; printf("%.3lf\n", (FF(R) - FF(L)) * 2);&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3908 异或之和]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu3908%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一对每一位统计这一位上有多少个1。1234567891011121314151617181920212223#include &lt;iostream&gt;#define INF 2000000000using namespace std;typedef unsigned long long ll;ll n;void init()&#123; cin &gt;&gt; n;&#125;void solve()&#123; ll t = n, ans = 0; for(ll c = 1; ; c &lt;&lt;= 1)&#123; ll cnt = c * ((t / c + 1) &gt;&gt; 1) + (t % c) * ((t / c + 1) &amp; 1); if(cnt &amp; 1) ans |= c; if(t &gt; c) t -= c; else break; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; 方法二两个相邻（从0,1开始）的数异或必然为1。所以统计一下即可。如果$n$是偶数只要在$n$是奇数的情况上异或即可。]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2388 阶乘之乘]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu2388%2F</url>
    <content type="text"><![CDATA[题目链接 题解可以知道阶乘$n!$中因子$p$的次数是 \sum_{k = 1} \lfloor \frac{n}{p^k}\rfloor而末尾$0$的个数就要看因子$10$的次数，而$10$的次数要看$2$和$5$的次数。因为本题中容易看出$2$的次数远大于$5$的次数，所以只要算出后者即可。这里我用了一点等差数列的技巧。。。123456789101112131415161718192021#include &lt;cstdio&gt;#define INF 2000000000using namespace std;typedef long long ll;ll n;void init()&#123; scanf("%lld", &amp;n);&#125;void solve()&#123; ll n5 = 0; for(ll i = 5; i &lt;= n; i *= 5)&#123; ll clos = (n % i == i - 1) ? n : (n - (n + 1) % i); n5 += ((clos + 1) / i - 1) * (clos + 1) / 2 + (n - clos) * (clos + 1) / i; &#125; printf("%lld\n", n5);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 高精度整数]]></title>
    <url>%2F2018%2F08%2F29%2Ftemplate-biginteger%2F</url>
    <content type="text"><![CDATA[高精度整数运算的模板。为了节省空间，此处不将运算封装成为一个类。 字符串变为高精度数高精度整数用的比较多的是将大数变成一个万进制数，用一个数组储存。数组的第一位为万进制数的长度。1234567891011int ten[] = &#123;1, 10, 100, 1000&#125;;inline void clearZero(int *bi)&#123; while(bi[0] &amp;&amp; !bi[bi[0]]) --bi[0];&#125;void build(char *src, int *dst)&#123; int len = strlen(src); dst[0] = (len - 1) / 4 + 1; for(int i = len - 1, j = 0; i &gt;= 0; --i, ++j) dst[(j &gt;&gt; 2) + 1] = (src[i] - '0') * ten[j &amp; 3]; clearZero(dst);&#125; 高精度比较和字符串比大小差不多。1234567891011121314151617181920//前者小于后者？bool cmp1(int *s1, int *s2)&#123; if(s1[0] != s2[0]) return s1[0] &lt; s2[0]; for(int i = s1[0]; i &gt;= 1; --i) if(s1[i] != s2[i]) return s1[i] &lt; s2[i]; return false;&#125;//小于等于bool cmp2(int *s1, int *s2)&#123; if(s1[0] != s2[0]) return s1[0] &lt; s2[0]; for(int i = s1[0]; i &gt;= 1; --i) if(s1[i] != s2[i]) return s1[i] &lt; s2[i]; return true;&#125;//等于bool cmp3(int *s1, int *s2)&#123; for(int i = 0; i &lt;= s1[0]; ++i) if(s1[i] != s2[i]) return false; return true;&#125; 高精度加法从最低位开始加，一直加到更大数的最高位。1234567void add(int *s1, int *s2, int *dst)&#123; int len = max(s1[0], s2[0]), x = 0; dst[0] = len; for(int i = 1; i &lt;= len; ++i) x += s1[i] + s2[i], dst[i] = x % 10000, x /= 10000; if(x &gt; 0) dst[++dst[0]] = x;&#125; 如果不支持不停的memset那就改写成这样：123456789101112void add(int *s1, int *s2, int *dst)&#123; int len1 = max(s1[0], s2[0]), len2 = s1[0] + s2[0] - len1, x = 0; dst[0] = len1; int *smax; if(s1[0] == len1) smax = s1; else smax = s2; for(int i = 1; i &lt;= len2; ++i) x += s1[i] + s2[i], dst[i] = x % 10000, x /= 10000; for(int i = len2 + 1; i &lt;= len1; ++i) x += smax[i], dst[i] = x % 10000, x /= 10000; if(x &gt; 0) dst[++dst[0]] = x;&#125; 高精度减法默认为$a-b$，因为负数不太好实现。 高精度乘法乘一个小于10000的数乘一个大数高精度左移直接执行对该数乘上2。 高精度幂高精度除法高精度开方高精度GCD直接使用Stein算法。void gcd(int s1, int s2, int *dst){ dst[0] = dst[1] = 1;}]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BJWC2008 雷涛的小猫]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu1107%2F</url>
    <content type="text"><![CDATA[题目链接 题解水DP记录每一层的最大值用于优化转移。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, h, d, dp[2005][2005] = &#123;0&#125;, maxi[2005] = &#123;0&#125;, cnt[2005][2005] = &#123;0&#125;;void init()&#123; n = read(), h = read(), d = read(); for(int i = 0; i &lt; n; ++i)&#123; int ni = read(); for(int j = 0; j &lt; ni; ++j) cnt[i][read()]++; &#125;&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i) dp[i][h] = cnt[i][h], maxi[h] = max(maxi[h], cnt[i][h]); for(int i = h - 1; i &gt;= 0; --i) for(int j = 0; j &lt; n; ++j)&#123; dp[j][i] = dp[j][i + 1]; if(h - i &gt;= d) dp[j][i] = max(dp[j][i], maxi[i + d]); dp[j][i] += cnt[j][i]; maxi[i] = max(maxi[i], dp[j][i]); &#125; printf("%d\n", maxi[0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数降幂定理]]></title>
    <url>%2F2018%2F08%2F28%2Fproblem-eulerjiangmi%2F</url>
    <content type="text"><![CDATA[问题证明： a^x \equiv a^{x\mod \phi(c) + \phi(c)} \pmod c \quad (x\ge \phi(c))求解容易知道，数列$a^0, a^1, a^2, …, a^x,…$一定有一段长度不超过$c$的循环节。设这段循环节从$r$开始，长度为$l$，那么$a^r \equiv a^{r+l} \pmod c$。而定理中有一个$\mod \phi(c)$，这提示我们考虑循环的性质。根据定理，我们不妨猜想$\phi(c)$就是一个循环节的长度的倍数，即$l\mid \phi(c)$，并且从数列的前$\phi(c)$项中的某一项开始就已经开始循环了。首先对于$r$有2个性质： 数列前$r$项和后面所有项分别处于两个不同的集合中。因为如果两个集合相交，那么说明可以改变$r$的大小使得两个集合不相交，这样就不符合循环从$r$开始。 前$r$项没有重复的项。因为如果有，说明循环在$r$之前就已经开始，这也不符合$r$的定义。 对于$\gcd(a, c) = 1$的情况，由于欧拉定理，该式子显然成立。对于其他更为平凡的情况，则有： $a$是质数，则$a\mid c$。则设$c=ka^e$，则$\phi(c)=\phi(k) \times a^{e-1}\times (a-1)$。则$a^{\phi(k)} \equiv 1 \pmod k$，则$a^{\phi(c)} \equiv 1 \pmod k$。令$a^{\phi(c)}=sk + 1$，则$a^{\phi(c)+e}=ska^e+a^e=sc+a^e$，即$a^{e+\phi(c)} \equiv a^e \pmod c$。因此可知$r\le e$。易证$\phi(c)\ge e$。（考虑构造不等式） $a$是质数的幂，则设$a=p^e$，$c=kp^w$。则$\phi(c)=\phi(k)\times p^{w-1}\times (p-1)$。则$p^{\phi(k)} \equiv 1 \pmod k$，则$p^{\phi(c) \frac{e}{\gcd(e, \phi(c))}} \equiv 1 \pmod k$。令$l’ = \frac{\phi(c)}{\gcd(e, \phi(c))}$,$p^{e l’}=sk+1$，则$p^{(l’+w)e }=a^{w+l’}=skp^{ew}+p^{ew}=sp^{(e-1)w}c+a^w$，即$a^{w+l’} \equiv a^w \pmod c$。因此可知$r\le w$，$l’\mid \phi(c)$，即$\phi(c)$可以构成一个周期。同样，易证$\phi(c)\ge w$。（考虑构造不等式） $a$是2个质数的幂的积，则设a=p_1^{e_1} p_2^{e_2}，那么由2可得p_1^{e_1 (w_1+\phi(c))} \equiv p_1^{e_1 w_1}\pmod c,p_2^{e_2 (w_2+\phi(c))} \equiv p_2^{e_2 w_2} \pmod c。对前一个式子两边乘以p_1^{e_1 w_2}，对后一个式子两边乘上p_2^{e_2 w_1}，将两个式子合并就有a^{w_1+w_2+\phi(c)} \equiv a^{w_1+w_2} \pmod c。同样，令c=kp_1^{w_1}p_2^{w_2}，就有\phi(c)=\phi(k)\times p_1^{w_1 - 1} \times (p_1 - 1) \times p_2^{w_2 - 1} \times (p_2 - 1)，因此利用上式即可证明w_1 + w_2 \le \phi(c)。 $a$为多个质数的幂的积，则依照3进行即可。 由此就完成了证明。（如果证错了请和我说！） 参考资料]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTSC2014 企鹅QQ]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4503%2F</url>
    <content type="text"><![CDATA[题目链接 题解裸hash的命中率太低了。还是要开unsigned long long，而且要搞2个模数。反正大概就是枚举删去哪一位，然后排序找不同。千万不要用传统的Hash，会疯狂wa。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define INF 2000000000#define P 390791ull#define P_ 323591ullusing namespace std;typedef unsigned long long ll;int n,L,S,ans=0,cnt[11179120]=&#123;0&#125;;ll hsh[11179120]=&#123;0&#125;,ppow1[306],ppow2[306],H[30005],T[30005];bool vis[11179120]=&#123;0&#125;;char Str[30005][205];ll Hash(char *s)&#123; ll resa=0,resb=0; //给某一个特殊位置赋值0 for(int i=0;i&lt;L;i++) resa=P*resa+s[i],resb=P_*resb+s[i]; resa+=resb; return resa;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),L=read(),S=read(); ppow1[0]=ppow2[0]=1; for(int i=1;i&lt;=L;i++) ppow1[i]=ppow1[i-1]*P,ppow2[i]=ppow2[i-1]*P_;&#125;void solve()&#123; int tmp; ll valu; for(int i=1;i&lt;=n;i++) scanf("%s",Str[i]), H[i]=Hash(Str[i]); for(int j=0;j&lt;L;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; valu=H[i],valu-=Str[i][j]*ppow1[L-j-1], valu-=Str[i][j]*ppow2[L-j-1]; T[i]=valu; &#125; sort(T+1,T+n+1); int cur=1; for(int i=2;i&lt;=n;i++)&#123; if(T[i]==T[i-1])ans+=cur,cur++; else cur=1; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>CTSC</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3884 上帝与集合的正确用法]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4139%2F</url>
    <content type="text"><![CDATA[题目链接 题解直接上欧拉定理降幂公式。 a^x \equiv a^{x\mod \phi(c) + \phi(c)} \pmod c \quad (x\ge \phi(c))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll P,phi[10000005]=&#123;0&#125;;ll Pow(ll a,ll b,ll c)&#123; a%=c; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll getphi(ll N)&#123; ll res=N,t=N; for(ll i=2;i*i&lt;=N;i++)&#123; if(t%i==0)&#123; while(t%i==0)t/=i; res/=i,res*=(i-1); &#125; if(t==1)break; &#125; if(t!=1)res/=t,res*=(t-1); return res;&#125;ll dfs(ll p)&#123; if(p==1)return 0; //S=2^S=2^S mod phi P，what is S? if(!phi[p])phi[p]=getphi(p); return (Pow(2,dfs(phi[p])+phi[p],p));&#125;void init()&#123; phi[1]=1;&#125;void solve()&#123; int T=read(); while(T--)&#123; P=read(),printf("%lld\n",dfs(P)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2429 GCD & LCM Inverse]]></title>
    <url>%2F2018%2F08%2F28%2Fpoj2429%2F</url>
    <content type="text"><![CDATA[题目地址 题解找质因子用Miller-Rabin和Pollard-Rho实现，然后求解的时候考虑对勾函数，当$a$和$b$越接近$\sqrt{ab}$时$a+b$越小。就做完了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;ll g, l, prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;ll dd[55], ans = -1;int e1[55] = &#123;0&#125;, e2[55] = &#123;0&#125;, cnt = 0;double lev, dis;ll gcd(ll a, ll b)&#123; return (!b) ? a : gcd(b, a % b);&#125;ll mul(ll a, ll b, ll M)&#123; ll res = 0; while(b)&#123; if(b &amp; 1ll) &#123; res += a; if(res &gt;= M) res -= M; &#125; a &lt;&lt;= 1, b &gt;&gt;= 1; if(a &gt;= M) a -= M; &#125; return res;&#125;ll modpow(ll a, ll b, ll M)&#123; a %= M; ll res = 1; while(b)&#123; if(b &amp; 1ll) res = mul(res, a, M); a = mul(a, a, M), b &gt;&gt;= 1; &#125; return res;&#125;bool witness(ll a, ll n, ll t, ll u)&#123; ll x = modpow(a, u, n); for(ll i = 1; i &lt;= t; ++i)&#123; ll xx = mul(x, x, n); if(xx == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return true; x = xx; &#125; if(x != 1) return true; return false;&#125;bool miller_rabin(ll n)&#123; for(int i = 0; i &lt; 10; ++i)&#123; if(n == prime[i]) return true; else if(n % prime[i] == 0) return false; &#125; ll t, u; for(t = 1; ; ++t) if((n - 1) % (1 &lt;&lt; t) == 0) break; u = (n - 1) / (1 &lt;&lt; t); for(int i = 0; i &lt; 10; ++i) if(witness(rand() % (n - 1) + 1, n, t, u)) return false; return true;&#125;ll rho(ll n, ll c)&#123; ll x = modpow(rand(), rand(), n), y = x, d = 1; int k = 2; for(int i = 1; d == 1; ++i)&#123; x = mul(x, x, n) + c; if(x &gt;= n) x -= n; if(x &gt; y) d = gcd(x - y, n); else d = gcd(y - x, n); if(i == k) y = x, k &lt;&lt;= 1; &#125; return d;&#125;ll Pollard(ll n)&#123; ll d = n; while(d == n) d = rho(n, rand() % (n - 1) + 1); return d;&#125;void addFac(ll &amp;x, ll d, int *e)&#123; int cur; for(cur = 0; cur &lt; cnt; ++cur) if(dd[cur] == d) break; dd[cur] = d; do&#123; x /= d, e[cur]++; &#125;while(x % d == 0); if(cur == cnt) cnt++;&#125;void getFac(ll x, int *e)&#123; if(!miller_rabin(x))&#123; ll d = Pollard(x); getFac(d, e), getFac(x / d, e); &#125;else&#123; addFac(x, x, e); &#125;&#125;void dfs(int ind, ll x)&#123; if(ind == cnt)&#123; if(1.0 * x &gt; lev &amp;&amp; ans &gt; x) ans = x; return ; &#125; ll res = 1; for(int i = 0; i &lt; e2[ind]; ++i) res *= dd[ind]; dfs(ind + 1, x * res); for(int i = e2[ind]; i &lt; e1[ind]; ++i) res *= dd[ind]; dfs(ind + 1, x * res);&#125;void init()&#123; srand(122144);&#125;void solve()&#123; cnt = 0; memset(dd, 0, sizeof(dd)); memset(e1, 0, sizeof(e1)); memset(e2, 0, sizeof(e2)); if(g == l) cout &lt;&lt; g &lt;&lt; " " &lt;&lt; l &lt;&lt; endl; else&#123; getFac(l, e1); if(g != 1) getFac(g, e2); lev = sqrt(1.0 * l * g); ans = l, dfs(0, 1); cout &lt;&lt; (l / ans) * g &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl; &#125;&#125;int main()&#123; while(scanf("%lld %lld", &amp;g, &amp;l) == 2)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2006 狼抓兔子]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4001%2F</url>
    <content type="text"><![CDATA[题目链接 题解平面图最小割转对偶图最短路裸题。数组要开大！开大！开大！要特判！特判！特判！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; struct Edge&#123; int v,cost,_next; &#125;; Edge edge[7000005];int cnt=0,at[2000005],n,m,S,T,sq,d[2010005];int que[7000005];bool in[2000005]=&#123;0&#125;;int id(int i,int j)&#123;return (i-1)*(m-1)+j;&#125;void addedge(int _u,int _v,int _cost)&#123; edge[++cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt; edge[++cnt].v=_u, edge[cnt].cost=_cost, edge[cnt]._next=at[_v], at[_v]=cnt;&#125; void spfa_bfs()&#123; fill(d+1,d+sq*2+10000,INF); int i,_u,_v,_co,r=0,f=0,qc=0; d[S]=0,que[r++]=S,in[S]=1,qc++; while(qc&amp;&amp;qc&lt;=7000000)&#123; _u=que[f],in[_u]=0; f=(f==7000000)?0:f+1; qc--; for(i=at[_u];i;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r]=_v; r=(r==7000000)?0:r+1; qc++; &#125; &#125; &#125; &#125;&#125;void init()&#123; n=read(),m=read(),sq=(n-1)*(m-1); if(n==1||m==1)&#123; int ans=INF,c; for(int i=1;i&lt;=m+n-2;i++) c=read(),ans=min(ans,c); printf("%d\n",ans); return ; &#125; S=2*sq+1,T=2*sq+2; int u,v,c; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++)&#123; c=read(); if(i==1)addedge(id(i,j),T,c); else if(i==n)addedge(id(i-1,j)+sq,S,c); else addedge(id(i-1,j)+sq,id(i,j),c); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++)&#123; c=read(); if(j==1)addedge(id(i,j)+sq,S,c); else if(j==m)addedge(id(i,j-1),T,c); else addedge(id(i,j-1),id(i,j)+sq,c); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++)&#123; c=read(); addedge(id(i,j),id(i,j)+sq,c); &#125; spfa_bfs(); printf("%d\n",d[T]);&#125;void solve()&#123; &#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最小割</tag>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判圈问题]]></title>
    <url>%2F2018%2F08%2F28%2Fwriting%2Fproblem-findcycle%2F</url>
    <content type="text"><![CDATA[这里讨论主流的判圈算法。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（3）]]></title>
    <url>%2F2018%2F08%2F28%2Fwriting%2Ftemplate-math-3%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于数值，高精度计算相关的问题。 积分计算自适应Simpson方法Romberg方法]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018多校第一场 题解]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Fcontest-2018multischool%2F</url>
    <content type="text"><![CDATA[题目链接 A一个很神奇的数学题…我个人只会观察，发现当$n=3k$时可以利用均值不等式直接输出最大值，$n=4k$时答案就是$2k^3$，其他的手算了几个，估计没有，就直接$-1$。居然对了。这是为什么呢？题解里面只写了一个等式，我看不太懂 1=\frac{1}{2}+\frac{1}{3}+\frac{1}{6}=\frac{1}{3}+\frac{1}{3}+\frac{1}{3}=\frac{1}{2}+\frac{1}{4}+\frac{1}{4}12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll n;void init()&#123; n = read();&#125;void solve()&#123; if(n % 3 == 0) n /= 3, printf("%lld\n", n * n * n); else if(n % 4 == 0) n &gt;&gt;= 2, printf("%lld\n", n * n * n * 2ll); else printf("-1\n");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; B首先先把可以匹配的弄掉，最后剩一堆$pair(a, b)$，表示该字符串有$a$个’)’，$b$个’(‘。然后贪心，用一种迷之方法排序。。。排序的中心要求是让)少(多的在前面，)多(少的在后面，由前者过渡到后者。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef pair&lt;int, int&gt; pp;int n, st[100005], top, ans;pp p[100005];char s[100005];void init()&#123; ans = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", s); int r = 0, l = 0, len = strlen(s); top = 0; for(int j = 0; j &lt; len; ++j)&#123; if(s[j] == ')')&#123; if(top &amp;&amp; st[top - 1] == '(') top--, l--, ans += 2; else st[top++] = ')', r++; &#125;else st[top++] = '(', l++; &#125; p[i].first = r, p[i].second = l; &#125;&#125;bool cmp(const pp&amp; p1, const pp&amp; p2)&#123; if(!p1.first) return 1; if(!p2.first) return 0; int f1 = p1.first - p1.second, f2 = p2.first - p2.second; if(f1 * f2 &lt;= 0) return f1 &lt; f2; if(f1 &lt; 0) return p1.first &lt;= p2.first; return p1.second &gt;= p2.second;&#125;void solve()&#123; sort(p, p + n, cmp); int l = p[0].first, r = p[0].second; for(int i = 1; i &lt; n; ++i)&#123; int ll = p[i].first, rr = p[i].second; ans += min(r, ll) * 2; if(r &gt; ll) r = r - ll + rr; else l = ll - r + l, r = rr; &#125; printf("%d\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; C]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2559]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Fpoj2559%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（2）]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Ftemplate-math-2%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于模相关的问题。 求$\gcd$欧几里得算法（辗转相除法）辗转相除法基于GCD递归定理： \gcd(a, b) = \gcd(b, a\mod b)该定理可以用反证法进行证明，也可以通过证明左右两数分别被对方整除证明。此处不列出证法。123int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125; Stein算法该算法相对欧几里得算法而言，在计算机上实现的效率更高，尤其是对于一些大数的计算。该算法的步骤也非常简单，即为以下式子： \gcd(a, b) = \begin{cases}2\gcd(\frac {a}{2}, \frac{b}{2}) \quad (a为偶数,b为偶数)\\ \gcd(\frac{a}{2}, b) \quad (a为偶数,b为奇数) \\ \gcd(\frac{\left| a- b\right|}{2}, b)\quad (a为奇数,b为奇数)\end{cases}以上式子的正确性可以用同余式的性质证明，此处不给出。1234567891011int gcd(int a, int b)&#123; if(!b) return a; if(!a) return b; if(a &amp; 1)&#123; if(b &amp; 1) return gcd(b, abs(a - b) &gt;&gt; 1); else return gcd(a, b &gt;&gt; 1); &#125;else&#123; if(b &amp; 1) return gcd(a &gt;&gt; 1, b); else return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; &#125;&#125; 扩展欧几里得扩展欧几里得可以用来求解线性同余方程组。 123456789int extgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b)&#123; x = 1, y = 0; return a; &#125; int d = extgcd(b, a % b, y, x); y -= x * (a / b); return d;&#125; 欧拉函数欧拉定理欧拉定理叙述如下： 欧拉定理降幂公式 解线性同余方程组中国剩余定理中国剩余定理（CRT）可以用来求解线性同余方程组。它的描述如下：有$n$个线性同余方程组： \begin{cases} x \equiv a_1 \pmod {m_1} \\ x \equiv a_2 \pmod {m_2} \\ \vdots \\ x \equiv a_n \pmod {m_n} \\ \end{cases}其中m_1, m_2, \cdots, m_n两两互质，那么存在唯一的一个$x$在模M = \Pi_{i = 1}^{n} m_i使得上述方程组成立。证明如下：首先构造一个这样的$x$证明存在性。令M_i为除m_i外所有m_j的积，那么\gcd(M_i, m_i)=1。解b_i \dot M_i \equiv 1 \pmod {m_i}。然后令x=\sum_{i = 1}^{n} a_i \dot b_i \dot M_i，则这个$x$就是答案。（容易验证这一点）然后再证明唯一性。假设存在另一个不同的解$y$，那么$x-y$同时是m_i(\forall i)的倍数。因为m_i两两互质。所以$x-y$是$M$的倍数。所以$x\equiv y \pmod M$。矛盾。这样就可以利用这个构造性算法构造出这个问题的解了：123456789101112int CRT(int m[], int a[], int n)&#123; int M = 1, x = 0; for(int i = 0; i &lt; n; ++i) M *= m[i]; for(int i = 0; i &lt; n; ++i)&#123; int Mi = M / m[i], b, q; extgcd(Mi, m[i], b, q); Mi = ((Mi * a[i]) % M) * b % M; x = (x + Mi) % M; &#125; return (x + M) % M;&#125; 扩展中国剩余定理（线性同余方程一般形式）当m_i不两两互质怎么办？依然可以求出线性同余方程组的解。 12345678ll extCRT(ll m[], ll a[], ll n)&#123; ll M = m[0], ans = a[0], x, y; for(int i = 1; i &lt; n; ++i)&#123; ll d = extgcd(M, m[i], x, y), a_ = ((a[i] - ans) % M + M) % M; &#125;&#125; 组合数取模卢卡斯定理一句话描述卢卡斯定理，就是： C_n^m \equiv C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} C_{n \mod p}^{m \mod p} \pmod p其中$p$是质数。容易发现卢卡斯定理的表达式里面有一个递归结构，所以可以把它做成递归的。123ll Lucas(ll n, ll m)&#123; return (!m) ? 1 : C(n % p, m % p) * Lucas(n / p, m / p) % p;&#125; 求逆元]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（1）]]></title>
    <url>%2F2018%2F08%2F26%2Ftemplate-math-1%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于快速幂和快速乘，与质数相关的问题。 快速幂对于$a^b$，把$b$展开成为二进制形式，然后按位乘，同时让$a$反复平方。时间复杂度：$O(\log n)$12345678int modpow(int a, int b, int M)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (res * a) % M; a = (a * a) % M, b &gt;&gt;= 1; &#125; return res;&#125; 特化版本：12345678ll modpow(ll a, ll b, ll M)&#123; ll res = 1; while(b)&#123; if(b &amp; 1) res = fstmul(res, a, M); a = fstmul(a, a, M), b &gt;&gt;= 1; &#125; return res;&#125; 快速乘实现一当$a\times b \mod M$可能超过当前类型限制时，可以将$b$展开成为二进制，然后根据乘法分配律让$a$按位乘，即可避免溢出。时间复杂度：$O(\log n)$12345678int fstmul(int a, int b, int M)&#123; int res = 0; while(b)&#123; if(b &amp; 1) res = (res + a) % M; a &lt;&lt;= 1, a %= M, b &gt;&gt;= 1; &#125; return res;&#125; 特化版本：123456789101112ll fstmul(ll a, ll b, ll M)&#123; ll res = 0; while(b)&#123; if(b &amp; 1) &#123; res += a; if(res &gt;= M) res -= M; &#125; a &lt;&lt;= 1, b &gt;&gt;= 1; if(a &gt;= M) a -= M; &#125; return res;&#125; 实现二因为$a\times b \mod M = a\times b - \lfloor \frac{a\times b}{M} \rfloor \times M$，因此可以用(long) double来存$\frac{a\times b}{M}$，然后再化成整数去乘$M$，再算出对应的结果。时间复杂度：$O(1)$123456int fstmul_2(int a, int b, int M)&#123; int c = (double)a * b / M; int res = a * b - c * M; //此时res由于溢出，可能为负数 if(res &lt; 0) res += M; return res;&#125; 素数定理\pi(x) \sim \frac{N}{\ln N} 质数判断试除法一个数$N$为合数，那么一定有一个数$T$，使得$T|N,2\le T \le \sqrt{N}$。根据这个可以用时间复杂度$O(\sqrt n)$判断质数。123456bool isP(int x)&#123; if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125; Miller-Rabin算法由费马小定理，当$p$为一个质数，对于$gcd(a, p) = 1$，有$a^{p - 1} \equiv 1 \pmod p$。反过来说，当我们知道有$gcd(a, p) = 1$，并且$a^{p - 1} \equiv 1 \pmod p$时，那么$p$就有可能是质数。理论上，要认定一个数$p$为一个质数，我们可以用所有小于它的和它互质的数$a$做一个判定，即判断是否有$a^{p - 1} \equiv 1 \pmod p$。如果全部成立，那么$p$几乎就是一个质数。可惜的是，存在这样的合数——卡迈克尔数(Carmicheal Number)。因此，必须要做出一些改进，使得判定更为准确。下面先直接给出Miller-Rabin算法的代码：123456789101112131415161718192021bool witness(int a, int n, int t, int u)&#123; int x = modpow(a, u, n); for(int i = 0; i &lt; t; ++i)&#123; int xx = (x * x) % n; if(xx == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return true; x = xx; &#125; if(x != 1) return true; return false;&#125;bool isP_miller_rabin(int n, int times)&#123;//执行times次 int t = 1, u; while((n - 1) % (2 &lt;&lt; t) == 0) t++; u = (n - 1) / (1 &lt;&lt; t); while(times--)&#123; int a = rand() % (n - 1) + 1; if(witness(a, n, t, u)) return false; &#125; return true;&#125; 该算法的另一个理论基础是二次探测定理：若$x^2 \equiv 1\pmod p$，$p$为质数，那么$x\equiv 1 \pmod p$或者$x \equiv -1 \pmod p$。这是因为上式可以化成$(x+1)(x-1)\equiv 0 \pmod p$，而$p$是一个质数，由质数的锐利性质可得。当$p$为质数时，令$p-1= 2^tu$，那么对于序列$a^u, a^{2u}, a^{2^2u}, …, a^{2^tu}$，由于最后一项一定为$1$，那么必然有以下条件中的一个： $a^u \equiv 1 \pmod p$ $\exists i \in \left{ 0, 1, 2, … , t\right}, a^{2^iu} \equiv -1 \pmod p$ 若这两个性质都不符合，那么就能够确认$p$是合数。可以证明，这样的$a$占了$1$到$p-1$的$75\%$左右，因此做$T$次判断，失误率近似在$4^{-T}$。要取得更加优秀的结果，可以先根据质数表，看看几个小质数是不是程序中$n$的因子，然后再进行Miller-Rabin验证。 求质数埃氏筛法基于“合数一定有一个大于$1$，小于自身的质因数”的想法，可以直接从$2$向$N$扫描，遇到没有被标记的数就认为它是质数，然后把它的倍数全部标记。这样没有被标记的数就全部都是质数了。由于遇到一个质数$p$的时候小于$p^2$的$p$的倍数已经全部被标记了，所以可以直接从$p^2$开始进行筛除。时间复杂度：$O(n\log \log n)$。（小于$n$的质数的倒数和约为$\log \log n$，参见此处）1234567void getP(int N)&#123; for(int i = 2; i &lt;= N; ++i) if(!vis[i])&#123; for(int j = i * i; j &lt;= N; j += i) vis[j] = 1; &#125;&#125; 区间筛法要筛出$[L, R]$上面的质数，只需要筛出所有$[2, \sqrt{R}]$上面的质数即可，因为$[L, R]$上面的合数必然有一个位于$[2, \sqrt{R}]$上面的质因子。 时间复杂度：$O(N \log \log N)$（基于埃氏筛法）123456789void getP(int L, int R)&#123; if(L &lt;= 1) L = 2; for(int i = 1; i &lt;= cnt; ++i)&#123; unsigned int p = prime[i]; if(R &lt; p) break; for(unsigned int j = max((L - 1 + p) / p, 2u); j &lt;= R / p; ++j)//这里取j的初始值是为了保证能取道区间内所有p的倍数 vis2[j * p - L] = 1; &#125;&#125; 欧拉筛法也称线性筛法。观察上面的埃氏筛法程序容易发现，一个数常常会被多个质数筛掉，这样会影响效率。如果一个数只会被筛一次，那么就可以做到线性的时间复杂度。考虑每一个数的最小质因数$mindiv[i]$，从$2$到$N$扫描。如果一个数未被访问过，那就把它加入质数里面。然后对于当前的数，利用所有小于或者等于$mindiv[i]$的质数$p$，标记$mindiv[i]\times p$为合数，同时置其最小质因数为$p$。这样每一个合数就都被它的最小质因数筛掉了。时间复杂度：$O(n)$1234567891011121314// 本代码未显式保存mindivint prime[N &gt;&gt; 1], tot = 0;bool vis[N];void getP(int N)&#123; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i]) prime[tot++] = i; for(int j = 0; j &lt; tot; ++j)&#123; if(i * prime[j] &gt; N) break; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; //这一步起到的是让p不大于最小质因数 &#125; &#125;&#125; 质因数分解算术基本定理对于任何一个大于$1$的正整数$n$，$n$都能被唯一分解为有限个质数的乘积，写作： n = p_1^{c_1} p_2^{c_2} \cdots p_m^{c_m}其中c_i \ge 1、p_i是质数$(\forall i)$，且p_1]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NOI1997-2002 题解]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fnoi1997-2002%2F</url>
    <content type="text"><![CDATA[包含了NOI1997-2002六年部分题目的题解。 NOI1997D1T2 最优乘车题目链接 单源最短路问题。考输入。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='\n'||c==EOF)return -1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;bool mp[505][505]=&#123;0&#125;;int n,m,q[5005],f=0,r=0,d[505];void solve()&#123; q[r++]=0,d[0]=-1; int h,v; while(r-f)&#123; h=q[f++]; for(v=0;v&lt;n;v++) if(mp[h][v]&amp;&amp;d[v]&gt;d[h]+1)d[v]=d[h]+1,q[r++]=v; &#125;&#125;int main()&#123; m=read(),read();n=read(),read(); fill(d,d+n,10000000); int i,j,u,v; for(i=0;i&lt;m;i++)&#123; j=0;while((v=read())&gt;0)q[j++]=v; for(u=0;u&lt;j;u++) for(v=u+1;v&lt;j;v++) mp[q[u]-1][q[v]-1]=1; &#125; solve(); if(d[n-1]&gt;=1000000)printf("NO\n"); else printf("%d\n",d[n-1]); return 0;&#125; NOI1998D1T1 个人所得税题目链接 模拟即可。开数组存每个员工每个月的收入，最后再计算；遇到单个的就直接计算。本题读入很神奇，需注意。还有就是负数的处理问题，应交税的部分不能为负。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int m,money[50005][20]=&#123;0&#125;;char typ[10],tim[10],PAY[]="PAY",INC[]="INCOME";double ans=0,pay_l[]=&#123;0,500,2000,5000,20000,40000,60000,80000,100000,999999999&#125;,inc_l[]=&#123;0,20000,50000,999999999&#125;;void init()&#123; scanf("%d",&amp;m);&#125;double Count_pay(int pr)&#123; double left=max(0,pr-800),_ans=0; for(int i=1;i&lt;=9;i++) if(left&lt;pay_l[i])&#123; _ans+=i*0.05*(left-pay_l[i-1]); break; &#125;else _ans+=i*0.05*(pay_l[i]-pay_l[i-1]); return _ans;&#125;double Count_income(int pr)&#123; double left,_ans=0; left=(pr&gt;4000)?(pr*0.8):(max(0,pr-800)); for(int i=1;i&lt;=3;i++)&#123; if(left&lt;inc_l[i])&#123; _ans+=(i+1)*0.1*(left-inc_l[i-1]); break; &#125;else _ans+=(i+1)*0.1*(inc_l[i]-inc_l[i-1]); &#125; return _ans;&#125;void solve()&#123; int id,pr,mon; for(;;)&#123; scanf("%s",typ); if(typ[0]=='#')break; scanf("%d%s%d",&amp;id,tim,&amp;pr); if(!strcmp(PAY,typ))&#123; if(tim[1]=='/')mon=tim[0]-'0'; else mon=10*(tim[0]-'0')+tim[1]-'0'; money[id][mon]+=pr; &#125;else&#123; ans+=Count_income(pr); &#125; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=12;j++) if(money[i][j]) ans+=Count_pay(money[i][j]); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; NOI2000D1T1 瓷片项链题目链接 二次函数。12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int v,v0;int main()&#123; if((v%v0==0&amp;&amp;v%(v0+v0))||v==0) printf("0\n"); else &#123; double a=v,b=v0,ans,d=v/(v0+v0); if(ceil(d)-d&gt;d-floor(d)) ans=floor(d); else ans=ceil(d); printf("%d\n",(int)ans); &#125; return 0;&#125; D1T3 古城之谜题目链接 这题怎么想的。。。看了byvoid的题解还是有点晕晕乎乎。要先对给出的形式进行简化。 句子：是名词、动词短语交替出现的，且开头必定为名词短语。名词短语：相当于任意多个副词+名词。动词短语：相当于任意多个副词+动词。 考虑刻画状态，字母要算进去，当前词性要算进去，还要考虑最少的句子数和单词数。所以设$f(i,j,k)$表示前$i$个字母，最后一个单词词性为$j$，组成$k$个句子的最小单词数量。$j$有$3$种，用$0,1,2$表示名，动，副。但是还要考虑到副词的链接问题。所以加一种情况：$j=3$，表明是副词，并且前面最近的非副词是动词。$j=2$时前面最近的非副词是名词。然后就大力转移即可。直接开数组会MLE，但是可以发现$k$的转移来源只会是$k$和$k-1$，所以用滚动数组压掉这一维。匹配串我用的是hash，大概不会被卡掉…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000#define Mod 10000007ullusing namespace std;typedef unsigned long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,len,f[5005][4][2],maxl=0;char word[1005][25],tex[50005];ll hsh[50005],Pow[50005];bool t1[10000007],t2[10000007],t3[10000007];ll getHash(int i,int j)&#123; return hsh[j]-(hsh[i-1]*Pow[j-i+1]);&#125; void init()&#123; n=read(); int l;ll Hash; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",word[i]); l=strlen(word[i]),Hash=0,maxl=max(maxl,l-2); for(int j=2;j&lt;l;j++) Hash=Hash*137ull+(ll)word[i][j]+157ull; if(word[i][0]=='n')t1[Hash%Mod]=1; if(word[i][0]=='v')t2[Hash%Mod]=1; if(word[i][0]=='a')t3[Hash%Mod]=1; &#125; scanf("%s",tex+1); len=strlen(tex+1)-1,hsh[0]=0,Pow[0]=1; for(int i=1;i&lt;=len;i++) hsh[i]=hsh[i-1]*137ull+(ll)tex[i]+157ull,Pow[i]=Pow[i-1]*137ull;&#125;void solve()&#123; memset(f,0x3f,sizeof(f)); f[0][0][0]=0; int B,B_,ans1,ans2; ll tmp; for(int k=1;k&lt;=len;k++)&#123; B=(k&amp;1),B_=B^1; for(int i=1;i&lt;=len;i++)&#123; f[i][0][B]=f[i][1][B]=f[i][2][B]=f[i][3][B]=0x3f3f3f3f; for(int t=i;t&gt;i-maxl&amp;&amp;t&gt;=1;t--)&#123; tmp=getHash(t,i)%Mod; if(t1[tmp])&#123; int &amp;T=f[i][0][B]; T=min(T,min(f[t-1][1][B]+1,f[t-1][3][B]+1)); T=min(T,min(f[t-1][0][B_]+1,f[t-1][1][B_]+1)); &#125; if(t2[tmp])&#123; int &amp;T=f[i][1][B]; T=min(T,min(f[t-1][0][B]+1,f[t-1][2][B]+1)); &#125; if(t3[tmp])&#123; int &amp;T=f[i][2][B]; T=min(T,min(f[t-1][0][B]+1,f[t-1][2][B]+1)); T=min(T,f[t-1][0][B_]+1); int &amp;T2=f[i][3][B]; T2=min(T2,min(f[t-1][1][B]+1,f[t-1][3][B]+1)); T2=min(T2,min(f[t-1][0][B_]+1,f[t-1][1][B_]+1)); &#125; &#125; &#125; if(f[len][0][B]&lt;INF||f[len][1][B]&lt;INF)&#123; ans1=k,ans2=min(f[len][0][B],f[len][1][B]); break; &#125; &#125; printf("%d\n%d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T1 单词查找树题目链接 trie树模板题？123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int trie[100005][29]=&#123;0&#125;;char wd[1005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void solve()&#123; int ans=1,p; char *s; while(~scanf("%s",wd))&#123; p=1; for(s=wd;*s;s++)&#123; if(!trie[p][*s-'A']) trie[p][*s-'A']=++ans; p=trie[p][*s-'A']; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; solve(); return 0;&#125; D2T2 青蛙过河题目链接 设$f(h,k)$为答案。则显然的是$f(0,k)=k+1$。我们加一个石墩，那么可以先把最上面一波青蛙送到新加的上面去，然后把下面那一拨送到对岸，再把石墩上的送走。所以$f(1,k)=2f(0,k)$。再加一个。我们又把一波青蛙送到其中一个石墩上，然后问题变成了$f(1,k)$的形式，所以$f(2,k)=2f(1,k)$。换言之，加一个石墩，送青蛙的能力就增强一倍。所以$f(h,k)=2^h (k+1)$。12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll h,k;void init()&#123; scanf("%lld%lld",&amp;h,&amp;k);&#125;void solve()&#123; printf("%lld\n",(k+1)*(1&lt;&lt;h));&#125;int main()&#123; init(); solve(); return 0;&#125; D2T3 算符破译NOI2001D1T1 食物链题目链接 设$a,2a,3a$分别表示$a$属于$A,B,C$。则对于1，判断$a$与$2b$和$a$与$3b$是否在同一集合对于2，判断$a$吃不吃自己与$b$吃不吃$a$即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int rank[150010],parent[150010],t,ans=0,k,n,x,y;int same(int a,int b),find(int a);void init(int n),joint(int x,int y);void init(int n)&#123; int i;for(i=1;i&lt;=n;i++)&#123; parent[i]=i; rank[i]=0; &#125;&#125;void joint(int x,int y)&#123; int a=find(x),b=find(y); if(a==b)return; if(rank[a]&lt;rank[b])&#123; parent[a]=b; &#125;else&#123; parent[b]=a; if(rank[a]==rank[b])rank[a]++; &#125;&#125;int find(int a)&#123; if(parent[a]==a)return a; else return (parent[a]=find(parent[a]));&#125;int same(int a,int b)&#123;return find(a)==find(b);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k);int i; init(n*3);for(i=0;i&lt;k;i++)&#123; scanf("%d%d%d",&amp;t,&amp;x,&amp;y); if(x&gt;n||y&gt;n||x&lt;1||y&lt;1)ans++; else&#123; if(t==1)&#123; if(same(x,y+n)||same(x,y+2*n))ans++; else &#123;joint(x,y);joint(x+n,y+n);joint(x+n*2,y+n*2);&#125; &#125;else&#123; if(same(x,y+2*n)||same(x,y))ans++; else&#123; joint(x,y+n);joint(x+n,y+2*n);joint(x+n*2,y); &#125; &#125; &#125; &#125;printf("%d\n",ans); return 0;&#125; D1T2 反正切函数的应用题目链接 $O(\sqrt n)$乱搞。利用$(a-b)(a-c)=a^2+1$12345678910111213141516#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned int uint;uint a,ans=4000000000u,d;int main()&#123; scanf("%u",&amp;a); d=a*a+1; for(uint i=1;i*i&lt;=d;i++) if(d%i==0)ans=min(ans,a+a+i+d/i); printf("%u\n",ans); return 0;&#125; D1T3 聪明的打字员题目链接 标准的广搜。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char vis[1000000][6]=&#123;0&#125;;int S,T,ans[1000005][6],ten[10];queue&lt;int&gt; q1,q2;//000000-999999int ptoi(int *L)&#123; int res=0; for(int i=0;i&lt;6;i++)res=res*10+L[i]; return res;&#125;void itop(int *L,int x)&#123; for(int i=5;i&gt;=0;i--)L[i]=x%10,x/=10;&#125;void init()&#123; S=read(),T=read(); memset(ans,0x3f,sizeof(ans)); ans[S][0]=0; ten[5]=1; for(int i=4;i&gt;=0;i--)ten[i]=ten[i+1]*10;&#125;void solve()&#123; vis[S][0]=1,q1.push(S),q2.push(0); int h,pos,permu[10],Ans=INF,now,to; while(!q1.empty())&#123; h=q1.front(),q1.pop(),pos=q2.front(),q2.pop(); if(h==T)break; now=ans[h][pos],itop(permu,h); if(pos&amp;&amp;!vis[h][pos-1])//left vis[h][pos-1]=1,ans[h][pos-1]=now+1, q1.push(h),q2.push(pos-1); if(pos!=5&amp;&amp;!vis[h][pos+1])//right vis[h][pos+1]=1,ans[h][pos+1]=now+1, q1.push(h),q2.push(pos+1); if(permu[pos]!=9)&#123;//up to=h+ten[pos]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(permu[pos])&#123;//down to=h-ten[pos]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(pos&amp;&amp;permu[0]!=permu[pos])&#123; to=h-permu[0]*ten[0]-permu[pos]*ten[pos]+permu[0]*ten[pos]+permu[pos]*ten[0]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(pos!=5&amp;&amp;permu[5]!=permu[pos])&#123; to=h-permu[5]*ten[5]-permu[pos]*ten[pos]+permu[5]*ten[pos]+permu[pos]*ten[5]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; &#125; for(int i=0;i&lt;6;i++)Ans=min(Ans,ans[T][i]); printf("%d\n",Ans);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T1 炮兵阵地题目链接 标准的状压DP。 D2T2 方程的解数题目链接 meet in the middle。拆成两半，$O(M^3)$枚举+核对。用map会MLE，干脆hash。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define P 4000037using namespace std;typedef long long ll;int n,m;ll k[15],p[15],ppow[155][40]=&#123;0&#125;,half,ans=0;ll LIM=2147483647;int hsh[4000060],cnt[4000060];bool vis[4000060]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;k[i],&amp;p[i]); for(ll i=1;i&lt;=m;i++)&#123; ppow[i][0]=1; ll lim=1; for(int j=1;j&lt;=35;j++)&#123; lim*=i; if(lim&gt;=LIM)break; ppow[i][j]=ppow[i][j-1]*i; &#125; &#125;&#125;int locate(int val)&#123; int q=abs(val); for(q%=P;vis[q]&amp;&amp;hsh[q]!=val;q=(q==P-1)?0:q+1); return q;&#125;void build(int at,ll val)&#123; if(at&gt;half)&#123; int loc=locate((int)val); cnt[loc]++,hsh[loc]=(int)val,vis[loc]=1; return ; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!ppow[i][p[at]])break; ll lim=val+ppow[i][p[at]]*k[at]; if(lim&gt;=LIM||lim&lt;=-LIM)break;//爆了 build(at+1,lim); &#125;&#125;void Search(int at,ll val)&#123; if(at==n+1)&#123; int _val=(int)(-val); int loc=locate(_val); if(hsh[loc]==_val)ans+=cnt[loc]; return ; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!ppow[i][p[at]])break; ll lim=val+ppow[i][p[at]]*k[at]; if(lim&gt;=LIM||lim&lt;=-LIM)break;//爆了 Search(at+1,lim); &#125;&#125;void solve()&#123; half=n/2; build(1,0); Search(half+1,0); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T3 陨石的秘密题目链接可以发现SS表达式的定义是递归形式的，而且SS表达式形成了一个树形结构（有深度，还有儿子）。设$f(i,j,k,d)$为$i$对大括号，$j$对中括号，$k$对小括号，树深度$&lt;=d$的方案总数。对于同一层而言，决策有： 分出一支，深度变大。 同一层上增加。对于第一种情况，我们再加一个状态：设$g(i,j,k,d)$为$i$对大括号，$j$对中括号，$k$对小括号，树深度$\le d$，且表达式构成一棵树的方案总数。他从$f$转移而来，决策是给$f$加一个根。这样就可以转移了。初始：$f(0,0,0,0…D)=1$。答案：f(L_1,L_2,L_3,D)-f(L_1,L_2,L_3,D-1)（相当于容斥）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define Mod 11380using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int l1,l2,l3,D,f[11][11][11][31]=&#123;0&#125;,g[11][11][11][31]=&#123;0&#125;;char vis1[11][11][11][31]=&#123;0&#125;,vis2[11][11][11][31]=&#123;0&#125;;int dp_g(int a,int b,int c,int d);int dp_f(int a,int b,int c,int d);int dp_g(int a,int b,int c,int d)&#123; if(vis2[a][b][c][d])return g[a][b][c][d]; int t=0; if(!a&amp;&amp;!b&amp;&amp;c&gt;=1)(t+=dp_f(a,b,c-1,d-1))%=Mod; if(!a&amp;&amp;b&gt;=1)(t+=dp_f(a,b-1,c,d-1))%=Mod; if(a&gt;=1)(t+=dp_f(a-1,b,c,d-1))%=Mod; vis2[a][b][c][d]=1; return (g[a][b][c][d]=t);&#125;int dp_f(int a,int b,int c,int d)&#123; if(vis1[a][b][c][d])return f[a][b][c][d]; int t=0; for(int i=0;i&lt;=a;i++) for(int j=0;j&lt;=b;j++) for(int k=0;k&lt;=c;k++) if(i||j||k)(t+=dp_g(i,j,k,d)*dp_f(a-i,b-j,c-k,d))%=Mod; vis1[a][b][c][d]=1; return (f[a][b][c][d]=t);&#125;void init()&#123; l1=read(),l2=read(),l3=read(),D=read(); for(int i=0;i&lt;=D;i++) vis1[0][0][0][i]=1,f[0][0][0][i]=1, vis2[0][0][0][i]=1,g[0][0][0][i]=0;&#125;void solve()&#123; printf("%d\n",(dp_f(l1,l2,l3,D)-dp_f(l1,l2,l3,D-1)+Mod)%Mod);&#125;int main()&#123; init(); solve(); return 0;&#125; NOI2002D1T2 调皮的小孩（题目暂缺） 显然你最多只能问一个人$2$遍。显然你问裁判同样问题$2$次他就会自爆。那就分类讨论。先随便找个人，然后对其他人问他是不是0队的。 $N$个人Yes$M$个No，那么这个人就有可能是0队的。（1）$N\neq M$，他就是0队的。（2）$N=M$，让他问1队的任意一个人是不是1队的$2$次，答案一样这个人就是0队的，反之就是裁判。 $N+1$个人No$M-1$个人Yes，那么这个人是1队的，去另外$N+1$个人问他是不是1队的即可。 $N$个人No$M$个人Yes，$N\neq M$他就是裁判，$N=M$就套用1的解决方法。]]></content>
      <categories>
        <category>NOI题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>枚举</tag>
        <tag>递推</tag>
        <tag>其他DP</tag>
        <tag>并查集</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2440 完全平方数]]></title>
    <url>%2F2018%2F08%2F25%2Fbzoj2440%2F</url>
    <content type="text"><![CDATA[题目链接 题解我觉得这题比较简单= =对于这种难以直接求解的问题一般采用二分解决。先二分一个答案$x$，然后看$[1,x]$间有多少个这样的数。直接算算不出，由于是完全平方数，考虑补集转化，求是完全平方数倍数的个数。有重叠，考虑容斥。答案就是$n-$只有一个质因子的平方数倍数个数$+$有$2$个质因子的$-$有$3$个质因子的…但是质因子太多，会TLE。我们知道容斥和莫比乌斯函数有关，所以利用莫比乌斯函数优化。这样答案就是 \sum_{i = 1}^{\sqrt{x}}\mu(i)\times \lfloor \frac{x}{i^2}\rfloor二分范围？观察样例，猜测不会超过2k_i。。。话说这个题 二分有点奇怪 改了一下改成这样才能过？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int mu[100005];int prime[100005],tot=0,n,k;bool vis[100005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int judge(int x)&#123; int res=0,l=(int)sqrt(x); for(int i=1;i*i&lt;=x;i++)&#123; res+=mu[i]*(x/(i*i)); &#125; return res;&#125;void init()&#123; mu[1]=1,vis[1]=1; for(int i=2;i&lt;=100000;i++)&#123; if(!vis[i]) mu[i]=-1,prime[tot++]=i; for(int j=0;j&lt;tot;j++)&#123; ll t=i;t*=(ll)prime[j]; if(t&gt;100000)break; vis[i*prime[j]]=1,mu[i*prime[j]]=-mu[i]; if(i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; &#125; &#125;&#125;void solve()&#123; n=read(); while(n--)&#123; k=read(); int L=1,R=2*k,M; while(R-L)&#123; M=L+(R-L)/2; if(judge(M)&gt;=k)R=M; else L=M+1; &#125; printf("%d\n",L); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3614]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fpoj3614%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 506 (Div. 3) 题解]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fcontest-cf1029%2F</url>
    <content type="text"><![CDATA[A题目链接 观察样例可以发现，只要找到最长的和后缀相同的前缀，然后重复该前缀$k$次，再输出剩下的即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, k;char s[105];void init()&#123; n = read(), k = read(); scanf("%s", s);&#125;void solve()&#123; int st; for(st = 1; st &lt; n; st++)&#123; int flag = 1; for(int j = 0; j &lt; n - st; ++j) if(s[st + j] != s[j])&#123; flag = 0; break; &#125; if(flag) break; &#125; if(st == n)&#123; for(int i = 0; i &lt; k; ++i) printf("%s", s); &#125;else&#123; for(int i = 0; i &lt; k; ++i) for(int j = 0; j &lt; st; ++j) putchar(s[j]); for(int i = st; i &lt; n; ++i) putchar(s[i]); &#125; printf("\n");&#125;int main()&#123; init(); solve(); return 0;&#125; B题目链接 C题目链接]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4317]]></title>
    <url>%2F2018%2F08%2F24%2Fwriting%2Fluogu4317%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 405C Unusual Product]]></title>
    <url>%2F2018%2F08%2F24%2Fcf405c%2F</url>
    <content type="text"><![CDATA[题目链接 题解因为觉得这是一道出的很好的模拟题，所以拿过来了。上文中提到的flip操作其实就是取反。暴力做法是$O(nq)$的，挂。看数据，考虑有没有什么接近线性的做法：我们将整个结果展开。比如这么一个方阵： \begin{bmatrix} a_1 & b _1 & c_1 \\ a_2 & b_2 & c_2 \\ a_3 & b_3 & c_3 \end{bmatrix}他的unusual square 就是a_1^2 + b_2^2 + c_3^2 + 2(a_2b_1+a_3c_1+b_3c_2)由于是在模$2$的环境下进行，这个式子后半部分都是没有用的东西。所以只要时时刻刻维护前面平方项的和即可。然而…每一次操作都必然改变一项且仅改变一个平方项，使之从0变1或从1变0.所以做法就是 读入时不保留矩阵，只算平方项 更新时只要知道它更新了即可，然后把平方和异或1。这个算法的复杂度就是$O(n^2+q)-O(1)$的。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,sum=0,lg[1005],q,jc;//保留对角线只是我无聊...int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;((i==j)?lg[i]:jc)); for(int i=0;i&lt;n;i++) sum^=lg[i];&#125;void solve()&#123; scanf("%d",&amp;q); int op; for(int i=0;i&lt;q;i++)&#123; scanf("%d",&amp;op); if(op==3)printf("%d",sum); else scanf("%d",&amp;jc),sum^=1; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 438D The Child and Sequence]]></title>
    <url>%2F2018%2F08%2F24%2Fcf438d%2F</url>
    <content type="text"><![CDATA[题目链接 题解第一次写这种靠数学分析来找特定规律的题目…观察区间取模的问题，我们可以发现一个数最多会被取模log_2 n次。（因为一次取模至少会缩小一半，和启发式合并相似）所以没什么顾虑，暴力做就是了。操作一用lazytag解决，操作二的话维护区间内最大值及其下标，每次暴力找最大的，如果大于模数就单点修改。操作三就是单点修改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll seg[400005]=&#123;0&#125;,tag[400005]=&#123;0&#125;,_v,sum[400005],loc[400005];int _a,_b,m,n,siz;pair&lt;int,ll&gt; Nulll;void maintain(int id)&#123; if(seg[id&lt;&lt;1]&gt;seg[id&lt;&lt;1|1]) seg[id]=seg[id&lt;&lt;1],loc[id]=loc[id&lt;&lt;1]; else seg[id]=seg[id&lt;&lt;1|1],loc[id]=loc[id&lt;&lt;1|1]; sum[id]=sum[id&lt;&lt;1]+sum[id&lt;&lt;1|1];&#125;void build_seg()&#123; for(siz=1;siz&lt;n;siz&lt;&lt;=1); int i; for(i=siz;i&lt;siz+n;i++) scanf("%lld",&amp;seg[i]), tag[i]=0,sum[i]=seg[i],loc[i]=i-siz+1; //seg最大值，sum和，tag标记，loc最大值位置 for(;i&lt;(siz&lt;&lt;1);i++) seg[i]=sum[i]=tag[i]=loc[i]=0; for(i=siz-1;i&gt;=1;i--) maintain(i);&#125;void pushdown(int id,ll len)&#123; if(!tag[id])return ; seg[id&lt;&lt;1]+=tag[id],seg[id&lt;&lt;1|1]+=tag[id]; tag[id&lt;&lt;1]+=tag[id],tag[id&lt;&lt;1|1]+=tag[id]; sum[id&lt;&lt;1]+=tag[id]*(len&gt;&gt;1),sum[id&lt;&lt;1|1]+=tag[id]*(len&gt;&gt;1); tag[id]=0;&#125;void update(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(l&gt;=_a&amp;&amp;r&lt;=_b)&#123; seg[id]+=_v,tag[id]+=_v,sum[id]+=(r-l+1)*_v; return ; &#125; pushdown(id,(ll)(r-l+1)); update(id&lt;&lt;1,l,(l+r)&gt;&gt;1); update(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); maintain(id);&#125;pair&lt;int,ll&gt; query_p(int id,int l,int r)&#123; //查询区间最大值 pair&lt;int,ll&gt; P,p1; P.first=P.second=-1; if(l&gt;_b||r&lt;_a)return Nulll; if(l&gt;=_a&amp;&amp;r&lt;=_b)&#123; P.first=loc[id],P.second=seg[id]; return P; &#125; pushdown(id,(ll)(r-l+1)); p1=query_p(id&lt;&lt;1,l,(l+r)&gt;&gt;1); if(p1.second&gt;P.second)P=p1; p1=query_p(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); if(p1.second&gt;P.second)P=p1; return P; &#125;ll query(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return 0; if(l&gt;=_a&amp;&amp;r&lt;=_b)return sum[id]; pushdown(id,(ll)(r-l+1)); return query(id&lt;&lt;1,l,(l+r)&gt;&gt;1)+query(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r);&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); build_seg(); Nulll.first=-1,Nulll.second=-1; &#125;void solve()&#123; for(int i=0;i&lt;m;i++)&#123; int typ,_c,_d; scanf("%d",&amp;typ); if(typ==1) scanf("%d%d",&amp;_a,&amp;_b), printf("%lld\n",query(1,1,siz)); else if(typ==2)&#123; scanf("%d%d%lld",&amp;_c,&amp;_d,&amp;_v); ll Mod=_v; pair&lt;int,ll&gt; P; for(;;)&#123; _a=_c,_b=_d; P=query_p(1,1,siz); if(P.second&lt;Mod)break; _a=_b=P.first,_v=P.second%Mod-P.second; update(1,1,siz); &#125; //for(int i=0;i&lt;5;i++) // _a=_b=i+1, // printf("%lld ",query(1,1,siz)); //printf("\n"); &#125;else&#123; scanf("%d%lld",&amp;_a,&amp;_v), _b=_a,_v-=query(1,1,siz),update(1,1,siz); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 813C The Tag Game]]></title>
    <url>%2F2018%2F08%2F24%2Fcf813c%2F</url>
    <content type="text"><![CDATA[题目链接 题解显然这是一个追逐的局面。Alice的棋追着Bob的跑。要保证时间拖得最长，就必须使得Bob逃离的越远。算出AB两个棋子到这棵树上每一个其他点的时间t_A和t_B，然后dfs，看B棋子能到达哪一个点使得t_A>t_B且t_A最大。答案就是最大的这个2t_A。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,x,at[200005],to[400005],_next[400005],cnt=0;int ldis[200005]=&#123;0&#125;,rdis[200005]=&#123;0&#125;,ans=0;bool vis[200005]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;x); int u,v; memset(at,-1,sizeof(at)); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v); u--,v--; to[cnt]=v,_next[cnt]=at[u],at[u]=cnt++; to[cnt]=u,_next[cnt]=at[v],at[v]=cnt++; &#125;&#125;void dfs(int cur,int *dis)&#123; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]]) vis[to[i]]=1, dis[to[i]]=dis[cur]+1, dfs(to[i],dis); &#125;&#125;void dfs2(int cur)&#123; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]]&amp;&amp;ldis[to[i]]&gt;rdis[to[i]]) vis[to[i]]=1,dfs2(to[i]); &#125; ans=max(ans,ldis[cur]);&#125;void solve()&#123; vis[0]=1,dfs(0,ldis); memset(vis,0,sizeof(vis)); vis[x-1]=1,dfs(x-1,rdis); memset(vis,0,sizeof(vis)); dfs2(x-1); printf("%d\n",ans*2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 670C Cinema]]></title>
    <url>%2F2018%2F08%2F24%2Fcf670c%2F</url>
    <content type="text"><![CDATA[题目链接 题解对于每一个影片分别统计一下看的很满意的人和比较满意的人数，维护答案即可。数据很大，需要离散化一下。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[200005], b[200005], c[200005];void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) a[i] = read(); m = read(); for(int i = 0; i &lt; m; ++i) b[i] = read(); for(int i = 0; i &lt; m; ++i) c[i] = read();&#125;void solve()&#123; sort(a, a + n); int max1 = 0, max2 = 0, ans = 1; for(int i = 0; i &lt; m; ++i)&#123; int r1 = upper_bound(a, a + n, b[i]) - lower_bound(a, a + n, b[i]); int r2 = upper_bound(a, a + n, c[i]) - lower_bound(a, a + n, c[i]); if(r1 &gt; max1) max1 = r1, max2 = r2, ans = i + 1; else if(r1 == max1 &amp;&amp; r2 &gt; max2) max2 = r2, ans = i + 1; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 二分法和三分法]]></title>
    <url>%2F2018%2F08%2F24%2Fwriting%2Ftemplate-bi-or-trinary%2F</url>
    <content type="text"><![CDATA[简单的算法有时候也要仔细考量。 二分整数域上的二分二分很好写，但总是有一些坑，容易写的TLE或者是要额外判断。我个人推荐（也是某本书上给出的）的一种写法是：版本A:12345while (r - l)&#123; int mid = (r + l + 1) &gt;&gt; 1; if(judge(mid)) l = mid; else r = mid - 1;&#125; 版本B:12345while (r - l)&#123; int mid = (r + l) &gt;&gt; 1; if(judge(mid)) r = mid; else l = mid + 1;&#125; 这种写法的好处是最后$l$和$r$会回到一个数上面去，就不用担心后续特判的操作。两种版本都是正确的，只是使用的对象不一样。考虑好可行域的划分问题即可。（一般我都是用$[4,5]$这个区间当例子来考虑的）还有一点就是：这两个版本的二分对于负数域也是行得通的。因为一般右移都是算术右移，实现的是向下取整，所以可以正常工作。（不妨考虑$[-3,-2]$）从代码也可以看出版本A更接近左边，版本B更接近右边。 实数域上的二分比起整数域上的二分，实数域由于没有向哪里取整的问题，所以更加容易实现。只需要用一个$eps$判断是否足够接近即可。12345while (r - l &gt; eps)&#123; double mid = (r + l) / 2; if(judge(mid)) r = mid; else l = mid;&#125; 或者可以迭代一定次数，获得一个相对更高的精度。12345for(int i = 0; i &lt; 100; ++i)&#123; double mid = (r + l) / 2; if(judge(mid)) r = mid; else l = mid;&#125; STLlower_bound和upper_bound已经是广为人知了。 参考资料 《算法竞赛进阶指南》]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Tallest Cow]]></title>
    <url>%2F2018%2F08%2F24%2Fluogu2879%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果不存在任何大小关系，不妨认为所有牛的高度都达到了最高。存在大小关系，就不妨一步一步满足。由于最小的单位是1，就让两个牛之间的高度相对两边少1，这样就在满足尽量高的前提下满足了限制条件。这一步可以用区间减法或者差分实现。需要注意的是可能两个牛的关系会重复出现，此时需要去重。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, id, h, m, hi[10005] = &#123;0&#125;;pair&lt;int, int&gt; p[10005];void init()&#123; n = read(), id = read(), h = read(), m = read(); for(int i = 0; i &lt; m; ++i)&#123; p[i].first = read(), p[i].second = read(); if(p[i].first &gt; p[i].second) swap(p[i].first, p[i].second); &#125; sort(p, p + m); m = unique(p, p + m) - p;&#125;void solve()&#123; for(int i = 0; i &lt; m; ++i)&#123; int l = p[i].first, r = p[i].second; hi[l + 1]--, hi[r]++; &#125; int sum = 0; for(int i = 1; i &lt;= n; ++i) sum += hi[i], printf("%d\n", h + sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1958 Strange Towers of Hanoi]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj1958%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$f(i)$为$i$个盘子时候的情况，那么当把$j$个盘子移到另一个柱子上，然后将剩下的用3根柱子汉诺塔形式移动，再将$j$个移回去时，就可以推导出$f(i)$的表达式： f(i) = \min \limits_{1 \le j < i}\left\{2 f(j) + d(i - j) \right\}其中$d(i)$为3根柱子汉诺塔中有$i$个盘子的步数。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll d[15], f[15] = &#123;0&#125;;void init()&#123; d[1] = 1, f[1] = 1; for(int i = 2; i &lt;= 12; ++i) d[i] = d[i - 1] &lt;&lt; 1 | 1;&#125;void solve()&#123; printf("1\n"); for(int i = 2; i &lt;= 12; ++i)&#123; f[i] = INF; for(int j = 1; j &lt; i; ++j) f[i] = min(f[i], (f[j] &lt;&lt; 1) + d[i - j]); printf("%lld\n", f[i]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2018 Best Cow Fences]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj2018%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题精度高的一批…总之想到直接求解比较困难，联想到这样平均值的题目一般要用上二分，所以二分一个最大平均值，然后根据判定条件来就行了。 C(S):\exists l, r ,r - l \ge F,sum[r]-rS\ge sum[l] - lS12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, L, a[100005], sum[100005], maxi = 0;void init()&#123; n = read(), L = read(); sum[0] = 0; for(int i = 1; i &lt;= n; ++i) a[i] = read(), maxi = max(maxi, a[i]), sum[i] = sum[i - 1] + a[i];&#125;bool judge(double x)&#123; double mini = 0; for(int i = L; i &lt;= n; ++i)&#123; double cur = 1.0 * sum[i] - i * x; if(cur &gt; mini || abs(cur - mini) &lt; 1e-5) return true; mini = min(mini, 1.0 * sum[i + 1 - L] - (i + 1 - L) * x); &#125; return false;&#125;void solve()&#123; double l = 1.0 * sum[n] / n, r = 1.0 * maxi; for(int i = 0; i &lt; 60; ++i)&#123; double mid = (l + r) / 2; if(judge(mid)) l = mid; else r = mid; &#125; printf("%d\n", (int)(1000 * l));&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1458 Sumdiv]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj1845%2F</url>
    <content type="text"><![CDATA[题目地址 题解分治法求解等比数列和的一个运用。每次把数列分成两半，就可以做到$O(logn)$了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int a, b, sum = 1;int poww(int d, int e)&#123; int res = 1; while(e)&#123; if(e &amp; 1) res = (res * d) % 9901; d = (d * d) % 9901; e &gt;&gt;= 1; &#125; return res;&#125;int f(int p, int c)&#123; if(c == 0) return 1; if(c == 1) return (1 + p) % 9901; if(c &amp; 1) return f(p, c &gt;&gt; 1) * (1 + poww(p, (c + 1) &gt;&gt; 1)) % 9901; else return ((f(p, c &gt;&gt; 1) + 9900) * (1 + poww(p, c &gt;&gt; 1)) + 1) % 9901;&#125;void init()&#123; a = read(), b = read();&#125;void solve()&#123; int t = a; for(int i = 2; i * i &lt;= a; ++i)&#123; if(t % i == 0)&#123; int cc = 0; do&#123; t /= i, cc++; &#125;while(t % i == 0); sum = sum * f(i % 9901, cc * b) % 9901; &#125; if(t == 1) break; &#125; if(t != 1) sum = sum * f(t % 9901, b) % 9901; printf("%d\n", sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3784 Running Median]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj3784%2F</url>
    <content type="text"><![CDATA[题目地址 题解对顶堆技巧。就是把序列拆成两个部分，使得要维护的特定的数恰好处于被堆分割的部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq1;priority_queue&lt;int&gt; pq2;int n;void init()&#123; int snum = read(); n = read(); printf("%d %d\n", snum, (n + 1) &gt;&gt; 1);&#125;void solve()&#123; if(n == 1)&#123; printf("%d", read()); return ; &#125; int hd = read(), cnt = 2; printf("%d ", hd); pq2.push(hd); for(int i = 2; i &lt;= n; ++i)&#123; hd = read(); if(hd &lt;= pq2.top()) pq2.push(hd); else pq1.push(hd); if(i &amp; 1)&#123; while(pq2.size() &gt; pq1.size() + 1) pq1.push(pq2.top()), pq2.pop(); while(pq2.size() &lt; pq1.size() + 1) pq2.push(pq1.top()), pq1.pop(); printf("%d", pq2.top()); if(cnt == 10 &amp;&amp; i != n) cnt = 0, printf("\n"); else if(i != n) printf(" "); cnt++; &#125; &#125; while(!pq1.empty()) pq1.pop(); while(!pq2.empty()) pq2.pop();&#125;int main()&#123; int T = read(); for(int i = 1; i &lt;= T; ++i)&#123; init(); solve(); if(i != T) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1995 Raising Modulo Numbers]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj1995%2F</url>
    <content type="text"><![CDATA[题目地址 题解快速幂。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int poww(int a, int b, int m)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (res * a) % m; a = (a * a) % m; b &gt;&gt;= 1; &#125; return res;&#125;int m, h, dd[45005], ex[45005];void init()&#123; m = read(), h = read(); for(int i = 0; i &lt; h; ++i) dd[i] = read(), ex[i] = read();&#125;void solve()&#123; int sum = 0; for(int i = 0; i &lt; h; ++i) sum = (sum + poww(dd[i] % m, ex[i], m)) % m; printf("%d\n", sum);&#125;int main()&#123; int T = read(); while(T--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3468 A Simple Problem with Integers]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[题目地址 题解线段树水题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long ll;ll sum[400005],add[400005]=&#123;0&#125;,mul[400005]=&#123;0&#125;,_v;int n,size,_a,_b,m;void pushdown(int id,int len)&#123; if(id&gt;=size||!add[id])return ; sum[id&lt;&lt;1]+=add[id]*(ll)(len&gt;&gt;1); sum[id&lt;&lt;1|1]+=add[id]*(ll)(len&gt;&gt;1); add[id&lt;&lt;1]+=add[id]; add[id&lt;&lt;1|1]+=add[id]; add[id]=0;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); int i; for(size=1;size&lt;n;size&lt;&lt;=1); for(i=size;i-size&lt;n;i++) scanf("%lld",&amp;sum[i]); for(;i&lt;(size&lt;&lt;1);i++)sum[i]=0; for(i=size-1;i&gt;=1;i--) sum[i]=sum[i&lt;&lt;1]+sum[i&lt;&lt;1|1];&#125;void update(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(_a&lt;=l&amp;&amp;r&lt;=_b)&#123; sum[id]+=_v*(ll)(r-l+1),add[id]+=_v; return ; &#125; pushdown(id,r-l+1); update(id&lt;&lt;1,l,(l+r)&gt;&gt;1); update(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); sum[id]=sum[id&lt;&lt;1]+sum[id&lt;&lt;1|1];&#125;ll query(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return 0ll; if(_a&lt;=l&amp;&amp;r&lt;=_b)return sum[id]; pushdown(id,r-l+1); return query(id&lt;&lt;1,l,(l+r)&gt;&gt;1)+query(id&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;void solve()&#123; int i,j,o,u,v; char ord[3]; for(i=0;i&lt;m;i++)&#123; scanf("%s%d%d",ord,&amp;_a,&amp;_b); if(ord[0]=='C') scanf("%lld",&amp;_v), update(1,1,size); else printf("%lld\n",query(1,1,size)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2299 Ultra-QuickSort]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[题目地址 题解逆序对。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[500005], b[500005];ll ans;void init()&#123; for(int i = 0; i &lt; n; ++i) a[i] = read();&#125;void Merge(int ls, int rs, int re)&#123; int lp = ls, rp = rs, tp = ls; while(lp &lt; rs &amp;&amp; rp &lt; re)&#123; if(a[lp] &lt;= a[rp]) b[tp++] = a[lp++]; else b[tp++] = a[rp++], ans += 1ll * (rs - lp); &#125; while(lp &lt; rs) b[tp++] = a[lp++]; while(rp &lt; re) b[tp++] = a[rp++]; memcpy(a + ls, b + ls, sizeof(int) * (re - ls));&#125;void ms(int l, int r)&#123; int len = r - l, mid = (r + l) &gt;&gt; 1; if(len == 1) return ; ms(l, mid), ms(mid, r); Merge(l, mid, r);&#125;void solve()&#123; ans = 0; ms(0, n); printf("%lld\n", ans);&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2893 M × N Puzzle]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj2893%2F</url>
    <content type="text"><![CDATA[题目地址 题解将这个拼图展开，可以发现：0左右移动不改变序列的逆序对数，上下移动改变的逆序对数和列数的奇偶性相反。因此当列数是奇数时可以直接根据原序列逆序对数是不是偶数判断，列数是偶数时由于0上下移动引起对数的变化的奇偶性只和它始态行和终态行之间的距离有关，因此只需判断原序列逆序对数和这个距离的奇偶性是否相同即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[1000005], b[1000005], dis;ll ans;void init()&#123; int cnt = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j)&#123; a[cnt++] = read(); if(a[cnt - 1] == 0) cnt--, dis = n - 1 - i; &#125;&#125;void Merge(int ls, int rs, int re)&#123; int lp = ls, rp = rs, tp = ls; while(lp &lt; rs &amp;&amp; rp &lt; re)&#123; if(a[lp] &lt;= a[rp]) b[tp++] = a[lp++]; else b[tp++] = a[rp++], ans += 1ll * (rs - lp); &#125; while(lp &lt; rs) b[tp++] = a[lp++]; while(rp &lt; re) b[tp++] = a[rp++]; memcpy(a + ls, b + ls, sizeof(int) * (re - ls));&#125;void ms(int l, int r)&#123; int len = r - l, mid = (r + l) &gt;&gt; 1; if(len == 1) return ; ms(l, mid), ms(mid, r); Merge(l, mid, r);&#125;void solve()&#123; ans = 0; ms(0, n * m - 1); if(m &amp; 1) printf("%s\n", (ans % 2) ? "NO" : "YES"); else printf("%s\n", (ans % 2 == dis % 2) ? "YES" : "NO");&#125;int main()&#123; while(n = read(), m = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第九章]]></title>
    <url>%2F2018%2F08%2F23%2Faoapc-chapter9%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第九章部分习题的整合。 例9-1 UVa1025 A Spy in the Metro题目链接 每一个时刻都有3个决策：在当前车站等一下，从向左开的车上下车，从向右开的车上下车。由于“坐在车上”这个状态不好表示，因此相应的替换为后两个状态。由于要表示当前时刻和当前车站，因此用$dp(i, j)$表示当前在$i$时刻，$j$车站，最少的在车站的时间。这样的话整个dp的时间复杂度为$O(nT)$。注意越界！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, T, m1, m2;int dp[255][55], t[55];bool has[255][55][2];void init()&#123; T = read(); t[0] = t[n] = 0; for(int i = 1; i &lt; n; ++i) t[i] = read(); memset(has, 0, sizeof(has)); m1 = read(); for(int i = 0; i &lt; m1; ++i) &#123; int tt = read(); for(int j = 1; j &lt;= n; ++j)&#123; if(tt &gt; T) break; has[tt][j][0] = 1, tt += t[j]; &#125; &#125; m2 = read(); for(int i = 0; i &lt; m2; ++i) &#123; int tt = read(); for(int j = n; j &gt;= 1; --j)&#123; if(tt &gt; T) break; has[tt][j][1] = 1, tt += t[j - 1]; &#125; &#125;&#125;void solve()&#123; memset(dp, 0x3f, sizeof(dp)); dp[0][1] = 0; for(int i = 1; i &lt;= T; ++i) for(int j = 1; j &lt;= n; ++j)&#123; int&amp; d = dp[i][j]; d = dp[i - 1][j] + 1; if(j &gt; 1 &amp;&amp; has[i][j][0] &amp;&amp; i &gt;= t[j - 1]) d = min(d, dp[i - t[j - 1]][j - 1]); if(j &lt; n &amp;&amp; has[i][j][1] &amp;&amp; i &gt;= t[j]) d = min(d, dp[i - t[j]][j + 1]); &#125; if(dp[T][n] &gt; T) printf("impossible\n"); else printf("%d\n", dp[T][n]);&#125;int main()&#123; int kase = 1; while(n = read())&#123; printf("Case Number %d: ", kase++); init(); solve(); &#125; return 0;&#125; 例9-2 UVa437 The Tower of Babylon题目链接 一个扩展性的矩阵嵌套问题？我设计的状态是$dp(i, j, id)$表示塔的第$i$块砖为第$j$个方块，并且高的编号为$id$时塔的最高高度。这样由于每一次转移只需要枚举之前一次放上去的方块，就可以判断是否合法。由于至多需要$2n$层，每一层的决策数都为$O(n)$，故总的时间复杂度为$O(n^2)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int dp[63][33][3], n, ord[33][3];void init()&#123; int x[3]; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; 3; ++j) x[j] = read(); sort(x, x + 3); for(int j = 0; j &lt; 3; ++j) ord[i][j] = x[2 - j]; &#125;&#125;void solve()&#123; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; 3; ++j) dp[1][i][j] = ord[i][j]; int ans = 0; for(int i = 2; ; ++i)&#123; int flag = 0; for(int j = 0; j &lt; n; ++j) for(int k = 0; k &lt; 3; ++k)&#123; int &amp;d = dp[i][j][k]; int a, b; if(k == 0) a = ord[j][1], b = ord[j][2]; if(k == 1) a = ord[j][0], b = ord[j][2]; if(k == 2) a = ord[j][0], b = ord[j][1]; for(int jj = 0; jj &lt; n; ++jj) for(int kk = 0; kk &lt; 3; ++kk)&#123; if(!dp[i - 1][jj][kk]) continue; int aa, bb; if(kk == 0) aa = ord[jj][1], bb = ord[jj][2]; if(kk == 1) aa = ord[jj][0], bb = ord[jj][2]; if(kk == 2) aa = ord[jj][0], bb = ord[jj][1]; if(aa &gt; a &amp;&amp; bb &gt; b) d = max(d, dp[i - 1][jj][kk] + ord[j][k]), ans = max(ans, d), flag = 1; &#125; &#125; if(!flag) break; &#125; printf("%d\n", ans);&#125;int main()&#123; int kase = 1; while(n = read())&#123; printf("Case %d: maximum height = ", kase++); init(); solve(); &#125; return 0;&#125; 例9-5 UVa12563 Jin Ge Jin Qu hao题目链接 先对前$t-1$秒跑一个背包，然后再检查一下最多的方案和对应的时间，并且加上劲歌金曲即可。原因是因为劲歌金曲唱了一定比不唱好，所以$t$要减掉一。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, t, len[55], dp[10005];void init()&#123; n = read(), t = read(); for(int i = 0; i &lt; n; ++i) len[i] = read();&#125;void solve()&#123; memset(dp, -1, sizeof(dp)); dp[0] = 0; t--; for(int i = 0; i &lt; n; ++i) for(int j = t; j &gt;= len[i]; --j) if(dp[j - len[i]] &gt;= 0) dp[j] = max(dp[j], dp[j - len[i]] + 1); int ans = -1, maxi; for(int i = t; i &gt;= 0; --i) if(dp[i] &gt; ans) ans = dp[i], maxi = i; printf("%d %d\n", ans + 1, maxi + 678);&#125;int main()&#123; int T = read(); for(int i = 1; i &lt;= T; ++i)&#123; printf("Case %d: ", i); init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第八章]]></title>
    <url>%2F2018%2F08%2F23%2Faoapc-chapter8%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第八章部分习题的整合。 例8-1 UVa120 Stacks of Flapjacks题目链接 显然，直接把对应的数放到它应该在的地方的排序方式是最快的。所以可以先对整个序列排一个序，然后从底向上判断某个位置上的数是否是排序后对应的数，不是的话就先把该数翻到最顶上，然后再翻到对应位置。这么做就是最快的排序方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[10005];int st[10005], n, p[10005], cur;int read()&#123; int x = 0; char c = s[cur]; while(c &lt; '0' || c &gt; '9')&#123; if(c == '\n' || c == EOF) return 0; c = s[++cur]; &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = s[++cur]; return x; &#125;void init()&#123; cur = n = 0; while(st[n] = read()) p[n] = st[n], n++; sort(p, p + n);&#125;void solve()&#123; for(int i = 0; i &lt; n - 1; ++i) printf("%d ", st[i]); printf("%d\n", st[n - 1]); for(int i = n - 1; i &gt; 0; --i)&#123; if(p[i] == st[i]) continue; int j; for(j = i - 1; st[j] != p[i]; --j) ; if(j) reverse(st, st + j + 1), printf("%d ", n - j); reverse(st, st + i + 1), printf("%d ", n - i); &#125; printf("0\n");&#125;int main()&#123; while(fgets(s, 10000, stdin) != NULL)&#123; init(); solve(); &#125; return 0;&#125; 例8-3 UVa1152 4 Values whose Sum is 0题目链接 这题神烦，哈希表几乎不可能过得了。所以还是直接排序后二分比较快。即所谓中途相遇法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[4005], b[4005], c[4005], d[4005];int q[16000005];ll ans;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) a[i] = read(), b[i] = read(), c[i] = -read(), d[i] = -read(); int cnt = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) q[cnt++] = c[i] + d[j]; sort(q, q + cnt);&#125;void solve()&#123; ans = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) ans += upper_bound(q, q + n * n, a[i] + b[j]) - lower_bound(q, q + n * n, a[i] + b[j]); printf("%lld\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); if(T &gt; 0) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001-2005 题解]]></title>
    <url>%2F2018%2F08%2F23%2Fnoip2001-2005%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2001-2005题目的题解。 NOIP2001普及T1 数的计算题目地址 \mathcal dp\left(i\right) = 1+ \sum_{j=1}^{\lfloor i/2\rfloor} dp\left(j\right) (i>1) \\ dp\left(1\right) = 11234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;typedef long long ll;int dp[1005]=&#123;0&#125;,n;int main()&#123; dp[2]=2,dp[1]=1; scanf("%d",&amp;n); int i,j; for(i=3;i&lt;=n;i++)&#123; for(j=i/2;j&gt;=1;j--) dp[i]+=dp[j]; dp[i]++; &#125; printf("%d\n",dp[n]); return 0;&#125; 普及T2 最大公约数与最小公倍数问题题目地址 我们知道$\mathcal x_0$必须是$\mathcal y_0$的约数。所以记$\mathcal t=\frac{y_0}{x_0}$，则$\mathcal 2^u$（$\mathcal u$为$\mathcal t$不同质因子的个数）即为答案。（集合划分）很巧妙的数学方法。爆搜会TLE来着。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int isP(int a)&#123;for(int i=2;i*i&lt;=a;i++)if(a%i==0)return 0;return 1;&#125;int main()&#123; int x0,y0,i,ans=1; scanf("%d%d",&amp;x0,&amp;y0); if(y0%x0)&#123;printf("0\n");return 0;&#125; for(i=2,y0/=x0;i&lt;=y0;i++) if(y0%i==0&amp;&amp;isP(i))ans&lt;&lt;=1; printf("%d\n",ans); return 0;&#125; 普及T3 求先序排列题目链接 由后序得根，然后中序的两半继续分治。递归建立一颗树。具体过程是，在中序中找到根，然后由于左右子树分别在其左右，故可以再为左右子树建树。如果到了树为空的情况就返回。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s1[30], s2[30];int root, lc[250], rc[250];int get(int il, int ir, int pl, int pr)&#123; if(ir - il &lt; 0) return 0; int id = s2[pr], i; for(i = il; i &lt;= ir; ++i) if(s1[i] == id) break; int len = i - il; lc[id] = get(il, i - 1, pl, pl + len - 1); rc[id] = get(i + 1, ir, pl + len, pr - 1); return id;&#125;void getP(int id)&#123; printf("%c", id); if(lc[id]) getP(lc[id]); if(rc[id]) getP(rc[id]);&#125;void solve()&#123; int len = strlen(s1); root = get(0, len - 1, 0, len - 1); getP(root);&#125;int main()&#123; scanf("%s%s", s1, s2); solve(); return 0;&#125; 普及T4 装箱问题题目地址 一个简单的背包问题。不过稍微要做一些处理，只要考虑状态的合法性即可。初始合法的状态就是箱子为空，随后按照01背包扩展到其他状态。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int V, n, f[20005] = &#123;0&#125;, v[35];void init()&#123; V = read(), n = read(); for(int i = 0; i &lt; n; ++i) v[i] = read();&#125;void solve()&#123; f[0] = 1; for(int i = 0; i &lt; n; ++i) for(int j = V; j &gt;= v[i]; --j) f[j] |= f[j - v[i]]; int ans; for(ans = V; !f[ans]; --ans) ; printf("%d\n", V - ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 一元三次方程求解题目地址 有4种方法： 暴力，按$0.01$步长枚举 二分，按照单调性求解 数学公式 导数 这里用的是二分，感觉还不错。1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef double D;D a,b,c,d,t1,t2,epi=0.01;D get(D k)&#123; return k*a*k*k+b*k*k+c*k+d;&#125;D C(int ll,int rr)&#123; D tmp,mid,l=(D)ll,r=(D)rr; int i=(get(l)&gt;get(r))?1:0; for(;;)&#123; mid=(l+r)/2.0; tmp=get(mid); if(r-l&lt;epi&amp;&amp;r-l&gt;-epi)break; if(tmp&gt;0)&#123; if(i)l=mid; else r=mid; &#125;else&#123; if(i)r=mid; else l=mid; &#125; &#125; printf("%.2lf ",mid);&#125;int main()&#123; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); int i;for(i=-100;i&lt;=100;i++)&#123; t1=(D)i,t2=t1+0.99; t1=get(t1),t2=get(t2); if(t1*t2&lt;0)C(i,i+1); else if(t1&lt;epi&amp;&amp;t1&gt;-epi)printf("%.2lf ",(D)i); &#125; return 0; &#125; 提高T2 数的划分题目地址 一个经典的递推问题。 方法一我的方法是设$f(n, m, k)$为数$n$划分为$k$个小于或等于$m$的数的方法数。那么有 f(n, m, k) = f(n, m - 1, k) + f(n - m, m, k - 1)这么做是$O(n ^2 k)$的。1234567891011121314#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int f[205][7]=&#123;0&#125;,n,k;int main()&#123; f[0][0]=1; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) for(int p=1;p&lt;=n;p++) if(p-i&gt;=0)f[p][j]+=f[p-i][j-1]; printf("%d\n",f[n][k]); return 0;&#125; 方法二设$f(n, k)$为题意所求，那么： 划分里面有$1$，那么包含$f(n - 1, k - 1)$&gt; 划分里面没有$1$，那么给划分里面所有的数添上一个$1$，即包含$f(n - k, k)$。因此得到f(n, k) = f(n - 1, k - 1) + f(n - k, k)时间复杂度$O(nk)$。 提高T3 统计单词个数题目地址 提高T4 Car的旅行路线题目地址 非常简单的最短路，非常难的建图。出发地和到达地每个机场间道路权值设为0即可。建图就是暴力用勾股求矩形顶点。在下面的代码中，我将顶点拆成了4个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#define rep(e) for(e=0;e&lt;4;e++)using namespace std;typedef double db;int T,s,t,A,B,rec[405][2],pr[105],vis[405];db ds[405][405],d[405][405],l[405];db dis(int a,int b)&#123; return (rec[a][0]-rec[b][0])*(rec[a][0]-rec[b][0])+ (rec[a][1]-rec[b][1])*(rec[a][1]-rec[b][1]);&#125;bool eq(db a,db b)&#123;return a-b&gt;(-1e-6)&amp;&amp;a-b&lt;(1e-6);&#125;void make(int i)&#123; db q1=dis(i,i+2),q2=dis(i,i+1),q3=dis(i+1,i+2); if(eq(q1+q2,q3))rec[i+3][0]=rec[i+2][0]+rec[i+1][0]-rec[i][0], rec[i+3][1]=rec[i+2][1]+rec[i+1][1]-rec[i][1]; else if(eq(q2+q3,q1))rec[i+3][0]=rec[i+2][0]+rec[i][0]-rec[i+1][0], rec[i+3][1]=rec[i+2][1]+rec[i][1]-rec[i+1][1]; else if(eq(q1+q3,q2))rec[i+3][0]=rec[i+1][0]+rec[i][0]-rec[i+2][0], rec[i+3][1]=rec[i+1][1]+rec[i][1]-rec[i+2][1];&#125;void dijkstra()&#123; int at,i=A&lt;&lt;2,j;db lst; fill(l,l+s,1e10); fill(vis,vis+s,0); l[i]=l[i+1]=l[i+2]=l[i+3]=0.0; for(i=0;i&lt;s;i++)&#123; for(lst=1e10,j=0;j&lt;s;j++) if(!vis[j]&amp;&amp;l[j]&lt;lst)at=j,lst=l[j]; vis[at]=1; for(j=0;j&lt;s;j++) l[j]=min(l[at]+d[at][j],l[j]); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v;db price; while(T--)&#123; scanf("%d%d%d%d",&amp;s,&amp;t,&amp;A,&amp;B); A--,B--,s&lt;&lt;=2; for(i=0;i&lt;s;i+=4)&#123; scanf("%d%d%d%d%d%d%d",&amp;rec[i][0],&amp;rec[i][1],&amp; rec[i+1][0],&amp;rec[i+1][1],&amp;rec[i+2][0],&amp; rec[i+2][1],&amp;pr[i]),make(i); if(i/4==A||i/4==B)pr[i]=0; &#125; for(i=0;i&lt;s;i+=4)&#123; for(j=0;j&lt;s;j+=4)&#123; price=(i!=j)?t:pr[i]; rep(u)rep(v) ds[i+u][j+v]=sqrt(dis(i+u,j+v)), d[i+u][j+v]=price*ds[i+u][j+v]; &#125; &#125; dijkstra(); printf("%.1lf\n",l[B&lt;&lt;2]); &#125; return 0;&#125; NOIP2002普及T2 选数题目地址 用DFS构造出所有的组合即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,x[24],ans=0;bool isPrime(int t)&#123; if(t&amp;1)&#123; if(t==1)return false; else&#123; for(int i=3;i*i&lt;=t;i+=2) if(t%i==0)return false; return true; &#125; &#125;else return t==2;&#125;void dfs(int index,int used,int sum)&#123; sum+=x[index]; if(used==k)&#123; if(isPrime(sum))ans++; return ; &#125; for(int i=index+1;i&lt;=n-k+used;i++) dfs(i,used+1,sum);&#125;void init()&#123; n=read(),k=read(); for(int i=0;i&lt;n;i++) x[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;=n-k;i++) dfs(i,1,0); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; NOIP2003提高T1 神经网络题目地址 拓扑排序。按照题意模拟即可。注意，只有一个神经元的情况要特判。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int mp[105][105],c[105]=&#123;0&#125;,u[105],V,E,d[105]=&#123;0&#125;;int que[105],f=0,r=0,vis[105]=&#123;0&#125;,mat[105][105]=&#123;0&#125;;void topo()&#123; int du[105]=&#123;0&#125;,i,j,o=0; for(i=1;i&lt;=V;i++)&#123; for(j=1;j&lt;=V;j++) if(mat[j][i])du[i]++,d[j]++; if(!du[i])vis[i]=1,que[r++]=i; &#125; while(r-f)&#123; i=que[f++]; if(du[i])c[i]-=u[i]; if(c[i]&gt;0)&#123; for(j=1;j&lt;=V;j++) if(mat[i][j])&#123; c[j]+=mp[i][j]*c[i]; if(!vis[j]) vis[j]=1,que[r++]=j; &#125; &#125; &#125; for(i=1;i&lt;=V;i++) if(!d[i]&amp;&amp;c[i]&gt;0) o=1,printf("%d %d\n",i,c[i]); if(!o)printf("NULL\n");&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,_u,v,_c; for(i=1;i&lt;=V;i++) scanf("%d%d",&amp;c[i],&amp;u[i]); for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;_u,&amp;v,&amp;_c), mat[_u][v]=1, mp[_u][v]=_c; if(V==1&amp;&amp;c[1]&gt;0) printf("%d %d\n",1,c[1]); else topo(); return 0;&#125; NOIP2004提高T1 津津的储蓄计划题目地址 模拟神题。123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int saved = 0, cur = 0;int main()&#123; int flag = 1; for(int i = 1; i &lt;= 12; ++i)&#123; cur += 300; int curm; scanf("%d", &amp;curm); if(curm &gt; cur)&#123; printf("-%d\n", i), flag = 0; break; &#125; cur -= curm; saved += cur - (cur % 100); cur %= 100; &#125; if(flag) printf("%d\n", cur + saved * 6 / 5); return 0;&#125; NOIP2005提高T4 等价表达式题目地址 表达式求值。然而数据可以很大，直接比较答案和原式的做法不大现实。所以我们可以采用NOIP2014解方程的做法，把$a$带入一个数，再模一个质数，看结果是不是相同的。实际上为了保证准确性是可以模多个质数的，但这题数据很水，就没有这么做。最好还是多模几个质数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define A 1189using namespace std;int stack[2][10005],top[2]=&#123;0&#125;,pro[300],lim,targ,M=10009;char _exp[10000];int poww(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125; return res; &#125;void opr()&#123; int a1,a2,b; a2=stack[0][--top[0]], a1=stack[0][--top[0]], b=stack[1][--top[1]]; if(b=='+')stack[0][top[0]++]=(a1+a2)%M; if(b=='-')stack[0][top[0]++]=(a1-a2+M)%M; if(b=='*')stack[0][top[0]++]=(a1*a2)%M; if(b=='^')stack[0][top[0]++]=poww(a1,a2);&#125;void calc()&#123; int i,j,t=-1,cnt=0; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='a') stack[0][top[0]++]=A; else if(isdigit(_exp[i]))&#123; if(t&lt;0)t=_exp[i]-'0'; else t=t*10+_exp[i]-'0'; &#125;else if(_exp[i]!=' ')&#123; if(t!=-1) stack[0][top[0]++]=t, t=-1; if(_exp[i]=='(') stack[1][top[1]++]='(',cnt++; else if(_exp[i]==')')&#123; if(!cnt)continue; while(stack[1][top[1]-1]!='(') opr(); top[1]--,cnt--; &#125;else&#123; while(top[1]&amp;&amp;stack[1][top[1]-1]!='('&amp;&amp; pro[stack[1][top[1]-1]]&gt;=pro[_exp[i]]) opr(); stack[1][top[1]++]=_exp[i]; &#125; &#125; &#125;&#125;void init()&#123; pro['+']=pro['-']=1, pro['*']=2, pro['^']=3; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; calc(); targ=stack[0][0];&#125;void solve()&#123; int m,i; fgets(_exp,99,stdin); sscanf(_exp,"%d",&amp;m); for(i=0;i&lt;m;i++)&#123; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; top[0]=top[1]=0; memset(stack,0,sizeof(stack)); calc(); if(stack[0][0]==targ) printf("%c",'A'+i); &#125; printf("\n");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>栈</tag>
        <tag>树形结构</tag>
        <tag>拓扑排序</tag>
        <tag>DFS</tag>
        <tag>数论</tag>
        <tag>递推</tag>
        <tag>背包DP</tag>
        <tag>最短路</tag>
        <tag>非完美算法</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1996-2000 题解]]></title>
    <url>%2F2018%2F08%2F21%2Fnoip1996-2000%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP1996-2001部分题目的题解。 NOIP1996提高T3 挖地雷题目地址 题目已经帮你拓扑排序完了，直接转移就可以。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,V,mp[25][25]=&#123;0&#125;,m[25],dp[25]=&#123;0&#125;,pre[25],ans[25],maxi=0,at;int main()&#123; scanf("%d",&amp;n); int i,j; fill(pre,pre+n,-1);//记录路径 for(i=0;i&lt;n;i++) scanf("%d",&amp;m[i]); for(i=0;i&lt;n-1;i++) for(j=i+1;j&lt;n;j++) scanf("%d",&amp;mp[i][j]); dp[0]=maxi=m[0],at=0; for(i=1;i&lt;n;i++)&#123; for(j=i-1;j&gt;=0;j--) if(mp[j][i]&amp;&amp;dp[j]&gt;=dp[i]) dp[i]=dp[j],pre[i]=j; dp[i]+=m[i]; if(dp[i]&gt;maxi) maxi=dp[i],at=i; &#125; for(j=0,i=at;i!=-1;i=pre[i]) ans[j++]=i+1; for(i=j-1;i&gt;=0;i--)&#123; printf("%d",ans[i]); if(i)printf(" "); &#125; printf("\n%d\n",maxi); return 0;&#125; 提高T4 砝码称重题目地址 用了完全背包，但是数据很弱，好像没有必要。可以暴力枚举。123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int f[1005]=&#123;0&#125;,n,v[6],ans=0;void packX(int vv)&#123;//二进制枚举版本 int p=1,vi=vv,j; while(n&gt;=p)&#123; for(j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); n-=p,p&lt;&lt;=1,vi&lt;&lt;=1; &#125; if(n)&#123; for(vi=n*vv,j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); &#125;&#125;int main()&#123; v[0]=1,v[1]=2,v[2]=3,v[3]=5,v[4]=10,v[5]=20; f[0]=1; for(int i=0;i&lt;6;i++)&#123; scanf("%d",&amp;n); if(n)packX(v[i]); &#125; for(int i=1;i&lt;=1000;i++) ans+=f[i]; printf("Total=%d\n",ans); return 0;&#125; NOIP1997普及T1 棋盘题目地址 自己推一下就行了。长方形（含正方形）个数为 \frac {nm(n+1)(m+1) }{4}正方形个数为 \mathcal \sum_{i=1}^m {i \left( n-m+i \right) \left( m \le n \right)}1234567891011121314#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll n,m,a1=0,a2=0;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(n&lt;m)swap(n,m); a1=m*n*(n+1)*(m+1)/4; for(int i=1;i&lt;=m;i++) a2+=(n-m+i)*i; printf("%lld %lld\n",a2,a1-a2); return 0; &#125; 普及T2 三角形题目地址 暴力枚举即可。用了全排列。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int ans=0,p,rec[20],now[20]=&#123;1,2,3,4,5,6,7,8,9&#125;;void cmp()&#123; if(!ans||memcmp(now,rec,sizeof(int)*9)&lt;0) memcpy(rec,now,sizeof(rec)); ans++;&#125;int ok()&#123; return ((now[0]&lt;now[5]&amp;&amp;now[5]&lt;now[8]) &amp;&amp;(now[1]&lt;now[3]&amp;&amp;now[6]&lt;now[7]&amp;&amp;now[2]&lt;now[4]) &amp;&amp;(now[0]+now[1]+now[3]+now[5]==p) &amp;&amp;(now[6]+now[7]+now[8]+now[5]==p) &amp;&amp;(now[0]+now[2]+now[4]+now[8]==p));&#125;int main()&#123; scanf("%d",&amp;p); do&#123; if(ok())cmp(); &#125;while(next_permutation(now,now+9)); if(!ans)&#123; printf("NO\n"); return 0; &#125; printf("%d\n",ans); printf("%d\n%d %d\n%d %d\n%d %d %d %d\n",rec[0], rec[1],rec[2],rec[3],rec[4],rec[5],rec[6], rec[7],rec[8]); return 0; &#125; 普及T3 街道题目地址 就是非常正常的DP。递推式 \mathcal dp(i,j) = dp(i-1,j)+dp(i,j-1)之后再用一个简单的高精度就可以了。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll M=1000000000000000,dp[55][55][2]=&#123;0&#125;,n,m,x1,x2,y1,y2,ok=1;void add(ll u1,ll v1,ll u2,ll v2)&#123; ll a=dp[u1][v1][0]+dp[u2][v2][0]; dp[u2][v2][0]=a%M,a/=M; a+=dp[u1][v1][1]+dp[u2][v2][1]; dp[u2][v2][1]=a%M;//简单的高精度&#125;void solve()&#123; dp[1][1][0]=1; for(ll i=1;i&lt;=n;i++) for(ll j=1;j&lt;=m;j++) if((ok&amp;&amp;(i&lt;x1||i&gt;x2||j&lt;y1||j&gt;y2))||(!ok)) add(i-1,j,i,j), add(i,j-1,i,j); //递推过程 dp[n][m][1]%=100000; if(dp[n][m][1]&gt;0)printf("%lld%015lld\n",dp[n][m][1],dp[n][m][0]); else printf("%lld\n",dp[n][m][0]);&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(!x1&amp;&amp;!x2&amp;&amp;!y1&amp;&amp;!y2)ok=0; else&#123; if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); &#125; solve(); return 0;&#125; 提高T1 棋盘问题2（待考察？）题目地址 本题我只想出来了一种比较简单的搜索方法。。。实际上原题数据很小，基本上各种搜索方法都可以过，但是当$N = 10$的时候就很难卡过去了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,sqr,mat[15][15]=&#123;0&#125;,dx[]=&#123;0,0,-1,1&#125;,dy[]=&#123;-1,1,0,0&#125;,ans=0;bool isprime[205]=&#123;0&#125;,used[105]=&#123;0&#125;;void dfs(int x,int y)&#123; if(ans)return ; for(int i=2;!ans&amp;&amp;i&lt;=sqr;i++)&#123; if(!used[i]&amp;&amp;(!x||isprime[i+mat[x-1][y]])&amp;&amp;(!y||isprime[i+mat[x][y-1]]))&#123; mat[x][y]=i,used[i]=1; if(x==y)&#123; if(x==n-1)&#123;ans=1;return;&#125; else dfs(x,y+1); &#125;else if(y==n-1)dfs(x+1,x); else if(x==n-1)dfs(y+1,y+1); else if(y&gt;x)dfs(x,y+1); else if(x&gt;y)dfs(x+1,y); if(!ans)mat[x][y]=0,used[i]=0; &#125; &#125;&#125;void init()&#123; n=read(); sqr=n*n; for(int i=3;i&lt;=200;i+=2)&#123; isprime[i]=1; for(int j=3;j*j&lt;=i;j+=2) if(i%j==0)&#123; isprime[i]=0;break; &#125; &#125;&#125;void solve()&#123; mat[0][0]=1,used[1]=1; dfs(0,1); if(!ans)printf("NO\n"); else&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n-1;j++) printf("%d ",mat[i][j]); printf("%d\n",mat[i][n-1]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; NOIP1998普及T1 寻找三位数题目地址 很简单的枚举。只要从101枚举到333即可，然后记录每一位。可以采用特殊策略优化，比如当前数字必须不是5的倍数。1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char k[10];int main()&#123; int a,b,c,d,fl,i; for(a=101;a&lt;=333;a++)&#123; if(a%5==0)continue; memset(k,0,sizeof(k)); fl=1,b=a,c=a*2,d=a*3; k[b%10]++,k[c%10]++,k[d%10]++; k[(b/10)%10]++,k[(c/10)%10]++,k[(d/10)%10]++; k[b/100]++,k[c/100]++,k[d/100]++; for(i=1;i&lt;=9;i++) if(k[i]!=1) fl=0; if(fl)printf("%d %d %d\n",b,c,d); &#125; return 0;&#125; 普及T2 阶乘之和题目地址 高精度乘法+加法水过。12 普及T3 幂次方题目地址 递归计算即可。12 提高T1 火车站题目地址 设第二站上的人数是$p$，则：容易看出每一站上下车的人都等于$fib[i]a+fib[j]p$，其中$i$和$j$为相邻正整数。那么只需要算出最终车上的人等于多少$a$加多少$p$，解出$p$，然后带入第$x$站的数据即可。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int a,n,m,x,fib[25],xs1[25],xs2[25];void init()&#123; a=read(),n=read(),m=read(),x=read(); fib[0]=0,fib[1]=1; for(int i=2;i&lt;=24;i++) fib[i]=fib[i-1]+fib[i-2];&#125;void solve()&#123; xs1[1]=xs1[2]=1,xs2[1]=xs2[2]=0; for(int i=3;i&lt;n;i++) xs1[i]=xs1[i-1]+fib[i-2]-fib[i-3], xs2[i]=xs2[i-1]+fib[i-1]-fib[i-2]; printf("%d\n",xs1[x]*a+xs2[x]*(m-xs1[n-1]*a)/xs2[n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T2 拼数题目地址 NOIP1999普及T1 Cantor表题目地址 找规律，分奇偶讨论，最后$ \mathcal O(1)$计算。12345678#include &lt;cstdio&gt;using namespace std;int main()&#123; int n,i;scanf("%d",&amp;n); for(i=1;n&gt;(i*i+i)/2;i++); if(i%2==0)n=i*i+1-n; printf("%d/%d\n",i+(i*i-i)/2+1-n,n-(i*i-i)/2);&#125; 普及T2 回文数题目地址 套用高精度加法模板即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n, s1[1005], s2[1005];char s[1005];void init()&#123; scanf("%d%s", &amp;n, &amp;s);&#125;bool judge(int len)&#123; for(int i = 1; i &lt;= (len &gt;&gt; 1); ++i) if(s1[i] != s1[len - i + 1]) return false; return true;&#125;void add()&#123; memset(s2, 0, sizeof(s2)); int x = 0; s2[0] = s1[0]; for(int i = 1; i &lt;= s1[0]; ++i)&#123; x += s1[i] + s1[s1[0] - i + 1]; s2[i] = x % n; x /= n; &#125; if(x &gt; 0) s2[++s2[0]] = x;&#125;void solve()&#123; int len = strlen(s); s1[0] = len; for(int i = len - 1; i &gt;= 0; --i)&#123; if(isdigit(s[i])) s1[len - i] = s[i] - '0'; else s1[len - i] = s[i] - 'A' + 10; &#125; int flag = 0; for(int i = 0; i &lt;= 30; ++i)&#123; if(judge(s1[0]))&#123; flag = 1; printf("STEP=%d\n", i); break; &#125; add(); memcpy(s1, s2, sizeof(s2)); &#125; if(!flag) printf("Impossible!");&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 导弹拦截题目地址 先求最长不上升子序列，再求最长上升子序列。（Dilworth定理，最长链和最长反链）或者因为数据小，贪心的做法也能接受。所以我无聊的写了三个版本： $O(nlogn)$动态规划123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int high[50],tot=0,ans=0,dp[50]=&#123;0&#125;,tmp; int main()&#123; int i,j; while(scanf("%d",&amp;high[tot])==1)tot++; for(i=0;i&lt;tot;i++)&#123; for(tmp=1,j=0;j&lt;i;j++)&#123; if(high[j]&gt;=high[i])tmp=max(tmp,dp[j]+1); &#125;dp[i]=tmp; &#125;for(i=0;i&lt;tot;i++)ans=max(ans,dp[i]); fill(dp,dp+tot,0x7FFFFFFF);for(i=0;i&lt;tot;i++) *lower_bound(dp,dp+tot,high[i])=high[i]; tmp=lower_bound(dp,dp+tot,0x7FFFFFFF)-dp; printf("%d\n%d\n",ans,tmp); return 0; &#125; $O(n^2)$动态规划12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dat[55],n;int dp(int o)&#123; int dpp[55],ans=1; fill(dpp,dpp+n,1); for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++) if(o&amp;&amp;dat[j]&lt;=dat[i])dpp[i]=max(dpp[i],dpp[j]+1); else if(dat[j]&lt;dat[i])dpp[i]=max(dpp[i],dpp[j]+1); ans=max(ans,dpp[i]); &#125;return ans;&#125;int main()&#123; n=0;while(~scanf("%d",&amp;dat[n]))n++; reverse(dat,dat+n); printf("%d\n",dp(1)); reverse(dat,dat+n); printf("%d\n",dp(0)); return 0;&#125; $O(n^2)$贪心123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int h[25],low[25],n=0,ans,f[25];int main()&#123; int i,j,t; while(~scanf("%d",&amp;h[n]))n++; for(f[0]=1,ans=i=1;i&lt;n;i++)&#123; f[i]=1; for(j=0;j&lt;i;j++) if(h[j]&gt;=h[i])f[i]=max(f[i],f[j]+1); ans=max(ans,f[i]); &#125; printf("%d\n",ans); for(low[0]=h[0],ans=0,i=1;i&lt;n;i++)&#123; for(j=0;j&lt;=ans;j++) if(low[j]&gt;=h[i])&#123;low[j]=h[i];break;&#125; if(j&gt;ans)low[++ans]=h[i]; &#125; printf("%d\n",ans+1); return 0;&#125; 普及/提高T3 旅行家的预算题目地址 尽量选最便宜的，如果油满了就换次便宜的，这样递归（循环下去）。最后油全满了就No solution。这里使用了优先队列来取最优值。只是懒得手写堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;typedef double db;typedef struct&#123; int id;db count,dis,pri;&#125;Pp;bool operator&lt;(Pp a,Pp b)&#123;return a.pri&gt;b.pri;&#125;Pp dat[105];int n;db ans=0,C,D,per;priority_queue&lt;Pp&gt; pq;void solve()&#123; pq.push(dat[0]); int i,j,k; Pp tmp; for(i=1;i&lt;=n;i++)&#123; db need=(dat[i].dis-dat[i-1].dis)/per,mini; for(;!pq.empty();)&#123; tmp=pq.top(); for(mini=need,j=tmp.id;j&lt;i;j++) mini=min(C-dat[j].count,mini); for(j=tmp.id;j&lt;i;j++) dat[j].count+=mini; ans+=mini*tmp.pri; if(mini&lt;need) need-=mini,pq.pop(); else break; &#125; if(pq.empty())&#123;ans=-1;return ;&#125; pq.push(dat[i]); &#125; &#125;int main()&#123; int i,j; scanf("%lf%lf%lf%lf%d",&amp;D,&amp;C,&amp;per,&amp;dat[0].pri,&amp;n); for(i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;dat[i].dis,&amp;dat[i].pri); dat[0].dis=0; for(n++,i=0;i&lt;=n;i++) dat[i].count=0,dat[i].id=i; dat[n].dis=D; solve(); if(ans&lt;0)printf("No Solution\n"); else printf("%.2lf\n",ans); return 0;&#125; 提高T4 邮票面值设计题目链接]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>堆</tag>
        <tag>枚举</tag>
        <tag>贪心</tag>
        <tag>线性DP</tag>
        <tag>背包DP</tag>
        <tag>图上DP</tag>
        <tag>生成函数</tag>
        <tag>棋盘DP</tag>
        <tag>部分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2006 题解]]></title>
    <url>%2F2018%2F08%2F21%2Fnoip2006%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2006八道题目的题解。 普及T1 明明的随机数题目链接 排序去重即可。 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n;vector&lt;int&gt; v;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; int j; scanf("%d",&amp;j); v.push_back(j); &#125; sort(v.begin(),v.end()); vector&lt;int&gt;::iterator it=unique(v.begin(),v.end()); printf("%d\n",it-v.begin()); for(int i=0;i&lt;it-v.begin();i++) printf("%d ",v[i]); return 0; &#125; 普及T2 开心的金明题目链接 最基本的01背包。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int V, n, f[30005] = &#123;0&#125;, v[30], w[30];void init()&#123; V = read(), n = read(); for(int i = 0; i &lt; n; ++i) v[i] = read(), w[i] = read();&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i) for(int j = V; j &gt;= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + w[i] * v[i]); printf("%d\n", f[V]);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T3 Jam的计数法题目链接 自己手写一个生成下一个组合的函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int s, t, l;char p[30];void init()&#123; s = read() - 1, t = read() - 1, l = read(); scanf("%s", p); for(int i = 0; i &lt; l; ++i) p[i] -= 'a';&#125;bool getC()&#123; int cur = l - 1; while(cur &gt;= 0 &amp;&amp; p[cur] == t - l + 1 + cur) cur--; if(cur == -1) return false; p[cur]++, cur++; while(cur &lt; l) p[cur] = p[cur - 1] + 1, cur++; for(int i = 0; i &lt; l; ++i) putchar(p[i] + 'a'); putchar('\n'); return true;&#125;void solve()&#123; for(int i = 0; i &lt; 5; ++i) if(!getC()) break;&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 数列题目链接 容易证明 \forall b \in \mathbb{N}^*, k^b>\sum_{i=0}^{b-1} k^i令(N)_{10}=(a_na_{n-1}...a_1a_0)_2可以推出 \sum_{i=0}^n a_i \cdot k^i随着$N$递增。而$N$从$1$开始增加，因此该数列的第$N$项即为上式。12345678910111213141516#include &lt;cstdio&gt;int n,k,m=0,s=0;int p(int w)&#123; int res=1; for(int i=1;i&lt;=w;i++)res*=n; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); while(k)&#123; if(k&amp;1)s+=p(m); m++,k&gt;&gt;=1; &#125; printf("%d\n",s); return 0;&#125; 提高T1 能量项链题目链接 和石子合并差不多。由于是环状，所以需要把原来的项链复制一遍。很经典的区间DP。123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[205][205]=&#123;0&#125;,n,dat[205][2];int main()&#123; scanf("%d",&amp;n); n&lt;&lt;=1; int _n=n; for(int i=0;i&lt;_n;i++) scanf("%d",&amp;dat[i][0]), dat[i+_n][0]=dat[i][0]; dat[n-1][1]=dat[0][0]; for(int i=0;i&lt;n-1;i++) dat[i][1]=dat[i+1][0]; for(int i=1;i&lt;_n;i++)//i:length for(int j=0;j+i&lt;n;j++) for(int k=j;k&lt;i+j;k++) dp[j][i+j]=max(dp[j][j+i],dp[j][k]+dp[k+1][i+j]+ dat[j][0]*dat[k][1]*dat[i+j][1]); int ans=dp[0][_n-1]; for(int i=1;i&lt;_n;i++) ans=max(ans,dp[i][i+_n-1]); printf("%d\n",ans); return 0;&#125; 提高T2 金明的预算方案题目链接 一个很不寻常的背包DP。由于有附件的存在，我们需要将购买不同的附件相分开。即将购买0到多个附件分别作为不同的决策考虑。由于附件数不超过2个，所以我们购买某一个主件和其附件的时候至多只有4种决策：只购买主件，或者买主件和两个附件中的一个，或者主附件全买。这样的话就归化成了一个普通的01背包问题。1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int dp[32005]=&#123;0&#125;,n,W,w[62][5]=&#123;0&#125;,v[62][5]=&#123;0&#125;;int main()&#123; scanf("%d%d", &amp;W, &amp;n); for(int i = 1; i &lt;= n; ++i)&#123; int j, p, k; scanf("%d%d%d", &amp;j, &amp;p, &amp;k); if(k)&#123; if(w[k][0] &gt; 1) w[k][3] += j, w[k][4] += j, w[k][0] += 2, v[k][3] += p * j, v[k][4] += p * j; else w[k][2] += j, w[k][3] += j, w[k][0]++, v[k][3] += p * j, v[k][2] += p * j; &#125;else&#123; w[i][0]++, w[i][1] += j, w[i][2] += j, w[i][3] += j, w[i][4] += j; v[i][3] += p * j, v[i][4] += p * j, v[i][1] = p * j, v[i][2] += p * j; &#125; &#125; for(int i = 1; i &lt;= n; ++i) if(w[i][0]) for(int j = W; j &gt;= w[i][1]; --j) for(int k = 1; k &lt;= w[i][0]; ++k) if(j - w[i][k] &gt;= 0) dp[j] = max(dp[j], dp[j - w[i][k]] + v[i][k]); printf("%d\n", dp[W]); return 0;&#125; 提高T3 作业调度方案题目链接 模拟即可…千万不要考虑什么奇奇怪怪的优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int gid,_id,p[2]; &#125;Move;Move move[405],*pt[25][25];int mac[25][455]=&#123;0&#125;,cnt[25]=&#123;0&#125;,m,n;int ok(int id,int l,int r)&#123; for(int i=l;i&lt;=r;i++) if(mac[id][i])return i; for(int i=l;i&lt;=r;i++) mac[id][i]=1; return 0;&#125; int solve()&#123; int i,j,k,u,v,id,ans=0; fill(cnt,cnt+24,1); for(i=1;i&lt;=m*n;i++)&#123; u=move[i].p[0],v=move[i].p[1], id=move[i].gid; for(j=cnt[id];;)&#123; k=ok(u,j,j+v-1); if(!k)&#123;cnt[id]=j+v;break;&#125; else j=k+1; &#125; &#125; for(i=1;i&lt;=n;i++) ans=max(ans,cnt[i]); return ans-1;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int i,j,k; for(i=1;i&lt;=m*n;i++) scanf("%d",&amp;j), move[i].gid=j, move[i]._id=++cnt[j], pt[j][cnt[j]]=&amp;move[i]; for(k=0;k&lt;2;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) scanf("%d",&amp;pt[i][j]-&gt;p[k]); printf("%d\n",solve()); return 0;&#125; 提高T4 $2^k$进制数题目地址 组合数问题。数码递增视为一个组合。这样一个数，数码只有$\mathcal 2^k-1$个，故长度至多为$\mathcal 2^k-1$。因此当$\mathcal w \ge \left(2^k-1\right) \times k $的时候，多出的那部分没有意义。此时令$\mathcal w = \left(2^k-1\right) \times k $。对于一个$\mathcal w$，一个$\mathcal 2^k$进制数除去最高位至多有$\mathcal \lfloor \frac {w}{k} \rfloor$位。考虑$\mathcal 2$到$\mathcal \lfloor \frac {w}{k} \rfloor$位，由于数码有$\mathcal 2^k-1$个，故此部分答案为 \mathcal \sum_{i=2}^{ \lfloor \frac {w}{k} \rfloor} C_{2^k-1}^{i}考虑最高位，由于最高位可能的最大数我们可以算出，设其为$\mathcal u$，则 \mathcal u=2^{w \mod k}-1最高位已经确定，剩下的只有$\mathcal \lfloor \frac {w}{k} \rfloor$个数字要选，备选的数字有$\mathcal 2^k-1-o \left( 1\le o \le u\right)$个，故此部分答案为 \mathcal \sum_{o=1}^u C_{2^k-1-o}^{\lfloor \frac {w}{k} \rfloor}两部分相加即为本题答案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define p 10000using namespace std;int c[520][25],ans[56]=&#123;0&#125;,k,w,k1,k2;void mul(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=1;i&lt;=s1[0];i++) x+=s1[i]*s2,to[i]=x%p,x/=p; for(;x&gt;0;)to[++to[0]]=x%p,x/=p; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void add(int s1[],int s2[])&#123; s2[0]=max(s1[0],s2[0]); int x=0; for(int i=1;i&lt;=s2[0];i++) x+=s1[i]+s2[i],s2[i]=x%p,x/=p; for(;x!=0;)s2[++s2[0]]=x%p,x/=p;&#125;void divide(int s1[],int s2)&#123; int x=0; for(int i=s1[0];i&gt;=1;i--)&#123; x=x*p+s1[i],s1[i]=x/s2,x%=s2; &#125; for(;s1[0]&gt;1&amp;&amp;s1[s1[0]]==0;)s1[0]--;&#125;void C(int m,int n)&#123; c[0][0]=c[0][1]=1; for(int i=1;i&lt;=m;i++) mul(c[i-1],n-i+1,c[i]),divide(c[i],i);&#125;int output(int big[])&#123; printf("%d",big[big[0]]); for(int i=big[0]-1;i&gt;=1;i--) printf("%04d",big[i]); printf("\n");&#125;int main()&#123; scanf("%d%d",&amp;k,&amp;w); k1=1&lt;&lt;k; if(w&gt;k*(k1-1))w=k*(k1-1); C(w/k,k1-1); for(int i=2;i&lt;=w/k;i++)add(c[i],ans); k2=1&lt;&lt;(w%k); for(int i=1;i&lt;k2;i++) C(w/k,k1-1-i),add(c[w/k],ans); output(ans); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>背包DP</tag>
        <tag>区间DP</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hanoi]]></title>
    <url>%2F2018%2F08%2F21%2Fwriting%2FHanoi%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP2007 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2007%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2007八道题目的题解。 普及T1 奖学金题目链接 按照题意排序即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;struct Stu&#123; int all, chi, id;&#125;;struct cmp&#123; inline bool operator()(const Stu&amp; s1, const Stu&amp; s2)&#123; if(s1.all != s2.all)return s1.all &gt; s2.all; if(s1.chi != s2.chi)return s1.chi &gt; s2.chi; return s1.id &lt; s2.id; &#125;&#125;;Stu s[505];int n;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) s[i].id = i + 1, s[i].all = s[i].chi = read(), s[i].all += read() + read(); sort(s, s + n, cmp());&#125;void solve()&#123; for(int i = 0; i &lt; 5; ++i) printf("%d %d\n", s[i].id, s[i].all);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T2 纪念品分组题目链接 排序后大的尽量和小的组合，无法组合则直接退出。123456789101112131415#include &lt;cstdio&gt;#include &lt;algorithm&gt;int limit,n,k[30005],ans=0;int main()&#123; scanf("%d%d",&amp;limit,&amp;n); int i,at,o=0; for(i=0;i&lt;n;i++)scanf("%d",&amp;k[i]); std::sort(k,k+n); for(i=0;i&lt;n;i++)&#123; for(o=0,at=n-1;at&gt;i;at--) if(k[at]&lt;=limit-k[i])&#123;o=1;break;&#125; if(o)&#123;ans+=n-at;n=at;&#125;else&#123;ans+=n-i;break;&#125; &#125;printf("%d\n",ans); return 0;&#125; 普及T3 守望者的逃离题目链接 方法一分类讨论。。尽量采取最优的策略。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;int m, s, t, ts, lim;int get()&#123; if((10 - m) % 4) return (10 - m) / 4 + 1; return (10 - m) / 4;&#125;int main()&#123; scanf("%d%d%d", &amp;m, &amp;s, &amp;t); for(int i = t, ts = s; i &gt; 0; )&#123; if(ts &lt;= 0) break; if(m &gt;= 10) m -= 10, ts -= 60, i--; else&#123; if(ts &lt;= 17) i--, ts=0;//跑一下就跑的到 else&#123; if((lim = get()) &lt; 3)&#123; if(i &gt;= lim + 1)&#123; if(ts &lt;= 34)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else i = i - (lim + 1), ts -= 60, m -= 10, m += lim * 4; &#125;else &#123; if(ts &lt;= i * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else ts -= i * 17, i = 0;//尽量跑 &#125; &#125;else&#123; if(i &gt;= 7)&#123; if(ts &lt;= 7 * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else i -= 7, ts -= 120; &#125;else &#123; if(ts &lt;= i * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else ts -= i * 17, i = 0;//尽量跑 &#125; &#125; &#125; &#125; if(ts &gt; 0) printf("No\n%d\n", s - ts); else printf("Yes\n%d\n", t - i); return 0; &#125; 方法二我们将法术和跑步分开来，跑一遍DP。一开始只有法术，然后修改决策为跑步。（来自洛谷上的神奇方法）该方法之所以成立，就在于恢复完全是为了放出法术，而和跑步无关。因此可以将两者视为不同的决策。12345678910111213141516171819int dp[300005];void solve()&#123; int m = read(), s = read(), T = read(); dp[0] = 0; for(int i = 1; i &lt;= T; ++i)&#123; if(m &gt;= 10) dp[i] = dp[i - 1] + 60, m -= 10; else dp[i] = dp[i - 1], m += 4; &#125; for(int i = 1; i &lt;= T; ++i)&#123; dp[i] = max(dp[i], dp[i - 1] + 17); if(dp[i] &gt;= s)&#123; printf("Yes\n%d\n", i); break; &#125; &#125; printf("No\n%d\n", dp[T]);&#125; 普及T4 Hanoi双塔问题题目链接 可以证明最短的次数一定是原汉诺塔问题的答案的两倍。（因为最优情况下就是每一次要移动2个同样大小的盘子）所以…加个高精度就完了。 提高T1 统计数字题目链接 模拟即可。123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; int n,k[200005],tot=1,last;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;k[i]); sort(k,k+n); last=k[0]; for(int i=1;i&lt;n;i++)&#123; if(last!=k[i]) printf("%d %d\n",last,tot),tot=1,last=k[i]; else tot++; &#125; printf("%d %d\n",last,tot); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第七章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter7%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第七章部分习题的整合。 例7-1 UVa725 Division题目链接 直接枚举除数即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, cnt[20];void solve()&#123; int flag = 0; for(int i = 1234; ; ++i)&#123; int j = i * n; if(j &lt; 10000 &amp;&amp; i &lt; 10000) continue; int tot = 0; while(j) cnt[tot++] = j % 10, j /= 10; j = i; while(j) cnt[tot++] = j % 10, j /= 10; if(i &lt; 10000)cnt[tot++] = 0; if(tot &gt; 10)break; sort(cnt, cnt + 10); for(j = 0; j &lt; 10; ++j) if(cnt[j] != j) break; if(j == 10) printf("%d / %05d = %d\n", i * n, i, n), flag = 1; &#125; if(!flag) printf("There are no solutions for %d.\n", n);&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(); if(!n)break; if(T &gt; 1)printf("\n"); solve(); &#125; return 0;&#125; 例7-2 UVa11059 Maximum Product题目链接 枚举两端即可。数据比较小，直接用long long。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;ll seq[50];void init()&#123; for(int i = 0; i &lt; n; ++i) seq[i] = read();&#125;void solve()&#123; ll ans = 0; for(int i = 0; i &lt; n; ++i) for(int j = i; j &lt; n; ++j)&#123; ll st = 1; for(int k = i; k &lt;= j; ++k) st *= seq[k]; ans = max(ans, st); &#125; printf("%lld.\n\n", ans);&#125;int main()&#123; int T = 0; while(scanf("%d", &amp;n) == 1)&#123; T++; printf("Case #%d: The maximum product is ", T); init(); solve(); &#125; return 0;&#125; 例7-3 UVa10976 Fractions Again?!题目链接 由于$x \ge y$可以发现$\frac{1}{x} \le \frac{1}{y}$。故$y$的下限为$k+1$，上限为$2k$。将$y$从$k+1$开始枚举到$2k$即可。12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, ans[10005][2], cnt;void solve()&#123; cnt = 0; for(int i = n + 1; i &lt;= n + n; ++i)&#123; int fz = i - n, fm = n * i; if(fm % fz == 0) ans[cnt][0] = fm / fz, ans[cnt++][1] = i; &#125; printf("%d\n", cnt); for(int i = 0; i &lt; cnt; ++i) printf("1/%d = 1/%d + 1/%d\n", n, ans[i][0], ans[i][1]);&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; solve(); &#125; return 0;&#125; 例7-4 UVa524 Prime Ring Problem题目链接 直接DFS即可。回溯法的入门型题目。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, ring[20];bool isnt[50] = &#123;0&#125;, vis[20] = &#123;0&#125;;void init()&#123; isnt[1] = 1; for(int i = 2; i &lt;= 32; ++i) if(!isnt[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 32; j += i) isnt[j] = 1; &#125;&#125;void dfs(int index, int cur)&#123; ring[cur] = index; if(cur == n)&#123; if(!isnt[ring[1] + index])&#123; for(int i = 1; i &lt; n; ++i) printf("%d ", ring[i]); printf("%d\n", ring[n]); &#125; return ; &#125; vis[index] = 1; for(int i = 2; i &lt;= n; ++i) if(!vis[i] &amp;&amp; !isnt[i + ring[cur]]) dfs(i, cur + 1); vis[index] = 0;&#125;void solve()&#123; dfs(1, 1);&#125;int main()&#123; init(); int T = 1; while(scanf("%d", &amp;n) == 1)&#123; if(T &gt; 1)printf("\n"); printf("Case %d:\n", T); solve(); T++; &#125; return 0;&#125; 例7-6 UVa140 Bandwidth题目链接 枚举全排列，然后模拟即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005];bool mat[50][50], vis[50];int p[10], n, b[10], ansp[10];void init()&#123; memset(mat, 0, sizeof(mat)); memset(vis, 0, sizeof(vis)); for(int i = 0; isalpha(s[i]); ++i)&#123; int cur = s[i++] - 'A'; vis[cur] = 1; for(i++; isalpha(s[i]); ++i)&#123; int to = s[i] - 'A'; mat[cur][to] = mat[to][cur] = 1; vis[to] = 1; &#125; &#125;&#125;void solve()&#123; n = 0; for(int i = 0; i &lt; 26; ++i) if(vis[i]) p[n++] = i; int ans = INF; do&#123; int cur = 0; memset(b, 0, sizeof(b)); for(int i = 0; i &lt; n; ++i)&#123; for(int j = i - 1; j &gt;= 0; --j) if(mat[p[i]][p[j]]) b[i] = max(b[i], i - j); for(int j = i + 1; j &lt; n; ++j) if(mat[p[i]][p[j]]) b[i] = max(b[i], j - i); cur = max(cur, b[i]); if(cur &gt;= ans) break; &#125; if(cur &lt; ans)&#123; memcpy(ansp, p, sizeof(p)); ans = cur; &#125; &#125;while(next_permutation(p, p + n)); for(int i = 0; i &lt; n; ++i) printf("%c ", ansp[i] + 'A'); printf("-&gt; %d\n", ans);&#125;int main()&#123; for(; ; )&#123; scanf("%s", s); if(s[0] == '#')break; init(); solve(); memset(s, 0, sizeof(s)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>枚举</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第六章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter6%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第六章部分习题的整合。 例6-2 UVa514 Rails题目链接 用栈模拟即可。对于要求顺序的第$i$项，只有$2$种可能： 它不在栈里，那么把它前面的全部入栈。 它在栈里，那么除非它在栈顶，不然不可能满足此顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, permu[1005], st[1005], top, in[1005];void solve()&#123; top = 0; memset(in, 0, sizeof(in)); int cur = 1, ans = 1; for(int i = 1; i &lt;= n; ++i)&#123; if(!in[permu[i]])&#123; for(; cur &lt; permu[i]; ++cur) st[top++] = cur, in[cur] = 1; cur++; &#125;else&#123; if(st[top - 1] == permu[i]) top--, in[permu[i]] = 0; else&#123; ans = 0; break; &#125; &#125; &#125; printf("%s\n", ans ? "Yes" : "No");&#125;void init()&#123; for(; ; )&#123; if(permu[1] = read())&#123; for(int i = 2; i &lt;= n; ++i) permu[i] = read(); solve(); &#125;else &#123; printf("\n"); break ; &#125; &#125;&#125;int main()&#123; for(; ; )&#123; n = read(); if(!n)break ; init(); &#125; return 0;&#125; 例6-4 UVa11988 Broken Keyboard (a.k.a. Beiju Text)题目链接 直接用链表模拟即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[5000005];int cur, nxt[5000005], lst;void solve()&#123; cur = lst = 0; nxt[0] = -1; int len = strlen(s + 1); for(int i = 1; i &lt;= len; ++i)&#123; if(s[i] == '[')&#123; cur = 0; &#125;else if(s[i] == ']')&#123; cur = lst; &#125;else&#123; nxt[i] = nxt[cur]; nxt[cur] = i; cur = i; if(nxt[cur] == -1) lst = cur; &#125; &#125; for(int i = nxt[0]; i != -1; i = nxt[i]) putchar(s[i]); putchar('\n');&#125;int main()&#123; while(scanf("%s", s + 1) == 1) solve(); return 0;&#125; 例6-6 UVa679 Dropping Balls题目链接 可以根据奇偶判断一个球在一个节点应该是向左还是向右走，同时算出有多少个球走到了下一个节点。这样的话就可以递归计算。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int d, id, ans;void init()&#123; d = read(), id = read();&#125;void get(int curd, int curi, int curp)&#123; if(curd == d)&#123; ans = curp; return ; &#125; if(curi &amp; 1) get(curd + 1, curi / 2 + 1, curp &lt;&lt; 1); else get(curd + 1, curi / 2, curp &lt;&lt; 1 | 1);&#125;void solve()&#123; get(1, id, 1); printf("%d\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; scanf("%d", &amp;T); return 0;&#125; 例6-8 UVa548 Tree题目链接 根据中序遍历和后序遍历构造树即可。细节有一点多。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[2000005];int cur, p1[10005], p2[10005], n;int lc[10005], rc[10005], key[10005], mini[10005], ans;int read()&#123; int x = 0; char c = s[cur]; while(c &lt; '0' || c &gt; '9')&#123; if(c == '\n' || c == EOF) return -1; c = s[++cur]; &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = s[++cur]; return x; &#125;void init()&#123; n = 0; for(cur = 0; ; ++n)&#123; p1[n] = read(); if(p1[n] &lt; 0) break; &#125; fgets(s, 2000000, stdin); cur = 0; for(int i = 0; i &lt; n; ++i) p2[i] = read();&#125;int get(int il, int ir, int pl, int pr)&#123; if(ir - il &lt; 0) return 0; int i, id = p2[pr]; for(i = il; i &lt;= ir; ++i) if(p1[i] == id) break; int len = i - il; lc[id] = get(il, i - 1, pl, pl + len - 1); rc[id] = get(i + 1, ir, pl + len, pr - 1); key[id] = id; if(lc[id] &amp;&amp; rc[id])&#123; if(key[lc[id]] &gt; key[rc[id]]) key[id] += key[rc[id]], mini[id] = mini[rc[id]]; else if(key[lc[id]] &lt; key[rc[id]]) key[id] += key[lc[id]], mini[id] = mini[lc[id]]; else key[id] += key[rc[id]], mini[id] = mini[rc[id]], mini[id] = min(mini[lc[id]], mini[rc[id]]); &#125;else if(lc[id]) key[id] += key[lc[id]], mini[id] = mini[lc[id]]; else if(rc[id]) key[id] += key[rc[id]], mini[id] = mini[rc[id]]; else mini[id] = id; return id;&#125;void solve()&#123; int root = get(0, n - 1, 0, n - 1); printf("%d\n", mini[root]);&#125;int main()&#123; while(fgets(s, 2000000, stdin) != NULL)&#123; init(); solve(); &#125; return 0;&#125; 例6-9 UVa839 Not so Mobile题目链接 按照递归顺序生成整个天平即可。例题给出的代码中get函数的返回值是天平是否平衡，这里我稍微做了一些调整。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int ans = 1;int get()&#123; int wl = read(), dl = read(), wr = read(), dr = read(); if(!wl) wl = get(); if(!wr) wr = get(); if(wl * dl != wr * dr) ans = 0; return wl + wr;&#125;void solve()&#123; ans = 1; get(); printf("%s\n", ans ? "YES" : "NO");&#125;int main()&#123; int T = read(); while(T--)&#123; solve(); if(T &gt; 0) printf("\n"); &#125; return 0;&#125; 例6-10 UVa699 The Falling Leaves题目链接 也是利用递归构造出整个树的结构。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int root, lc[100005], rc[100005];int cntl[100005], cntr[100005], maxl, maxr;void build(int id, int pos)&#123; if(pos &gt;= 0) cntr[pos] += id, maxr = max(maxr, pos); else cntl[-pos] += id, maxl = min(maxl, pos); lc[id] = read(); if(lc[id] &gt; 0) build(lc[id], pos - 1); rc[id] = read(); if(rc[id] &gt; 0) build(rc[id], pos + 1);&#125;void solve()&#123; memset(cntl, 0, sizeof(cntl)); memset(cntr, 0, sizeof(cntr)); maxl = maxr = 0; build(root, 0);&#125;int main()&#123; int T = 1; while((root = read()) != -1)&#123; solve(); printf("Case %d:\n", T); for(int i = -maxl; i &gt;= 1; --i) printf("%d ", cntl[i]); for(int i = 0; i &lt; maxr; ++i) printf("%d ", cntr[i]); printf("%d\n\n", cntr[maxr]); T++; &#125; return 0;&#125; 例6-13 UVa1103 Ancient Messages题目链接 搜索联通块即可。这里用了一点技巧：先把所有符号外围的白色填充掉，然后再对符号框架部分搜索。在搜索框架时发现了没有访问过的白色块就说明这个符号有洞，用这种方法统计出洞的个数即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m;int dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;, lis[] = &#123;'W', 'A', 'K', 'J', 'S', 'D'&#125;;int dat[205][205], tot, cnt;bool vis[205][205];char ans[1005];void init()&#123; memset(dat, 0, sizeof(dat)); for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; int d; scanf("%1x", &amp;d); if(d &amp; 8)dat[i][j &lt;&lt; 2] = 1; if(d &amp; 4)dat[i][j &lt;&lt; 2 | 1] = 1; if(d &amp; 2)dat[i][j &lt;&lt; 2 | 2] = 1; if(d &amp; 1)dat[i][j &lt;&lt; 2 | 3] = 1; &#125; &#125; m &lt;&lt;= 2;&#125;void dfs(int cx, int cy, int o)&#123;//o代表当前填充的是框架还是白色块 vis[cx][cy] = 1; for(int i = 0; i &lt; 4; ++i)&#123; int ex = cx + dx[i], ey = cy + dy[i]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; !vis[ex][ey])&#123; if(o)&#123; if(!dat[ex][ey]) dat[ex][ey] = ++tot, dfs(ex, ey, 0); else if(dat[ex][ey] == 1) dfs(ex, ey, 1); &#125;else if(!dat[ex][ey]) dat[ex][ey] = tot, dfs(ex, ey, 0); &#125; &#125;&#125;void solve()&#123; memset(vis, 0, sizeof(vis)); tot = 2, cnt = 0; for(int i = 0; i &lt; n; ++i)&#123; if(!vis[i][0] &amp;&amp; !dat[i][0]) dfs(i, 0, 0); if(!vis[i][m - 1] &amp;&amp; !dat[i][m - 1]) dfs(i, m - 1, 0); &#125; for(int i = 0; i &lt; m; ++i)&#123; if(!vis[0][i] &amp;&amp; !dat[0][i]) dfs(0, i, 0); if(!vis[n - 1][i] &amp;&amp; !dat[n - 1][i]) dfs(n - 1, i, 0); &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; if(!vis[i][j] &amp;&amp; dat[i][j] == 1)&#123; int his = tot; dfs(i, j, 1); ans[cnt++] = lis[tot - his]; &#125; &#125; &#125; sort(ans, ans + cnt); ans[cnt] = '\0'; printf("%s\n", ans);&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), m = read(); if(!n &amp;&amp; !m) break; printf("Case %d: ", T); init(); solve(); &#125; return 0;&#125; 例6-15 UVa10305 Ordering Tasks题目链接 直接拓扑排序即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, du[105];int que[105], f, r, lis[105];bool e[105][105];void init()&#123; memset(du, 0, sizeof(du)); for(int i = 0; i &lt; m; ++i)&#123; int u = read(), v = read(); du[v]++; e[u][v] = 1; &#125;&#125;void solve()&#123; f = r = 0; for(int i = 1; i &lt;= n; ++i) if(!du[i]) que[r++] = i; int cnt = 0; while(r - f)&#123; int cur = que[f++]; lis[cnt++] = cur; for(int i = 1; i &lt;= n; ++i) if(e[cur][i])&#123; du[i]--; if(!du[i]) que[r++] = i; &#125; &#125; for(int i = 0; i &lt; n - 1; ++i) printf("%d ", lis[i]); printf("%d\n", lis[n - 1]); memset(e, 0, sizeof(e));&#125;int main()&#123; for(; ; ) &#123; n = read(), m = read(); if (!n &amp;&amp; !m) break; init(); solve(); &#125; return 0;&#125; 6-1 UVa673 Parentheses Balance题目链接 括号序列的匹配。。用栈模拟即可。我一开始没看清题，以为只要能配对即可，结果疯狂WA。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005];int st[10005], top;void init()&#123; fgets(s, 1000, stdin);&#125;void solve()&#123; int len = strlen(s), flag = 1; top = 0; for(int i = 0; i &lt; len; ++i)&#123; if(s[i] == '(' || s[i] == '[') st[top++] = s[i]; else if(s[i] == ')')&#123; if(top &amp;&amp; st[top - 1] == '(') top--; else&#123; flag = 0; break; &#125; &#125;else if(s[i] == ']')&#123; if(top &amp;&amp; st[top - 1] == '[') top--; else&#123; flag = 0; break; &#125; &#125; &#125; if(top) flag = 0; printf("%s\n", flag ? "Yes" : "No");&#125;int main()&#123; fgets(s, 1000, stdin); int T; sscanf(s, "%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 6-3 UVa536 Tree Recovery题目链接 和根据后序和中序求先序一样。只要知道先序的根在开头，后序的根在末尾即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s1[30], s2[30];int root, lc[250], rc[250];int get(int pl, int pr, int il, int ir)&#123; if(ir - il &lt; 0) return 0; int id = s1[pl], i; for(i = il; i &lt;= ir; ++i) if(s2[i] == id) break; int len = i - il; lc[id] = get(pl + 1, pl + len, il, i - 1); rc[id] = get(pl + len + 1, pr, i + 1, ir); return id;&#125;void getP(int id)&#123; if(lc[id]) getP(lc[id]); if(rc[id]) getP(rc[id]); printf("%c", id);&#125;void solve()&#123; int len = strlen(s1); root = get(0, len - 1, 0, len - 1); getP(root); printf("\n");&#125;int main()&#123; while(scanf("%s%s", s1, s2) == 2) solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>链表</tag>
        <tag>树形结构</tag>
        <tag>拓扑排序</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第五章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter5%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第五章部分习题的整合。 例5-1 UVa10474 Where is the Marble?题目链接 排序后二分查找即可。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, q, st[10005];void init()&#123; for(int i = 0; i &lt; n; ++i) st[i] = read(); sort(st, st + n);&#125;void solve()&#123; int x; for(int i = 0; i &lt; q; ++i)&#123; x = read(); int index = lower_bound(st, st + n, x) - st; if(st[index] == x) printf("%d found at %d\n", x, index + 1); else printf("%d not found\n", x); &#125;&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), q = read(); if(!n &amp;&amp; !q)break ; printf("CASE# %d:\n", T); init(); solve(); &#125; return 0;&#125; 例5-5 UVa12096 The SetStack Computer题目链接 将集合映射成数，然后进行操作。非常好的练习STL的题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef set&lt;int&gt; Set;map&lt;Set, int&gt; mp;int n, stack[10005], top, tot;Set st[2005];int getID(Set *s)&#123; if(!mp.count(*s))&#123; mp[*s] = tot, tot++; return tot - 1; &#125; return mp[*s];&#125;void push()&#123; stack[top++] = 0;&#125;void dup()&#123; stack[top] = stack[top - 1]; top++;&#125;void _union()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss; set_union(st[xa].begin(), st[xa].end(), st[xb].begin(), st[xb].end(), inserter(ss, ss.begin())); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void _inter()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss; set_intersection(st[xa].begin(), st[xa].end(), st[xb].begin(), st[xb].end(), inserter(ss, ss.begin())); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void add()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss = st[xb]; ss.insert(xa); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void init()&#123; n = read(); top = tot = 1; mp.clear(); Set s; mp[s] = 0, st[0] = s;&#125;void solve()&#123; char opr[12]; for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", opr); if(opr[0] == 'P')push(); if(opr[0] == 'D')dup(); if(opr[0] == 'U')_union(); if(opr[0] == 'I')_inter(); if(opr[0] == 'A')add(); printf("%d\n", st[stack[top - 1]].size()); &#125; printf("***\n");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 例5-7 UVa136 Ugly Numbers题目链接 用一个堆，每次取出最小的丑数，然后生成新的丑数。本题在其他地方有多个变种，故不在此贴出代码。答案：859963392 例5-8 UVa1592 Database题目链接 先对每一个字符串进行处理，将字符串映射为数后枚举c_1,c_2，然后从上到下扫描每一行，对同一行的两个格子打包成一个pair，然后再对pair进行映射，映射为当前的行号。之后即可判断是否有符合条件的r_1,r_2。和集合栈计算机那道题有异曲同工之妙。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, tab[10005][11];char s[110];map&lt;string, int&gt; mp1;map&lt;pair&lt;int, int&gt;, int&gt; mp2;void init()&#123; mp1.clear(); int tots = 0; for(int i = 0; i &lt; n; ++i)&#123; fgets(s, 99, stdin); int len = strlen(s); for(; isspace(s[len - 1]); --len) s[len - 1] = '\0'; for(int j = 0, k = 0, l = 0; j &lt; len; j = k, ++l)&#123; while(s[j] != ',' &amp;&amp; s[j] != '\0') ++j; s[j] = '\0'; string ss(s + k); if(!mp1.count(ss)) tab[i][l] = mp1[ss] = ++tots; else tab[i][l] = mp1[ss]; k = j + 1; &#125; &#125;&#125;void solve()&#123; int r1, r2, c1, c2; for(int i = 0; i &lt; m - 1; ++i) for(int j = i + 1; j &lt; m; ++j)&#123; mp2.clear(); for(int k = 0; k &lt; n; ++k)&#123; pair&lt;int,int&gt; pp(tab[k][i], tab[k][j]); if(!mp2.count(pp)) mp2[pp] = k + 1; else&#123; r1 = mp2[pp], r2 = k + 1, c1 = i + 1, c2 = j + 1; goto printans; &#125; &#125; &#125; printf("YES\n"); return ; printans: printf("NO\n%d %d\n%d %d\n", r1, r2, c1, c2);&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; m = read(); init(); solve(); &#125; return 0;&#125; 例5-12 UVa221 Urban Elevations题目链接 类似于扫描？对每一个建筑物左右两端的$x$坐标构成的序列排序去重，然后由于每两个$x$坐标之间的建筑物只会有一段，故使用一个数组保存坐标x_i右边这一段的高度。然后对建筑物从前往后（即按照$y$坐标升序）判断是否可见即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;double eps = 1e-5, xx[2005], zz[2005];struct City&#123; double x, y, lx, lz; int id, vis;&#125;;struct cmp&#123; inline bool operator()(const City&amp; c1, const City&amp; c2)&#123; if(c1.y - c2.y &lt; eps &amp;&amp; c1.y - c2.y &gt; -eps)return c1.x &lt; c2.x; return c1.y &lt; c2.y; &#125;&#125;;int n, len;City c[1005];void init()&#123; double tmp; for(int i = 0; i &lt; n; ++i) scanf("%lf%lf%lf%lf%lf", &amp;c[i].x, &amp;c[i].y, &amp;c[i].lx, &amp;tmp, &amp;c[i].lz), c[i].id = i + 1, c[i].vis = 0, xx[i &lt;&lt; 1] = c[i].x, xx[i &lt;&lt; 1 | 1] = c[i].x + c[i].lx; sort(c, c + n, cmp()); sort(xx, xx + n + n); len = unique(xx, xx + n + n) - xx; fill(zz, zz + len, 0.0);&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; int flag = 0, st = lower_bound(xx, xx + len, c[i].x) - xx; for(int j = st; xx[j] &lt; c[i].x + c[i].lx; ++j) if(c[i].lz &gt; zz[j]) flag = 1, zz[j] = c[i].lz; if(flag) c[i].vis = 1; &#125; for(int i = 0; i &lt; n; ++i) swap(c[i].x, c[i].y); sort(c, c + n, cmp()); int f = 0; for(int i = 0; i &lt; n; ++i) if(c[i].vis)&#123; if(f)printf(" "); printf("%d", c[i].id); if(!f)f = 1; &#125; printf("\n");&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(); if(!n)break ; else if(T &gt; 1)printf("\n"); printf("For map #%d, the visible buildings are numbered as follows:\n", T); init(); solve(); &#125; return 0;&#125; 5-2 UVa1594 Ducci Sequence题目链接直接模拟1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, d[20], dd[20];void init()&#123; n = read();&#125;void solve()&#123; bool ans = 0; for(int i = 0; i &lt; n; ++i) d[i] = read(); for(int i = 0; i &lt; 1001; ++i)&#123; int flag = 1; for(int j = 0; j &lt; n; ++j) if(d[j])&#123; flag = 0; break; &#125; if(flag)&#123; ans = 1; break; &#125;else &#123; for(int j = 0; j &lt; n - 1; ++j) dd[j] = abs(d[j] - d[j + 1]); dd[n - 1] = abs(d[n - 1] - d[0]); memcpy(d, dd, sizeof(d)); &#125; &#125; printf("%s\n", ans ? "ZERO" : "LOOP");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-3 UVa10935 Throwing cards away I题目链接 用队列模拟即可123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, que[505], l, r;void init()&#123; for(int i = 0; i &lt; n; ++i) que[i] = i + 1; l = 0, r = n;&#125;void solve()&#123; printf("Discarded cards:"); while(r - l &gt; 1)&#123; int a = que[l++]; printf(" %d", a); if(r - l &gt;= 2)printf(","); int b = que[l++]; que[r++] = b; &#125; printf("\nRemaining card: %d\n", que[l]);&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125; 5-4 UVa10763 Foreign Exchange题目链接 用multiset模拟即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;pair&lt;int, int&gt; p[500005];multiset&lt;pair&lt;int, int&gt; &gt; s;void init()&#123; for(int i = 0; i &lt; n; i++) p[i].first = read(), p[i].second = read();&#125;void solve()&#123; if(n &amp; 1)printf("NO\n"); else&#123; for(int i = 0; i &lt; n; ++i)&#123; pair&lt;int, int&gt; pp; pp.first = p[i].second, pp.second = p[i].first; if(!s.count(pp)) s.insert(p[i]); else s.erase(s.find(pp)); &#125; if(s.empty())printf("YES\n"); else printf("NO\n"); s.clear(); &#125;&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125; 5-5 UVa10391 Compound Words题目链接 用string类提供的各种方法即可。从每个词开始向下遍历，看看下面的词是不是以自己为前缀。如果不是就停止遍历，如果是那就看以自己为前缀的那个词的后缀是不是一个词（用set判断）。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;string&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;string s[120005];bool vis[120005] = &#123;0&#125;;int n;set&lt;string&gt; ss;void init()&#123; n = 0; while(cin &gt;&gt; s[n]) n++, ss.insert(s[n - 1]);&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; if(s[j].find(s[i]) == 0)&#123; string suff(s[j], s[i].length()); if(ss.count(suff)) vis[j] = 1; &#125;else break; &#125; &#125; for(int i = 0; i &lt; n; ++i) if(vis[i])cout &lt;&lt; s[i] &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; 5-6 UVa1595 Symmetry题目链接 先判断是否有这么一条竖线可以使得点的左右分布对称，再看是不是完全对称。方法很多，我采用了一个比较简单的写法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;pair&lt;int, int&gt; p[1005];void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) p[i].first = read(), p[i].second = read(); sort(p, p + n);&#125;void solve()&#123; int flag = 1, half; if(n &amp; 1) half = p[n &gt;&gt; 1].first &lt;&lt; 1; else half = p[(n &gt;&gt; 1) - 1].first + p[n &gt;&gt; 1].first ; for(int i = 0; i &lt; (n &gt;&gt; 1); ++i) if(p[n - i - 1].first + p[i].first != half)&#123; flag = 0; break; &#125; if(flag)&#123; for(int i = (n &gt;&gt; 1); i &lt; n; ++i) p[i].second = -p[i].second; sort(p + (n &gt;&gt; 1), p + n); for(int i = (n &gt;&gt; 1); i &lt; n; ++i) if(p[i].second + p[n - i - 1].second != 0 &amp;&amp; p[i].first * 2 != half)&#123; flag = 0; break; &#125; &#125; printf("%s\n", flag ? "YES" : "NO");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-7 UVa12100 Printer Queue题目链接 用一个队列模拟即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int pcnt[11], n, m;int que[10005][2], l, r;void init()&#123; n = read(), m = read(); memset(pcnt, 0, sizeof(pcnt)); for(int i = 0; i &lt; n; ++i) que[i][1] = i, pcnt[que[i][0] = read()]++; l = 0, r = n;&#125;void solve()&#123; int t; for(t = 1; r &gt; l; t++)&#123; for(; ; )&#123; int cur = que[l][0], flag = 0; for(int i = cur + 1; i &lt; 10; ++i) if(pcnt[i])&#123; flag = 1; break; &#125; if(flag) que[r][0] = cur, que[r++][1] = que[l][1], l++; else break; &#125; if(que[l][1] == m)break; pcnt[que[l][0]]--, l++; &#125; printf("%d\n", t);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-9 UVa1596 Bug Hunt题目链接 很神奇的模拟题。注意细节即可。在bug里找bug其乐无穷12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005][85];int line;struct Arr&#123; int size; map&lt;int, int&gt; mp;&#125;;Arr arr[130];int getVal(int id, int st)&#123; if(isalpha(s[id][st + 1]))&#123; int _val = getVal(id, st + 2); char c = s[id][st + 1]; if(_val &lt; 0 || arr[c].size &lt; 0 || _val &gt;= arr[c].size || !arr[c].mp.count(_val)) return -1; else return arr[c].mp[_val]; &#125;else&#123; int x = 0; for(st++; s[id][st] != ']'; ++st) x = x * 10 + s[id][st] - '0'; return x; &#125;&#125;bool getInitalized(int id)&#123; char c = s[id][0]; arr[c].mp.clear(); int val = getVal(id, 1); if(val &lt; 0)return false; arr[c].size = val; //printf("%d\n", val); return true;&#125;void solve()&#123; for(int i = 0; i &lt; 127; ++i) arr[i].size = -1; int ans; for(ans = 0; ans &lt; line; ++ans)&#123; char *sp = strchr(s[ans], '='); if(sp != NULL)&#123; int index = getVal(ans, 1); char c = s[ans][0]; if(index &lt; 0 || arr[c].size &lt; 0 || index &gt;= arr[c].size) break; else&#123; if(isalpha(*(sp + 1)))&#123; char cc = *(sp + 1); int x = getVal(ans, sp - s[ans] + 2); if(x &lt; 0 || arr[cc].size &lt; 0 || x &gt;= arr[cc].size || !arr[cc].mp.count(x)) break; else arr[c].mp[index] = arr[cc].mp[x]; &#125;else&#123; int x = 0; for(int st = sp - s[ans] + 1; isdigit(s[ans][st]); ++st) x = x * 10 + s[ans][st] - '0'; arr[c].mp[index] = x; &#125; &#125; &#125;else&#123; if(!getInitalized(ans)) break ; &#125; &#125; printf("%d\n", ans == line ? 0 : (ans + 1));&#125;int main()&#123; for(; ; )&#123; line = 0; for(; ; )&#123; fgets(s[line], 82, stdin); if(s[line][0] == '.') break; line++; &#125; if(!line)break; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>STL</tag>
        <tag>二分</tag>
        <tag>栈</tag>
        <tag>堆</tag>
        <tag>离散化</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第四章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter4%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第四章部分习题的整合。 例4-2 UVa489 Hangman Judge题目链接 模拟即可。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; #include &lt;math.h&gt; char b1[27]=&#123;0&#125;,n1[100005],n2[100005];int n=-1,solve(),res,lim1,i;int solve()&#123; int chance=6,all=0; lim1=strlen(n1); for(i=0;i&lt;lim1;i++)&#123; if(!b1[n1[i]-'a'])&#123; b1[n1[i]-'a']++;all++; &#125; &#125; lim1=strlen(n2); for(i=0;i&lt;lim1;i++)&#123; if(b1[n2[i]-'a'])&#123; b1[n2[i]-'a']--;all--; if(all==0&amp;&amp;(chance&gt;=0))return 1; &#125; else chance--; &#125; if(chance&lt;0)return -1; if(all&gt;0)return 0;&#125;int main()&#123; for(scanf("%d",&amp;n);n!=-1;n=-1,scanf("%d",&amp;n))&#123; scanf("%s%s",n1,n2); res=solve(); printf("Round %d\n",n); if(res==1)printf("You win.\n"); if(res==0)printf("You chickened out.\n"); if(res==-1)printf("You lose.\n"); memset(b1,0,sizeof(b1)); &#125; return 0; &#125; 例4-3 UVa133 The Dole Queue题目链接 按照题意模拟即可。1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;int p[25], n, k, m;int main()&#123; for(n = 0,scanf("%d%d%d", &amp;n, &amp;k, &amp;m); n != 0; n = 0,scanf("%d%d%d", &amp;n, &amp;k, &amp;m))&#123; for(int i = 1; i &lt;= n; ++i) p[i] = i; for(int l = 0, tmp = n, r = n + 1; tmp; )&#123; int s = k % tmp; if(!s)s = tmp; for(; s; )&#123; ++l; if(l &gt; n)l = 1; if(p[l])s--; &#125; s = m % tmp; if(!s)s = tmp; for(; s; )&#123; --r; if(r &lt; 1)r = n; if(p[r])s--; &#125; if(l != r) printf("%3d%3d", p[l], p[r]), tmp -= 2; else printf("%3d", p[l]), tmp--; p[l] = p[r] = 0; if(tmp)putchar(','); &#125; putchar('\n'); &#125; return 0;&#125; 4-1 UVa1589 Xiangqi题目链接 长的模拟注意当开始就将帅碰头的时候，不能认为黑方必胜。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,bx,by,loc[10][3],puz[15][15];//g 0 c 1 h 2 r 3int dx[]=&#123;-1,0,0,1&#125;,dy[]=&#123;0,1,-1,0&#125;;int ddx[]=&#123;-2,-2,-1,1,-1,1,2,2&#125;,ddy[]=&#123;-1,1,2,2,-2,-2,-1,1&#125;;bool ask(int cx,int cy)&#123; for(int i=0;i&lt;n;i++)&#123; int kx=loc[i][1],ky=loc[i][2]; if(kx==cx&amp;&amp;cy==ky)continue; if(loc[i][0]==0)&#123; int flag=1; if(cy!=ky)continue; for(int j=cx+1;j&lt;kx;j++) if(puz[j][cy])&#123; flag=0;break; &#125; if(flag)return true; &#125;else if(loc[i][0]==1)&#123; int cnt=0; if(cx==kx)&#123; for(int j=min(cy,ky)+1;j&lt;max(cy,ky);j++) if(puz[cx][j])cnt++; &#125;else if(cy==ky)&#123; for(int j=min(cx,kx)+1;j&lt;max(cx,kx);j++) if(puz[j][cy])cnt++; &#125; if(cnt==1)return true; &#125;else if(loc[i][0]==2)&#123; for(int j=0;j&lt;8;j++)&#123; int ccx=kx+ddx[j],ccy=ky+ddy[j]; if(ccx==cx&amp;&amp;ccy==cy&amp;&amp;!puz[kx+dx[j&gt;&gt;1]][ky+dy[j&gt;&gt;1]]) return true; &#125; &#125;else&#123; int flag=1; if(cx==kx)&#123; for(int j=min(cy,ky)+1;j&lt;max(cy,ky);j++) if(puz[cx][j])&#123; flag=0;break; &#125; &#125;else if(cy==ky)&#123; for(int j=min(cx,kx)+1;j&lt;max(cx,kx);j++) if(puz[j][cy])&#123; flag=0;break; &#125; &#125;else flag=0; if(flag)return true; &#125; &#125; return false;&#125;void init()&#123; memset(puz,0,sizeof(puz)); bx=read(),by=read(); char s[3]; for(int i=0;i&lt;n;i++)&#123; scanf("%s%d%d",s,&amp;loc[i][1],&amp;loc[i][2]); if(s[0]=='G')loc[i][0]=0; if(s[0]=='C')loc[i][0]=1; if(s[0]=='H')loc[i][0]=2; if(s[0]=='R')loc[i][0]=3; puz[loc[i][1]][loc[i][2]]=1; &#125;&#125;void solve()&#123; int ans=1; for(int i=0;i&lt;4;i++)&#123; int cx=bx+dx[i],cy=by+dy[i]; if(!cx||cx&gt;3||cy&lt;4||cy&gt;6)continue; puz[cx][cy]=1; if(!ask(cx,cy))&#123; ans=0;break; &#125; puz[cx][cy]=0; &#125; if(!ans)printf("NO\n"); else printf("YES\n");&#125;int main()&#123; while(n=read())&#123; init(); solve(); &#125; return 0;&#125; 4-4 UVa253 Cube painting题目链接 让第一个骰子不断向左/向上翻转，直到所有视图均被翻出位置。若此时所有翻出的可能的视图中没有第二个骰子的视图则认为两个骰子不等价。反之等价。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool vis[1000];char s[15];int h2,k1[]=&#123;4,0,2,3,5,1&#125;,k2[]=&#123;0,2,4,1,3,5&#125;;int cg(char c)&#123; if(c=='r')return 0; if(c=='g')return 1; if(c=='b')return 2;&#125;void dfs(int hs)&#123; int bs[7],hh1=0,hh2=0; for(int i=5;i&gt;=0;i--)bs[i]=hs%3,hs/=3; for(int i=0;i&lt;6;i++)hh1=hh1*3+bs[k1[i]]; for(int i=0;i&lt;6;i++)hh2=hh2*3+bs[k2[i]]; if(!vis[hh1])vis[hh1]=1,dfs(hh1); if(!vis[hh2])vis[hh2]=1,dfs(hh2);&#125;void init()&#123; memset(vis,0,sizeof(vis)); int h1=0;h2=0; for(int i=0;i&lt;6;i++)h1=h1*3+cg(s[i]); for(int i=6;i&lt;12;i++)h2=h2*3+cg(s[i]); vis[h1]=1; dfs(h1);&#125;void solve()&#123; if(vis[h2])printf("TRUE\n"); else printf("FALSE\n");&#125;int main()&#123; while(scanf("%s",s)==1)&#123; init(); solve(); &#125; return 0;&#125; 4-5 UVa1590 IP Networks题目链接 模拟即可熟悉位运算的好题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef unsigned int u_int;u_int ip[1005] = &#123;0&#125;;int m;void init()&#123; memset(ip, 0, sizeof(ip)); for(int i = 0; i &lt; m; ++i) for(int j = 3; j &gt;= 0; --j)&#123; u_int t = read(); ip[i] += (t &lt;&lt; (j * 8)); &#125;&#125;void solve()&#123; int n = 0, i; for(; n &lt;= 31; ++n)&#123; u_int pp = ~((1 &lt;&lt; n) - 1); for(i = 1; i &lt; m; ++i) if((pp &amp; ip[i]) != (pp &amp; ip[i - 1]))break ; if(i == m)break ; &#125; u_int ans = ~((1 &lt;&lt; n) - 1), t = 0xff000000; ip[0] &amp;= ans; for(int j = 3; j &gt;= 0; --j) printf("%u%s", (ip[0] &amp; t) &gt;&gt; (j * 8), j ? "." : "\n"), t &gt;&gt;= 8; t = 0xff000000; for(int j = 3; j &gt;= 0; --j) printf("%u%s", (ans &amp; t) &gt;&gt; (j * 8), j ? "." : "\n"), t &gt;&gt;= 8;&#125;int main()&#123; while(scanf("%d", &amp;m) == 1)&#123; init(); solve(); &#125; return 0;&#125; 4-7 UVa509 RAID!题目链接 模拟…即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int d, s, b, val, seq[100005];char data[7][6500];void init()&#123; char ord[3]; s = read(), b = read(); scanf("%s", ord); val = (ord[0] == 'E' ? 0 : 1); for(int i = 0; i &lt; d; ++i) scanf("%s", data[i]);&#125;void solve()&#123; int cur = 0, tot = 0; for(int i = 0; i &lt; b; ++i)&#123; for(int j = 0; j &lt; s; ++j)&#123; //当前的校验块在磁盘号为cur int c = 0, cnt = 0, id; for(int k = 0; k &lt; d; ++k)&#123; if(data[k][i * s + j] == 'x') cnt++, id = k;//坏的在id处 else c ^= (data[k][i * s + j] - '0'); &#125; if(cnt &gt;= 2) goto failed; else if(cnt == 1) data[id][i * s + j] = (c ^ val) + '0'; else&#123; if(c != val)//校验错误 goto failed; &#125; &#125; for(int j = 0; j &lt; d; ++j)&#123; if(j == cur)continue ; for(int k = 0; k &lt; s; ++k)&#123; if(data[j][i * s + k] - '0') seq[tot &gt;&gt; 2] += (1 &lt;&lt; (3 - (tot % 4))); tot++; &#125; &#125; cur = (cur + 1) % d; &#125; printf("valid, contents are: "); while(tot % 4)tot++; tot &gt;&gt;= 2; for(int i = 0; i &lt; tot; ++i)&#123; if(seq[i] &lt; 10)printf("%d", seq[i]); else putchar(seq[i] - 10 + 'A'); &#125; printf("\n"); return ; failed: printf("invalid.\n");&#125;int main()&#123; for(int T = 1; ; ++T)&#123; d = read(); if(!d)break ; printf("Disk set %d is ", T); init(); solve(); memset(seq, 0, sizeof(seq)); &#125; return 0;&#125; 4-9 Uva1591 Data Mining（待补充） 4-10 UVa815 Flooded!题目链接 先对高度排一个序，然后从最下方向上面淹即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m;double h[905], V;void init()&#123; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) h[i * m + j] = read(); V = read(), V /= 100.0; sort(h, h + n * m); h[n * m] = 100000000;&#125;void solve()&#123; double tot = 0.0, ans1, ans2; int i; for(i = 1; i &lt;= n * m; ++i)&#123; tot += h[i - 1]; if(V &lt; i * h[i] - tot) break; &#125; ans1 = (V + tot) / (double)i, ans2 = 100.0 * i / (n * m); printf("Water level is %.2lf meters.\n%.2lf percent of the region is under water.\n\n", ans1, ans2); &#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), m = read(); if(!n &amp;&amp; !m)break ; printf("Region %d\n", T); init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第三章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter3%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第三章部分习题的整合。 例3-1 TEX Quotes题目链接 简单模拟123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void init()&#123; &#125;void solve()&#123; char c; int flag=0; while((c=getchar())!=EOF)&#123; if(c!='"')putchar(c); else&#123; if(flag)putchar('\''),putchar('\''),flag=0; else putchar('`'),putchar('`'),flag=1; &#125; &#125;&#125;int main()&#123;、 init(); solve(); return 0;&#125; 例3-2 UVa10082 WERTYU题目链接 模拟12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[]="`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./'";void init()&#123; &#125;void solve()&#123; char c; while((c=getchar())!=EOF)&#123; int ind; if(isspace(c))putchar(c); else&#123; for(ind=0;s[ind]!=c;ind++); putchar(s[ind-1]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-3 UVa401 Palindromes题目链接 常量数组技巧！123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char rev_al[]="A 3 HIL JM O 2TUVWXY5",rev_num[]="1SE Z 8 ";char ask(char c)&#123; if(isalpha(c))return rev_al[c-'A']; if(isdigit(c))return rev_num[c-'1'];&#125;void init()&#123; &#125;void solve()&#123; char s[30]; while(scanf("%s",s)==1)&#123; int len=strlen(s),f1=1,f2=1; for(int i=0;i&lt;(len+1)/2;i++) if(s[i]!=s[len-i-1])&#123;f1=0;break;&#125; for(int i=0;i&lt;(len+1)/2;i++) if(s[len-i-1]!=ask(s[i]))&#123;f2=0;break;&#125; if(f1&amp;&amp;f2)printf("%s -- is a mirrored palindrome.\n",s); if((!f1)&amp;&amp;f2)printf("%s -- is a mirrored string.\n",s); if(f1&amp;&amp;(!f2))printf("%s -- is a regular palindrome.\n",s); if((!f1)&amp;&amp;(!f2))printf("%s -- is not a palindrome.\n",s); putchar('\n'); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-4 UVa340 Master-Mind Hints题目链接 模拟123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,numa[1005],numb[1005],co[10],ca[10],cb[10];void init()&#123; memset(co,0,sizeof(co)); for(int i=0;i&lt;n;i++) numa[i]=read(),co[numa[i]]++;&#125;void solve()&#123; for(;;)&#123; memset(cb,0,sizeof(cb)); memcpy(ca,co,sizeof(co)); int ans1=0,ans2=0; for(int i=0;i&lt;n;i++)&#123; numb[i]=read(),cb[numb[i]]++; if(numa[i]==numb[i])ans1++,ca[numa[i]]--,cb[numb[i]]--; &#125; if(!numb[0])break; for(int i=1;i&lt;=9;i++) ans2+=min(ca[i],cb[i]); printf(" (%d,%d)\n",ans1,ans2); &#125;&#125;int main()&#123; for(int T=1;;T++)&#123; n=read(); if(!n)break; printf("Game %d:\n",T); init(); solve(); &#125; return 0;&#125; 例3-5 UVa1583 Digit Generator题目链接 模拟123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int tab[100005]=&#123;0&#125;;void init()&#123; for(int i=1;i&lt;=100000;i++)&#123; int tmp=i,tot=i; while(tmp)tot+=tmp%10,tmp/=10; if(tot&lt;=100000&amp;&amp;!tab[tot])tab[tot]=i; &#125;&#125;void solve()&#123; for(int n=read();n;n--)printf("%d\n",tab[read()]);&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-6 UVa1584 Circular Sequence题目链接 模拟12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[1005];int len;void init()&#123; scanf("%s",s); len=strlen(s),memcpy(s+len,s,sizeof(char)*len);&#125;void solve()&#123; int ans=0; for(int t=1;t&lt;len;t++)&#123; int flag=1; for(int j=0;j&lt;len;j++) if(s[t+j]&lt;s[ans+j])&#123;flag=0;break;&#125; else if(s[t+j]&gt;s[ans+j])break; if(!flag)ans=t; &#125; for(int i=0;i&lt;len;i++) putchar(s[i+ans]); putchar('\n');&#125;int main()&#123; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-1 UVa1585 Score题目链接 模拟123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[100];void init()&#123; scanf("%s",s);&#125;void solve()&#123; int len=strlen(s),tot=0,sc=0; for(int i=0;i&lt;len;i++)&#123; if(s[i]=='O')tot++,sc+=tot; else tot=0; &#125; printf("%d\n",sc);&#125;int main()&#123; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-2 UVa1586 Score题目链接 模拟123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[100];double mass[26];void init()&#123; scanf("%s",s);&#125;void solve()&#123; double ans=0.0; int len=strlen(s),tot=0,ind=0; for(int i=0;i&lt;len;i++)&#123; if(isalpha(s[i]))&#123; if(ind&amp;&amp;!tot)tot=1; ans+=tot*mass[ind],tot=0,ind=s[i]-'A'; &#125;else tot=tot*10+s[i]-'0'; &#125; if(ind&amp;&amp;!tot)tot=1; ans+=tot*mass[ind]; printf("%.3lf\n",ans);&#125;int main()&#123; mass[0]=0; mass[2]=12.010,mass[7]=1.008,mass[14]=16.000,mass[13]=14.010; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-3 UVa1225 Digit Counting题目链接 模拟1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int T,tab[10005]=&#123;0&#125;,ans[22][11],cnt[11]=&#123;0&#125;,maxn=0;void init()&#123; T=read(); for(int i=0;i&lt;T;i++)&#123; int t=read(); tab[t]=i+1,maxn=max(maxn,t); &#125;&#125;void solve()&#123; for(int i=1;i&lt;=maxn;i++)&#123; int tmp=i; while(tmp)cnt[tmp%10]++,tmp/=10; if(tab[i])&#123; int ind=tab[i]; for(int j=0;j&lt;10;j++)ans[ind][j]=cnt[j]; &#125; &#125; for(int i=1;i&lt;=T;i++)&#123; for(int j=0;j&lt;9;j++)printf("%d ",ans[i][j]); printf("%d\n",ans[i][9]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 3-4 UVA455 Periodic Strings题目链接 这题有多种做法，这里选的是最容易想到的一种。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[1005];int main()&#123; int N=read(),flag=0; while(N--)&#123; scanf("%s",s); int len=strlen(s),ans=len; for(int i=1;i&lt;len;i++) if(len%i==0)&#123; int fl=1; for(int j=i;j&lt;len;j++) if(s[j]!=s[j%i])&#123;fl=0;break;&#125; if(fl)&#123;ans=i;break;&#125; &#125; if(!flag)flag=1; else putchar('\n'); printf("%d\n",ans); &#125;; return 0;&#125; 3-5 UVa227 Puzzle题目链接 这题神坑 有可能拼图里面有字母Z 最后一行的空行不能有，不然无限WA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char puz[7][7],list[100005],tmp[100005];int len,x,y;bool readPuzzle()&#123; char c[10]; for(int i=0;i&lt;5;i++)&#123; fgets(c,10,stdin); if(c[0]=='Z'&amp;&amp;strlen(c)&lt;5)return false; for(int j=0;j&lt;5;j++) if(isalpha(c[j]))puz[i][j]=c[j]; else if(c[j]==' ')puz[(x=i)][(y=j)]=c[j]; &#125; return true;&#125;bool move(int id)&#123; if(list[id]=='A')&#123; if(!x)return false; swap(puz[x-1][y],puz[x][y]),x--; return true; &#125; if(list[id]=='B')&#123; if(x==4)return false; swap(puz[x+1][y],puz[x][y]),x++; return true; &#125; if(list[id]=='L')&#123; if(!y)return false; swap(puz[x][y],puz[x][y-1]),y--; return true; &#125; if(list[id]=='R')&#123; if(y==4)return false; swap(puz[x][y+1],puz[x][y]),y++; return true; &#125; return false;&#125;void solve()&#123; int flag=1; for(int _flag=1;_flag;)&#123; fgets(list,100000,stdin); int len=strlen(list); for(int i=0;i&lt;len;i++)&#123; //printf("%c",list[i]); if(isalpha(list[i]))&#123; if(!move(i)&amp;&amp;flag)&#123; printf("This puzzle has no final configuration.\n"); flag=0; &#125; &#125;else if(list[i]=='0')&#123; _flag=0; break; &#125;else if(!isspace(list[i]))&#123; if(flag) printf("This puzzle has no final configuration.\n"),flag=0; &#125; &#125; &#125; if(flag)&#123; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;4;j++) printf("%c ",puz[i][j]); printf("%c\n",puz[i][4]); &#125; &#125;&#125;int main()&#123; int T=1; while(readPuzzle())&#123; if(T!=1)putchar('\n'); printf("Puzzle #%d:\n",T++); solve(); memset(puz,0,sizeof(puz)); &#125; return 0;&#125; 3-8 UVa202 Repeating Decimals题目链接 模拟只要除出来了一样的余数就停止因为除数不是很大，所以余数不算多，可以完成12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int m,n,vis[3005]=&#123;0&#125;,lis[3105];void init()&#123; printf("%d/%d = %d.",m,n,m/n); m%=n;&#125;void solve()&#123; int ans=1,pace=1; memset(vis,0,sizeof(vis)); for(;m;pace++)&#123; if(vis[m])break; vis[m]=pace,m*=10; lis[pace]=m/n,m%=n; &#125; if(!m)&#123; for(int i=1;i&lt;pace;i++) printf("%d",lis[i]); printf("(0)\n"); &#125;else &#123; for(int i=1;i&lt;vis[m];i++) printf("%d",lis[i]); printf("("); if(pace&lt;=50)&#123; for(int i=vis[m];i&lt;pace;i++) printf("%d",lis[i]); printf(")\n"); &#125;else&#123; for(int i=vis[m];i&lt;=50;i++) printf("%d",lis[i]); printf("...)\n"); &#125; ans=pace-vis[m]; &#125; printf(" %d = number of digits in repeating cycle\n\n",ans);&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)==2)&#123; init(); solve(); &#125; return 0;&#125; 3-10 UVa1587 Box题目链接保证构成一个长方体需要： 有3组相同的面 有3组长宽高 判断即可。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;pair&lt;int,int&gt; p[7];int a[19];void init()&#123; for(int i=1;i&lt;6;i++) scanf("%d%d",&amp;p[i].first,&amp;p[i].second); for(int i=0;i&lt;6;i++)&#123; if(p[i].first&lt;p[i].second) swap(p[i].first,p[i].second); a[i&lt;&lt;1]=p[i].first,a[i&lt;&lt;1|1]=p[i].second; &#125; sort(a,a+12); sort(p,p+6);&#125;void solve()&#123; int ans=1; for(int i=0;i&lt;6;i+=2) if(p[i].first!=p[i+1].first||p[i].second!=p[i+1].second)&#123; ans=0;break; &#125; for(int i=0;i&lt;12;i+=4) if(a[i]!=a[i+1]||a[i]!=a[i+2]||a[i]!=a[i+3])&#123; ans=0;break; &#125; if(!ans)printf("IM"); printf("POSSIBLE\n");&#125;int main()&#123; while(scanf("%d%d",&amp;p[0].first,&amp;p[0].second)==2)&#123; init(); solve(); &#125; return 0;&#125; 3-12 UVa11809 Floating-Point Numbers题目链接 数字都很大，用数字的对数比较。事先对不同M和E打个表，然后比即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;double tab[11][50],eps=1e-6;//M Evoid init()&#123; double t=0.5,u=0.5; for(int i=0;i&lt;=9;i++)&#123; for(int j=1;j&lt;=30;j++)&#123; double k=(double)((1&lt;&lt;j)-1); tab[i][j]=k*log(2.0)+log(t); &#125; u*=0.5,t+=u; &#125;&#125;void solve()&#123; char s[50]; while(scanf("%s",s)==1)&#123; if(strlen(s)==3)break; s[17]=' '; double t,u,g; sscanf(s,"%lf%lf",&amp;t,&amp;u); g=u*log(10.0)+log(t); for(int i=0;i&lt;=9;i++) for(int j=1;j&lt;=30;j++) if(g-tab[i][j]&lt;eps&amp;&amp;g-tab[i][j]&gt;-eps)&#123; printf("%d %d\n",i,j); break; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fwriting%2Fnoip2017%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2017十道题目的题解。 提高D1T1 小凯的疑惑题目链接 和USACO上的麦香牛块差不多，套上公式即可。最大的数即为$ab-a-b$。12345678910111213141516#include &lt;iostream&gt;#define INF 2000000000using namespace std;typedef unsigned long long ll;ll s, t;void init()&#123; cin &gt;&gt; s &gt;&gt; t;&#125;void solve()&#123; cout &lt;&lt; s * t - s - t &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2010%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2010八道题目的题解。 普及T1 数字统计题目地址 某一道普及的弱化版。模拟即可。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int l,r,ans=0;int main()&#123; scanf("%d%d",&amp;l,&amp;r); for(int i=l;i&lt;=r;i++)&#123; int t=i; while(t)ans+=(t%10==2),t/=10; &#125; printf("%d\n",ans); return 0;&#125; 普及T2 接水问题题目地址 模拟即可。可以用堆加速，但我的代码里没用。不用堆的时间复杂度是$O(nm)$，用的话是$O(nlogm)$。12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int n,m,at[105],w[10005],f=0,ans=0; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d",&amp;at[i]); for(int i=m;i&lt;n;i++) scanf("%d",&amp;w[i-m]); for(;;)&#123; int mini=INF; for(int i=0;i&lt;m;i++) if(at[i]&gt;0&amp;&amp;at[i]&lt;mini)mini=at[i]; if(mini==INF)break; ans+=mini; for(int i=0;i&lt;m;i++) if(at[i]&gt;0)&#123; at[i]-=mini; if(!at[i])&#123; if(f!=n-m)at[i]=w[f++]; else at[i]=-1; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 普及T3 导弹拦截题目地址 此题致敬了11年前的那道经典题目。我们希望这个工作半径最小，直觉上就要让这两个系统都被充分利用。也就是让第一套拦截一部分，第二套拦截另一部分。我们先对所有导弹到第一套系统的距离从近到远排一个序，企图把这个序列切成$2$份，将前半部分给第一个系统，将后半部分（远的）给第二个系统。枚举切开的部位，找到第二套系统应该有的工作半径，也就是分配给第二套系统的最远导弹到他的距离。这里用各种方法实现，我用的是对所有导弹到第二套系统的距离从远到近排一个序，然后用一个指针扫的方法。综上，解决本题的时间复杂度为$O(nlogn)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int id,dis;&#125;Mis;Mis mis[200005];bool operator&lt;(Mis a,Mis b)&#123;return a.dis&lt;b.dis;&#125;int p1[2],p2[2],n,at;//p1 x p2 ybool vis[100005]=&#123;0&#125;;int ask()&#123;//找第二套应该有的工作半径 while(vis[mis[at].id]&amp;&amp;at&lt;2*n) at++; if(at==2*n)return 0; else return mis[at].dis;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;p1[0],&amp;p2[0],&amp;p1[1],&amp;p2[1],&amp;n); int i,j,l1,l2,ans=2000000000; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;l1,&amp;l2), mis[i].dis=(p1[0]-l1)*(p1[0]-l1)+ (p2[0]-l2)*(p2[0]-l2), mis[i+n].dis=-(p1[1]-l1)*(p1[1]-l1)- (p2[1]-l2)*(p2[1]-l2), mis[i].id=mis[i+n].id=i; sort(mis,mis+n), sort(mis+n,mis+n+n), at=n; ans=min(ans,-ask());//全部分配给第二套 for(i=0;i&lt;n;i++) vis[mis[i].id]=1, ans=min(ans,(mis[i].dis-ask())); printf("%d\n",ans); return 0;&#125; 普及T4 三国游戏题目地址 这个人肯定不会输给电脑。因为计算机的选将是完全根据这个人的选法来的，也就是说，这个人自己是一定有把握选中更好的策略的。然后具体选法，非常简单：最大的一定被拆，所以我们矮子里拔高个儿，选默契值排第二且是所有第二中最高的一对将。这样就做完了。时间复杂度：$O(n^2)$。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,mat[505][505]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) scanf("%d",&amp;mat[i][j]), mat[j][i]=mat[i][j];&#125;void solve()&#123; int max1=0,max2=0,ans=0; for(int i=0;i&lt;n;i++)&#123; max1=max2=0; for(int j=0;j&lt;n;j++)&#123; if(mat[i][j]&gt;max1)max2=max1,max1=mat[i][j]; else if(mat[i][j]&gt;max2)max2=mat[i][j]; &#125; ans=max(ans,max2); &#125; printf("1\n%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 机器翻译题目地址 用队列模拟即可。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool vis[1005];int w,m,n,que[100005],f=0,r=0;void init()&#123; m=read(),n=read();&#125;void solve()&#123; int ans=0; while(n--)&#123; w=read(); if(!vis[w])&#123; vis[w]=1,que[r++]=w,ans++; if(r-f==m+1)vis[que[f++]]=0; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T2 乌龟棋题目地址 按卡片数$DP$即可。只要知道每一种卡片的使用情况就可以推知当前所处位置，从而进行状态转移。设$f(i,j,k,l)$表示用了$i$张$1$，$j$张$2$，$k$张$3$，$l$张$4$的最大得分，则状态转移方程容易导出。1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define dis(a,b,c,d) score[1+a+(b&lt;&lt;1)+(d&lt;&lt;2)+(c&lt;&lt;2)-c]#define fep(a,b) for(a=0;a&lt;=cnt[b];a++)using namespace std;int dp[41][41][41][41]=&#123;0&#125;,n,m,cnt[4]=&#123;0&#125;,score[353];int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v,d; for(i=1;i&lt;=n;i++) scanf("%d",&amp;score[i]); for(i=0;i&lt;m;i++) scanf("%d",&amp;j),cnt[j-1]++; dp[0][0][0][0]=score[1]; fep(i,0)fep(j,1)fep(u,2)fep(v,3)&#123; d=dis(i,j,u,v); if(i)dp[i][j][u][v]=max(dp[i-1][j][u][v]+d,dp[i][j][u][v]); if(j)dp[i][j][u][v]=max(dp[i][j-1][u][v]+d,dp[i][j][u][v]); if(u)dp[i][j][u][v]=max(dp[i][j][u-1][v]+d,dp[i][j][u][v]); if(v)dp[i][j][u][v]=max(dp[i][j][u][v-1]+d,dp[i][j][u][v]); &#125; printf("%d\n",dp[cnt[0]][cnt[1]][cnt[2]][cnt[3]]); return 0;&#125; 提高T3 关押罪犯（待考察）题目地址 贪心。将仇恨值从大到小排序，从仇恨最大的一对人开始处理起。记录每一个人的“对手”，看作是这个人和“对手”必须处在不同监狱。如果两人所处监狱相同那就表示分配到此为止，输出答案。然后分类讨论，假设两人都还没有对手就互相记为对手，表示两人不会在一个监狱；只有一个人有对手，那就另一个人把这个人记为对手，并且把这个人的对手收为己方（用并查集实现）；两个人都有，那就收各自的对手为己方。讨论完之后，处理下一对罪犯，如此反复。这样就可以在$O(mlogm)$的时间复杂度内解决这个问题。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int parent[20005],riv[20005]=&#123;0&#125;,m,n,re[100005][3];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;&#125;void init(int k)&#123; for(int i=1;i&lt;=k;i++)parent[i]=i;&#125;int Find(int a)&#123; if(parent[a]==a)return a; return (parent[a]=Find(parent[a]));&#125;void joint(int x,int y)&#123; int a=Find(x),b=Find(y); if(a==b)return; parent[b]=a;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(n);int i,k1,k2,t1,t2; for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;re[i][1],&amp;re[i][2],&amp;re[i][0]); qsort(re,m,sizeof(re[0]),cmp); for(i=0;i&lt;m;i++)&#123; t1=re[i][1],t2=re[i][2]; if(Find(t1)==Find(t2))break; if(riv[t2]&amp;&amp;!riv[t1])swap(t1,t2); if(!riv[t2])&#123; if(!riv[t1])riv[t1]=t2,riv[t2]=t1; else riv[t2]=t1,joint(t2,riv[t1]); &#125;else joint(t2,riv[t1]),joint(t1,riv[t2]); &#125; if(i==m)printf("0\n"); else printf("%d\n",re[i][0]); return 0;&#125; 提高T4 引水入城题目地址 先搜索，搜出每一个出水站能最多支援几个国家。然后会发现每一个国家能支援到的国家一定是一段一段存在的。如果不是，那么会形成一些国家无法被到达的局面，就输出$0$，然后统计。否则对每段区间排序后贪心选择即可。可以用一些手段加速，如对在第一行的国家，只选取相对周围的国家更高一些的国家来搜索，因为这个国家肯定可以向两侧扩展。时间复杂度：$O(nm)$（近似）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;bool dp[505][505],able[505][505]=&#123;0&#125;;int n,m,h[505][505],par[505],res,ans,dx[]=&#123;-1,0,0,1&#125;,dy[]=&#123;0,-1,1,0&#125;;int stack[250005][2],top=0;void dfs(int x,int y)&#123; int nx,ny,i; stack[top][0]=x,stack[top++][1]=y; while(top)&#123; x=stack[--top][0],y=stack[top][1]; for(i=0;i&lt;4;i++)&#123; nx=x+dx[i],ny=y+dy[i]; if(nx&gt;=0&amp;&amp;ny&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&lt;m&amp;&amp; h[nx][ny]&lt;h[x][y]&amp;&amp;!dp[nx][ny]) dp[nx][ny]=1,stack[top][0]=nx,stack[top++][1]=ny; &#125; &#125;&#125;void _solve()&#123; int i,j,p,k,rec[505][2],tot=0,l,r; for(ans=1,i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; p=par[i-1],k=0; while(k&lt;m&amp;&amp;!able[p][k])k++; rec[tot][0]=k; if(tot&amp;&amp;rec[tot-1][0]==k)tot--; while(k&lt;m&amp;&amp;able[p][k])k++; rec[tot++][1]=k-1; if(k-1&lt;rec[tot-1][0])tot--; j=i-1; &#125; for(l=rec[0][0],r=rec[0][1],i=1;i&lt;tot;i++)&#123; while(i&lt;tot&amp;&amp;rec[i][0]&lt;=r+1)i++; if(r==m-1)break; i--,r=rec[i][1],ans++; &#125;&#125;void solve()&#123; int i,j,k; for(i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; memset(dp,0,sizeof(dp)); dp[0][par[i-1]]=1,dfs(0,par[i-1]); memcpy(able[par[i-1]],dp[n-1],sizeof(bool)*m); j=i-1; &#125; bool cnt[505]=&#123;0&#125;; for(k=i=0;i&lt;m;i++) for(j=0;j&lt;m;j++) if(able[par[i]][j]&amp;&amp;!cnt[j])cnt[j]=1,k++; res=(k==m)?1:0; if(res)_solve(); else ans=m-k; printf("%d\n%d\n",res,ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,maxi,lst; for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++) scanf("%d",&amp;h[i][j]); for(i=0;i&lt;m;i++)&#123; while(i&lt;m-1&amp;&amp;h[0][i+1]&gt;h[0][i])i++; for(j=i-1;j&gt;=0&amp;&amp;h[0][j]&lt;h[0][j+1];j--) par[j]=i; par[i]=i; for(j=i+1;j&lt;m&amp;&amp;h[0][j]&lt;h[0][j-1];j++) par[j]=i; while(i&lt;m-1&amp;&amp;h[0][i+1]&lt;h[0][i])i++; &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>堆</tag>
        <tag>队列</tag>
        <tag>搜索</tag>
        <tag>贪心</tag>
        <tag>其他DP</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2009%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2009八道题目的题解。 普及T1 多项式输出题目地址 只要读懂了题就不难了。模拟即可，代码可能有点长。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int n,xs;int main()&#123; scanf("%d",&amp;n); for(int i=n;i&gt;=0;i--)&#123; scanf("%d",&amp;xs); if(xs!=0)&#123; if(i==n)&#123; if(abs(xs)==1)&#123; if(xs==-1)putchar('-'); &#125;else printf("%d",xs); &#125;else if(i==1)&#123; if(xs==1)printf("+x"); else if(xs==-1)printf("-x"); else printf("%+dx",xs); continue; &#125;else if(i==0)&#123; printf("%+d",xs); break; &#125;else &#123; if(xs==1)printf("+"); else if(xs==-1)printf("-"); else printf("%+d",xs); &#125; printf("x^%d",i); &#125; &#125; printf("\n"); return 0;&#125; 普及T2 分数线划定题目地址 根据题目描述来模拟和排序即可。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[10005];bool cmp(const P &amp;pa,const P &amp;pb)&#123; return pa.first&gt;pb.first||(pa.first==pb.first&amp;&amp;pa.second&lt;pb.second);&#125;int n,m,lim;int main()&#123; scanf("%d%d",&amp;n,&amp;m); lim=m*150/100; for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;p[i].second,&amp;p[i].first); sort(p,p+n,cmp); int sc=p[lim-1].first,extra=0; for(int i=lim;i&lt;n;i++) if(p[i].first==sc)extra++; else break; printf("%d %d\n",sc,lim+extra); for(int i=0;i&lt;lim+extra;i++) printf("%d %d\n",p[i].second,p[i].first); return 0; &#125; 普及T3 细胞分裂题目地址 题意：找出某一个数$S_i$，使得$\mathcal S_i^T=M={m_1}^{m_2}$，且$T$最小。考虑$S_i$的唯一分解，只要使得每一个质因数对应的次数都能超过$M$的唯一分解中这个质因数对应的次数即可。这样就可以算出对应的时间$T$来。由于一个数的质因数个数大约是$O(logn)$级别的，使用以上算法的时间复杂度约为$O(nlogm_1)$。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll m1,m2,ans=-1,lis[10][2],a,tot,p,k;int n,t=0;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;m1,&amp;m2); ll e=m1; for(ll b=2;b&lt;=m1;b++) if(e%b==0)&#123; lis[t++][0]=b,lis[t-1][1]=0; while(e%b==0) lis[t-1][1]++,e/=b; lis[t-1][1]*=m2; &#125; for(int i=0;i&lt;n;i++)&#123; tot=0; scanf("%lld",&amp;a); int j; for(j=0;j&lt;t;j++) if(a%lis[j][0]==0)&#123; p=0; while(a%lis[j][0]==0) p++,a/=lis[j][0]; k=lis[j][1]/p; if(lis[j][1]%p)k++;tot=max(tot,k); &#125;else break; if(j!=t)continue; ans=(ans&lt;0)?tot:(ans&gt;tot?tot:ans); &#125; printf("%lld\n",ans); return 0; &#125; 普及T4 道路游戏题目地址 方法一这是一道比较难的DP。状态的表示比较难想，我个人一开始给出的转移方程是：设$f(i,j,k)$表示当前在$i$工厂，$j$时间，$k$状态时的最大金币量，其中$k=0$表示当前机器人刚刚走出了第一步，$k=1$表示当前机器人走出了$2$到$p$步，并且已经被回收。这样状态转移方程就很好写，$f(i,j,0)$就从上一秒的$f(i-1,j-1,1)$里面找最大值，$f(i,j,1)$就枚举一下步数。这么做的时间复杂度是$O(nmp)$的。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005][1005][2]=&#123;0&#125;,m[1005][1005],n,t,p,cost[1005];int deque[4005][2],f=0,r=0,R;void in(int o,int at)&#123; while(r&gt;f&amp;&amp;o&gt;deque[r-1][0]) r--; deque[r][0]=o,deque[r++][1]=at;&#125;int out(int at)&#123; if(deque[f][1]==(at+R-p)%n) f++; return deque[f][0];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;t,&amp;p); int i,j,m2=0,m3=0,k,l,ans=0,sum; R=1000*n; for(i=0;i&lt;n;i++) for(j=0;j&lt;t;j++) scanf("%d",&amp;m[i][j]); for(i=0;i&lt;n;i++) scanf("%d",&amp;cost[i]); for(i=1;i&lt;=t;i++)&#123;//[f,r] for(j=0;j&lt;n;j++)&#123; dp[i][j][1]=m2; if(!j)dp[i][j][1]+=m[n-1][i-1]-cost[n-1]; else dp[i][j][1]+=m[j-1][i-1]-cost[j-1]; for(k=(j-1+n)%n,l=1,sum=0;l&lt;p;l++,k=(k-1+n)%n) if(i-l&gt;0) sum+=m[k][i-l], dp[i][j][0]=max(dp[i][j][0],dp[i-l][k][1]+sum); else break; m3=max(m3,max(dp[i][j][0],dp[i][j][1])); &#125; m2=m3,m3=0; &#125; for(i=0;i&lt;n;i++) ans=max(ans,max(dp[t][i][0],dp[t][i][1])); printf("%d\n",ans); return 0;&#125; 但是居然过了！我就没留意这道题了（其实我都写了单调队列但没用上）今天想了一下，发现没必要那么麻烦，很多地方可以优化。 方法二设$f(i,j)$为机器人走到$i$工厂，$j$时间所能收集的最大金币量。那么 f(i,j)=\max \limits_{i\le k \le p} \left\{ \max \limits_{1\le s\le n}\left\{f(s,j-k) \right\} +sum(i-1,j)-sum(i-k-1,j-k)-cost[i-k]\right\}其中 sum(i,j)=sum(i-1,j-1)+coin[i][j]那么提出$sum(i,j)$就可以发现括号里的量只与$k$有关，就用单调队列。而$sum$是可以前后递推出来的。所以，解决本题的时间复杂度就优化为了$O(nm)$。其实你如果读上面的题解读得仔细的话就会发现我没有讲到一个东西，那就是单调队列该怎么用。本题的优化方式十分特殊，由于$sum$是斜方格形进行求和的（$i-k,j-k \rightarrow i,j$），所以单调队列的下标也要随着$i$改变而改变。具体可以看代码。 完了么？没有。很多题解都会被洛谷上的Extra Test卡掉，虽然我也不知道这数据怎么出的但反正很厉害。（提示：其实读懂了题就不会被坑）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,p,coin[2005][1005],sum[1005][1005],cost[2005];int Deque[1005][1005][2],f[1005],r[1005],maxi[1005];int dp[1005][1005];void init()&#123; n=read(),m=read(),p=read(); for(int i=0;i&lt;n;i++) for(int j=1;j&lt;=m;j++) coin[i][j]=coin[i+n][j]=read(); for(int i=0;i&lt;n;i++)cost[i]=cost[i+n]=read();&#125;void inque(int x,int val,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;val&gt;Deque[x][r[x]-1][0])r[x]--; Deque[x][r[x]][0]=val,Deque[x][r[x]++][1]=k;&#125;int outque(int x,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;k-Deque[x][f[x]][1]&gt;p)f[x]++; return Deque[x][f[x]][0];&#125;void solve()&#123; for(int i=0;i&lt;n;i++)inque(i,-cost[i],0); int R=1000*n; //R：当前单调队列的偏移量 for(int j=1;j&lt;=m;j++)&#123; R--; sum[n-1][j]=sum[n-2][j-1]+coin[n-1][j]; sum[0][j]=sum[n-1][j-1]+coin[0][j]; dp[0][j]=outque(R%n,j)+sum[n-1][j]; maxi[j]=dp[0][j]; for(int i=1;i&lt;n;i++)&#123; sum[i][j]=sum[i-1][j-1]+coin[i][j]; dp[i][j]=outque((i+R)%n,j)+sum[i-1][j]; maxi[j]=max(maxi[j],dp[i][j]); &#125; inque(R%n,maxi[j]-cost[0]-sum[n-1][j],j); for(int i=1;i&lt;n;i++) inque((i+R)%n,maxi[j]-cost[i]-sum[i-1][j],j); &#125; //以上把0单独处理了 printf("%d\n",maxi[m]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 潜伏者题目地址 稍微麻烦的模拟。只要注意及时停止即可。12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;char f[27],sec[105],ori[105],s[105];int flag=1,vis[27];int main()&#123; scanf("%s%s%s",sec,ori,s); int l1=strlen(sec),l2=strlen(s); if(l1&lt;26)&#123; flag=0;goto end; &#125;//不够26个字母 for(int i=0;i&lt;l1;i++)&#123; if(f[sec[i]-'A']&amp;&amp;ori[i]!=f[sec[i]-'A'])&#123; flag=0;goto end; &#125;//没对上 f[sec[i]-'A']=ori[i],vis[sec[i]-'A']=1; &#125; for(int i=0;i&lt;26;i++) if(!vis[i]||!f[i])&#123; flag=0;goto end; &#125;//禁止没有得对 for(int i=0;i&lt;26;i++)vis[f[i]-'A']++; for(int i=0;i&lt;26;i++) if(vis[i]&gt;2)&#123; flag=0;goto end; &#125;//禁止一对多 end: if(!flag)printf("Failed\n"); else &#123; for(int i=0;i&lt;l2;i++) printf("%c",f[s[i]-'A']); printf("\n"); &#125; return 0;&#125; 提高T2 Hankson的趣味题题目地址 一道奇怪的数学题。（理论上这题爆搜比正解快，数据好像不是很好）考虑唯一分解和$GCD$，$LCM$的关系。设对于一个质数$p$，其为b_1的一个因数。那么：设k_{a_0},k_{a_1},k_{b_0},k_{b_1},k_x为a_0,a_1,b_0,b_1,x中$p$的次数。则：因为k_{a_1}=\min\{k_{a_0},k_x\},k_{b_1}=\max\{k_{b_0},k_x\}，若k_{a_0}>k_{a_1}那么k_x=k_{a_1}；若k_{a_0}=k_{a_1}，那么k_x\ge k_{a_1}.若k_{b_0}]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>搜索</tag>
        <tag>数论</tag>
        <tag>其他DP</tag>
        <tag>单调队列</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2015%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2015十道题目的题解。 普及T1 金币题目地址 模拟123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int k,ans=0; scanf("%d",&amp;k); for(int i=1,j=1;i&lt;=k;i++)&#123; ans+=j; if(j*(j+1)/2==i)j++; &#125; printf("%d\n",ans); return 0;&#125; 普及T2 扫雷游戏题目地址 模拟1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,mat[105][105],dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;char s[105];void get(int x,int y)&#123; int res=0; for(int i=0;i&lt;8;i++) res+=(mat[x+dx[i]][y+dy[i]]==-1); mat[x][y]=res; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) mat[i][j]-=(s[j]=='*'); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) if(!mat[i][j])get(i,j),printf("%d",mat[i][j]); else putchar('*'); putchar('\n'); &#125; return 0;&#125; 普及T3 求和题目地址 我们挖掘条件的性质可以发现：$y$无关紧要，当$x$和$z$的奇偶性相同时，他们之间旧就会产生分数。所以每一种颜色分奇偶计数，然后一种颜色一个奇偶性产生的分数为 score=(s_4-2)\times s_1+s_2\times s_3其中$s_4$为该种颜色该种奇偶性的格子数，$s_1$为这些格子$x\times num_x$的和，$s_2$和$s_3$分别为这些格子$x$和$num_x$的和。其中$x$指编号，$num_x$指编号为$x$的格子上的数。证明过程略，可以自己手动推导。综上，这个算法的时间复杂度是$O(n+m)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define INF 2000000000#define M 10007using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,num[100005],col[100005],ans=0;int s1[100005][2],s2[100005][2],s3[100005][2],s4[100005][2];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)num[i]=read()%M; for(int i=1;i&lt;=n;i++)col[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; int c=col[i],B=i&amp;1; s1[c][B]+=i*num[i],s1[c][B]%=M; s2[c][B]+=i,s2[c][B]%=M; s3[c][B]+=num[i],s3[c][B]%=M; s4[c][B]++; &#125; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;2;j++) ans+=(s4[i][j]-2)*s1[i][j]%M, ans+=s2[i][j]*s3[i][j]%M, ans%=M; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 推销员题目地址 一道贪心。我们可以先算出总的疲劳值，然后每一次选择哪一户人家再也不去。这个时候，我们要保证减少的疲劳值最少。我们可以发现一次只有$2$种删去住户的决策：如图，$head$表示当前疲劳值消耗最小的住户编号，$last$表示最低端的住户编号，$front$是$last$前一个住户的编号。每一次可以去掉$head$，也可以去掉$last$。而去掉$last$就没必要走$front$到$last$的路了，所以第二种决策会减少$(dis[last]-dis[front])\times 2+last$需要的疲劳值。对住户的(疲劳值,编号)二元组按疲劳值排个序，然后维护以上3个量即可：$last$,$front$和$head$。注意，还需要维护每一个住户是否已经被清除，是的话要打标记，否则$head$指向的住户可能会是$last$，这样就不合法。时间复杂度：$O(nlogn)$1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define M 100005using namespace std;int dis[M],cost[M][2],ans[M],tmp[M],front,t,n,last,head;bool vis[M]=&#123;0&#125;;int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;int main()&#123; scanf("%d",&amp;n); int i; for(i=0;i&lt;n;i++) scanf("%d",&amp;dis[i]); ans[n-1]=dis[n-1]*2; for(i=0;i&lt;n;i++) scanf("%d",&amp;tmp[i]), cost[i][1]=i, cost[i][0]=tmp[i], ans[n-1]+=cost[i][0]; qsort(cost,n,sizeof(cost[0]),cmp); last=n-1,front=n-2,head=0; vis[last]=true; for(i=n-2;i&gt;=0;i--)&#123; ans[i]=ans[i+1]; while(head&lt;n&amp;&amp;(vis[cost[head][1]]))head++; t=(dis[last]-dis[front])*2+tmp[last]; if(t&lt;cost[head][0]) vis[last]=vis[front]=1, ans[i]-=t, last=front--; else vis[cost[head][1]]=1, ans[i]-=cost[head][0], head++; while(vis[front])front--; &#125; for(i=0;i&lt;n;i++) printf("%d\n",ans[i]); return 0;&#125; 提高D1T1 神奇的幻方题目地址 模拟12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int n,ans[50][50]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); int i,j,x,y; for(i=2,x=0,y=n/2,ans[x][y]=1;i&lt;=n*n;i++)&#123; if(!x)&#123; if(y==n-1)x++; else x=n-1,y++; &#125;else&#123; if(y==n-1)y=0,x--; else &#123; if(!ans[x-1][y+1]) x--,y++; else x++; &#125; &#125; ans[x][y]=i; &#125; for(i=0;i&lt;n;i++,printf("\n")) for(j=0;j&lt;n;j++,(j&lt;n)?printf(" "):0) printf("%d",ans[i][j]); return 0;&#125; 提高D1T2 信息传递题目地址 乱搞。题目：求最小环。解：爆搜/tarjan。能用tarjan是因为这里面的强连通分量只能是简单环。 DFS解法123456789101112131415161718192021222324#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int n,to[200005],vis[200005]=&#123;0&#125;,ans=INF;void dfs(int cur,int st)&#123; if(vis[cur]==-1)return ; if(vis[cur])&#123; ans=min(ans,st-vis[cur]); vis[cur]=-1; return ; &#125; vis[cur]=st; dfs(to[cur],st+1),vis[cur]=-1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;to[i]); for(int i=1;i&lt;=n;i++) dfs(to[i],1); printf("%d\n",ans); return 0; &#125; Tarjan解法12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define addedge(_u,_v) edge[cnt].v=_v,edge[cnt].next=at[_u],at[_u]=cnt,cnt++using namespace std;typedef struct &#123; int v,next;&#125;Edge;Edge edge[200105];int at[200005],VNum,mini,D=0;int dfn[200005]=&#123;0&#125;,low[200005],stack[200005],top=0;bool in[200005];void init()&#123; int i,cnt=0,a,b,t; memset(at,-1,sizeof(at)); for(i=0;i&lt;VNum;i++) scanf("%d",&amp;a),addedge(i,a-1);&#125;void tarjan_scc(int id)&#123; dfn[id]=low[id]=++D; in[id]=true;stack[top++]=id; int i=at[id],vv;while(i!=-1)&#123;vv=edge[i].v; if(!dfn[vv])tarjan_scc(vv),low[id]=min(low[id],low[vv]); else if(in[vv])low[id]=min(low[id],dfn[vv]); i=edge[i].next; &#125; if(dfn[id]==low[id])&#123; i=0; do in[stack[--top]]=false,i++; while(stack[top]!=id); if(i!=1)mini=min(mini,i); &#125;&#125;int main()&#123; scanf("%d",&amp;VNum); init(); mini=VNum; for(int i=0;i&lt;VNum;i++)if(!dfn[i])tarjan_scc(i); printf("%d\n",mini); return 0;&#125; 提高D1T3 斗地主题目地址 部分搜索。先搞掉所有顺子，然后问题转化为一个简单的最优化问题，dp可解。设$f(i,j,k,l)$为一副牌，有$i$份4张，$j$份3张，$k$份2张，$l$份1张，最少打几次。这个最开始就可以做。然后搜索即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//剪枝:出牌数递减，（牌大小递增） //贪心：5个直接搞 int n,cnt[20],ans;int f[7][9][13][24],pat[5];void dp()&#123;//与顺子无关的dp memset(f,0x3f,sizeof(f)); f[0][0][0][0]=0; int xa=n/4,xb=n/3,xc=n/2; for(int i=0;i&lt;=xa;i++) for(int j=0;j&lt;=xb;j++) for(int k=0;k&lt;=xc;k++) for(int l=0;l&lt;=n;l++)&#123; int &amp;t=f[i][j][k][l]; if(i)&#123; t=min(t,f[i-1][j][k][l]+1); if(l&gt;=2)t=min(t,f[i-1][j][k][l-2]+1); if(k&gt;=2)t=min(t,f[i-1][j][k-2][l]+1); &#125; if(j)&#123; t=min(t,f[i][j-1][k][l]+1); if(l)t=min(t,f[i][j-1][k][l-1]+1); if(k)t=min(t,f[i][j-1][k-1][l]+1); &#125; if(k)t=min(t,f[i][j][k-1][l]+1); if(l)t=min(t,f[i][j][k][l-1]+1); &#125;&#125;int small_solve()&#123; for(int i=0;i&lt;=4;i++)pat[i]=0; for(int i=0;i&lt;=13;i++)pat[cnt[i]]++; return f[pat[4]][pat[3]][pat[2]][pat[1]];&#125;void dfs(int cd,int st)&#123; if(st+1&gt;=ans&amp;&amp;cd!=0)return ; if(cd==0)&#123; ans=min(ans,st); return ; &#125; int flag=0; //只搜索顺子 for(int k=1;k&lt;=12;k++)&#123; if(cnt[k]&gt;=3)&#123; if(k&lt;=11)&#123; for(int i=k+1;i&lt;=12&amp;&amp;cnt[i]&gt;=3;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=3; dfs(cd-(i-k+1)*3,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=3; &#125; &#125; &#125; if(cnt[k]&gt;=2)&#123; if(k&lt;=10&amp;&amp;cnt[k+1]&gt;=2)&#123; for(int i=k+2;i&lt;=12&amp;&amp;cnt[i]&gt;=2;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=2; dfs(cd-(i-k+1)*2,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=2; &#125; &#125; &#125; if(cnt[k])&#123; if(k&lt;=8&amp;&amp;cnt[k+1]&amp;&amp;cnt[k+2]&amp;&amp;cnt[k+3])&#123; for(int i=k+4;i&lt;=12&amp;&amp;cnt[i];i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]--; dfs(cd-(i-k+1),st+1); for(int j=k;j&lt;=i;j++)cnt[j]++; &#125; &#125; &#125; &#125; ans=min(ans,st+small_solve());&#125;void init()&#123; ans=n; memset(cnt,0,sizeof(cnt)); int u; for(int i=1;i&lt;=n;i++)&#123; u=read(); if(!u)cnt[u]++; else if(u&lt;=2)cnt[u+11]++; else cnt[u-2]++; read(); &#125;&#125;void solve()&#123; dfs(n,0); printf("%d\n",ans);&#125;int main()&#123; int T=read(); n=read(); dp(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 提高D2T1 跳石头题目地址 看到描述就看的出是二分答案。二分答案，设为$x$，把石头排序之后扫一遍，看看是否有石头与前一个石头的间隔小于$x$，有的话拆掉该石头，否则把这个石头作为“前一个石头”，再看下一个。如果拆的次数大于$M$就判定失败，否则判定成功。时间复杂度$O(NlogL)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,m,at[50005];bool C(int x)&#123; int left=m,lst=0; for(int i=2;i&lt;=n+2;i++)&#123; if(at[i]-lst&lt;x)left--; else lst=at[i]; if(left&lt;0)return 0; &#125; return 1;&#125;void init()&#123; L=read(),n=read(),m=read(); at[1]=0,at[n+2]=L; for(int i=2;i&lt;=n+1;i++) at[i]=read(); sort(at+2,at+n+2);&#125;void solve()&#123; int l=0,r=L,mid; while(r&gt;l)&#123; mid=(l+r+1)&gt;&gt;1; if(C(mid))l=mid; else r=mid-1; &#125; printf("%d\n",l);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T2 子串题目地址 看数据范围猜算法系列时间复杂度相信各位都看的出来：$O(nmk)$怎么刻画状态呢？首先有$2$维必不可缺：$i$表示$A$前$i$个字符，$j$表示$B$前$j$个字符。这里指的是用前$i$个$A$的字符来匹配$B$的前$j$个字符，串$A$的前$i$个不一定要严格匹配，但串$B$的前$j$个必须严格匹配上。之后，段也要表示：$t$表示现在做了$t$段。看到这些段不是连续的，所以使用情况也要表示出来，设一个布尔变量$l$表示串$A$的这个字符是不是被使用了，是为$1$，不是为$0$。够了，用$f(i,j,t,l)$来表示。不使用这个字符，就继承串$A$上一位的状态。使用的话，必须匹配成功，然后有$2$个决策：开启新的一段（前一个字符没用的话就默认开启新的一段了），或者接上前一段。得到状态转移方程： f(i,j,t,0)=f(i-1,j,t,0)+f(i-1,j,t,1) \\ f(i,j,t,1)= \begin{cases} f(i-1,j-1,t,1)+f(i-1,j-1,t-1,0)+f(i-1,j-1,t-1,1) \quad (a[i]=b[j]) \\0\quad (a[i] \neq b[j]) \end{cases}初始是$f(i,0,0,0)=1$。要用滚动数组，不然MLE。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,k,dp[2][205][205][2]=&#123;0&#125;,ans=0,M=1000000007;char a[1005]=&#123;0&#125;,b[205]=&#123;0&#125;;int main()&#123; scanf("%d%d%d%s%s",&amp;n,&amp;m,&amp;k,&amp;a[1],&amp;b[1]); int i,j,o,p,t; dp[0][0][0][0]=dp[1][0][0][0]=1; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; for(o=1;o&lt;=k;o++)&#123; if(a[i]==b[j]) dp[i&amp;1][j][o][1]=(( dp[1^(i&amp;1)][j-1][o-1][0]+ dp[1^(i&amp;1)][j-1][o][1])%M+ dp[1^(i&amp;1)][j-1][o-1][1])%M; else dp[i&amp;1][j][o][1]=0; dp[i&amp;1][j][o][0]=( dp[1^(i&amp;1)][j][o][0]+// dp[1^(i&amp;1)][j][o][1])%M; &#125; &#125; &#125; printf("%d\n",(dp[n&amp;1][m][k][0]+dp[n&amp;1][m][k][1])%M); return 0;&#125; 提高D2T3 运输计划题目地址 直接求解显然很困难，考虑转化为判定性问题，二分一个答案$x$，判定他是否可行。完成一次运输的时间取决于最长路的大小，也就是保证所有路径的长度都小于$x$。考虑大于$x$的路径，在他们的公共路上删掉一段路才可以使他们一起变小。理所当然的，这段路必须是他们的公共路径中最长的一段。怎么找这条最长的公共路呢？我们可以玩一玩区间加法，给每一个在$(u,v)$两点上的路径打一个标记，这样就说明这些点在$(u,v)$路径上。如果两点的标记数都等于长度大于$x$的路径总数，呢么两点间的这段路就是他们的公共路径。区间加法有$2$种实现方式：一种是树剖/$LCT$，一种是树上差分（和序列上的没区别）。由于只需要查询一遍，没必要用什么奇奇怪怪的数据结构，所以用差分，在$x$和$y$上打一个$+1$标记，在$LCA$处打一个$-2$标记。由于是对点操作，所以要把边和点捆绑起来。具体不难实现。时间复杂度取决于求解$LCA$时所用算法的时间复杂度。用倍增的时间复杂度是$O((n+m)logn)$。注意卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXN 300005using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[MAXN*2];int n,m,par[MAXN][20]=&#123;0&#125;,dis[MAXN]=&#123;0&#125;,cnt=0,at[MAXN];int son[MAXN]=&#123;0&#125;,bro[MAXN]=&#123;0&#125;,depth[MAXN];int bus[MAXN][4],_dis[MAXN];// 0 路径长 1 _dis 到父亲的路径长 int dec[MAXN]=&#123;0&#125;,que[MAXN],f,r,sum[MAXN];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;//从大到小 &#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;int bs(int lth)&#123; int s=0,len=m,md,pos; while(len)&#123; md=s+(len&gt;&gt;1); if(lth&lt;bus[md][0]) s=md+1,len=len-(len&gt;&gt;1)-1; else len&gt;&gt;=1; &#125; return s;&#125;void _init()&#123; int i,j,h,u,v,c; f=r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; h=que[f++]; for(i=at[h];i!=-1;i=edge[i]._next)&#123; v=edge[i].v; if(v==par[h][0])continue; que[r++]=v, depth[v]=depth[h]+1, par[v][0]=h, bro[v]=son[h],son[h]=v, _dis[v]=edge[i].cost, dis[v]=dis[h]+_dis[v]; &#125; for(i=1;i&lt;=19;i++) if(par[h][i-1]) par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j; if(depth[u]&lt;depth[v]) swap(u,v); for(i=0;(1&lt;&lt;i)&lt;=depth[u]-depth[v];i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=19;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;int C(int tot)&#123; int i,j,h,maxi=0,_max=0; for(i=r-1;i&gt;=0;i--)&#123; h=que[i]; for(sum[h]=dec[h],j=son[h];j;j=bro[j]) sum[h]+=sum[j]; if(sum[h]&gt;maxi) maxi=sum[h],_max=_dis[h]; else if(sum[h]==maxi) _max=max(_max,_dis[h]); &#125; return maxi==tot?_max:0; &#125;void prepare()&#123; n=read(),m=read(); int i,j,u,v,c; memset(at,-1,sizeof(at)); for(i=0;i&lt;n-1;i++) u=read(),v=read(),c=read(), addedge(u,v,c), addedge(v,u,c); _init(); for(i=0;i&lt;m;i++) u=read(),v=read(), bus[i][1]=u,bus[i][2]=v, bus[i][3]=query(u,v), bus[i][0]=dis[u]+dis[v]-2*dis[bus[i][3]];&#125;void solve()&#123; qsort(bus,m,sizeof(bus[0]),cmp); int s=max(0,bus[m-1][0]-1001),t=bus[0][0],md,i,w; while(t-s)&#123; md=(t+s)/2; memset(dec,0,sizeof(dec)); for(i=0;i&lt;m&amp;&amp;bus[i][0]&gt;md;i++) dec[bus[i][1]]++, dec[bus[i][2]]++, dec[bus[i][3]]-=2; w=C(i); if(bus[0][0]-w&lt;=md)t=md; else s=md+1; &#125; printf("%d\n",s);&#125;int main()&#123; prepare(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>搜索</tag>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>贪心</tag>
        <tag>其他DP</tag>
        <tag>字符串DP</tag>
        <tag>LCA</tag>
        <tag>差分</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2012%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2012十道题目的题解。 普及T1 质因数分解题目地址 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); for(int i=2;i*i&lt;=n;i++) if(n%i==0)&#123; printf("%d\n",n/i); return 0; &#125; return 0;&#125; 普及T2 寻宝题目地址 模拟，时间复杂度$O(nm)$。每一层记录一下有楼梯的房间数，找房间用一个循环实现。1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,sum=0,p=20123,at[10005][105][2],access[10005]=&#123;0&#125;,st;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int tmp=0,lf; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; scanf("%d%d",&amp;at[i][j][0],&amp;at[i][j][1]); if(at[i][j][0])access[i]++; &#125; scanf("%d",&amp;st); for(int i=0;i&lt;n;i++)&#123; lf=at[i][st][1]; sum+=lf,lf%=access[i],tmp=st; if(!lf)lf=access[i]; for(;;)&#123; if(at[i][tmp][0])lf--; if(!lf)break; tmp=(tmp+1)%m; &#125; st=tmp,sum%=p; &#125; printf("%d\n",sum); return 0;&#125; 普及T3 摆花题目地址 很容易看出来这是一个$DP$。设$f(i,j)$为摆到第i种花，共有$j$盆的方案数。那么 f(i,j)=\sum_{k=0}^{\min(j,a[i])}f(i-1,j-k)时间复杂度：$O(nm^2)$。12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;int n,m,a[105],dp[105][105]=&#123;0&#125;,p=1000007;int main()&#123; int i,j,k; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(i=0;i&lt;=a[0];i++) dp[1][i]=1; for(i=2;i&lt;=n;i++) for(j=0;j&lt;=m;j++) for(k=0;k&lt;=a[i-1];k++) if(j-k&gt;=0)dp[i][j]+=dp[i-1][j-k],dp[i][j]%=p; else break; printf("%d\n",dp[n][m]); return 0;&#125; 普及T4 文化之旅题目地址 错误方法不正确，但却能快速通过本题的方法是$SPFA$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 1000000000using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[20005];int cnt=0,at[105],n,k,m,s,t;int que[10005][105],f,r,c[105],mat[105][105],d[105],in[105]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125;void spfa_bfs()&#123; fill(d+1,d+n+1,INF); d[s]=0; que[r][0]=s,que[r++][c[s]]=1,in[s]=1; int i,_u,_v,_co,j,ok,cul; while(r-f)&#123; _u=que[f++][0],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost,cul=c[_v]; for(ok=1,j=1;j&lt;=k;j++) if(mat[cul][que[f-1][j]])&#123; ok=0;break; &#125; if(!ok)continue; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r][0]=_v; for(j=1;j&lt;=k;j++) que[r][j]=que[f-1][j]; r++; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;k,&amp;m,&amp;s,&amp;t); int i,j,u,v,_c; for(i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(i=1;i&lt;=k;i++) for(j=1;j&lt;=k;j++) scanf("%d",&amp;mat[i][j]); memset(at,-1,sizeof(at)); for(i=0;i&lt;m;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;_c), addedge(u,v,_c), addedge(v,u,_c); spfa_bfs(); printf("%d\n",d[t]&gt;=INF-100?-1:d[t]); return 0;&#125; 正解正解是搜索。考虑使用高效算法进行优化，那么先以$T$为起点跑$SPFA$，然后从起点搜索的时候，如果不考虑文化的容斥关系都有“当前点到$T$最短路长$+$当前已走距离$\ge ans$”的话就停止搜索。用$DFS$，跑的还比较快。upd:上述的做法是正确的，但是这题数据很恶，所以要调整搜索顺序，倒着搜。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int to[20005],at[105],nex[20005],cnt=0;int V,E,K,S,T,mat[105][105],c[105],dis[105][105];int que[10005],f,r,dist[105],in[105];int vis[105],ans=1000000000;void spfa()&#123; fill(dist+1,dist+V+1,INF); f=r=0,que[r++]=S,in[S]=1,dist[S]=0; int h,v; while(r&gt;f)&#123; h=que[f++],in[h]=0; for(int i=at[h];i;i=nex[i])&#123; v=to[i]; if(dist[v]&gt;dist[h]+dis[h][v])&#123; dist[v]=dist[h]+dis[h][v]; if(!in[v]) in[v]=1,que[r++]=v; &#125; &#125; &#125;&#125;void dfs(int cur,int d)&#123; if(cur==S)&#123; ans=min(ans,d); return ; &#125; if(d+dist[cur]&gt;=ans)return ; vis[c[cur]]=1; for(int i=at[cur];i;i=nex[i])&#123; int v=to[i],flag=0; if(vis[c[v]])continue; for(int j=1;j&lt;=K;j++) if(vis[j]&amp;&amp;mat[c[v]][j])&#123; flag=1; break; &#125; if(flag)continue; dfs(v,d+dis[cur][v]); &#125; vis[c[cur]]=0;&#125; void init()&#123; V=read(),K=read(),E=read(),S=read(),T=read(); for(int i=1;i&lt;=V;i++)c[i]=read(); for(int i=1;i&lt;=K;i++) for(int j=1;j&lt;=K;j++) mat[i][j]=read(); for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) dis[i][j]=INF; for(int i=1;i&lt;=E;i++)&#123; int u=read(),v=read(),co=read(); if(dis[u][v]&lt;co)continue; dis[u][v]=dis[v][u]=co; to[++cnt]=v,nex[cnt]=at[u],at[u]=cnt; to[++cnt]=u,nex[cnt]=at[v],at[v]=cnt; &#125; spfa();&#125;void solve()&#123; dfs(T,0); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 Vigenère密码题目地址 这个加密运算其实就是循环移位。密文是循环进位，我们倒着做就行了。12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char key[1005],tex[1005];int get(char a,char b)&#123; return (b-'a'-(a-'a')+26)%26;&#125;int main()&#123; scanf("%s%s",key,tex); int l1=strlen(key),l2=strlen(tex); for(int i=0;i&lt;l1;i++) key[i]=tolower(key[i]); for(int i=0;i&lt;l2;i++)&#123; if(isupper(tex[i])) putchar('A'+get(key[i%l1],tolower(tex[i]))); else putchar('a'+get(key[i%l1],tex[i])); &#125; return 0; &#125; 提高D1T2 国王游戏题目地址 考虑第$i$和第$i+1$个人，他们手上的数字分别为a_i,b_i,a_{i+1},b_{i+1}，第$i+1$个人站在第$i$个人身后。设第$i$个人前面所有人左手数字的积为$T$，那么这两个人拿到的金币数分别为\lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor如果两人交换顺序，那么两人拿到的金币数分别为\lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor为了让获得最多金币的人得到的金币尽量少，我们就需要根据\max \left \{ \lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor\right\}和\max \left \{ \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor\right\}判断是否该让两个人交换顺序。如果交换了顺序使得取得的$max$更小，那么就需要交换。而根据归纳法，对每一对人按这种方法排一个序，就可以求出正确的答案。此时排序的时间复杂度为$O(n^2)$。但仔细观察可以发现，\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor > \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor>\lfloor \frac{T}{b_i}\rfloor。因此只需要确定了\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor和\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor的大小关系，就可以根据不等号的传递性判断哪一种顺序产生的最大值更小。而对上面两个式子变形，消去$T$并且移项便可以发现：只要比较a_ib_i和a_{i+1}b_{i+1}的大小就可判断。于是可以以a_ib_i为关键字排序，来确定整个队伍的顺序。此时，时间复杂度为$O(nlogn+$高精度运算需要的时间$)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; using namespace std;typedef long long ll;struct P&#123; int a,b,t;&#125;;bool operator&lt;(const P &amp;u,const P &amp;v)&#123; return (u.t&lt;v.t);&#125;P p[1005];int d1[3]=&#123;0&#125;,d2[5000]=&#123;0&#125;,d3[5000],ans[5000]=&#123;0&#125;,n;void mul(int s1[],int s2[],int to[])&#123; to[0]=s1[0]+s2[0]; for(int i=1;i&lt;=s1[0];i++)&#123; int x=0; for(int j=1;j&lt;=s2[0];j++) x=s1[i]*s2[j]+x+to[i+j-1],to[i+j-1]=x%10000,x/=10000; to[i+s2[0]]=x; &#125; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void div(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=s1[0];i&gt;=1;i--) to[i]=(x*10000+s1[i])/s2,x=x*10000+s1[i]-to[i]*s2; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;int smaller(int n1[],int n2[])&#123;//&lt;0 ：小于 if(n1[0]!=n2[0])return n1[0]-n2[0]; else&#123; for(int i=n1[0];i&gt;=1;i--) if(n1[i]!=n2[i])return n1[i]-n2[i]; return 0; &#125;&#125;void output(int s[])&#123; printf("%d",s[s[0]]); for(int i=s[0]-1;i&gt;=1;i--) printf("%04d",s[i]); printf("\n");&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;=n;i++) scanf("%d%d",&amp;p[i].a,&amp;p[i].b),p[i].t=p[i].a*p[i].b; sort(p+1,p+1+n); d1[0]=d2[0]=d2[1]=1; for(int i=0;i&lt;n;i++)&#123; memset(d3,0,sizeof(d3)); d1[1]=p[i].a,mul(d1,d2,d3),memcpy(d2,d3,sizeof(d3)); div(d2,p[i+1].b,d3); if(smaller(ans,d3)&lt;0) memcpy(ans,d3,sizeof(d3)); &#125; output(ans); return 0;&#125; 提高D1T3 开车旅行题目地址 倍增。倍增出小A小B经过$2^k$个回合的情况，然后找最近的最小值用排序+双向链表或者$BST$即可。时间复杂度：$O((n+m)logn)$。边界的一些处理比较烦，需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2100000000using namespace std;typedef long long ll;int high[100005][2],_h[100005][2],lf[100005],rt[100005],n,lg,X,S;ll dis[100005][4],_dis[100005][18][4];//dis [0] 小A开距离 [1]小A开到 [2]小B开距离 [3]小B开到//_dis[i][j]过2^j个回合 [0]小a开距离 [1]小b开距离 [2]开到 [3]总路程 int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;void init()&#123; int i,j,lis[4],m1[2],m2[2],d; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;high[i][0]), high[i][1]=i; memcpy(_h,high,sizeof(high)); qsort(_h,n,sizeof(_h[0]),cmp); lf[_h[0][1]]=-1; for(i=1;i&lt;n;i++) lf[_h[i][1]]=_h[i-1][1]; rt[_h[n-1][1]]=-1; for(i=0;i&lt;n-1;i++) rt[_h[i][1]]=_h[i+1][1]; for(i=0;i&lt;n;i++)&#123; lis[0]=lf[i],lis[1]=rt[i]; lis[2]=(lf[i]&lt;0)?-1:lf[lis[0]]; lis[3]=(rt[i]&lt;0)?-1:rt[lis[1]]; m1[0]=m2[0]=INF; m1[1]=m2[1]=-1; //m1：最小 m2：第二小 [0]距离 [1]位置 for(j=0;j&lt;4;j++) if(lis[j]&gt;=0)&#123; d=abs(high[lis[j]][0]-high[i][0]); if(d&lt;m1[0]||(d==m1[0]&amp;&amp;high[lis[j]][0]&lt;high[m1[1]][0]))//lis[j]的海拔低 m2[0]=m1[0],m2[1]=m1[1], m1[0]=d,m1[1]=lis[j]; else if(d&lt;m2[0]||(d==m2[0]&amp;&amp;high[lis[j]][0]&lt;high[m2[1]][0])) m2[0]=d,m2[1]=lis[j]; &#125; if(m2[0]&gt;=INF)m2[0]=0; if(m1[0]&gt;=INF)m1[0]=0; dis[i][0]=m2[0], dis[i][1]=m2[1], dis[i][2]=m1[0], dis[i][3]=m1[1]; if(rt[i]&gt;=0)lf[rt[i]]=lf[i]; if(lf[i]&gt;=0)rt[lf[i]]=rt[i];//自我删除 &#125; for(i=1,d=0;i&lt;n;i&lt;&lt;=1,d++); lg=d; for(i=0;i&lt;n;i++)&#123; _dis[i][0][0]=dis[i][0]; if(dis[i][1]&gt;=0) _dis[i][0][1]=dis[dis[i][1]][2], _dis[i][0][2]=dis[dis[i][1]][3]; else _dis[i][0][1]=0,_dis[i][0][2]=-1; _dis[i][0][3]=_dis[i][0][0]+_dis[i][0][1]; &#125; for(j=1;j&lt;=lg;j++) for(i=0;i&lt;n;i++)&#123; _dis[i][j][0]=_dis[i][j-1][0], _dis[i][j][1]=_dis[i][j-1][1]; if(_dis[i][j-1][2]&gt;=0)//目的地存在 _dis[i][j][0]+=_dis[_dis[i][j-1][2]][j-1][0], _dis[i][j][1]+=_dis[_dis[i][j-1][2]][j-1][1], _dis[i][j][2]=_dis[_dis[i][j-1][2]][j-1][2]; else _dis[i][j][2]=-1; _dis[i][j][3]=_dis[i][j][0]+_dis[i][j][1]; &#125;&#125;void ask(int id,int &amp;a,int &amp;b)&#123; int i; for(i=lg;i&gt;=0;i-- ) if(_dis[id][i][3]+a+b&lt;=X&amp;&amp;_dis[id][i][2]&gt;=0)&#123; a+=_dis[id][i][0], b+=_dis[id][i][1], ask(_dis[id][i][2],a,b); break; &#125; if(i&lt;0) for(i=0;i&lt;=lg;i++) if(_dis[id][i][0]+a+b&lt;=X)&#123; a+=_dis[id][i][0]; break; &#125;&#125;void solve1()&#123; int i,_d[2],d_[2],ans; double bi=1e12,t1,t2; scanf("%d",&amp;X); for(i=0;i&lt;n;i++)&#123; d_[0]=d_[1]=0; ask(i,d_[0],d_[1]); t1=d_[0],t2=d_[1]; if(!t2)t1=1e11; else t1/=t2; if(bi&gt;t1||(abs(bi-t1)&lt;0.0000001&amp;&amp;high[i][0]&gt;high[ans][0])) bi=t1,_d[0]=d_[0],_d[1]=d_[1],ans=i; &#125; printf("%d\n",ans+1); &#125;void solve2()&#123; int m,i,u,v; scanf("%d",&amp;m); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;S,&amp;X), u=0,v=0, ask(S-1,u,v), printf("%d %d\n",u,v);&#125;int main()&#123; init(); solve1(); solve2(); return 0;&#125; 提高D2T1 同余方程题目地址 就是让你求一个逆元。用快速幂+欧拉函数或者扩欧都行。我只写了扩欧，但是前者应该好写一点。时间复杂度：$O(logn)$12345678910111213141516171819#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; ll d=a; if(b)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125;else x=1,y=0; return d; &#125;int main()&#123; ll a,m,x,y; scanf("%lld%lld",&amp;a,&amp;m); extgcd(a,m,x,y); x=(x%m+m)%m; printf("%lld\n",x); return 0; &#125; 提高D2T2 借教室题目地址 方法一维护一种数据结构，它支持:1.区间减法2.检查最小值的正负性线段树即可。这种方法常数很大。时间复杂度：$O((n+m)logn)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int seg[2200000],tag[2200000]=&#123;0&#125;;int n,size,_a,_b,m,rec[3][1000005],_v;int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar(); return x;&#125;void pushdown(int id)&#123; if(tag[id]&amp;&amp;id&lt;size) tag[id&lt;&lt;1]+=tag[id],tag[id&lt;&lt;1|1]+=tag[id], seg[id&lt;&lt;1]+=tag[id],seg[id&lt;&lt;1|1]+=tag[id], tag[id]=0; &#125;void init()&#123; int i; for(size=1;size&lt;n;size&lt;&lt;=1); for(i=size;i-size&lt;n;i++)seg[i]=read(); for(;i&lt;(size&lt;&lt;1);i++)seg[i]=INF; for(i=size-1;i&gt;=1;i--) seg[i]=min(seg[i&lt;&lt;1],seg[i&lt;&lt;1|1]);&#125;void minus(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(_a&lt;=l&amp;&amp;r&lt;=_b)&#123; tag[id]+=_v,seg[id]+=_v; return ; &#125; pushdown(id); minus(id&lt;&lt;1,l,(l+r)&gt;&gt;1); minus(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); seg[id]=min(seg[id&lt;&lt;1],seg[id&lt;&lt;1|1]);&#125;int solve()&#123; for(int i=0;i&lt;m;i++)&#123; _v=-rec[0][i],_a=rec[1][i],_b=rec[2][i], minus(1,1,size); if(seg[1]&lt;0)return i+1; &#125; return -1;&#125;int main()&#123; n=read(),m=read(); init(); for(int i=0;i&lt;m;i++) rec[0][i]=read(),rec[1][i]=read(),rec[2][i]=read(); int ans=solve(); if(ans&lt;0)printf("0\n"); else printf("-1\n%d\n",ans); return 0;&#125; 方法二我们发现随着订单的增多，可用教室的数量是只减不增的，所以我们尝试二分。二分一个最大订单量，然后区间减法用差分实现，最后扫一遍，看看是否存在负值即可。（差分：假设我们有一个数列:a_1,a_2,a_3,...,a_n 定义它的差分数列是a_1,a_2-a_1,a_3-a_2,...a_n-a_{n-1} 这样可以发现差分数列中前$n$个元素的和就是原来数列当前位置元素的值。然后为什么说他可以用来做区间减法呢？比方有$5$个数，$a_1,a_2,a_3,a_4,a_5$，差分数列就是$a_1,a_2-a_1,a_3-a_2,a_4-a_3,a_5-a_4$，然后第$2$到$4$个每一个减掉$p$，那么原数列就是 a_1,a_2-p,a_3-p,a_4-p,a_5新的差分数列就是 a_1,a_2-a_1-p,a_3-a_2,a_4-a_3,a_5-a_4+p可以发现，本来要修改多个元素，在差分数列里就只要修改$2$个元素。由于我们只要在处理完所有区间操作后再扫一遍查询负数，所以这么做能满足我们的需求。时间复杂度：$O((n+m)logn)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,d[N],q[N],s[N],e[N];int oold,nnew;void update()&#123; if(nnew&gt;oold)&#123; for(int i=oold+1;i&lt;=nnew;i++) d[s[i]]-=q[i],d[e[i]+1]+=q[i]; &#125;else&#123; for(int i=oold;i&gt;nnew;i--) d[s[i]]+=q[i],d[e[i]+1]-=q[i]; &#125;&#125;bool C()&#123; int flag=0,sum=0; update(); for(int i=1;i&lt;=n;i++)&#123; sum+=d[i]; if(sum&lt;0)&#123; flag=1; break; &#125; &#125; return flag;&#125;void init()&#123; n=read(),m=read(); int lst=read(); d[1]=lst; for(int i=2;i&lt;=n;i++) d[i]=read(),d[i]-=lst,lst+=d[i]; d[n+1]=-lst; for(int i=1;i&lt;=m;i++) q[i]=read(),s[i]=read(),e[i]=read();&#125;void solve()&#123; int L=1,R=m; oold=0; while(R&gt;L)&#123; nnew=(L+R)&gt;&gt;1; if(C())R=nnew; else L=nnew+1; oold=nnew; &#125; if(L==m)printf("0\n"); else printf("-1\n%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T3 疫情控制题目地址 容易发现时间越多，控制疫情的任务越有可能完成。所以先二分一个答案$x$，然后判断它可不可行。显然，一个军队走的越高，他能控制的就越多，所以让军队尽量向上走，直到走到根或者时间不够为止。如果可以走到根就记录一下走到根的时候剩余的时间，走不到就给最后到的点打一个标记，这个向上走可以用倍增实现。还可以发现的是，与根直接相连的点很重要，我们称呼他们为关键点，只要全部控制了他们就完成了任务。而判断一个关键点是否被控制可以用一遍$DFS$实现。对于没被控制的关键点，我们把他们到根的路径长记录下来。我们要让可以到根的军队发配到相应的关键点，并且使得这个分配尽可能合理。怎么做呢？考虑贪心，让剩余时间少的军队去占领最近的关键点，时间多的去占领远的。所以给军队剩余时间和关键点的距离分别排序，做一个贪心即可。注意，如果当前扫到的军队无法前往最近的关键点，那就让他回到他之前到根的路上经过的关键点。这样可以最大程度的利用军队。综上，我们在$O(nlogn+mlognlogw)$的时间复杂度内完成了本题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 10000000000000ll#define LOG 17using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P left[50005],city[50005];int to[100005],nex[100005],at[50005],cnt=0;int n,m,p[100005],par[50005][20],secfa[50005];int cost[100005],depth[50005],maxd=0,dis[50005][20];int tot=0,totc=0;bool vis[50005];int query(int u,int t)&#123; if(depth[u]&lt;=t)return 1; for(int i=LOG;i&gt;=0;i--) if(par[u][i]&amp;&amp;dis[u][i]&lt;=t) t-=dis[u][i],u=par[u][i]; return u;&#125;void dfs2(int cur,int fa)&#123; if(vis[cur])return ; bool flag=1,isleaf=1; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; dfs2(to[i],cur),flag&amp;=vis[to[i]]; isleaf=0; &#125; if(!isleaf)vis[cur]=flag;&#125;bool C(int x)&#123; tot=totc=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=m;i++)&#123; int goal=query(p[i],x); if(goal==1)left[++tot].first=x-depth[p[i]],left[tot].second=p[i]; else vis[goal]=1; //打标记 &#125; dfs2(1,0); if(vis[1])return 1;//根节点的子树全部被覆盖了 for(int i=at[1];i;i=nex[i]) if(!vis[to[i]])city[++totc].second=to[i],city[totc].first=cost[i]; sort(left+1,left+tot+1); sort(city+1,city+totc+1); int r=1,fr; for(int i=1;r&lt;=totc&amp;&amp;i&lt;=tot;i++)&#123; fr=left[i].second; if(left[i].first&lt;city[r].first)&#123; vis[secfa[fr]]=1; &#125;else&#123; vis[city[r].second]=1,r++; &#125; while(vis[city[r].second]&amp;&amp;r&lt;=totc)r++; &#125; if(r==totc+1)return 1; return 0;&#125;void addedge(int _u,int _v,int _c)&#123; to[++cnt]=_v,cost[cnt]=_c,nex[cnt]=at[_u],at[_u]=cnt;&#125;void dfs(int cur,int fa)&#123; par[cur][0]=fa,maxd=max(maxd,depth[cur]); for(int j=1;j&lt;=LOG;j++) if(par[cur][j-1]) par[cur][j]=par[par[cur][j-1]][j-1], dis[cur][j]=dis[cur][j-1]+dis[par[cur][j-1]][j-1]; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; int _v=to[i],_c=cost[i]; depth[_v]=depth[cur]+_c, dis[_v][0]=_c; if(cur==1)secfa[_v]=_v; else secfa[_v]=secfa[cur]; dfs(_v,cur); &#125;&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); m=read(); for(int i=1;i&lt;=m;i++)p[i]=read(); dfs(1,0);&#125;void solve()&#123; int son=0; for(int i=at[1];i;i=nex[i])son++; if(son&gt;m)&#123; printf("-1\n"); return ; &#125; int L=0,R=2*maxd,M; while(R&gt;L)&#123; M=(L+R)&gt;&gt;1; if(C(M))R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>搜索</tag>
        <tag>数论</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
        <tag>其他DP</tag>
        <tag>SPFA</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2011%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2011十道题目的题解。 普及T1 数字反转题目地址 模拟123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;char num[15];int main()&#123; scanf("%s",num); int f=(num[0]=='-'),len=strlen(num),cur=0; reverse(num,num+len); while(num[cur]=='0')cur++; if(f)putchar('-'); if(!num[cur]||num[cur]=='-')printf("0\n"); else&#123; while(isdigit(num[cur]))putchar(num[cur]),cur++; &#125; return 0;&#125; 普及T2 统计单词数题目地址 本题不需要使用字符串匹配的高级算法，模拟即可。注意单词必须完全匹配，即匹配时两个单词长度要一样。123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;char w[20],s[1000005];int ans1=-1,ans2=0,l1,l2;bool judge(int t)&#123; for(int i=0;i&lt;l1;i++) if(w[i]!=s[t+i])return 0; if(t+l1==l2||s[t+l1]==' ')return 1; return 0;&#125;int main()&#123; scanf("%s",w); while(getchar()!='\n'); fgets(s,1000003,stdin); l1=strlen(w),l2=strlen(s); for(int i=0;i&lt;l1;i++)if(isupper(w[i]))w[i]+='a'-'A'; for(int i=0;i&lt;l2;i++)if(isupper(s[i]))s[i]+='a'-'A'; for(int i=0;i&lt;l2;i++) if(s[i]!=' '&amp;&amp;(!i||s[i-1]==' ')&amp;&amp;i+l1-1&lt;l2) if(judge(i))&#123; if(ans1&lt;0)ans1=i; ans2++; &#125; if(ans1&lt;0)printf("%d\n",ans1); else printf("%d %d\n",ans2,ans1); return 0;&#125; 普及T3 瑞士轮题目地址 模拟+归并。直接模拟的话是$O(nqlogn)$的时间复杂度，会超时。发现每次比完赛之后赢的人和输的人各自的相对排名不变，所以将胜者和败者归并起来，时间复杂度为$O(nq)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[200005],pp[200005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,r,q,w[200005],q1[200005],q2[200005],r1,r2;//q1胜者 q2败者 void Merge()&#123; int tot=0,lb=1,rb=1; while(lb&lt;=r1&amp;&amp;rb&lt;=r2)&#123; int L=q1[lb],R=q2[rb]; if(p[L]&lt;p[R])pp[++tot]=p[L],lb++; else pp[++tot]=p[R],rb++; &#125; while(lb&lt;=r1)pp[++tot]=p[q1[lb]],lb++; while(rb&lt;=r2)pp[++tot]=p[q2[rb]],rb++; memcpy(p+1,pp+1,sizeof(P)*n);&#125;void init()&#123; n=read()&lt;&lt;1,r=read(),q=read(); for(int i=1;i&lt;=n;i++) p[i].first=-read(),p[i].second=i; for(int i=1;i&lt;=n;i++)w[i]=read(); sort(p+1,p+n+1); &#125;void solve()&#123; while(r--)&#123; r1=r2=0; for(int i=1;i&lt;=n;i+=2)&#123; q1[++r1]=i,q2[++r2]=i+1; if(w[p[i].second]&lt;w[p[i+1].second]) swap(q1[r1],q2[r2]),p[i+1].first--; else p[i].first--; &#125; Merge(); &#125; printf("%d\n",p[q].second);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 表达式的值题目地址 $DP$。实际上那两个运算就是与和或，所以直接用栈来模拟一下运算过程即可。按运算数来$DP$，记录一下当前编号为$id$的运算数取$0$和$1$时的方案数，这样做法就比较显然了，在模拟的时候计数即可。时间复杂度为$O(n)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;int s1[100005][2]=&#123;0&#125;,s2[100005]=&#123;0&#125;,t1=0,t2=0,pro[300],lim,M=10007;char _exp[100005];void opr()&#123; int a1,a2,b1,b2,o; a1=s1[--t1][0],a2=s1[t1][1], b1=s1[--t1][0],b2=s1[t1][1], o=s2[--t2]; if(o=='+') s1[t1][0]=(a1*b1)%M, s1[t1++][1]=(a1*b2+a2*b1+a2*b2)%M; if(o=='*')&#123; s1[t1][1]=(a2*b2)%M, s1[t1++][0]=(a1*b1+a1*b2+a2*b1)%M; &#125;&#125;void calc()&#123; int i,j; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='(') s2[t2++]='('; else if(_exp[i]==')')&#123; while(s2[t2-1]!='(') opr(); t2--; &#125;else&#123; if(_exp[i-1]!=')') s1[t1][0]=1, s1[t1++][1]=1; while(t2&amp;&amp;s2[t2-1]!='('&amp;&amp; pro[s2[t2-1]]&gt;=pro[_exp[i]]) opr(); s2[t2++]=_exp[i]; if(_exp[i+1]==')') s1[t1][0]=1, s1[t1++][1]=1; &#125; &#125;&#125;void init()&#123; pro['+']=1,pro['*']=2; scanf("%d%s",&amp;lim,&amp;_exp[1]); lim++; _exp[0]='('; _exp[lim++]=')';&#125;void solve()&#123; calc(); printf("%d\n",s1[0][0]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 铺地毯题目地址 模拟即可。注意判断矩形和无解条件。1234567891011121314#include &lt;bits/stdc++.h&gt;int x[10002],y[10002],l[10002],w[10002],n,dx,dy;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d%d%d",&amp;x[i],&amp;y[i],&amp;l[i],&amp;w[i]); scanf("%d%d",&amp;dx,&amp;dy); int at=-1; for(int i=0;i&lt;n;i++) if((dx&lt;=x[i]+l[i]&amp;&amp;dx&gt;=x[i])&amp;&amp;(dy&lt;=y[i]+w[i]&amp;&amp;dy&gt;=y[i])) at=i+1; printf("%d\n",at); return 0;&#125; 提高D1T2 选择客栈（待考察）题目地址 直接枚举是$O(n^2)$的，不够优秀。考虑这么一种做法：我们分颜色考虑，对于一种颜色$col$，用某个数据结构按距离从大到小存一 下客栈的编号（其实从小到大还是从大到小不重要），然后按顺序枚举每一个客栈，统计一下它的贡献。（也就是有几种方案，他被住下了）贡献怎么算呢？我们画个图 $cur$表示我们找到的离当前枚举到的客栈最近的合法（指最低消费$\le p$）客栈的编号，那么由乘法原理，这个时候$cur$左边的颜色为$col$的客栈数乘上右边颜色为$col$的客栈数就是可行的贡献。诶，刚才不是说算每一个客栈的贡献么？对的。这里由于$cur$右边的$col$颜色客栈之间没有合法客栈，所以把右边的一起算。这里还有一个问题：如果$cur$的颜色是$col$怎么办？如果$cur$右边的客栈全被统计过了，就把他划分到右边，否则划分到左边，这样可以保证正确性。计算完后继续看下一个客栈，这里有一个优化：如果客栈编号大于$cur$就直接跳过，因为他的贡献算过了。综上，使用以上算法的时间复杂度为$O(nk)$。由于数据的原因，实际时间复杂度远小于该值。本题还存在一个时间复杂度仅为$O(n)$的算法，可根据以上算法优化而来，各位不妨自行思考。提示：如果我们边读入数据，边动态更新$cur$会怎么样呢？123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,p,col[200005],cost[200005];int at[55],id[200005],nex[200005],cnt=0,tot[55];void init()&#123; n=read(),k=read(),p=read(); for(int i=1;i&lt;=n;i++)&#123; col[i]=read(),cost[i]=read(); id[++cnt]=i,nex[cnt]=at[col[i]],at[col[i]]=cnt,tot[col[i]]++; &#125; //链式前向星 &#125;void solve()&#123; int ans=0; for(int i=0;i&lt;k;i++)&#123; if(!at[i])continue ; int lf=tot[i],cur=id[at[i]]+1; //lf 左端 rt 右端 for(int j=at[i];j;j=nex[j])&#123; if(id[j]&gt;cur)continue;//优化，该客栈被统计过就跳过 int rt=0;//一开始cur右边没被统计过的客栈数是0 for(cur=id[j];cur&amp;&amp;cost[cur]&gt;p;cur--)//更新cur if(col[cur]==i)rt++,lf--;//遇到一个客栈在cur右边 if(!cur)break;//找不到这样的合法客栈 if(col[cur]==i&amp;&amp;!rt)rt=1,lf--;//对应右边无客栈被统计的情况 ans+=rt*lf;//计算贡献 &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T3 Mayan游戏题目地址 本题模拟的成分远大于搜索。由于步数已经确定，所以只要采用最简单的$DFS$即可求出结果。当然，我们需要一些必要的剪枝和优化： 列表内容最优化剪枝：按照$x,y$的顺序遍历方块，保证第一个找到的可行方案一定是最优方案。 最优化剪枝：只有当左边是空的时候才左移，否则等价于左边的右移。 最优化剪枝：不移动同色方块。 可行性剪枝：有某种方块个数$\le 2$直接退出，因为不可能消除。 程序上的优化：用$2$个队列处理事件，一个处理掉落，一个处理消除。这样就可以跑的非常快了。理论上还可以加一个估价的优化，就是通过同色方块的连接情况判断至少还要走几步，但实际上以上的优化已经足够了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//交换2个方块后要处理影响//1.掉落 2.消除 //可行性剪枝：同颜色&lt;=2个退出//设置一个掉落队列和一个事件队列//事件队列检查是否有可以消除的方块，有的话就把最上面一层得上一个加入掉落队列 //在掉落队列里检查上方是否有方块，有的话将上方的方块下降后全部加入事件队列 //两者需要交替进行。int pz[10][5][7];int n,ans[10][3],movement[10][3],cnt[11],flag=0;int dque[10005][2],dr,df;//掉落队列 int eque[10005][2],er,ef;//事件队列 int visx[10],visy[10],vis[5][7];void solve_clear(int cur)&#123; int dx,dy,col,len; for(int i=0;i&lt;5;i++)visx[i]=0; for(int i=0;i&lt;7;i++)visy[i]=0; memset(vis,0,sizeof(vis)); while(er&gt;ef)&#123; dx=eque[ef][0],dy=eque[ef++][1]; if(!visx[dx])&#123;//同一个x visx[dx]=1; col=pz[cur][dx][0],len=1; for(int i=1;i&lt;7;i++)&#123; if(pz[cur][dx][i]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[dx][j]=1; &#125; col=pz[cur][dx][i],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=6;7-j&lt;=len;j--)vis[dx][j]=1; &#125; &#125; if(!visy[dy])&#123; visy[dy]=1; col=pz[cur][0][dy],len=1; for(int i=1;i&lt;5;i++)&#123; if(pz[cur][i][dy]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[j][dy]=1; &#125; col=pz[cur][i][dy],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=4;5-j&lt;=len;j--)vis[j][dy]=1; &#125; &#125; &#125; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) if(vis[i][j])&#123; pz[cur][i][j]=0; if(j!=6) dque[dr][0]=i,dque[dr++][1]=j+1; &#125; &#125;void solve_drop(int cur)&#123; int dx,dy,des; while(dr&gt;df)&#123; dx=dque[df][0],dy=dque[df++][1]; for(des=dy-1;des&gt;=0&amp;&amp;!pz[cur][dx][des];des--); des++; for(int i=dy;i&lt;7;i++) if(pz[cur][dx][i]) pz[cur][dx][des++]=pz[cur][dx][i], eque[er][0]=dx,eque[er++][1]=des-1; for(int i=des;i&lt;7;i++) pz[cur][dx][i]=0; &#125;&#125;void dfs(int cur)&#123; if(flag)return ; if(cur==n)&#123; for(int i=0;i&lt;5;i++) if(pz[cur][i][0])return ; memcpy(ans,movement,sizeof(ans)); flag=1; return ; &#125; for(int i=1;i&lt;=10;i++)cnt[i]=0; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) cnt[pz[cur][i][j]]++; for(int i=1;i&lt;=10;i++) if(cnt[i]&amp;&amp;cnt[i]&lt;3)return ; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(!pz[cur][i][j])continue; if(i!=4&amp;&amp;pz[cur][i+1][j]!=pz[cur][i][j])&#123; //向右移动 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i+1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i+1,dque[dr++][1]=j; while(dr&gt;df) solve_drop(cur+1),solve_clear(cur+1); movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=1; dfs(cur+1); &#125; if(i&amp;&amp;!pz[cur][i-1][j]&amp;&amp;pz[cur][i-1][j]!=pz[cur][i][j])&#123;//向左边 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i-1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i-1,dque[dr++][1]=j; while(dr&gt;df)&#123; solve_drop(cur+1),solve_clear(cur+1); &#125; movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=-1; dfs(cur+1); &#125; &#125; &#125;&#125;void init()&#123; n=read(); int t; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;8;j++)&#123; t=read(); if(!t)break; pz[0][i][j]=t; &#125;&#125;void solve()&#123; dfs(0); if(!flag)printf("-1\n"); else &#123; for(int i=0;i&lt;n;i++) printf("%d %d %d\n",ans[i][0],ans[i][1],ans[i][2]); &#125;&#125;int main()&#123; freopen("a.in","r",stdin); init(); solve(); return 0;&#125; 提高D2T1 计算系数题目地址 套用二项式定理和组合数取模即可。$x^ny^m$的系数是$C_n^k \times a^n\times b^m$。时间复杂度：$O(k^2)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define M 10007using namespace std; int dp[1005]=&#123;0&#125;,a,b,k,m,n,ans; int Pow(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125;return res;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;k,&amp;n,&amp;m); a%=M,b%=M,dp[0]=1; for(int i=1;i&lt;=k;i++) for(int j=i;j&gt;=1;j--) dp[j]+=dp[j-1],dp[j]%=M; //计算组合数 ans=(dp[n]*Pow(a,n))%M, ans=(ans*Pow(b,m))%M; printf("%d\n",ans); return 0; &#125; 提高D2T2 聪明的质监员题目地址 较为明显的二分。二分一个$x$，然后扫一遍表，看看哪些$w$大于等于$x$，然后用前缀和存一下符合条件的$w$前缀和与$w$的数量前缀和，最后$m$个区间算一遍加起来即可。时间复杂度：$O((n+m)logn)$123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;ll S,tot,v[200005],ans,sum[200005],cnt[200005];int w[200005],n,m,ev[200005][2];void solve(int r)&#123; int i; sum[0]=cnt[0]=0; for(i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1], cnt[i]=cnt[i-1]; if(w[i-1]&gt;=r)sum[i]+=v[i-1],cnt[i]++; &#125; for(i=0;i&lt;m;i++) tot+=(cnt[ev[i][1]]-cnt[ev[i][0]-1])* (sum[ev[i][1]]-sum[ev[i][0]-1]);&#125;int main()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;S); int i,j,lb=0,rb=1000000,md; ans=S; for(i=0;i&lt;n;i++) scanf("%d%lld",&amp;w[i],&amp;v[i]); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;ev[i][0],&amp;ev[i][1]); while(rb-lb)&#123; md=(rb+lb)/2,tot=0; solve(md); if(tot==S)&#123;ans=0;break;&#125; else if(tot&gt;S)ans=min(ans,tot-S),lb=md+1; else ans=min(ans,S-tot),rb=md; &#125; printf("%lld\n",ans); return 0;&#125; 提高D2T3 观光公交（待考察）题目地址 题解题目的意思就是选择若干条路，修改他们的长度，使得总的旅行时间最少。具体的做法就是贪心，找省时间最多的路段用。我们把道路分块，为什么要这么做呢？我们把本题第一个数据画成图。123456710 5 05 7 2 4 8 2 8 3 110 3 41 1 333 6 914 4 81 1 4 上面的竖线表示到站的人的到站时间，点表示时间点。虚线部分是指车子到站之后还要等待虚线的时间才能等到人全部上齐。虚线左端是到站时间点，右端是发车时间点。设一个站i中，来的最晚的人到达时间是$latest[i]$。然后，我们手算后可以发现一些性质：性质1.如果车子到达i站的时间是$curt$，并且$curt\le latest[i]$，那么$i$前面和$i$后面，两个路段相互独立。什么意思呢？我们可以感性地这么想：让一段路的长度减少，就相当于把这段路以及其后面的到站时间点往前拉。但是第i站的点永远不会动，因为他的到站时间点和发车时间点是用虚线连接着的，发车时间一定不变。所以对i前面的路修改，$i$后面的就不会受影响；同理对$i$后面的路修改，$i$前面的路也不会受影响。我们称呼到达这样的站的路为隔离路。上图中，$5\rightarrow 6$就是隔离路。根据这个性质，我们可以很方便的把路分块，分割成几个相互不影响的路块以及分隔他们的隔离路。分完了块就可以计算优化一条路能节省的时间了。下面我们对一个路块进行探究：设一个块中开头的站编号为$belong$，末尾的站是$tail$。显然，由上文，$tail\rightarrow tail+1$的路是隔离路。性质2.一个块中，如果优化$i\rightarrow i+1$站的路，使其长度$-1$，可以节省的时间是在$i+1,i+2,…tail,tail+1$这些站下车的人数的总和。这个性质很容易证明，由于这些人都已经上了车，所以优化这段路就相当于把后面站的到站时间点都$-1$，每一个人的到达时间就$-1$，所以省下的时间是人数的和，证毕。根据这个性质，我们可以用后缀和计算出省下的时间，找到在块中最优的那段路。不在块中的隔离路也能优化，优化一次节省的时间是在隔离路通向的下一站下车的人数。接下来的问题是一段路最多可以优化多少次。根据上图可以发现，一段路被优化一定次数，前面的某一段路就会变成隔离路。比如优化$1\rightarrow 2$的路后，$3\rightarrow 4$就变成了隔离路。所以在分块时还要对每一段路统计一个$mingap$，表示一段路最多优化几次就会导致后面的某段路变为隔离路。优化$mingap$次数之后，原来的块就失效了，需要对当前操作块进行重构。如果一段路的长度变成了$0$，或者$mingap$为$0$，就称这一段路是无效路，在寻找最大值时忽略。之后重复以上步骤即可。分析一下时间复杂度：每一轮我们找出一段可以修改的路，修改完成后，至少会使得一段路变为隔离路，或者使得一条隔离路变为无效路。所以每一条路最多被修改$2$次。一共有$O(n)$条路，所以最多做$O(n)$次，所有的路就被修改完了。每一轮我们需要$O(n)$的时间找到省时间最多的路段，并且至多用$O(n)$的时间更新块的情况，结合上面可知，最多做$O(n)$轮，所以该算法的理论时间复杂度为$O(n^2)$。贪心的正确性比较显然，在此不证明。存在$O(nk)$的编程复杂度更低，但是可能会超时的做法。很可惜，本题数据太水，根本卡不掉。事实上，本题存在时间运行上比本题解程序实现更优的程序实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,K,dis[1005],latest[1005],dec[1005],cost[1005],cnt[1005],cnt2[1005];int belong[1005],mingap[1005],tail[1005],ans=0;void build_block(int l,int r)&#123; int bid=l,curt=latest[l]; for(int i=l+1;i&lt;=r;i++)&#123; curt+=dis[i-1]; if(curt&gt;latest[i])belong[i-1]=bid; else&#123; belong[i-1]=-1,mingap[i-1]=INF; int tmp=curt-dis[i-1]; for(int j=i-2;j&gt;=bid;j--) mingap[j]=min(min(tmp-latest[j+1],dis[j]),mingap[j+1]), tmp-=dis[j]; curt=latest[i],tail[bid]=i-1,bid=i; &#125; &#125; if(bid!=r)&#123; int bef=INF; for(int j=r-1;j&gt;=bid;j--) mingap[j]=min(bef,min(dis[j],curt-latest[j+1])), bef=min(bef,mingap[j]),curt-=dis[j]; tail[bid]=r; &#125;&#125;void init()&#123; n=read(),m=read(),K=read(); for(int i=1;i&lt;n;i++)dis[i]=read(); for(int i=1;i&lt;=m;i++)&#123; int Ti=read(),Ai=read(),Bi=read(); latest[Ai]=max(latest[Ai],Ti); cost[Ai]+=Ti; dec[Ai]++,dec[Bi]--,cnt[Ai]++,cnt2[Bi]++; &#125; for(int i=2;i&lt;=n+1;i++)dec[i]+=dec[i-1]; int curt=latest[1]; ans+=cnt[1]*latest[1]-cost[1]; for(int i=1;i&lt;n;i++)&#123; if(latest[i+1]&gt;curt+dis[i])&#123; ans+=cnt2[i+1]*dis[i]+(dec[i]-cnt2[i+1])*(latest[i+1]-curt); ans+=cnt[i+1]*latest[i+1]-cost[i+1]; curt=latest[i+1]; &#125;else&#123; ans+=dec[i]*dis[i],curt+=dis[i]; ans+=cnt[i+1]*curt-cost[i+1]; &#125; &#125; //每一段路上坐车人数 &#125;void solve()&#123; build_block(1,n); for(;K;)&#123; int maxi=0,maxid=-1,curb=0,bid,sum; for(int i=1;i&lt;n;i++)&#123; bid=belong[i]; if(bid&lt;0)&#123; if(dis[i]&amp;&amp;cnt2[i+1]&gt;maxi)maxi=cnt2[i+1],maxid=i; &#125;else&#123; if(curb!=bid)&#123; curb=bid,sum=0; for(int j=tail[bid]+1;j&gt;=i+1;j--)sum+=cnt2[j]; &#125; if(mingap[i]&amp;&amp;sum&gt;maxi)maxi=sum,maxid=i; sum-=cnt2[i+1]; &#125; &#125; if(maxid&lt;0)break; bid=belong[maxid]; if(bid&lt;0)&#123; if(K&gt;dis[maxid]) ans-=maxi*dis[maxid],K-=dis[maxid],dis[maxid]=0; else &#123; ans-=maxi*K; break; &#125; &#125;else&#123; if(K&gt;mingap[maxid])&#123; ans-=maxi*mingap[maxid],K-=mingap[maxid],dis[maxid]-=mingap[maxid]; &#125;else &#123; ans-=maxi*K; break; &#125; build_block(bid,tail[bid]); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>二分</tag>
        <tag>栈</tag>
        <tag>搜索</tag>
        <tag>枚举</tag>
        <tag>贪心</tag>
        <tag>字符串DP</tag>
        <tag>二路归并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2014%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2014十道题目的题解。 普及T1 珠心算测验题目地址 没读懂题目就会被坑。模拟即可，但是要注意先去重，不然会多次统计。另外还要注意整数对的无序性。也就是说，两个数$a+b=c$和$b+a=c$不能算$2$遍。在找到这个数$c$后，还要及时把他删除，以免多次统计。所以，$O(n^2)$扫一遍即可。12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int a[104],n,ans=0;char vis[20004]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); sort(a,a+n); n=unique(a,a+n)-a; for(int i=0;i&lt;n;i++)vis[a[i]]=1; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) if(vis[a[i]+a[j]])ans++,vis[a[i]+a[j]]=0; printf("%d\n",ans); return 0;&#125; 普及T2 比例简化题目地址 方法一模拟即可，注意简化后分数和原分数的比较，涉及浮点数的运算。时间复杂度$O(L^2)$。123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int a,b,lim,fz,fm;double bi,mini=1e9,cur;int gcd(int a,int b)&#123; return (!b)?a:gcd(b,a%b);&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;lim); bi=(double)a/b,cur=1e9; for(int i=1;i&lt;=lim;i++) for(int j=1;j&lt;=lim;j++)&#123; double t=(double)i/j; if(t-bi&gt;0&amp;&amp;t-bi&lt;cur) cur=t-bi,fz=i,fm=j; else if(fabs(t-bi)&lt;1e-8)&#123; fz=i,fm=j;break; &#125; &#125; int g=gcd(fz,fm); fz/=g,fm/=g; printf("%d %d\n",fz,fm); return 0;&#125; 方法二对每一个不大于$L$的数进行一次二分，找出以此数为分母时最接近$\frac {A}{B}$的分数的分子。时间复杂度：$O(LlogL)$。 普及T3 螺旋矩阵题目地址 观察发现这个结构很有规律，因为螺旋矩阵是一层一层螺旋的，所以考虑一层一层递进求解。我们每一次去掉矩阵最外面的一层，如12341 2 3 4 12 13 14 5 ---&gt; 13 1411 16 15 6 ---&gt; 16 1510 9 8 7 这样里面还是一个螺旋矩阵，但由$n\times n$变为了$(n-2)\times (n-2)$。最后到了要求的数的那一层的时候采用模拟算法，算出那个数即可。时间复杂度：$O(n)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n,x,y,tot=0;int main()&#123; scanf("%d%d%d",&amp;n,&amp;x,&amp;y); for(;x!=1&amp;&amp;y!=1&amp;&amp;x!=n&amp;&amp;y!=n;) tot+=4*n-4,n-=2,x--,y--; if(x==1)tot+=y; else&#123; tot+=n-1; if(y==n)tot+=x; else&#123; tot+=n-1; if(x==n)tot+=(n-y+1); else&#123; tot+=n-1; if(y==1)tot+=(n-x+1); &#125; &#125; &#125; printf("%d\n",tot); return 0;&#125; 普及T4 子矩阵题目地址 这题一脸不可做。是吗？我们先尝试搜索，按照计算，我们最多搜索$(C_{16}^8)^2$次。这样会$TLE$。别急，先搜出我们当前选取的行。然后问题就转化为了求这些行中某些列产生的最小的分数。这个问题我们就很熟悉了，这不是一个$O(m^2)$的$DP$么？设$f(i,j)$为选了$i$列，当前在第$j$列时最小的分数，则状态转移方程易导出。综上，我们使用搜索和$DP$相结合的方法解决了本题。实际上，这样的搜索和高效算法结合的思想早在许多年前就已经用到（即$NOI2003$智破连环阵），在这里出现着实很妙。而在$NOIP2015$中也有这样的思想。时间复杂度：$O(C_n^mm^2)$（近似）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,r,c,mat[20][20],ans=1000000000;int cur_r[20],cur_c[20],v_c[20]=&#123;0&#125;,w[20][20],dp[20][20]=&#123;0&#125;;void dfs_c(int at,int cur)&#123; int fm=cur_c[at-1],val,pos; cur+=v_c[fm]; if(cur&gt;=ans)return; if(at==c)&#123; ans=min(ans,cur);return ; &#125; for(int i=fm+1;i&lt;=m-c+at;i++)&#123; cur_c[at]=i; if(cur&gt;=ans)return ; else dfs_c(at+1,cur); for(int j=0;j&lt;r;j++)&#123; pos=cur_r[j]; val=mat[pos][i]-mat[pos][fm]; if(val&lt;0)val=-val; cur-=val; &#125; &#125;&#125;void solve_()&#123; int pos; memset(v_c,0,sizeof(v_c)); memset(w,0,sizeof(w)); memset(dp,0,sizeof(dp)); for(int i=0;i&lt;m;i++) for(int j=1;j&lt;r;j++) v_c[i]+=abs(mat[cur_r[j]][i]-mat[cur_r[j-1]][i]); for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=0;k&lt;r;k++) pos=cur_r[k], w[i][j]+=abs(mat[pos][i]-mat[pos][j]); for(int i=0;i&lt;m;i++) dp[1][i]=v_c[i]; for(int i=2;i&lt;=c;i++)&#123; for(int j=0;j&lt;m;j++)&#123; pos=1000000000; for(int k=0;k&lt;j;k++) if(dp[i-1][k]+w[k][j]&lt;pos) pos=dp[i-1][k]+w[k][j]; dp[i][j]=pos+v_c[j]; &#125; &#125; for(int i=c-1;i&lt;m;i++) ans=min(ans,dp[c][i]);&#125;void dfs_r(int at)&#123; int fm=cur_r[at-1],val; for(int i=fm+1;i&lt;=n-r+at;i++)&#123; cur_r[at]=i; for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]+=val; &#125; if(at==r-1)solve_(); else dfs_r(at+1); for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]-=val; &#125; &#125;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;r,&amp;c); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;mat[i][j]);&#125;void solve()&#123; for(int i=0;i&lt;=n-r;i++)&#123; cur_r[0]=i; dfs_r(1); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 生活大爆炸版石头剪刀布题目地址 判断胜负你可以用一堆if else 或者 switch case，但最简便的还是打表计算。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int tab[5][5]=&#123;//A打B &#123;0,0,1,1,0&#125;, &#123;1,0,0,1,0&#125;, &#123;0,1,0,0,1&#125;, &#123;0,0,1,0,1&#125;, &#123;1,1,0,0,0&#125;&#125;;int n,na,nb,a[205],b[205],ans1=0,ans2=0;void init()&#123; n=read(),na=read(),nb=read(); for(int i=0;i&lt;na;i++)a[i]=read(); for(int i=0;i&lt;nb;i++)b[i]=read();&#125;void solve()&#123; int ra,rb; for(int i=0;i&lt;n;i++) ra=i%na,rb=i%nb, ans1+=tab[a[ra]][b[rb]],ans2+=tab[b[rb]][a[ra]]; printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T2 联合权值题目地址 这是一棵树，同时点对距离为$2$这个条件也很微妙，所以先把他转化为一棵有根树，再利用父子关系求解。距离为$2$，我们可以枚举中心点。对于树上的一个点来说，这意味着以他为中心点的点对是由它的父亲与儿子，儿子与儿子构成的。这样最大的权值好做了，记录儿子中的最大权值和次大权值，比较父亲的权值和儿子中最大权值的积以及儿子中最大、次大权值的积，以此更新答案即可。但是权值的和就比较麻烦，儿子和父亲形成的点对的权值和好算，但儿子之间相互的乘积是相互乘的，一次要花费$O(儿子数^2)$的时间计算。最坏情况下是$O(n^2)$的。如何优化？这需要一些数学知识。设儿子的权值为a_1,a_2,a_3,...,a_m,那么儿子们的联合权值之和就是a_1a_2+a_1a_3+...+a_1a_m+a_2a_3+...+a_2a_m+...+a_{m-1}a_m。这里不加证明的给出$2$种在$O(n)$时间计算该值的方法：1.设f(i)=a_1+a_2+...+a_i，g(i)=a_1a_2+a_1a_3+...+a_1a_i+a_2a_3+...+a_2a_i+...+a_{i-1}a_i。更新$g(i)$需要$f(i)$。步骤如下：初始$f(0)=g(0)=0$，$i=1$。（1：g(i)=g(i-1)+a_i\times f(i-1)（2：f(i)=f(i-1)+a_i（3：$i=i+1$2.展开(a_1+a_2+a_3+...+a_m)^2可知维护儿子的权值和和权值平方和就可以算出联合权值之和。代码用的是方法2.综上所述，在使用$DFS/BFS$对树进行遍历的情况下，以上算法的时间复杂度是$O(n)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt; using namespace std;typedef struct&#123; int w,par,son,bro;&#125;Tree;Tree tr[200005];int n,q[200005],f=0,r=0,M=10007,ans=0,ans2=0;void prepare()&#123; int i,h,sum,sum2,mx,mx2,e; for(i=0;i&lt;n;i++) if(tr[i].par&lt;0)&#123;q[r++]=i;break;&#125; while(r-f)&#123; h=q[f++],sum=sum2=mx=mx2=0; for(i=tr[h].son;i!=-1;i=tr[i].bro)&#123; e=tr[i].w, sum=(sum+e)%M, sum2=(sum2+(e*e)%M)%M; if(e&gt;mx)mx2=mx,mx=e; else if(e&gt;mx2)mx2=e; q[r++]=i; &#125; ans2=max(ans2,max(mx*mx2,mx*tr[tr[h].par].w)), ans=(ans+(tr[tr[h].par].w*sum*2)%M)%M, ans=(ans+(sum*sum-sum2)%M+M)%M; &#125;&#125;int main()&#123; scanf("%d",&amp;n); int i,u,v; for(i=0;i&lt;n;i++) tr[i].par=tr[i].son=tr[i].bro=-1; for(i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v), u--,v--; if(tr[v].par&gt;=0)swap(u,v); tr[v].par=u,tr[v].bro=tr[u].son,tr[u].son=v; &#125; for(i=0;i&lt;n;i++) scanf("%d",&amp;tr[i].w); prepare(); printf("%d %d\n",ans2,ans); return 0;&#125; 提高D1T3 飞扬的小鸟题目地址 一个背包DP的模型。按$x$坐标划分阶段，状态是坐标，决策有：1.点若干次屏幕；2.不点屏幕。发现决策$1$对应无限背包，决策$2$对应$01$背包。所以做一次DP。设$f(i,j,l)$表示到了点$(i,j)$最少需要点击屏幕的次数，其中$l=0$表示本次不点击屏幕，$l=1$表示本次点击。则状态转移方程容易导出，在此就不列出了。在转移的时候注意之前转移而来的状态和当前转移的合法性，以及一个细节：在最高处，小鸟可以平移飞行。时间复杂度：$O(nm)$（近似，因为在最高点有一次枚举）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 2000000000using namespace std;int dp[2][1005][2],n,m,k,up[10005],down[10005],rec[10005][2];void input()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int i,j; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;up[i],&amp;down[i]), rec[i][0]=-1,rec[i][1]=m+3; rec[n][0]=-1,rec[n][1]=m+3; for(i=0;i&lt;k;i++) scanf("%d",&amp;j), scanf("%d%d",&amp;rec[j][0],&amp;rec[j][1]);&#125;void solve()&#123; int res,ans,i,j,t,u,v,o,l,p,q; for(i=0;i&lt;=m;i++) dp[0][i][0]=dp[0][i][1]=0; for(i=1;i&lt;=n;i++)&#123; for(o=0,j=1;j&lt;=m;j++)&#123; dp[i&amp;1][j][0]=dp[i&amp;1][j][1]=INF; if(j+down[i-1]&lt;=m) p=(j+down[i-1]&lt;rec[i-1][1])&amp;&amp;(j+down[i-1]&gt;rec[i-1][0]), q=(j&lt;rec[i][1])&amp;&amp;(j&gt;rec[i][0]), u=(p)?dp[1^(i&amp;1)][j+down[i-1]][0]:INF, v=(p)?dp[1^(i&amp;1)][j+down[i-1]][1]:INF, dp[i&amp;1][j][0]=(q)?min(u,v):INF; if(j-up[i-1]&gt;0) for(l=(j==m)?0:up[i-1];l&lt;=up[i-1];l++) p=(j-l&lt;rec[i-1][1])&amp;&amp;(j-l&gt;rec[i-1][0]), t=dp[i&amp;1][j-l][1], u=(p)?dp[1^(i&amp;1)][j-l][0]:INF, v=(p)?dp[1^(i&amp;1)][j-l][1]:INF, t=min(min(u,v),t), dp[i&amp;1][j][1]=min(dp[i&amp;1][j][1],t+1); if(j&lt;rec[i][1]&amp;&amp;j&gt;rec[i][0]&amp;&amp;(dp[i&amp;1][j][0]&lt;INF|| dp[i&amp;1][j][1]&lt;INF))o=1; &#125; if(!o)&#123;res=0;break;&#125; &#125; if(i==n+1)res=1; printf("%d\n",res); if(res) for(ans=INF,j=n,i=1;i&lt;=m;i++) ans=min(ans,min(dp[j&amp;1][i][0],dp[j&amp;1][i][1])); else for(ans=0,j=0;j&lt;i;j++) if(rec[j][0]!=-1)ans++; printf("%d\n",ans);&#125;int main()&#123; input(); solve(); return 0;&#125; 提高D2T1 无线网络发射器选址题目地址 枚举一下路口即可。或者玩矩阵前缀和。时间复杂度：$O(128^2 n)$或者$O(d^2)$（理论上）12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int d,R,n,sum[1000][1000],cnt=0,ans=0;void init()&#123; d=read(),n=read(),R=(d&lt;&lt;1|1); for(int i=1;i&lt;=n;i++) sum[read()+R][read()+R]=read(); for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i][j-1]; for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i-1][j];&#125;void solve()&#123; for(int i=R+d;i&lt;=128+R+d;i++) for(int j=R+d;j&lt;=128+R+d;j++)&#123; int val=sum[i][j]-sum[i-R][j]-sum[i][j-R]+sum[i-R][j-R]; if(val&gt;ans)ans=val,cnt=1; else if(val==ans)cnt++; &#125; printf("%d %d\n",cnt,ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T2 寻找道路题目地址 考虑先删不合法的点，再跑一遍BFS找到最短路。首先把边反向，从终点跑一下，看看哪些点是合法的。遍历到的点都是和终点直接或者间接连通着的。对于没有被遍历到的点，就要取消它和它连着的点的合法性。这一步可以直接在下一步跑最短路的时候做。时间复杂度：$O(n)$。注意判断起点的合法性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;typedef long long ll;typedef struct&#123; int v,_nex;&#125;Edge;Edge edge[400005];char vis[10005]=&#123;0&#125;;int n,m,que[20005],f,r,at[10005],cnt=0,S,T,d[10005];int at_[10005];void bfs1()&#123; f=r=0; que[r++]=T,vis[T]=1; int h,i,j,v; while(r-f)&#123; h=que[f++]; for(i=at[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!vis[v]) vis[v]=1,que[r++]=v; &#125; &#125;&#125;bool judge(int u)&#123; for(int i=at_[u];i;i=edge[i]._nex) if(!vis[edge[i].v])return 0; return 1;&#125;void bfs2()&#123; if(!judge(S))return ; d[S]=0,f=r=0; que[r++]=S; int i,j,h,v,st; while(r-f)&#123; h=que[f++]; for(i=at_[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!judge(v))continue; if(d[v]&gt;d[h]+1) d[v]=d[h]+1,que[r++]=v; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v; for(i=0;i&lt;m;i++) scanf("%d%d",&amp;u,&amp;v), edge[++cnt].v=u,edge[cnt]._nex=at[v],at[v]=cnt; scanf("%d%d",&amp;S,&amp;T); fill(d+1,d+n+1,INF); bfs1(); for(i=1;i&lt;=n;i++) for(j=at[i];j;j=edge[j]._nex) edge[++cnt].v=i,edge[cnt]._nex=at_[edge[j].v],at_[edge[j].v]=cnt; bfs2(); if(d[T]==INF)printf("-1\n"); else printf("%d\n",d[T]); return 0;&#125; 提高D2T3 解方程题目地址 高精大概可以做到$50$分。想一想，带进去一个$x$，怎么判断左边是否是$0$呢？可不可以避免计算这个准确值呢？学过哈希，我们知道可以把字符串映射到一个值上，值相等那么认为两个字符串相等。但是这个数一般而言很大，所以要对素数取模，来缩小这个值。（虽然哈希跟这题没什么关系）我们也可以用这种类似的做法。对于一个$x$，只要把左边的值模一下一个质数$p$，如果答案是$0$，那么左边的值就很有可能是$0$。为了提高准确程度，我们多模几个质数，如果得到的结果都是$0$，就认为$x$是一个根。这么做可以拿$70$分，因为判断一个解的时间复杂度是$O(n\times $质数个数$)$的，总时间复杂度是$O(m\times n\times $质数个数$)$。然后发现其实没必要全部枚举$m$，因为只要几个$x$模$p$的余数相同，左边的值都是相同的。所以只要保存$x=0,1,…p-1$的取模结果即可，时间复杂度是$O(n\times p_{max}\times $质数个数$+m)$。质数选几个不大不小的即可，推荐选$5$~$6$个。当然如果你幸运EX的话模一两个也是能A掉的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int p[]=&#123;9973,10723,10937,11161,13337&#125;;int n,m,a[5][105]=&#123;0&#125;,fx[5][20000];char s[100005];bool ans[1000005];int read_(int M)&#123;; int f=1,x=0; if(s[0]=='-')f=-f; for(char *t=(s[0]=='-'?s+1:s);*t;t++)x=(x*10+*t-'0')%M; return f*x;&#125;void init()&#123; n=read(),m=read(); for(int i=0;i&lt;=n;i++)&#123; scanf("%s",s); for(int j=0;j&lt;5;j++)a[j][i]=read_(p[j]); &#125; for(int i=0;i&lt;5;i++) for(int j=1;j&lt;=p[i];j++)&#123; int res=0; for(int k=n;k&gt;=0;k--) res=(res*j+a[i][k])%p[i]; fx[i][j]=res; &#125;&#125;void solve()&#123; int cnt=0,flag; for(int i=1;i&lt;=m;i++)&#123; flag=0; for(int j=0;j&lt;5;j++) if(fx[j][i%p[j]])&#123; flag=1; break; &#125; if(!flag)cnt++,ans[i]=1; &#125; printf("%d\n",cnt); for(int i=1;i&lt;=m;i++) if(ans[i])printf("%d\n",i);&#125;int main()&#123; init(); solve(); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>树形结构</tag>
        <tag>枚举</tag>
        <tag>背包DP</tag>
        <tag>最短路</tag>
        <tag>非完美算法</tag>
        <tag>部分搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2008%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2008八道题目的题解。 普及T1 ISBN号码题目地址 模拟即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;char isbn[20];int last,sum=0,cnt=1;int main()&#123; scanf("%s",isbn); for(int i=0;i&lt;13;i++)&#123; if(isdigit(isbn[i])&amp;&amp;i!=12) sum+=(isbn[i]-'0')*cnt,cnt++; else if(isdigit(isbn[i])&amp;&amp;i==12) sum%=11,last=isbn[i]-'0'; else sum%=11,last=10; &#125; if(last==sum)&#123; printf("Right"); &#125;else&#123; for(int i=0;i&lt;12;i++) putchar(isbn[i]); printf("%c\n",sum==10?'X':sum+'0'); &#125; return 0;&#125; 普及T2 排座椅题目地址 算一下选每一行或者每一列可以阻断的人数，然后排序贪心即可。注意行号和列号都要排序再输出。时间复杂度：$\mathcal O(nlogn+mlogm)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;struct Seat&#123; int id,tot;&#125;;Seat line[1005],row[1005];bool cmp(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.tot&gt;sb.tot;&#125;bool cmp2(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.id&lt;sb.id;&#125;int n,m,K,L,D;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;L,&amp;D); int x1,y1,x2,y2; for(int i=1;i&lt;=n;i++) line[i].tot=0,line[i].id=i;//该行上面 for(int i=1;i&lt;=m;i++) row[i].tot=0,row[i].id=i;//该列右边 for(int i=1;i&lt;=D;i++)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(x1==x2) row[min(y1,y2)].tot++; //同行记录列 else if(y1==y2) line[min(x1,x2)].tot++; &#125; sort(line+1,line+1+n,cmp),sort(line+1,line+K+1,cmp2); sort(row+1,row+1+m,cmp),sort(row+1,row+1+L,cmp2); for(int i=1;i&lt;K;i++) printf("%d ",line[i].id); printf("%d\n",line[K].id); for(int i=1;i&lt;L;i++) printf("%d ",row[i].id); printf("%d\n",row[L].id); return 0;&#125; 普及T3 传球游戏题目地址 方法一数据怎么小，怎么玩？打表！123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt;int q[28][28]=&#123;&#123;2,6,10,22,42,86,170,342,682,1366,2730,5462,10922,21846,43690,87382,174762,349526,699050,1398102,2796202,5592406,11184810,22369622,44739242,89478486,178956970,357913942&#125;,&#123;0,8,0,32,0,128,0,512,0,2048,0,8192,0,32768,0,131072,0,524288,0,2097152,0,8388608,0,33554432,0,134217728,0,536870912&#125;,&#123;0,6,2,20,14,70,72,254,330,948,1430,3614,6008,13990,24786,54740,101118,215766,409640,854702,1652090,3396916,6643782,13530350,26667864,53971350,106914242,215492564&#125;,&#123;0,6,0,22,0,86,0,342,0,1366,0,5462,0,21846,0,87382,0,349526,0,1398102,0,5592406,0,22369622,0,89478486,0,357913942&#125;,&#123;0,6,0,20,2,70,18,252,110,924,572,3434,2730,12902,12376,48926,54264,187036,232562,720062,980674,2789164,4086550,10861060,16878420,42484682,69242082,166823430&#125;,&#123;0,6,0,20,0,72,0,272,0,1056,0,4160,0,16512,0,65792,0,262656,0,1049600,0,4196352,0,16781312,0,67117056,0,268451840&#125;,&#123;0,6,0,20,0,70,2,252,22,924,156,3432,910,12870,4760,48622,23256,184796,108528,705894,490314,2708204,2163150,10430500,9373652,40313160,40060078,156305070&#125;,&#123;0,6,0,20,0,70,0,254,0,948,0,3614,0,13990,0,54740,0,215766,0,854702,0,3396916,0,13530350,0,53971350,0,215492564&#125;,&#123;0,6,0,20,0,70,0,252,2,924,26,3432,210,12870,1360,48620,7752,184756,40698,705434,201894,2704204,961400,10401250,4440150,40123152,20030010,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,926,0,3460,0,13110,0,50252,0,194446,0,758100,0,2973350,0,11716252,0,46333566,0,183739940&#125;,&#123;0,6,0,20,0,70,0,252,0,924,2,3432,30,12870,272,48620,1938,184756,11970,705432,67298,2704156,354200,10400602,1776060,40116656,8584290,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3434,0,12902,0,48926,0,187036,0,720062,0,2789164,0,10861060,0,42484682,0,166823430&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,2,12870,34,48620,342,184756,2660,705432,17710,2704156,106260,10400600,592020,40116600,3121560,155117522&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12872,0,48656,0,185136,0,708512,0,2725408,0,10532160,0,40870080,0,159189120&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,2,48620,38,184756,420,705432,3542,2704156,25300,10400600,161460,40116600,950040,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48622,0,184796,0,705894,0,2708204,0,10430500,0,40313160,0,156305070&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,2,184756,42,705432,506,2704156,4600,10400600,35100,40116600,237510,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184758,0,705476,0,2704708,0,10405800,0,40157550,0,155402532&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,2,705432,46,2704156,600,10400600,5850,40116600,47502,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705434,0,2704204,0,10401250,0,40123152,0,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,2,2704156,50,10400600,702,40116600,7308,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704158,0,10400652,0,40117356,0,155125640&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,2,10400600,54,40116600,812,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400602,0,40116656,0,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,2,40116600,58,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116602,0,155117580&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,2,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,0,155117522&#125;&#125;;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m);printf("%d\n",q[n-3][m-3]); return 0; &#125; 方法二实际上这个递推是很水，设$\mathcal f\left(i,j\right)$为当前球到了第$i$个人的时候是第$j$次的情况下，传球的方法数，则可以递推得 \mathcal f\left(i,j\right)=f\left(i-1,j-1\right)+f\left(i+1,j-1\right)其中$i-1$指$i$左边的人，$i+1$指$i$右边的人。假设开始的人是￥0￥号即可。时间复杂度：$\mathcal O\left(nm\right)$123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,f[35][35];int main()&#123; scanf("%d%d",&amp;n,&amp;m); f[0][0]=1; for(int j=1;j&lt;=m;j++)&#123; f[0][j]=f[n-1][j-1]+f[1][j-1]; f[n-1][j]=f[0][j-1]+f[n-2][j-1]; for(int i=1;i&lt;n-1;i++) f[i][j]=f[i-1][j-1]+f[i+1][j-1]; &#125; printf("%d\n",f[0][m]); return 0;&#125; 普及T4 立体图题目地址 这题目是不是一看就很恶劣啊？是的！但是只要知道构图的顺序就完成了一部分。我的构图顺序是从最底层构起，每一层按列构成，从远到近，从左到右，从下到上，这样就解决了图形覆盖的问题。然后就是坐标的计算以及图形具体元素坐标的计算，这里可以参考我的代码。时间复杂度：画一个正方体的时间是常数，所以是$O($正方体数$)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;char mp[20001][350];int n,m,mp2[55][55],BOT=20000;void lie(int x,int y)&#123; mp[x][y]=mp[x][y+4]='+', mp[x][y+1]=mp[x][y+2]=mp[x][y+3]='-';&#125;void build(int x,int y,int z)&#123; int dx=BOT,dy=0; dx-=(z-1)*3+3+2*(m-x+1);//yuanlaiwei x dy+=(m-x+1)*2+(y-1)*4; lie(dx,dy),lie(dx+2,dy-2),lie(dx+5,dy-2); mp[dx+3][dy+4]='+', mp[dx+1][dy-1]=mp[dx+1][dy+3]=mp[dx+4][dy+3]='/'; mp[dx+3][dy-2]=mp[dx+3][dy+2]= mp[dx+4][dy-2]=mp[dx+4][dy+2]= mp[dx+1][dy+4]=mp[dx+2][dy+4]='|', mp[dx+1][dy]=mp[dx+1][dy+1]=mp[dx+1][dy+2]= mp[dx+2][dy+3]=mp[dx+3][dy+3]= mp[dx+3][dy]=mp[dx+3][dy-1]=mp[dx+3][dy+1]= mp[dx+4][dy]=mp[dx+4][dy-1]=mp[dx+4][dy+1]=' ';&#125;void output()&#123; int s1=0,s2=0,i,j,ok; for(i=BOT;i&gt;=0;i--)&#123; for(j=0,ok=0;j&lt;350;j++) if(mp[i][j]!='.')ok=1; if(!ok)break; &#125; s1=i+1; for(i=349;i&gt;=0;i--)&#123; for(j=s1,ok=0;j&lt;=BOT;j++) if(mp[j][i]!='.')ok=1; if(ok)break; &#125; s2=i; //printf("%d %d\n",s1,s2); for(i=s1;i&lt;=BOT;i++)&#123; for(j=0;j&lt;=s2;j++) printf("%c",mp[i][j]); printf("\n"); &#125;&#125;int main()&#123; memset(mp,'.',sizeof(mp)); scanf("%d%d",&amp;m,&amp;n); int i,j,k; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mp2[i][j]); for(i=1;i&lt;=100;i++) for(k=0;k&lt;n;k++) for(j=0;j&lt;m;j++) if(mp2[j][k]&gt;=i) build(j+1,k+1,i); output(); return 0;&#125; 提高T1 笨小猴题目地址 模拟即可。注意0和1都不是质数。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;bool judge(int x)&#123; if(!x||x==1)return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0)return 0; return 1;&#125;char s[1005];int cnt[27],len;int main()&#123; scanf("%s",s); len=strlen(s); for(int i=0;i&lt;len;i++) cnt[s[i]-'a']++; int maxi=0,mini=1000; for(int i=0;i&lt;26;i++)&#123; if(!cnt[i])continue; maxi=max(maxi,cnt[i]),mini=min(mini,cnt[i]); &#125; if(judge(maxi-mini)) printf("Lucky Word\n%d\n",maxi-mini); else printf("No Answer\n0\n"); return 0;&#125; 提高T2 火柴棒等式题目地址 方法一大概划定一下加数的范围，然后暴力枚举即可。1是最少的，所以以他为标准，大概左右两边的加数是在2000左右。（实际上试验后发现在1000左右）1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int cnt[]=&#123;6,2,5,5,4,5,6,3,7,6&#125;,n,ans=0;int table[2005];int get(int a)&#123; int res=0; while(a)res+=cnt[a%10],a/=10; return res;&#125;int main()&#123; scanf("%d",&amp;n),n-=4; table[0]=6; for(int i=1;i&lt;=2000;i++) table[i]=get(i); for(int i=0;i&lt;=1000;i++) for(int j=0;j&lt;=1000;j++) if(table[i]+table[j]+table[i+j]==n)ans++; printf("%d\n",ans); return 0;&#125; 方法二题目是死的，人是活的。打表也是好手段。1int ans[]=&#123;0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128&#125;; 提高T3 传纸条题目地址 设$\mathcal f\left( k,i,j\right) \left( i \le j \right)$为走了$\mathcal k$步，第一条路径当前在第$\mathcal i$列，第二条在第$\mathcal j$列时的最大的爱心值。则转移方程为 \mathcal f\left( k,i,j\right) = \max \left\{ f\left( k-1,i,j\right) , f\left( k-1,i-1,j\right) , f\left( k-1,i,j-1\right),f\left( k-1,i-1,j-1\right) \right\} + \begin{cases} data[k-i][i] \quad \left(i=j\right)\\ data[k-i][i]+data[k-j][j] \quad \left(i \neq j\right) \\ \end{cases}1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][51][51]=&#123;0&#125;,m,n,mat[51][51];int main()&#123; int i,j,k;scanf("%d%d",&amp;m,&amp;n); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(k=1;k&lt;m+n-1;k++) for(j=0;j&lt;n;j++) for(i=0;i&lt;=j;i++)&#123; if(k-i&lt;0||k-i&gt;=m||k-j&lt;0||k-j&gt;=m)continue; dp[k][i][j]=max(dp[k-1][i][j],dp[k][i][j]); if(i)dp[k][i][j]=max(dp[k-1][i-1][j],dp[k][i][j]); if(j)dp[k][i][j]=max(dp[k-1][i][j-1],dp[k][i][j]); if(i&amp;&amp;j)dp[k][i][j]=max(dp[k-1][i-1][j-1],dp[k][i][j]); dp[k][i][j]+=mat[k-i][i]; if(i!=j)dp[k][i][j]+=mat[k-j][j]; &#125; printf("%d\n",dp[m+n-2][n-1][n-1]); return 0;&#125; 提高T4 双栈排序题目地址 双栈排序=单栈排序*2。那我们探究一下单栈排序吧！显然，单栈排序中，如果有两个数$\mathcal a_i$和$\mathcal a_k$，其中$\mathcal a_k&lt;a_i$，那么显然$\mathcal a_k$先弹出，$\mathcal a_i$后弹出。什么时候一个序列无法被单栈排序呢？如果因为某个原因，上面的事情做不到，就说明无法单栈排序。换言之，我们假设$\mathcal i&lt;k$且$\mathcal a_k&lt;a_i$，那么如果两个数之间有一个碍事的：有元素$\mathcal i&lt;j&lt;k$，并且$\mathcal a_i&lt;a_j$，那么显然在弹出$\mathcal a_k$后必须要先弹掉$\mathcal a_j$才能弹出$\mathcal a_i$，这不符合条件。所以无法单栈排序。一个栈做不成，那就两个。考虑把这些碍事的元素放到另一个栈里，这样就不矛盾了。问题是如何分配呢？我们知道，根据上述条件，$\mathcal a_i$和$\mathcal a_j$必然无法在同一个栈中。根据这种”二分“的性质，我们想到了二分图。把下标看做结点，然后不能在一个栈里的点对间连一条边，判断这个图是否是二分图即可。这一步可以直接用DFS实现。之后就比较简单了，输出排序过程即可。 还有一个瓶颈：怎么求这样的点对？直接枚举会带来$\mathcal O\left(n^3\right)$的时间复杂度，我们承受不住。观察到$\mathcal a_k$具体是多少不重要，只要有一个$\mathcal k$满足\mathcal j]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>递推</tag>
        <tag>贪心</tag>
        <tag>暴力</tag>
        <tag>二分图</tag>
        <tag>多线程DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2016%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2016十道题目的题解。 普及T1 买铅笔题目地址 对于每一种都判断一下，我要达到这个量最少要买几包铅笔。这是一个简单的除法和模运算。1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n,c,v,ans=2000000000;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;3;i++)&#123; scanf("%d%d",&amp;v,&amp;c); j=(n%v==0)?n/v:(n/v+1); j*=c,ans=min(ans,j); &#125; printf("%d\n",ans); return 0;&#125; 普及T2 回文日期题目地址 你可以估计一下年份的范围，然后直接暴力统计。使用字符串函数是基本功呢。（笑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;char a[10],b[10];int rs[]=&#123;1,3,5,7,8,10,12&#125;,ans=0,x1,x2,y1,y2,m1,m2,d1,d2;bool cmp(int ye,int mo,int da)&#123; if(ye&lt;y1||ye&gt;y2)return false; if(ye==y1)&#123; if(mo&lt;m1)return false; else if(mo==m1)&#123; if(da&lt;d1)return false; &#125; &#125;else if(ye==y2)&#123; if(mo&gt;m2)return false; else if(mo==m2)&#123; if(da&gt;d2)return false; &#125; &#125; return true;&#125;int main()&#123; scanf("%s%s",a,b); x1=atoi(a),x2=atoi(b); y1=x1/10000,y2=x2/10000; m1=(x1%10000)/100,m2=(x2%10000)/100; d1=x1%100,d2=x2%100; int i,j,k,l,t,ye,mo,da,ok; for(i=0;i&lt;=1;i++) for(j=0;j&lt;=9;j++)&#123; mo=i*10+j; if(mo&gt;12)break; if(!mo)continue; for(k=0;k&lt;=3;k++)&#123; if(k==3&amp;&amp;mo==2)break; for(l=0;l&lt;=9;l++)&#123; ye=l*1000+k*100+j*10+i, da=k*10+l; if(da&gt;31)break; if(!da)continue; if(da==31)&#123; for(ok=t=0;t&lt;7;t++) if(mo==rs[t])ok=1; if(!ok)break; &#125; if(ye%400==0||(ye%4==0&amp;&amp;ye%100!=0))&#123; if(mo==2&amp;&amp;da&gt;29)break; &#125;else if(mo==2&amp;&amp;da&gt;28)break; if(!cmp(ye,mo,da))continue; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 普及T3 海港题目地址 统计？12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int t,k,st;&#125;D;D _q[100005];int n,cnt[100005]=&#123;0&#125;,_cnt=0,q[300005],f,r,cur=0;int main()&#123; scanf("%d",&amp;n); int t,m,i,j,l; f=r=0; for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;t,&amp;m); _q[r].t=t,_q[r++].k=m; while(r&gt;f&amp;&amp;_q[f].t&lt;=t-86400)&#123; for(j=_q[f].st,l=0;l&lt;_q[f].k;l++,j++)&#123; cnt[q[j]]--; if(!cnt[q[j]])_cnt--; &#125; f++; &#125; _q[r-1].st=cur; for(l=0;l&lt;m;l++,cur++)&#123; scanf("%d",&amp;q[cur]); cnt[q[cur]]++; if(cnt[q[cur]]==1)_cnt++; &#125; printf("%d\n",_cnt); &#125; return 0;&#125; 普及T4 魔法阵题目地址 好方法不妨设x_a-x_b=len，那么对于每一个$i$，设i=x_b，枚举一次$len$。接下来的事情就很玄学了：$len$的限制是$len\le i-1$且$len\le 2\times\lfloor \frac{n-i-1}7 \rfloor$，算一下发现$len_{max}=\lfloor \frac{2n-4}9 \rfloor$，又由于$len$是偶数，所以每一次枚举的次数至多为$\lfloor \frac n 9 \rfloor$。这个常数很小，考虑暴力。总体上是枚举长度$len$，每一次枚举x_a，x_b，算出可行的x_c，x_d贡献，再对x_c，x_d做一遍。（当然也可以只做一遍，那样会很麻烦，见下面的下面的失败代码）这里可以发现随着x_c，x_d的递增x_a，x_b是递增的，所以可以用前缀和优化；对于x_c，x_d同理。时间复杂度$O(n^2)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],cnt[15005]=&#123;0&#125;;int ca[15005],cb[15005],cc[15005],cd[15005];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) a[i]=read(),cnt[a[i]]++;&#125;void solve()&#123; int hf_max=n/9,len,rp,xa,xb,xc,xd,sum; for(int hf=1;hf&lt;=hf_max;hf++)&#123;//长度的一半 len=hf&lt;&lt;1,sum=0; for(xc=4*len+2;xc&lt;=n-hf;xc++)&#123;//枚举xc xd=xc+hf,xa=xc-4*len-1,xb=xa+len; sum+=cnt[xa]*cnt[xb]; cc[xc]+=cnt[xd]*sum,cd[xd]+=cnt[xc]*sum; &#125; sum=0; for(xb=n-7*hf-1;xb&gt;=len+1;xb--)&#123;//枚举xb xa=xb-len,xd=7*hf+xb+1,xc=xd-hf; sum+=cnt[xc]*cnt[xd]; ca[xa]+=cnt[xb]*sum,cb[xb]+=cnt[xa]*sum; &#125; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]],cb[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125; 劣方法之前写了一个不够好，但是空间够大的情况下可以拿95分（大概）的程序。。。有兴趣的同学可以看看。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],ws[15005];int pre[2005][15005],dc[2005][15005],dd[2005][15005]; int ca[15005],cb[15005],cc[15005],cd[15005];bool calced[15005];void calc(int at,int len)&#123; int *cur=pre[len]; for(int i=at;i+len&lt;=n;i++) cur[i]=cur[i-1]+ws[i]*ws[i+len]; calced[len]=1;&#125;void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++)a[i]=read(),ws[a[i]]++;&#125;void solve()&#123; int xb,len,cnt,cnt_c,xs,hf; int lenmax=n/9,*tc,*td; for(int i=2;i&lt;=n;i++)&#123; if(!ws[i])continue; cnt=0; for(int len=2;len&lt;xb;len+=2)&#123; int rp=7*(len&gt;&gt;1)+i+1; if(rp&gt;n)break; if(!ws[i-len])continue; xs=ws[i-len]*ws[i],hf=(len&gt;&gt;1); dc[hf][rp-hf]+=xs,dc[hf][n-hf+1]-=xs; dd[hf][rp]+=xs,dd[hf][n+1]-=xs; if(!calced[hf])calc(rp-hf,hf); cnt_c=pre[hf][n-hf]-pre[hf][rp-hf-1]; cnt_c*=xs,cnt+=cnt_c,ca[i-len]+=cnt_c; &#125; cb[i]+=cnt; &#125; for(int i=1;i&lt;=lenmax;i++)&#123; tc=dc[i],td=dd[i]; for(int j=8*i+2;j&lt;=n-i;j++) tc[j]+=tc[j-1],td[j+i]+=td[j+i-1], cc[j]+=tc[j]*ws[j+i],cd[j+i]+=td[j+i]*ws[j]; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]]/ws[a[i]],cb[a[i]]/ws[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 玩具谜题题目地址 按照题意模拟即可。确定左右方向就用异或的方法。当然，多写几行判断也是可行的。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int in_or_out[100005],n,m;//in 0,out 1char job[100005][20];void init()&#123; n=read(),m=read(); for(int i=0;i&lt;n;i++) scanf("%d%s",&amp;in_or_out[i],job[i]);&#125;void solve()&#123; int opr,s,lst=0; while(m--)&#123; opr=read(),s=read(); int res=opr^in_or_out[lst]; if(!res)lst=(lst-s+n)%n; else lst=(lst+s)%n; &#125; printf("%s\n",job[lst]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T2 天天爱跑步题目地址 当初比赛的时候连暴力都没写对orz暴力的话，直接上$LCA$，大力模拟即可，大概可以拿25分。。。满分做法是从链状做法中过渡而来的。我们发现，从$S$到$T$总是经过他们的$LCA$的（废话），也就是说，可以从$LCA$的角度入手。然后考虑把树问题变成链问题，只要把$LCA$两边的链扯出来即可。对于一条链，一个点$S$可以给另一个点$i$贡献的情况只有从$S$到$i$走的步数=$W_i$。反映在链上，就是$|S-i|=W_i$。反映在树上，就是$depth[S]-depth[i]=W_i$，即$depth[S]=W_i+depth[i]$。这里假定$S$不是LCA，那么从$S$出发时不会往下面走的。我们显然希望对于$i$统计合法的对应$S$。那么就造一个数组，统计当前合法的$S$的个数，走到一个$i$上查一下即可。同理，另一边，有从LCA向下走到$T$，也是一样的道理，多开一个数组就行。（条件是$depth[i]-W_i=depth[T]-len(x,y)$）计算答案的顺序需要注意： 进入的时候先减掉答案，出去的时候再加上，才可以得到自身的贡献。（对于自己统计到的$S$和$T$） 由于$S$到$LCA$是向上，并且我们只希望在$S$到$LCA$的路径上查到我们想要的贡献，所以在向下DFS时添加自己作为$S$的信息，并在回到$LCA$时再减掉$S$的贡献；对$LCA$到$T$，我们只要它向上走的贡献，所以在回溯的时候在$T$处加上，再在$LCA$处减去。 负数下标。 总结一下，这道题有一个类似于差分的思想。。。在2015年应该有所领略。时间复杂度取决于你求$LCA$时算法的时间复杂度。为$O((n+m)logn)$或者$O(n+m)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define MAXN 300005#define MAXL 21using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,to[MAXN*2],_next[MAXN*2],at[MAXN]=&#123;0&#125;,Cnt=0;//树部分 int que[MAXN],depth[MAXN],par[MAXN][MAXL]=&#123;0&#125;,LOG;//LCA部分 int at2[MAXN]=&#123;0&#125;,to2[MAXN],_next2[MAXN],Cnt2=0;//存T的信息 int ats[MAXN]=&#123;0&#125;,tos[MAXN],_nexts[MAXN],Cnts=0;//自己是LCA时存S的深度 int att[MAXN]=&#123;0&#125;,tot[MAXN],_nextt[MAXN],Cntt=0;//自己是LCA时存T的深度 int m,ans[MAXN],w[MAXN],c[MAXN]=&#123;0&#125;;//ans答案 w出现时间 cS人数 int down[MAXN],up[MAXN*2]=&#123;0&#125;;//up S-&gt;LCA down LCA-&gt;T（可能有负数） void addedge(int _u,int _v)&#123; to[++Cnt]=_v,_next[Cnt]=at[_u],at[_u]=Cnt;&#125;void bfs()&#123; int f=0,r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; int h=que[f++]; for(int i=at[h];i;i=_next[i])&#123; int _v=to[i]; if(_v==par[h][0])continue; que[r++]=_v,depth[_v]=depth[h]+1,par[_v][0]=h; &#125; for(int i=1;i&lt;=LOG;i++) if(par[h][i-1])par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j,d; if(depth[u]&lt;depth[v]) swap(u,v); for(d=depth[u]-depth[v],i=0;(1&lt;&lt;i)&lt;=d;i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=LOG;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;//倍增求解LCAvoid dfs(int cur)&#123; //主要求解过程 int up_ans=up[depth[cur]+w[cur]], down_ans=down[depth[cur]-w[cur]+MAXN]; //旧的答案 up[depth[cur]]+=c[cur]; //作为S，添加自己 for(int i=at[cur];i;i=_next[i]) if(to[i]!=par[cur][0])dfs(to[i]); //搜索子树 for(int i=at2[cur];i;i=_next2[i]) down[to2[i]+MAXN]++; //作为T，添加自己的信息 ans[cur]=up[depth[cur]+w[cur]]+down[depth[cur]-w[cur]+MAXN]-up_ans-down_ans; //利用DFS性质计算自己的答案 for(int i=ats[cur];i;i=_nexts[i])&#123; up[tos[i]]--;//回溯时删去S if(tos[i]==depth[cur]+w[cur])ans[cur]--;//如果S就是LCA，那么答案重复，减掉1个 &#125; for(int i=att[cur];i;i=_nextt[i]) down[tot[i]+MAXN]--;//作为LCA，回溯时删去T&#125;void init()&#123; n=read(),m=read(); for(LOG=1;(1&lt;&lt;LOG)&lt;n;LOG++); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; bfs(); for(int i=1;i&lt;=n;i++)w[i]=read(); for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(); int lca=query(u,v),len=depth[u]+depth[v]-2*depth[lca]; c[u]++; tos[++Cnts]=depth[u],_nexts[Cnts]=ats[lca],ats[lca]=Cnts; tot[++Cntt]=depth[v]-len,_nextt[Cntt]=att[lca],att[lca]=Cntt; to2[++Cnt2]=depth[v]-len,_next2[Cnt2]=at2[v],at2[v]=Cnt2; &#125;&#125;void solve()&#123; dfs(1); for(int i=1;i&lt;n;i++) printf("%d ",ans[i]); printf("%d\n",ans[n]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T3 换教室题目地址 很水的期望DP，但是对于第一次写的人有点难度。（比方说我） 题目说要求最小的体力消耗期望值，并给出了地图，说明肯定先要求一次多源最短路。然后在现实意义上理解一下这里期望的意义。在这里，期望是概率和权值的乘积之和。并且每一次是否选课和其他几次都是没有关系的。会对权值造成影响的是这一次和前一次的申请情况。比如第$i$次申请了，第$i-1$次没申请，那么有两种情况：一是申请通过，本次体力消耗是c_{i-1}到d_i的最短路长；二是没有通过，本次体力消耗是c_{i-1}到c_i的最短路长。那么期望体力就是 E=k_i*d[c_{i-1},d_i]+(1-k_i)\times d[c_{i-1},c_i]以此类推，都申请有4种情况，一个申请一个不申请有2种情况，都不申请有1种情况，每种情况对应的期望体力是不变的。这样就转化为了一个类似背包的问题。设$f(i,j,k)$表示对于前$i$节课，使用了$j$次机会时需要的最小期望体力，$k=0$表示此次不申请，$k=1$表示此次不申请，分类讨论即可写出状态转移方程。具体见代码。时间复杂度：$O(nm+V^3)$注意，由于涉及了浮点数运算，该题的代码如果写的常数太大的话就会在最后一个点TLE。所以要适度卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,V,E,INF=1000000000;int d[305][305];int p1[2005],p2[2005];double f[2005][2005][2],p[2005],inf=1e9;void floyd()&#123; for(int k=0;k&lt;V;k++) for(int i=0;i&lt;V;i++) for(int j=0;j&lt;V;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;V,&amp;E); int i,j,u,v,c; for(i=0;i&lt;n;i++) scanf("%d",&amp;p1[i]),p1[i]--; for(i=0;i&lt;n;i++) scanf("%d",&amp;p2[i]),p2[i]--; for(i=0;i&lt;n;i++) scanf("%lf",&amp;p[i]); for(i=0;i&lt;V;i++) for(j=0;j&lt;V;j++) d[i][j]=(i==j)?0:INF; for(i=0;i&lt;E;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); if(d[u-1][v-1]&gt;c) d[u-1][v-1]=d[v-1][u-1]=c; &#125; floyd();&#125;void solve()&#123; int i,j,A,B,C,D; double choice,ans=inf; for(i=0;i&lt;n;i++) for(j=0;j&lt;=m;j++) f[i][j][0]=f[i][j][1]=inf; f[0][0][0]=f[0][1][1]=0; for(i=1;i&lt;n;i++)&#123; A=d[p1[i-1]][p1[i]], B=d[p1[i-1]][p2[i]], C=d[p2[i-1]][p1[i]], D=d[p2[i-1]][p2[i]]; f[i][0][0]=f[i-1][0][0]+A; for(j=1;j&lt;=m;j++)&#123; choice=min(f[i-1][j][0]+A, f[i-1][j][1]+p[i-1]*C+(1-p[i-1])*A); f[i][j][0]=min(f[i][j][0],choice); choice=min(f[i-1][j-1][0]+p[i]*B+ (1-p[i])*A, f[i-1][j-1][1]+p[i-1]*p[i]*D+ (1-p[i-1])*p[i]*B+ p[i-1]*(1-p[i])*C+ (1-p[i-1])*(1-p[i])*A); f[i][j][1]=min(f[i][j][1],choice); &#125; &#125; for(i=0;i&lt;=m;i++) ans=min(ans,min(f[n-1][i][0],f[n-1][i][1])); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T1 组合数问题题目地址 这题给你公式就是给你坑。（如果你不会求逆元的话）实际上没有必要求逆元，直接拿组合数经典公式就可以做了。我们知道：C_n^m=C_{n-1}^{m-1}+C_{n-1}^m。同时，如果一个组合数是$k$的倍数，那么C_n^m \mod k =0。所以就$O(nm)$递推一下，在递推的过程中让C_n^m对$k$取模，如果结果为$0$就在当前位置记录一下。这样可以解决一次回答，但时间复杂度不够优，每次都这么做是O(n_{max}\times m_{max}\times t)的，可能只能过70%左右的数据。发现$k$不变，所以考虑预处理再回答。这里使用前缀和思想。设$ans(n,m)$表示所有$0\le i\le n,0\le j \le m$中，有多少C_i^j是$k$的倍数，即C_i^j \mod k =0。先求出每一行的前缀和，再求一次每一列的前缀和就可得到所有的$ans(n,m)$。（详见代码）这样回答一个询问的时间是$O(1)$，总时间复杂度是O(n_{max}\times m_{max} +t)。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int T,k,C[2005][2005],sum[2005][2005]=&#123;0&#125;,maxn=0,maxm=0,n[10005],m[10005];void init()&#123; int i,j,v; for(i=0;i&lt;=maxn;i++) C[i][0]=1; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%k; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++)&#123; if(j&lt;=i&amp;&amp;C[i][j]==0)v=1;else v=0; sum[i][j]=sum[i-1][j]+v; &#125; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++) sum[i][j]+=sum[i][j-1];&#125;int main()&#123; scanf("%d%d",&amp;T,&amp;k); for(int i=1;i&lt;=T;i++) scanf("%d%d",&amp;n[i],&amp;m[i]),maxn=max(maxn,n[i]),maxm=max(maxm,m[i]); init(); for(int i=1;i&lt;=T;i++) printf("%d\n",sum[n[i]][m[i]]); return 0;&#125; 提高D2T2 蚯蚓题目地址 考场上我想到了这个方法，但因为没证明所以不敢用。。。结果一看题解就吓傻了。可以证明同一种切法下，先切割的比后切割的长度会更长，所以维护$3$个递减队列，然后先把所有初始蚯蚓放在队列$1$，然后不断取出，把$\lfloor px\rfloor$的放在队列$2$中，$x-\lfloor px\rfloor $放在队列$3$中，每一次取$1,2,3$中最大值出来切。注意：1.维护下标（切的时间）很麻烦，不妨直接先减去当前时间和$q$的乘积，然后到了它在加上。为什么可以这么做？因为一条蚯蚓的实际长度是len+(t_{当前}-t_{被切})*q，展开得(len-t_{被切}\times q)+q\times t_{当前}，所以队列里只需要维护前面括号里的元素即可。相应的，在求最大值时，初始最大值要取很小，因为要维护的值可能是个很小的负数。2.要卡常，STL慢的飞起。时间复杂度$O(n+m)$。 补充证明上面那个性质。假设有$2$条蚯蚓长度分别是$a,b(a&gt;b)$，那么$a$会比$b$先被切。设两个蚯蚓被切得时间点分别是t_a,t_b(t_a \lfloor p\times b\rfloor和a-\lfloor p\times a\rfloor +(t_b-t_a)\times q>b-\lfloor p\times b\rfloor。所以上面的命题成立，证毕。大家都看的出来好嘛1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int q1[100005]=&#123;0&#125;,q2[7000005],q3[7000005],n,m,q,u,v,t;int f1=0,f2=0,f3=0,r1=0,r2=0,r3=0;double xs,tmp;int main()&#123; scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t); xs=u,xs/=(double)v; int i,j,k,maxi,_max,fi,se,ok=0; for(i=0;i&lt;n;i++) scanf("%d",&amp;q1[i]); sort(q1,q1+n); r1=n,reverse(q1,q1+n); for(i=0;i&lt;m;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=i*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; tmp=_max,tmp*=xs; fi=(int)floor(tmp),se=_max-fi; q2[r2++]=fi-(i+1)*q, q3[r3++]=se-(i+1)*q; &#125; printf("\n"); for(ok=i=0;i&lt;m+n;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=m*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; &#125; printf("\n"); return 0;&#125; 提高D2T3 愤怒的小鸟题目地址 状压搜索/DP枚举抛物线，看一次抛物线能砸死哪些猪，然后跑DP搜索过不去？那就卡时呗。DP？设$f(i,S)$表示解决了前i头猪，正在解决第$i+1$头，猪被打死的情况为$S$的最小方案数。那么先算出以包含第$i$头猪在内的所有抛物线能砸死的猪的情况（压位表示），然后跑记忆化搜索即可。时间复杂度：搜索：$O($你卡时就能过$)$DP：$O($你不卡时也能过$)$实际检验发现，搜索效率很高，对于小数据非常轻松。但DP的发挥更加稳定，不会被奇奇怪怪的东西卡死。在洛谷上，搜索不卡时95分，花费254ms；DP花费2154ms。 DP做法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,tag,tab[20][500];int in[20][1&lt;&lt;19];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1;//x坐标相同 a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1;//a必须&lt;0 b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;//解方程void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=((1&lt;&lt;i)|(1&lt;&lt;j)); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]-_a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;int dfs(int at,int S)&#123; if(in[at][S]&lt;0x3f3f3f3f)return in[at][S]; int st=0x3f3f3f3f,i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; st=min(st,1+dfs(j,_S)); &#125; return (in[at][S]=st);&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); memset(in,0x3f,sizeof(in)); tag=(1&lt;&lt;n); for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); in[n][tag-1]=0; printf("%d\n",dfs(0,0)); &#125; return 0;&#125; 搜索做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,ans,tag,tab[20][500];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1; a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1; b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=0;S|=(1&lt;&lt;i);S|=(1&lt;&lt;j); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]- _a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;void dfs(int at,int st,int S)&#123; if(S!=tag-1&amp;&amp;st&gt;=ans-1)return ; if(S==tag-1)&#123;ans=min(ans,st);return ;&#125; int i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; dfs(j,st+1,_S); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); tag=(1&lt;&lt;n),ans=n; for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); dfs(0,0,0); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>DFS</tag>
        <tag>数论</tag>
        <tag>最短路</tag>
        <tag>单调队列</tag>
        <tag>状压DP</tag>
        <tag>LCA</tag>
        <tag>期望DP</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2013%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2013十道题目的题解。 普及T1 计数问题题目地址 某一道著名数位DP的弱化版。模拟即可，时间复杂度为$O(n)$。1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans=0,x;int main()&#123; scanf("%d%d",&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) for(int j=i;j;j/=10) ans+=(j%10==x); printf("%d\n",ans); return 0;&#125; 普及T2 表达式求值题目地址 简单而又基础的表达式计算的题目。连括号都没有，只要注意取模即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;char k[1200005]=&#123;0&#125;;int len,st[2][100005]=&#123;0&#125;,top[2]=&#123;0&#125;,pro[255];void push(int a,int to)&#123; st[to][top[to]++]=a;&#125;int pop(int to)&#123; top[to]--; return st[to][top[to]];&#125;void opr()&#123; int a1,a2,p; a2=pop(1),a1=pop(1),p=pop(0); if(p=='+')push((a1+a2)%10000,1); if(p=='*')push((a1%10000)*(a2%10000)%10000,1);&#125;int main()&#123; fgets(&amp;k[1],1200000,stdin); k[0]='(',len=strlen(k); while(isspace(k[len-1])) k[--len]='\0'; k[len++]=')'; pro['+']=pro['-']=1; pro['*']=pro['/']=2; int sum=-1; for(int i=0;i&lt;len;i++)&#123; if(isdigit(k[i]))&#123; if(sum==-1)sum=k[i]-'0'; else sum=sum*10+k[i]-'0'; &#125;else&#123; if(sum&gt;-1) push(sum,1),sum=-1; if(k[i]=='(') push('(',0); else if(k[i]==')')&#123; while(st[0][top[0]-1]!='(') opr(); pop(0); &#125;else&#123; while(st[0][top[0]-1]!='('&amp;&amp;pro[st[0][top[0]-1]]&gt;=pro[k[i]]) opr(); push(k[i],0); &#125; &#125; &#125; printf("%d\n",pop(1)%10000); return 0; &#125; 普及T3 小朋友的数字题目地址 容易看出这是一个最大子段和的问题。我们知道小朋友的分数是不递减的，所以边算便取模即可。 完了吗？没有。相信很多人都挂在了第一个点。这个点很有意思，因为通过它，我们发现上文的一个重要结论是错的。小朋友的分数在第2-n个是不递减的。但第一个不是。所以要加上对第一个的特判，方法就是：如果当前记录的（分数+特征值）的最大值还是负数，答案就取第一个分数和当前分数的较大值，否则直接取当前分数。因为如果（分数+特征值）的最大值还是负数，那么他一定还有可能小于第一个的分数。时间复杂度：$O(n)$。本题代码可能有疏漏，如果能hack掉请告诉我一声，谢谢！12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 2100000000000000llusing namespace std;typedef long long ll;ll d,maxspc=-INF,sum=0,ans,maxi=-INF,mini=INF,p,sc,beg; int n;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;p,&amp;d); mini=0,sum=d,maxi=d,maxspc=2*d,sc=maxi%p,ans=maxi%p; beg=d; for(int i=2;i&lt;=n;i++)&#123; mini=min(mini,sum), scanf("%lld",&amp;d),sum+=d, maxi=max(maxi,sum-mini);//sp[i] sc=maxspc%p; if(maxi&gt;0)&#123; maxspc=(maxi+sc)%p; if(maxspc&lt;0)ans=max(sc,beg); else ans=sc; &#125; &#125; printf("%lld\n",ans); return 0;&#125; 普及T4 车站分级题目地址 一眼看出来是差分约束，后来发现这个图是一个$DAG$（题目保证存在这么一个方案，就不会有环的存在），求最长路可以直接跑拓扑排序，所以就做完了。时间复杂度为$O(n^2m)$，理论上如此，但实际操作中还行。（主要花在建图上）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,cnt[1005]=&#123;0&#125;,to[1005][1005],lis[1005];int vis[1005],d[1005]=&#123;0&#125;,que[1005],f,r,du[1005]=&#123;0&#125;;bool mat[1005][1005]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; memset(vis,0,sizeof(vis)); int u,v,k,fi,en; scanf("%d",&amp;k); for(int j=0;j&lt;k;j++) scanf("%d",&amp;lis[j]),vis[lis[j]]=1; fi=lis[0],en=lis[k-1]; //有无人向我连边？ for(int j=fi+1;j&lt;en;j++)&#123; if(vis[j])continue; for(u=0;u&lt;k;u++) if(!mat[j][lis[u]]) mat[j][lis[u]]=1, to[j][cnt[j]++]=lis[u], du[lis[u]]++; &#125; &#125;&#125;void solve()&#123; int i,j,lst,at,ans=0; memset(vis,0,sizeof(vis)); fill(d+1,d+n+1,-1); f=r=0; for(i=1;i&lt;=n;i++) if(!du[i]) d[i]=0,que[r++]=i; while(r-f)&#123; int h=que[f++],v; for(int i=0;i&lt;cnt[h];i++)&#123; v=to[h][i]; d[v]=max(d[v],d[h]+1); du[v]--; if(!du[v])que[r++]=v; &#125; ans=max(ans,d[h]); &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 转圈游戏题目地址 相当于每一次对编号加一个$m$，然后对$n$取模，如此做$10^k$次。所以答案就是$(m+m+m+…+m+x)\mod n=(m\times 10^k+x)\mod n$。使用快速幂即可，时间复杂度$O(logk)$。1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll n,m,k,x;int main()&#123; scanf("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;x); printf("%lld\n",((Pow(10%n,k,n))*m+x)%n); return 0;&#125; 提高D1T2 火柴排队题目地址 如果你知道什么叫排序不等式，这题就是道裸题。如果你不知道，额，你也可以自己证明：当a_1]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>拓扑排序</tag>
        <tag>搜索</tag>
        <tag>贪心</tag>
        <tag>线性DP</tag>
        <tag>MST</tag>
        <tag>LCA</tag>
        <tag>树状数组</tag>
        <tag>差分约束</tag>
        <tag>快速幂</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shortest-path-problems]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2Fshortest-path-problems%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[对循环不变式的理解]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2Floop-invariants%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SPFA 学习笔记]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2FSPFA%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa106 Fermat vs. Pythagoras]]></title>
    <url>%2F2018%2F08%2F18%2Fuva106%2F</url>
    <content type="text"><![CDATA[题目链接 题解考察了素毕达哥拉斯三元组的生成。貌似没必要加很多的优化？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int ans1[1000005] = &#123;0&#125;, ans2[1000005] = &#123;0&#125;;bool vis[1000005] = &#123;0&#125;;int n;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void init()&#123; for(int v = 2; v &lt;= 1000; ++v)&#123; if(v * v &gt; n)break; for(int u = (v % 2 == 0) ? 1 : 2; u &lt; v; u += 2)&#123; if(u * u + v * v &gt; n) break; if(gcd(v, u) != 1) continue; int aa = v * v - u * u, bb = 2 * u * v, cc = v * v + u * u; ans1[cc]++; for(int i = 1; i * cc &lt;= n; ++i) vis[i * aa] = 1, vis[i * bb] = 1, vis[i * cc] = 1; &#125; &#125; for(int i = 1; i &lt;= n; ++i) ans1[i] += ans1[i - 1], ans1[i - 1] = 0, ans2[i] = ans2[i - 1] + 1 - vis[i], ans2[i - 1] = 0, vis[i] = 0;&#125;void solve()&#123; printf("%d %d\n", ans1[n], ans2[n]); ans1[n] = ans2[n] = 0;&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[勾股数探究]]></title>
    <url>%2F2018%2F08%2F18%2FPythagorean-triple%2F</url>
    <content type="text"><![CDATA[勾股数，又叫毕达哥拉斯三元数， 是由正整数构成的三元组。其三个数对应一个直角三角形的三条边。这里对勾股数的性质做一些探究。 基本性质一般用一个三元组表示一组勾股数：$(a, b, c)$其中有 a ^ 2 + b ^ 2 = c ^2容易看出，一组勾股数中每一个数乘上一个正整数$n$，得到的三元组$(na, nb, nc)$仍为一组勾股数。正因如此，我们希望找到这样的勾股数，使它不为除自己外某一个勾股数的倍数。换句话说，我们希望有一种方法可以枚举出所有的素勾股数，即使$(a, b, c)=1$。 构造方式先直接给出这样的构造方式：设$u &lt; v(u ,v\in \mathbb{N}^*)$，并且$u,v$奇偶性不同，且$(u, v) = 1$，那么令 \begin{cases} a = v ^ 2 - u ^ 2\\ b = 2 u v \\ c = v ^ 2 + u ^ 2\end{cases}即可构造出全部的素勾股数。证明：假设这样产生的勾股数存在$(a, b, c)= d$，那么由于$u, v$奇偶性不同， 故$a, c$必为奇数。故$d$为奇数。则对于$c$则必须有$u|d, v|d$，导出$(u, v)\ge d$，与前提中的$(u, v)=1$矛盾。故原命题得证，证毕。 由此可见，使用这样的方式构造出素勾股数之后再进行倍增，即可构造出所有可能的勾股数。 问题扩展问题：已知$a, b, c\in \mathbb{N}^*$和$b$，求满足$a ^ 2 + b ^ 2 = c ^ 2$的所有解。解题：把式子化为$b ^ 2 = (c - a)(c + a)$，设$x = c + a, y= c - a$，那么就有$b ^2 = x y$。对$b$枚举一次因数，然后对因数进行组合，同时考虑一下奇偶性带来的问题，计算出$x,y$，解出$a,c$即可。因为因数的个数为$O(\sqrt b)$，组合因数的时候会产生$O(b)$的因数个数，所以该方法的时间复杂度应为$O(b)$。 相关运用UVa106（同Poj1305） 参考资料 《什么是数学》 百度百科]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 最短路]]></title>
    <url>%2F2018%2F08%2F18%2Ftemplate-shortest-path%2F</url>
    <content type="text"><![CDATA[各种最短路的模板！首先可以利用反证法证明一个定理：最短路径的子路径也是最短路径。这个定理构成了之后算法的基石。 同时还有一个重要的不等式： d(v)\le d(u)+w(u, v)这个不等式叫三角不等式，它是松弛操作的理论基础。 Bellman-Ford算法容易知道，当一个图$G=(V, E)$中不存在负环时，该图中的最短路最多经过$|V|-1$条边。最短路上是不可能存在一个路径的权重和为正的环的。因此进行松弛操作时，最多进行$|V|-1$次就可以算出最短路。若在第$|V|$次仍可以进行松弛，那么就说明存在一个负环。Bellman-Ford算法基于上述思路，对每一条边都进行$|V|-1$次的松弛，从而就可求出最短路。同时，也可以用于判断负环是否存在。从上述说明也可以看出，Bellman-Ford算法允许图中有负权边。1234567891011121314bool Bellman_Ford()&#123; for(int i = 1; i &lt; V; ++i) for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost) d[v] = d[u] + edge[j].cost; &#125; for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost) return false;//还能松弛说明这个图存在负环 &#125; return true;&#125; 除了上述写法，还有一种经过了一定优化的写法：12345678910111213141516bool Bellman_Ford()&#123; for(int i = 1; i &lt;= V; ++i)&#123; int flag = 0; for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost)&#123; d[v] = d[u] + edge[j].cost, flag = 1; if(i == V) return false; &#125; &#125; if(!flag) break;//松弛的次数已经足够了，没有必要再进行下去 &#125; return true;&#125; 容易看出，Bellman-Ford算法的时间复杂度为$O(|V|\times |E|)$。因此，大部分情况下Bellman-Ford算法在解决问题的时候时间复杂度都不够好。但是，它的一个优化版本——SPFA的应用场合就相当多了。 Dijkstra算法DIjkstra算法在求单源最短路方面表现相当稳定。朴素实现时它的时间复杂度为$O(|V|^2+|E|)$，而在使用一定的数据结构时可以将时间复杂度降到$O(|E|log|V|)$。Dijkstra算法的使用条件是图中没有负权边。当图中的边权全为正时，可以从起点出发，采用贪心的方法，一步一步得到最短路径。具体方法是：找出所有没有使用过的顶点中离起点最近的点，然后松弛所有与其相邻的边，将其加入已使用过的点的集合，重复这一步骤。 朴素版本如下：12345678910111213void dijkstra(int S)&#123; memset(d, 0x3f, sizeof(d)); d[S] = 0; for(int i = 0; i &lt; V; ++i)&#123; int mind = 2000000000, minp = -1; for(int i = 0; i &lt; V; ++i) if(mind &gt; d[i] &amp;&amp; !vis[i]) mind = d[i], minp = i;//寻找当前扩展点 vis[i] = true; for(int i = at[minp]; i; i = e[i].nxt) d[e[i].v] = min(d[e[i].v], d[minp] + e[i].cost);//松弛 &#125;&#125; 用堆优化的版本如下：123456789101112131415161718192021222324252627282930struct Node&#123; int id, curd; Node(int _id, int _curd)&#123; id = _id, curd = _curd; &#125;&#125;;struct cmp&#123; inline bool operator() (const Node &amp;na, const Node &amp;nb)&#123; return na.curd &gt; nb.curd; &#125;&#125;;priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;void dijkstra(int S)&#123; memset(d, 0x3f, sizeof(d)); d[S] = 0; pq.push(Node(S, 0)); for(int i = 0; i &lt; V; ++i)&#123; while(!pq.empty())&#123; if(pq.top().curd &gt; d[pq.top().id])//用这种方式省去了一个vis数组 pq.pop(); else break; &#125; int minp = pq.top().id; pq.pop(); for(int i = at[minp]; i; i = e[i].nxt)&#123; if(d[e[i].v] &gt; d[minp] + e[i].cost) d[e[i].v] = d[minp] + e[i].cost, pq.push(Node(e[i].v, d[e[i].v]));//通过这种方式判断是否已被访问 &#125; &#125;&#125; SPFASPFA一般被视为Bellman-Ford算法的改良版本。虽然其名字由某一篇论文提出，但似乎这个方法在很早以前就已经出现了。SPFA更详细的介绍在另一篇博客里，在此就不详细说明。 朴素搜索当边权相同或者图很特殊（如$DAG$）时，可以直接采用搜索或者递推的方式计算最短路。由于这不是一个统一的模型，故在此不给出代码。 以上算法一般用于解决单源最短路问题。 矩阵乘法将图上的边距离对应成矩阵中相应行列的一个点，即可构造出一个矩阵 Floyd算法Floyd最短路算法可以在$O(|V|^3)$的时间复杂度下解决多源最短路问题。Floyd算法用到了动态规划的思想。考虑原始情况下，令$d[i][j]$表示点$i$和点$j$之间的最短距离。但这并不够用来表示一个状态，因此我们加上一维$k$，令$d[k][i][j]$表示利用编号为$0$到$k - 1$的点作为中转站时，$i$和$j$之间的最短距离。初始化时令$d[0][i][j] = cost[i][j]$（此时认为不使用中转站），其他值设为$INF$。在$0$到$k-1$的答案被算出来后，考虑$k$的情况。当不以$k$为中转站时，有$d[k+1][i][j]=d[k][i][j]$；当以$k$为中转站时，有$d[k+1][i][j]=d[k][i][k]+d[k][k][j]$。结合一下就是 d[k+1][i][j]=\min\left\{d[k][i][j],d[k][i][k]+d[k][k][j]\right\}可以发现，此时第一维已经没有什么必要。故最后我们可以得到以下代码。1234567void Floyd()&#123; //此时d数组里面已经存了相关信息 for(int k = 0; k &lt; V; ++k) for(int i = 0; i &lt; V; ++i) for(int j = 0; j &lt; V; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; Floyd算法允许负权边的存在，同时也可以用来判断负环是否存在。当负环存在时，存在$i$使得$d[i][i]&lt;0$。Floyd算法在一些和动态规划有所联系的图论题目里也有不错的表现，比如题目最小密度路径里面，可以增加一维记录当前走过的路径的条数，然后求出恰好经过一定数目路径的最短路的长度。同时Floyd算法的实现性也很强，很容易实现。不过似乎Floyd算法无法求出最短路径树。 参考资料 《算法导论》 《挑战程序设计竞赛（第2版）》 相关博客]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学英语]]></title>
    <url>%2F2018%2F08%2F16%2Fmath-english%2F</url>
    <content type="text"><![CDATA[列出一些常见的数学英语 Aadjacentadj. 毗邻的 Ccuboidn. 立方体 Eequilateraladj. 等边的，等面的 Iintegraladj. 整的，整数的，完整的，积分的n. 积分，整体 Mmaximumadj. 最大值的，最大量的n. 最大的量、体积、强度等 minimumn. 最低限度; 最小量; 最低消费; 极小值adj. 最小的; 最低的; 最少的 Pperimetern. 周长，周围 primen. 质数adj. 质的 TtotientEuler’s totient function: 欧拉函数 Rrelatively prime互质e.g. 15 is relatively prime to 2.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连分数和佩尔方程 学习笔记]]></title>
    <url>%2F2018%2F08%2F15%2Fwriting%2Fcontinued-fraction-and-pell-equation%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectEuler 61-100题解]]></title>
    <url>%2F2018%2F08%2F15%2Fpe61-100%2F</url>
    <content type="text"><![CDATA[继续探索 PE61先枚举排列，然后按照排列顺序进行搜索即可。或者按照图论，构图搜索也可以。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int p[6][10005], cnt[6] = &#123;0&#125;;int per[] = &#123;0, 1, 2, 3, 4, 5&#125;;int ans[6], t_ans[6];void init()&#123; int i; for(i = 1; (i * (i + 1) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i + 1) &gt;&gt; 1) &lt; 10000; ++i) p[0][cnt[0]++] = (i * (i + 1) &gt;&gt; 1); for(i = 1; i * i &lt; 1000; ++i); for(; i * i &lt; 10000; ++i) p[1][cnt[1]++] = i * i; for(i = 1; (i * (i * 3 - 1) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i * 3 - 1) &gt;&gt; 1) &lt; 10000; ++i) p[2][cnt[2]++] = (i * (i * 3 - 1) &gt;&gt; 1); for(i = 1; i * (2 * i - 1) &lt; 1000; ++i); for(; i * (2 * i - 1) &lt; 10000; ++i) p[3][cnt[3]++] = i * (2 * i - 1); for(i = 1; (i * (i * 5 - 3) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i * 5 - 3) &gt;&gt; 1) &lt; 10000; ++i) p[4][cnt[4]++] = (i * (i * 5 - 3) &gt;&gt; 1); for(i = 1; i * (i * 3 - 2) &lt; 1000; ++i); for(; i * (i * 3 - 2) &lt; 10000; ++i) p[5][cnt[5]++] = i * (i * 3 - 2);&#125;void getN(int index, int tail)&#123; if(index == 6)&#123; if(ans[5] % 100 == ans[0] / 100) memcpy(t_ans, ans, sizeof(ans)); return ; &#125; int id = per[index], hd = tail * 100; int _index = lower_bound(p[id], p[id] + cnt[id], hd) - p[id]; if(p[id][_index] / 100 != tail) return ; for(int i = _index; i &lt; cnt[id]; ++i)&#123; if(p[id][i] / 100 != tail) break ; ans[index] = p[id][i]; getN(index + 1, p[id][i] % 100); &#125;&#125;void solve()&#123; do&#123; int st = per[0]; for(int i = 0; i &lt; cnt[st]; ++i) ans[0] = p[st][i], getN(1, p[st][i] % 100); &#125;while(next_permutation(per, per + 6)); int sum = 0; for(int i = 0; i &lt; 6; ++i) sum += t_ans[i]; printf("%d\n", sum);&#125; 答案：28684 PE62一个一个长度去试12345678910111213141516171819map&lt;string, int&gt; mp;map&lt;string, ll&gt; mp2;ll ans = INF;void solve()&#123; char s[20]; for(ll i = 4642ll; i * i * i &lt; 1000000000000ll; ++i)&#123; sprintf(s, "%lld", i * i * i); sort(s, s + 12); string ss(s); if(!mp.count(ss)) mp[ss] = 1, mp2[ss] = i; else&#123; mp[ss]++; if(mp[ss] == 5) ans = min(ans, mp2[ss]); &#125; &#125; printf("%lld\n", ans * ans * ans);&#125; 答案：127035954683 PE63拿python水过12345678ans = 0for n in range(1, 22, 1): for i in range(1, 10, 1): x = i ** n if len(str(x)) == n: ans += 1print(ans) 答案：49 PE64这个连分数的构造方法一开始还不太容易看出来。。。答案写在另一篇博文里了。12 答案： PE65用python水过12345678910111213141516171819202122232425262728p = 1q = 1def gcd(a, b): if b == 0: return a else: return gcd(b, a % b)for i in range(1, 99, 1): a = 0 if (99 - i) % 3 == 2: a = ((98 - i) / 3 + 1) * 2 else: a = 1 pp = q qq = p + q * a p = pp q = qqp = p + q + qp /= gcd(p, q)ans = 0while p &gt; 0: ans += p % 10 p /= 10print(ans) 答案：272 PE66这个方程有名字，叫做佩尔方程。它的解和连分数有着很大的关系，将其写在了另一篇博文里12 PE67水DP答案：7273 PE68PE69筛出欧拉函数然后直接枚举。。。123456789void solve()&#123; getPhi(); int maxi; double d = 0; for(int i = 2; i &lt;= 1000000; ++i) if(d &lt; 1.0 * i / phi[i]) d = 1.0 * i / phi[i], maxi = i; printf("%d\n", maxi);&#125; 答案：510510 PE70枚举即可123456789101112131415161718192021void solve()&#123; getPhi(); int maxi; double d = 10000000; char s1[10], s2[10]; for(int i = 2; i &lt; 10000000; ++i)&#123; sprintf(s1, "%d", i); sprintf(s2, "%d", phi[i]); int len1 = strlen(s1), len2 = strlen(s2); if(len1 == len2)&#123; sort(s1, s1 + len1); sort(s2, s2 + len2); if(!strcmp(s1, s2))&#123; double dd = 1.0 * i / phi[i]; if(dd &lt; d) d = dd, maxi = i; &#125; &#125; &#125; printf("%d\n", maxi);&#125; 答案：8319823 PE71对于每一个$d$二分即可123456789101112131415161718void solve()&#123; double rd = 1.0 * 3 / 7, eps = 1e6; int fz, fm; for(int d = 9; d &lt;= 1000000; ++d)&#123; if(d % 7 == 0)continue; int l = 1, r = d - 1; while(r - l)&#123; int mid = (r + l + 1) &gt;&gt; 1; double rr = 1.0 * mid / d; if(rr &gt; rd)r = mid - 1; else l = mid; &#125; double rr = 1.0 * r / d; if(rd - rr &lt; eps) eps = rd - rr, fz = r, fm = d; &#125; printf("%d %d\n", fz, fm);&#125; 答案：428570 PE72就是对1~1000000的欧拉函数求和。。。1234567891011121314151617181920212223242526bool vis[1000005] = &#123;0&#125;;int prime[500005], tot = 0;int phi[1000005];ll sum = 0;void getPhi()&#123; phi[1] = 1; for(int i = 2; i &lt;= 1000000; ++i)&#123; if(!vis[i]) phi[i] = i - 1, prime[++tot] = i; for(int j = 1; j &lt;= tot; ++j)&#123; if(1ll * prime[j] * i &gt; 1000000) break; vis[prime[j] * i] = 1; if(i % prime[j] == 0)&#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125;else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; sum += 1ll * phi[i]; &#125;&#125;void solve()&#123; getPhi(); printf("%lld\n", sum);&#125; 答案：303963552391 PE73注意分数为不可约。12345678910111213141516171819int ans = 0;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void solve()&#123; double l = 1.0 / 3, r = 1.0 / 2; for(int i = 4; i &lt;= 12000; ++i)&#123; for(int j = 1; j &lt; i; ++j)&#123; if(gcd(i, j) &gt; 1) continue; double cur = 1.0 * j / i; if(abs(cur - l) &lt; 1e-7 || abs(cur - r) &lt; 1e-7) continue ; if(cur &gt; l &amp;&amp; cur &lt; r) ans++; &#125; &#125; printf("%d\n", ans);&#125; 答案：7295372 PE74虽然这道题我给出了一个正确的答案但我还是觉得我写错了。。。怎么回事？做法就是顺着一个数DFS下去，然后记录步数。12345678910111213141516171819202122232425262728293031323334int fac[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int d[10000005], ans = 0, st[10000005] = &#123;0&#125;;bool vis[10000005] = &#123;0&#125;;void getD()&#123; for(int i = 0; i &lt; 10; ++i) d[i] = fac[i]; for(int i = 10; i &lt;= 10000000; ++i) d[i] = d[i / 10] + fac[i % 10];&#125;void dfs(int x)&#123; vis[x] = 1; int nx = d[x]; if(!vis[nx]) dfs(nx); else&#123; if(!st[nx])&#123; st[x] = 1; return ; &#125; &#125; st[x] = st[nx] + 1;&#125;void solve()&#123; getD(); vis[1] = vis[2] = true; st[1] = st[2] = 1; for(int i = 3; i &lt; 1000000; ++i) if(!vis[i]) dfs(i); for(int i = 3; i &lt; 1000000; ++i) if(st[i] == 60) ans++; printf("%d\n", ans);&#125; 答案：402 PE75一开始我写了一个暴力枚举，然后很干脆的挂掉了。。。后来我想到可以枚举所有的素毕达哥拉斯三元数， 然后用类似筛法的方法让其倍数的方法数$+1$， 最后统计方法数仅为$1$的对数。这样做就快多了。123456789101112131415161718192021222324int ans = 0;int cnt[1500005] = &#123;0&#125;;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void pre()&#123; for(int v = 2; v &lt;= 1000; ++v) for(int u = 1; u &lt; v; ++u)&#123; if((u &amp; 1) &amp;&amp; (v &amp; 1))continue; if(gcd(u, v) != 1)continue; int dis = 2 * v * v + 2 * u * v; if(dis &gt; 1500000) break; for(int i = dis; i &lt;= 1500000; i += dis) cnt[i]++; &#125;&#125;void solve()&#123; pre(); for(int i = 12; i &lt;= 1500000; i += 2) if(cnt[i] == 1) ans++; printf("%d\n", ans);&#125; 答案：161667 PE76划分问题。令$p(n, m)$表示$n$划分为若干个小于等于$m$的数的方法数。那么有 p(n, m)=\begin{cases} 1\quad(n = 0) \\ p(n, m - 1)\quad (m >n)\\p(n, m - 1) +p (n - m, m)\quad (else)\end{cases}1234567891011121314ll p[105][105] = &#123;0&#125;;void solve()&#123; for(int i = 1; i &lt;= 100; ++i) p[1][i] = 1ll; for(int i = 2; i &lt;= 100; ++i)&#123; p[i][1] = 1ll; for(int j = 2; j &lt; i; ++j) p[i][j] = p[i][j - 1] + p[i - j][j]; p[i][i] = p[i][i - 1] + 1; for(int j = i + 1; j &lt;= 100; ++j) p[i][j] = p[i][j - 1]; &#125; printf("%lld\n", p[100][99]);&#125; 答案：190569291 PE77对pe76进行一定程度的加工即可。12345678910111213141516171819202122232425262728293031ll p[10005][10005] = &#123;0&#125;;bool vis[10005] = &#123;0&#125;;int prime[5005], tot = 0;void init()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; prime[tot++] = i; &#125;&#125;void solve()&#123; int ans; for(int i = 0; i &lt; tot; ++i) p[0][prime[i]] = 1ll; for(int i = 2; i &lt;= 10000; ++i)&#123; int id = upper_bound(prime, prime + tot, i) - prime - 1; //int pp = prime[id]; if(i &amp; 1) p[i][2] = 0; else p[i][2] = 1; for(int j = 1; j &lt;= id; ++j) p[i][prime[j]] = p[i][prime[j - 1]] + p[i - prime[j]][prime[j]]; for(int j = id + 1; j &lt; tot; ++j) p[i][prime[j]] = p[i][prime[j - 1]]; if(p[i][prime[id]] &gt; 5000)&#123; ans = i; break; &#125; &#125; printf("%d\n", ans);&#125; 答案：71（蜜汁小） PE78一开始拿pe76写了很久，结果什么都没有。。。后来发现了一个很神奇的东西。12 PE79…手算…?对所有询问排个序，去个重，就差不多可以发现一些问题了。答案：73162890 PE80考虑到精度问题，我们考虑对一个大整数开根号。比如计算$\sqrt 2$的前一百位，可以改为计算$10^{100}\times \sqrt 2$的前一百位。即先把根号的值放大，然后二分出具体的值即可。12345678910111213141516171819x = 10 ** 300ans = 0for i in range(2, 100, 1): y = math.floor(math.sqrt(i) + 0.5) if y * y != i: z = i * x l = 1 r = z while r - l &gt; 0: mid = (r + l) &gt;&gt; 1 if mid * mid &lt; z: l = mid + 1 else: r = mid s = str(l) for j in range(0, 100, 1): ans += eval(s[j: j + 1])print(ans) 答案：40886 PE81水DP答案：427337 PE82根据矩阵和走路的方式建图，跑最短路即可。12 答案： PE83同上。 PE84我不会这样的神奇概率题。。。我就模拟这个游戏足够多次，然后根据访问次数判断哪三个地方访问概率最大。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int vis[49] = &#123;0&#125;, cur = 0;int curc = 0, curh = 0;int cc[20] = &#123;0&#125;, ch[20] = &#123;0&#125;;pair&lt;int, int&gt; pp[45];pair&lt;int, int&gt; getS()&#123; int i = 1 + rand() % 4, j = 1 + rand() % 4; return make_pair(i, j);&#125;int getR(int x)&#123; if(x == 7)return 15; if(x == 22)return 25; if(x == 36)return 5;&#125;int getU(int x)&#123; if(x == 7)return 12; if(x == 22)return 28; if(x == 36)return 12;&#125;void init()&#123; srand(time(NULL)); cc[rand() % 16] = 1; int i = rand() % 16; while(cc[i]) i = rand() % 16; cc[i] = 2; for(int j = 1; j &lt;= 10; ++j)&#123; i = rand() % 16; while(ch[i]) i = rand() % 16; ch[i] = j; &#125;&#125;void solve()&#123; int lst = 0; for(int i = 1; i &lt;= 100000000; ++i)&#123; pair&lt;int, int&gt; p = getS(); int d = p.first + p.second; if(p.first == p.second) lst++; else lst = 0; if(lst == 3)&#123; cur = 10, lst = 0; &#125;else&#123; int to = (cur + d) % 40; if(to == 2 || to == 17 || to == 33)&#123; int id = cc[curc]; curc = (curc + 1) % 16; if(id == 1)&#123; cur = 0; &#125;else if(id == 2)&#123; cur = 10; &#125;else&#123; cur = to; &#125; &#125;else if(to == 7 || to == 22 || to == 36)&#123; int id = ch[curh]; curh = (curh + 1) % 16; if(id == 1)&#123; cur = 0; &#125;else if(id == 2)&#123; cur = 10; &#125;else if(id == 3)&#123; cur = 11; &#125;else if(id == 4)&#123; cur = 24; &#125;else if(id == 5)&#123; cur = 39; &#125;else if(id == 6)&#123; cur = 5; &#125;else if(id == 7 || id == 8)&#123; cur = getR(to); &#125;else if(id == 9)&#123; cur = getU(to); &#125;else if(id == 10)&#123; cur = to - 3; &#125;else&#123; cur = to; &#125; &#125;else if(to == 30)&#123; cur = 10; &#125;else&#123; cur = to; &#125; &#125; vis[cur]++; &#125; for(int i = 0; i &lt; 40; ++i) pp[i] = make_pair(vis[i], i); sort(pp, pp + 40); for(int i = 39; i &gt; 36; --i) printf("%d", pp[i].second);&#125; 答案：101524 PE85小学奥数题。边长为$n,m$的矩形内部有C_{n+1}^2 C_{m+1}^2个小矩形。123456789101112ll ans = INF, maxi;void solve()&#123; for(int i = 1; i &lt;= 2000; ++i)&#123; for(int j = 1; j &lt;= 2000; ++j)&#123; ll pp = 1ll * i * j * (i + 1) * (j + 1); pp &gt;&gt;= 2; if(abs(pp - 2000000) &lt; ans) ans = abs(pp - 2000000), maxi = 1ll * i * j; &#125; &#125; printf("%lld\n", maxi);&#125; 答案：2772 PE87直接3重循环，算出所有可能即可。1234567891011121314151617181920212223242526272829303132bool vis[10005] = &#123;0&#125;;int prime[4][10005], tot[4] = &#123;0&#125;;bool dd[50000005] = &#123;0&#125;;void getP()&#123; for(int i = 2; i &lt;= 8000; ++i) if(!vis[i])&#123; for(int j = i + i; j &lt;= 8000; j += i) vis[j] = 1; prime[0][++tot[0]] = i; &#125;&#125;void solve()&#123; getP(); for(int i = 1; i &lt; 4; ++i)&#123; for(int j = 1; j &lt;= tot[i - 1]; ++j)&#123; if(1ll * prime[0][j] * prime[i - 1][j] &gt;= 50000000ll)&#123; tot[i] = j - 1; break; &#125; prime[i][j] = prime[0][j] * prime[i - 1][j]; &#125; &#125; for(int k = 1; k &lt;= tot[1]; ++k) for(int i = 1; i &lt;= tot[2]; ++i) for(int j = 1; j &lt;= tot[3]; ++j) if(prime[1][k] + prime[2][i] + prime[3][j] &lt; 50000000) dd[prime[1][k] + prime[2][i] + prime[3][j]] = 1; int ans = 0; for(int i = 1; i &lt; 50000000; ++i) ans += dd[i]; printf("%d\n", ans);&#125; 答案：1097343 PE90生成组合，然后测试即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int cb[2][10], ans = 0;void judge()&#123; int l[2]; l[0] = l[1] = 0; for(int o = 0; o &lt; 2; ++o)&#123; int flag = 0; for(int i = 0; i &lt; 6; ++i)&#123; l[o] |= (1 &lt;&lt; cb[o][i]); if(cb[o][i] == 6 || cb[o][i] == 9) flag += cb[o][i]; &#125; if(flag == 6) l[o] |= (1 &lt;&lt; 9); if(flag == 9) l[o] |= (1 &lt;&lt; 6); &#125; int flag = 1; for(int i = 1; i &lt; 10; ++i)&#123; int g = (i * i) % 10, s = (i * i) / 10; g = 1 &lt;&lt; g, s = 1 &lt;&lt; s; if(((s &amp; l[0]) &amp;&amp; (g &amp; l[1])) || (s &amp; l[1]) &amp;&amp; (g &amp; l[0]))&#123; continue; &#125;else&#123; flag = 0; break; &#125; &#125; ans += flag;&#125;void getC(int o, int index, int left)&#123; cb[o][5 - left] = index; if(!left)&#123; if(!o) for(int i = 0; i &lt;= 4; ++i) getC(1, i, 5); else&#123; judge(); &#125; return ; &#125; for(int i = index + 1; i &lt;= 10 - left; ++i) getC(o, i, left - 1);&#125;void solve()&#123; for(int i = 0; i &lt;= 4; ++i) getC(0, i, 5); printf("%d\n", ans &gt;&gt; 1);&#125; 答案：1217 PE91四重循环。。。12345678910111213141516int ans = 0;void solve()&#123; for(int i = 0; i &lt;= 50; ++i) for(int j = 0; j &lt;= 50; ++j) for(int k = 0; k &lt;= 50; ++k) for(int l = 0; l &lt;= 50; ++l)&#123; if(!i &amp;&amp; !j)continue; if(!k &amp;&amp; !l)continue; if(i == k &amp;&amp; j == l)continue; int a = i * i + j * j, b = k * k + l * l, c = (i - k) *(i - k) + (j - l) * (j - l); if(a + b == c || a + c == b || b + c == a) ans++; &#125; printf("%d\n", ans &gt;&gt; 1);&#125; 答案：14234 PE92直接模拟即可。。89的比例还是挺高的。1234567891011121314151617int ans = 0;int sqr(int x)&#123; return x * x;&#125;void solve()&#123; for(int i = 2; i &lt; 10000000; ++i)&#123; int j = i; for(; j != 1 &amp;&amp; j != 89; )&#123; int sum = 0; while(j) sum += sqr(j % 10), j /= 10; j = sum; &#125; if(j == 89)ans++; &#125; printf("%d\n", ans);&#125; 答案：8581146 PE94做一些数学上的分析根据海伦公式有：$S=\sqrt{p(p-a)(p-b)(p-c)}$其中$a,b,c$均为边长在这道题中上式可以化为$S=(p-i)\sqrt{p(p-i-1)}$或$S=(p-i)\sqrt{p(p-i+1)}$然后由于面积要求为正整数，所以需要$p(p-i+1)$为完全平方数按照这个枚举即可。123456789101112131415161718bool sqr(ll x)&#123; ll r = (ll)floor(sqrt(x) + 0.5); return r * r == x;&#125;void solve()&#123; int ans = 0; for(int i = 3; i &lt;= 333333333; i += 2)&#123; ll p = (3 * i - 1) &gt;&gt; 1; p *= (i + 1) &gt;&gt; 1; if(sqr(p)) ans += 3 * i - 1; p = (3 * i + 1) &gt;&gt; 1; p *= (i - 1) &gt;&gt; 1; if(sqr(p)) ans += 3 * i + 1; &#125; printf("%d\n", ans);&#125; 答案：518408346 PE95对每一个数DFS一遍即可。1234567891011121314151617181920212223242526272829303132int d[1000005] = &#123;0&#125;;int ans = 0, mini;int vis[1000005] = &#123;0&#125;, tot = 0;void getD()&#123; for(int i = 2; i &lt;= 1000000; ++i)&#123; int j; for(j = 1; j * j &lt; i; ++j) if(i % j == 0) d[i] += j + i / j; if(j * j == i)d[i] += j; d[i] -= i; &#125;&#125;void dfs(int x, int st)&#123; vis[x] = tot; if(d[x] &gt; 1000000 || !d[x]) return ; if(vis[d[x]] == tot)&#123; if(st &gt; ans) ans = st, mini = d[x]; return ; &#125;else if(!vis[d[x]])&#123; dfs(d[x], st + 1); &#125;&#125;void solve()&#123; getD(); for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i]) tot++, dfs(i, 1); printf("%d %d\n", mini, ans);&#125; 答案：14316 PE96把现成的数独模板丢上去即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0;int tans[10][10]=&#123;0&#125;;void get(int at)&#123; int mini=99,p,x,y,o; for(int i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(int j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini)mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1]; lis[at+1][0]=lis[p][0],lis[at+1][1]=lis[p][1]; lis[p][0]=x,lis[p][1]=y;&#125;void dfs(int at)&#123; int x=lis[at][0],y=lis[at][1]; for(int i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1,sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125;else &#123; memcpy(tans, sd, sizeof(sd)); &#125; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0,sd[x][y]=0; &#125;&#125;//0 行 1 列 2 宫 int main()&#123; int ans = 0; char s1[10], s2[10]; for(int i = 0; i &lt; 50; ++i)&#123; int tmp; tot = 0; memset(sd, 0, sizeof(sd)); memset(lis, 0, sizeof(lis)); memset(vis, 0, sizeof(vis)); scanf("%s%s", s1, s2); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp)&#123; sd[i][j]=tmp; vis[0][i][tmp]=vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; &#125;else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); ans += tans[0][0] * 100 + tans[0][1] * 10 + tans[0][2]; &#125; printf("%d\n", ans); return 0; &#125; 答案：24702 PE97python，这个我还能说什么。。。答案：8739992577 PE99化成对数比即可。1234567891011double maxm = 0;int ans;void solve()&#123; for(int i = 1; i &lt;= 1000; ++i)&#123; int b = read(), e = read(); double tt = 1.0 * e * log(b); if(tt &gt; maxm) maxm = tt, ans = i; &#125; printf("%d\n", ans);&#125; 答案：709]]></content>
      <categories>
        <category>ProjectEuler</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectEuler 1-60题解]]></title>
    <url>%2F2018%2F08%2F11%2Fpe1-60%2F</url>
    <content type="text"><![CDATA[探索新领域PE前面的题还是很比较简单的。除了某些题（如51，60）需要一定的枚举策略之外，其他题大部分靠暴力即可。 PE1直接枚举即可。1234567void solve()&#123; int sum = 0; for(int i = 3; i &lt; 1000; ++i) if(i % 3 == 0 || i % 5 == 0) sum += i; printf("%d\n", sum);&#125; 答案：233168 PE2直接枚举即可。1234567891011int fib[1005];void solve()&#123; int i, sum = 0; fib[0] = 1, fib[1] = 2; for(i = 2; fib[i - 1] &lt; 4000000; ++i) fib[i] = fib[i - 1] + fib[i - 2]; for(; i &gt;= 0; --i) if(fib[i] &lt;= 4000000 &amp;&amp; fib[i] % 2 == 0) sum += fib[i]; printf("%d\n", sum);&#125; 答案：4613732 PE3本来可以直接上Pollard-Rho，后来想了一下其实不用。因为这个数还是比较小的。1234567891011ll c = 600851475143;void solve()&#123; ll tmp = c; for(ll i = 2; i * i &lt;= c; ++i) if(tmp % i == 0)&#123; while(tmp % i == 0 &amp;&amp; tmp / i != 1) tmp /= i; if(tmp / i == 1)break ; &#125; printf("%d\n", tmp);&#125; 答案：6857 PE4枚举即可。1234567891011121314151617bool isP(int t)&#123; char s[8]; sprintf(s, "%d", t); int len = strlen(s); for(int i = 0; i &lt; (len &gt;&gt; 1); ++i) if(s[i] != s[len - i -1]) return false; return true;&#125;void solve()&#123; int ans = 0; for(int i = 100; i &lt; 1000; ++i) for(int j = 100; j &lt; 1000; ++j) if(isP(i * j)) ans = max(ans, i * j); printf("%d\n", ans);&#125; 答案：906609 PE5可以手算出答案。答案：232792560 PE6直接手算即可。答案：25164150 PE7直接用筛法计算即可。12345678910111213bool vis[1000005] = &#123;0&#125;;int sum = 0;void solve()&#123; int N = 1000000; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; sum++; if(sum == 10001)printf("%d\n", i); for(int j = i + i; j &lt;= N; j += i) vis[j] = 1; &#125; &#125;&#125; 答案：104743 PE8直接遍历即可。123456789101112131415char num[1005];ll ans = 0;void init()&#123; for(int i = 0; i &lt; 20; ++i) scanf("%s", num + i * 50);&#125;void solve()&#123; for(int i = 0; i &lt;= 987; ++i)&#123; ll pro = 1; for(int j = 0; j &lt; 13; ++j) pro *= (ll)(num[i + j] - '0'); ans = max(ans, pro); &#125; printf("%lld\n", ans);&#125; 答案：23514624000 PE9直接循环遍历，枚举即可。1234567891011ll ans;void solve()&#123; for(int i = 3; i &lt;= 1000; ++i) for(int j = 3; j &lt;= 1000; ++j) if(i * i + j * j == (1000 - i - j) * (1000 - i - j) &amp;&amp; 1000 &gt; i + j)&#123; ans = 1ll * i * j * (1000 - i - j); goto printans; &#125; printans: printf("%lld\n", ans);&#125; 答案：31875000 PE10使用筛法即可。12345678910111213bool vis[2000005] = &#123;0&#125;;ll sum = 0;void solve()&#123; int N = 2000000; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; sum += (ll)i; for(int j = i + i; j &lt;= N; j += i) vis[j] = 1; &#125; &#125; printf("%lld\n", sum);&#125; 答案：142913828922 PE11枚举即可。一个数只需要枚举4个方向。12345678910111213141516171819202122232425262728293031323334353637int dat[25][25];void init()&#123; for(int i = 0; i &lt; 20; ++i) for(int j = 0; j &lt; 20; ++j) dat[i][j] = read();&#125;void solve()&#123; int ans = 0; for(int i = 0; i &lt; 20; ++i) for(int j = 0; j &lt; 20; ++j)&#123; if(i &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j]; ans = max(ans, t); &#125; if(j &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i][j - k]; ans = max(ans, t); &#125; if(i &gt;= 3 &amp;&amp; j &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j - k]; ans = max(ans, t); &#125; if(i &gt;= 3 &amp;&amp; j &lt;= 16)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j + k]; ans = max(ans, t); &#125; &#125; printf("%d\n", ans);&#125; 答案：70600674 PE12直接枚举每一个三角形数的因子即可。123456789101112131415161718int getD(ll t)&#123; int cnt = 0; ll i; for(i = 1; i * i &lt; t; ++i) if(t % i == 0) cnt += 2; if(i * i == t)cnt++; return cnt;&#125;void solve()&#123; ll t, n; for(n = 11; ; ++n)&#123; t = n * (n + 1) &gt;&gt; 1; if(getD(t) &gt; 500) break; &#125; printf("%lld\n", t);&#125; 答案：76576500 PE13用python水过去123456y = 0for i in range(1, 101, 1): x = input() y = y + xprint(y) 答案：5537376230 PE14直接跑递归即可。看清题目，问的是什么数产生最长链而不是最长链有多长！12345678910111213141516171819202122int step[1000005] = &#123;0&#125;, ans = 0, maxi;int go(ll cur)&#123; if(cur &lt;= 1000000 &amp;&amp; step[cur]) return step[cur]; int res; if(cur &amp; 1) res = go(cur * 3 + 1) + 1; else res = go(cur &gt;&gt; 1) + 1; if(cur &lt;= 1000000) step[cur] = res; return res;&#125;void solve()&#123; step[1] = 1; for(int i = 2; i &lt;= 1000000; ++i)&#123; go(i); if(step[i] &gt; ans) ans = step[i], maxi = i; &#125; printf("%d\n", maxi);&#125; 答案：837799 PE15即为C_{40}^{20}答案：137846528820 PE16用python水过1234567x = 2 ** 1000sum = 0while x &gt; 0: sum += x % 10 x /= 10print(sum) 答案：1366 PE17神奇模拟题。了解一下英式的读数字方式即可。12345678910111213141516171819202122int ge[] = &#123;0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8&#125;;int ten[] = &#123;0, 0, 6, 6, 5, 5, 5, 7, 6, 6&#125;;void solve()&#123; int sum = 0; for(int i = 1; i &lt; 1000; ++i)&#123; if(i &lt; 20) sum += ge[i]; else if(i &lt; 100) sum += ge[i % 10] + ten[i / 10]; else &#123; sum += ge[i / 100] + 7; if(i % 100 != 0)&#123; sum += 3;//and if(i % 100 &lt; 20) sum += ge[i % 100]; else sum += ge[i % 10] + ten[(i % 100) / 10]; &#125; &#125; &#125; printf("%d\n", sum + 11);//one thousand&#125; 答案：21124 PE18一个简单的DP。12345678910111213141516int dat[17][17] = &#123;0&#125;;int dp[17][17] = &#123;0&#125;;void init()&#123; for(int i = 1; i &lt;= 15; ++i) for(int j = 1; j &lt;= i; ++j) dat[i][j] = read();&#125;void solve()&#123; for(int i = 1; i &lt;= 15; ++i) for(int j = 1; j &lt;= i; ++j) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + dat[i][j]; int ans = 0; for(int i = 1; i &lt;= 15; ++i) ans = max(ans, dp[15][i]); printf("%d\n", ans);&#125; 答案：1074 PE19模拟。1234567891011121314151617181920212223int month[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;void solve()&#123; int cury = 1901, curm = 1, curd = 1, curx = 2, ans = 0; for(; ; )&#123; curd++, curx++; if(curd &gt; month[curm])&#123; if(curm != 2)&#123; curm++, curd = 1; &#125;else&#123; if(cury % 4 != 0) curm++, curd = 1; else if(curd == 30) curm++, curd = 1; &#125; &#125; if(curm == 13) cury++, curm = 1; if(cury &gt; 2000)break; if(curx == 8)curx = 1; if(curx == 7 &amp;&amp; curd == 1)ans++; &#125; printf("%d\n", ans);&#125; 答案：171 PE20用python水过12345678910x = 1for i in range(2, 101, 1): x *= ians = 0while x &gt; 0: ans += x % 10 x /= 10print(ans) 答案：648 PE21遍历即可。1234567891011121314151617int ans = 0;int d(int x)&#123; int res = 0, i = 1; for(i = 1; i * i &lt; x; ++i) if(x % i == 0) res += i + x / i; if(i * i == x)res += i; return res - x;&#125;void solve()&#123; for(int i = 2; i &lt; 10000; ++i)&#123; int dd = d(i); if(dd != i &amp;&amp; d(dd) == i) ans += i + dd; &#125; printf("%d\n", ans &gt;&gt; 1);&#125; 答案：31626 PE22用string排序后水过。12345678910111213141516171819202122232425char s[105];string ss[10005];int n = 0;void solve()&#123; for(; ; )&#123; char c = getchar(); if(c == EOF)break; int i = 0; while((c = getchar()) != '"') s[i++] = c; s[i] = '\0'; getchar(); n++; ss[n] = s; &#125; sort(ss + 1, ss + n + 1); ll ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; int len = ss[i].length(), sum = 0; for(int j = 0; j &lt; len; ++j) sum += ss[i][j] - 'A' + 1; ans += 1ll * sum * i; &#125; printf("%lld\n", ans);&#125; 答案：871198282 PE23暴力水过12345678910111213141516171819202122232425int d[30005] = &#123;0&#125;, lis[30005], tot = 0;bool vis[30005] = &#123;0&#125;;void init()&#123; for(int i = 1; i &lt;= 28123; ++i)&#123; int j; for(j = 1; j * j &lt; i; ++j) if(i % j == 0) d[i] += j + i / j; if(j * j == i)d[i] += j; d[i] -= i; if(d[i] &gt; i) lis[++tot] = i; &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= tot; ++i) for(int j = i; j &lt;= tot; ++j) if(lis[i] + lis[j] &lt;= 28123) vis[lis[i] + lis[j]] = 1; int ans = 0; for(int i = 1; i &lt;= 28123; ++i) if(!vis[i]) ans += i; printf("%d\n", ans);&#125; 答案：4179871 PE24大力next_permutation答案：2783915460 PE25用python水过。123456789101112x = 1y = 1ind = 2while True: z = x + y x = y y = z ind += 1 if len(str(z)) == 1000: breakprint(ind) 答案：4782 PE26当余数出现循环时终止即可。12345678910111213141516171819202122int lis[1005], tot, cur[1005];int ans = 0, maxi;void solve()&#123; for(int i = 11; i &lt; 1000; ++i)&#123; int t = 10; memset(cur, 0, sizeof(cur)); for(tot = 1; ; ++tot)&#123; lis[tot] = t / i; if(!cur[t % i]) cur[t % i] = tot; else&#123; if(ans &lt; tot - cur[t % i]) ans = tot - cur[t % i], maxi = i; break ; &#125; t %= i; t *= 10; &#125; &#125; printf("%d %d\n", ans, maxi);&#125; 答案：983 PE27枚举即可。注意负数不能算质数。123456789101112131415161718192021int ans = 0, maxi;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;void solve()&#123; for(int a = -999; a &lt; 1000; ++a)&#123; for(int b = 2; b &lt;= 1000; ++b)&#123; int n; for(n = 0; ; ++n) if(!isP(n * n + a * n + b)) break; if(n &gt; ans) ans = n, maxi = a * b; &#125; &#125; printf("%d\n", maxi);&#125; 答案：-59231 PE28模拟出蛇形数阵即可。12345678910111213141516171819int d[1005][1005] = &#123;0&#125;;int dx[] = &#123;1, 0, -1, 0, 0&#125;, dy[] = &#123;0, -1, 0, 1, 1&#125;;void solve()&#123; int x = 501, y = 502, c = 2; d[501][501] = 1; for(int i = 2; i &lt;= 1000; i += 2)&#123; for(int j = 0; j &lt; 4; ++j)&#123; for(int k = 0; k &lt; i; ++k) d[x][y] = c, c++, x += dx[j], y += dy[j]; x -= dx[j], y -= dy[j]; x += dx[j + 1], y += dy[j + 1]; &#125; &#125; int sum = 0; for(int i = 1; i &lt;= 1001; ++i) sum += d[i][i] + d[i][1002 - i]; printf("%d\n", sum - 1);&#125; 答案：669171001 PE29用对数表示幂，排序去重即可。会有奇怪的精度问题。12345678910111213141516double d[10005];int tot = 0, ans = 0;bool cmp(const double&amp; d1, const double&amp; d2)&#123; return abs(d1 - d2) &lt; 1e-5;&#125;void solve()&#123; for(int i = 2; i &lt;= 100; ++i) for(int j = 2; j &lt;= 100; ++j) d[tot++] = 100.0 * j * log(i); sort(d, d + tot); double cur = -1; for(int i = 0; i &lt; tot; ++i) if(!cmp(cur, d[i])) cur = d[i], ans++; printf("%d\n", ans);&#125; 答案：9183 PE30枚举即可。上界小于100000012345678910111213int sum = 0;int qq(int x)&#123; return x * x * x * x * x;&#125;void solve()&#123; for(int i = 2; i &lt;= 1000000; ++i)&#123; int t = i, s = 0; while(t) s += qq(t % 10), t /= 10; if(s == i)sum += i; &#125; printf("%d\n", sum);&#125; 答案：443839 PE31多重背包。1234567891011121314int w[] = &#123;1, 2, 5, 10, 20, 50, 100, 200&#125;;int f[205] = &#123;0&#125;;void solve()&#123; f[0] = 1; for(int i = 0; i &lt; 8; ++i)&#123; for(int j = 1; ; j &lt;&lt;= 1)&#123; int d = j * w[i]; if(d &gt; 200)break ; for(int k = 200; k &gt;= d; --k) f[k] += f[k - d]; &#125; &#125; printf("%d\n", f[200]);&#125; 答案：73682 PE32从1234开始枚举即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int cnt[11];bool f(int x)&#123; bool flag = 1; while(x)&#123; if(cnt[x % 10] || x % 10 == 0) flag = 0; cnt[x % 10]++, x /= 10; &#125; return flag;&#125;void t(int x)&#123; while(x) cnt[x % 10]--, x /= 10;&#125;void solve()&#123; int ans = 0; for(int i = 1234; i &lt; 1000000; ++i)&#123; for(int j = 1; j &lt; 10; ++j) cnt[j] = 0; if(!f(i))continue ; for(int j = 2; j * j &lt; i; ++j)&#123; if(i % j == 0)&#123; if(!f(j))&#123; t(j); continue ; &#125;else&#123; if(!f(i / j))&#123; t(i / j), t(j); continue; &#125;else&#123; int flag = 1; for(int i = 1; i &lt; 10; ++i) if(cnt[i] != 1)&#123; flag = 0; break; &#125; if(flag)&#123; printf("%d %d %d\n", i, j, i / j); ans += i; break ; &#125;else &#123; t(j), t(i / j); continue; &#125; &#125; &#125; &#125; &#125; &#125; printf("%d\n", ans);&#125; 答案：45228 PE33枚举分子分母即可。题意有点不太好懂。1234567891011121314151617181920212223void solve()&#123; int fz = 1, fm = 1, cnt = 0; for(int i = 10; i &lt;= 99; ++i) for(int j = i + 1; j &lt;= 99; ++j)&#123; if(i % 10 == 0 &amp;&amp; j % 10 == 0) continue ; int a = i / 10, b = i % 10, c = j / 10, d = j % 10; if(a == c)&#123; if(i * d == j * b) fz *= i, fm *= j, cnt++; &#125;else if(a == d)&#123; if(i * c == j * b) fz *= i, fm *= j, cnt++; &#125;else if(b == c)&#123; if(i * d == j * a) fz *= i, fm *= j, cnt++; &#125;else if(b == d)&#123; if(i * c == j * a) fz *= i, fm *= j, cnt++; &#125; &#125; printf("%d %d\n", fm / gcd(fm, fz), cnt);&#125; 答案：100 PE34枚举即可只有2个数符合。。1234567891011121314int f[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;void solve()&#123; ll ans = 0; for(int i = 10; i &lt;= 100000000; ++i)&#123; int t = i, sum = 0; while(t) sum += f[t % 10], t /= 10; if(sum == i) ans += 1ll * i, printf("%d\n", i); &#125; printf("%lld\n", ans);&#125; 答案：40730 PE35循环枚举即可。1234567891011121314151617181920212223242526bool vis[1000005] = &#123;0&#125;;char s[16];void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; &#125;&#125;void solve()&#123; getP(); int ans = 13; for(int i = 111; i &lt; 1000000; i += 2)&#123; if(vis[i])continue; sprintf(s, "%d", i); int len = strlen(s), j; sprintf(s + len, "%d", i); for(j = len; j &gt; 0; --j)&#123; s[j + len] = '\0'; if(vis[atoi(s + j)]) break ; &#125; if(!j)ans++; &#125; printf("%d\n", ans);&#125; 答案：55 PE36直接枚举回文数即可。1234567891011121314151617181920212223ll sum = 0;int d[30];bool isP(int x)&#123; int t = x, cnt = 0; while(t) d[cnt++] = t % 10, t /= 10; for(int i = 0; i &lt; (cnt &gt;&gt; 1); ++i) if(d[i] != d[cnt - i - 1]) return false; t = x, cnt = 0; while(t) d[cnt++] = t % 2, t &gt;&gt;= 1; for(int i = 0; i &lt; (cnt &gt;&gt; 1); ++i) if(d[i] != d[cnt - i - 1]) return false; return true;&#125;void solve()&#123; for(int i = 1; i &lt; 1000000; i += 2) if(isP(i)) sum += 1ll * i; printf("%lld\n", sum);&#125; 答案：872187 PE37枚举即可1234567891011121314151617181920212223242526272829303132333435int sum = 0, ten[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000&#125;;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool is(int x)&#123; int t = x; if(!isP(x))return false; for(; ; )&#123; t /= 10; if(!t)break; if(!isP(t))return false; &#125; int m; for(m = 1; ten[m] &lt; x; m++) ; for(m--; m &gt; 0; --m)&#123; x %= ten[m]; if(!isP(x))return false; &#125; return true;&#125;void solve()&#123; int cnt = 0; for(int i = 11; cnt &lt; 11 &amp;&amp; i &lt; 1000000; i += 2)&#123; if(i % 10 != 3 &amp;&amp; i % 10 != 7) continue ; if(is(i)) cnt++, sum += i, printf("%d\n", i); &#125; printf("%d\n", sum);&#125; 答案：748317 PE38枚举这样的数即可12345678910111213141516171819202122232425262728int ans = 0;bool vis[11];void solve()&#123; char s[15]; for(int i = 2; i &lt; 10000; ++i)&#123; memset(vis, 0, sizeof(vis)); int cnt = 0, flag = 1, j; for(j = 1; flag &amp;&amp; cnt &lt; 9 &amp;&amp; j &lt; 10; ++j)&#123; int t = i * j; while(t)&#123; if(t % 10 == 0 || vis[t % 10])&#123; flag = 0; break; &#125;else vis[t % 10] = 1, cnt++, t /= 10; &#125; &#125; if(cnt == 9 &amp;&amp; flag)&#123; s[0] = '\0'; for(int k = 1, st = 0; k &lt; j; ++k) sprintf(s + st, "%d", k * i), st = strlen(s); ans = max(ans, atoi(s)); &#125; &#125; printf("%d\n", ans);&#125; 答案：932718654 PE39循环枚举即可1234567891011121314int ans = 0, maxi;void solve()&#123; for(int i = 12; i &lt;= 1000; ++i)&#123; int cnt = 0; for(int j = 3; j &lt;= i / 3; ++j)&#123; for(int k = j + 1; k &lt; i - j - j &amp;&amp; k &lt; (i - j) &gt;&gt; 1; ++k) if(j * j + k * k == (i - j - k) * (i - j - k)) cnt++; if(cnt &gt; ans) ans = cnt, maxi = i; &#125; &#125; printf("%d\n", maxi);&#125; 答案：840 PE40貌似只能枚举。。。数据还特别大。跑了几分钟才跑出来。123456789101112131415161718int len = 0;char s[1000105];int c(int x)&#123; return s[x - 1] - '0';&#125;void solve()&#123; s[0] = '\0'; for(int i = 1; len &lt; 1000000; ++i)&#123; sprintf(s + len, "%d", i); if(i &lt; 10)len++; else if(i &lt; 100)len += 2; else if(i &lt; 1000)len += 3; else if(i &lt; 10000)len += 4; else if(i &lt; 100000)len += 5; else if(i &lt; 1000000)len += 6; &#125; printf("%d\n", c(1) * c(10) * c(100) * c(1000) * c(10000) * c(100000) * c(1000000));&#125; 答案：210 PE41从长度为9的排列开始，一直向下尝试。123456789101112131415161718int p[] = &#123;7, 6, 5, 4, 3, 2, 1&#125;;bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;void solve()&#123; while(prev_permutation(p, p + 7))&#123; printf("x"); int x = 0; for(int i = 0; i &lt; 7; ++i) x = x * 10 + p[i]; if(isP(x))break ; &#125; for(int i = 0; i &lt; 7; ++i) printf("%d", p[i]);&#125; 答案：7652413 PE42字符串题。。。123456789101112131415161718int seq[10005], ans = 0;char s[16];void solve()&#123; for(int i = 1; i &lt;= 10000; ++i) seq[i - 1] = i * (i + 1) &gt;&gt; 1; for(; ; )&#123; char c = getchar(); if(c == EOF)break; int i = 0, sum = 0; while((c = getchar()) != '"') s[i++] = c, sum += c - 'A' + 1; s[i] = '\0'; getchar(); if(*lower_bound(seq, seq + 10000, sum) == sum) ans++; &#125; printf("%d\n", ans);&#125; 答案：162 PE43枚举排列即可。12345678910111213141516171819202122int p[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int pr[] = &#123;2, 3, 5, 7, 11, 13, 17&#125;;ll ans = 0;void solve()&#123; do&#123; int flag = 1; for(int i = 1; i &lt; 8; ++i)&#123; int j = p[i] * 100 + p[i + 1] * 10 + p[i + 2]; if(j % pr[i - 1] != 0)&#123; flag = 0; break; &#125; &#125; if(flag)&#123; ll x = 0; for(int i = 0; i &lt; 10; ++i) x = x * 10 + p[i]; ans += 1ll * x; &#125; &#125;while(next_permutation(p, p + 10)); printf("%lld\n", ans);&#125; 答案：16695334890 PE44枚举。但是数据有一点吓人。123456789101112131415161718192021222324ll seq[40005];void solve()&#123; for(ll i = 1; i &lt;= 40000; ++i) seq[i - 1] = i * (3 * i - 1) &gt;&gt; 1; int i; for(i = 0; i &lt; 40000; ++i)&#123; int flag = 0; for(int j = 0; j &lt; 40000; ++j)&#123; ll sum = seq[i] + seq[j]; int index = lower_bound(seq, seq + 40000, sum) - seq; if(index == 40000) break; if(seq[index] == sum)&#123; index = lower_bound(seq, seq + 40000, sum + seq[j]) - seq; if(index &lt; 40000 &amp;&amp; seq[index] == sum + seq[j])&#123; flag = 1; break; &#125; &#125; &#125; if(flag)break ; &#125; printf("%lld\n", seq[i]);&#125; 答案：5482660 PE45枚举即可。三角形数有点大。12345678910111213141516ll sqr(ll x)&#123; ll r = (ll)floor(sqrt(x) + 0.5); if(r * r != x) return -1; return r;&#125;void solve()&#123; ll n; for(n = 286; n &lt; 1000000; ++n)&#123; ll t = n * (n + 1) &gt;&gt; 1; ll a = sqr(1 + 8 * t), b = sqr(1 + 24 * t); if(a &gt; 0 &amp;&amp; (1 + a) % 4 == 0 &amp;&amp; b &gt; 0 &amp;&amp; (1 + b) % 6 == 0) break; &#125; printf("%lld\n", n);&#125; 答案：1533776805 PE46枚举即可。123456789101112131415161718192021222324252627282930313233343536373839int prime[100005], tot = 0;bool vis[1000005] = &#123;0&#125;;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool isQ(int x)&#123; int d = (int)floor(sqrt(x) + 0.5); return d * d == x;&#125;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; prime[tot++] = i; &#125;&#125;void solve()&#123; int ans; getP(); for(int i = 35; ; i += 2)&#123; if(isP(i))continue ; int flag = 0; for(int j = 1; j &lt; tot &amp;&amp; i - prime[j] &gt; 0; ++j) if(isQ((i - prime[j]) &gt;&gt; 1))&#123; flag = 1; break ; &#125; if(!flag)&#123; ans = i; break; &#125; &#125; printf("%d\n", ans);&#125; 答案：5777 PE47找质因数即可12345678910111213141516171819202122232425int get(int x)&#123; int cnt = 0, t = x; for(int i = 2; i * i &lt;= x; ++i)&#123; if(t % i == 0)&#123; while(t % i == 0) t /= i; cnt++; &#125; if(t == 1)break; &#125; if(t != 1)cnt++; return cnt;&#125;void solve()&#123; bool b1 = 0, b2 = 0, b3 = 0, b4 = 0; int i; for(i = 6; ; ++i)&#123; if(get(i) == 4) b4 = 1; if(b1 &amp;&amp; b2 &amp;&amp; b3 &amp;&amp; b4) break; b1 = b2, b2 = b3, b3 = b4, b4 = 0; &#125; printf("%d\n", i - 3);&#125; 答案：134043 PE48大力python答案：9110846700 PE49枚举即可1234567891011121314151617181920212223242526272829303132bool vis[10005] = &#123;0&#125;;char s1[10], s2[10];void getP()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; &#125;&#125;bool cmp(int x, int y)&#123; sprintf(s1, "%d", x); sprintf(s2, "%d", y); sort(s1, s1 + 4); sort(s2, s2 + 4); return strcmp(s1, s2) == 0;&#125;void solve()&#123; getP(); int ans1 = 0, ans2 = 0; for(int i = 1489; i &lt; 10000; i += 2)&#123; if(vis[i])continue; for(int j = 2; i + j + j &lt; 10000; ++j)&#123; if(vis[i + j] || vis[i + j + j]) continue; if(!cmp(i, i + j) || !cmp(i, i + j + j)) continue; ans1 = i, ans2 = j; &#125; if(ans1)break; &#125; printf("%d%d%d\n", ans1, ans1 + ans2, ans1 + 2 * ans2);&#125; 答案：296962999629 PE50用前缀和枚举即可12345678910111213141516171819202122232425int prime[100005], tot = 0, sum[100005] = &#123;0&#125;;bool vis[1000005] = &#123;0&#125;;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; prime[++tot] = i; &#125;&#125;void solve()&#123; getP(); for(int i = 1; i &lt;= 9592; ++i) sum[i] = sum[i - 1] + prime[i]; int ans = 0; for(int i = 547; i &gt;= 0; --i)&#123; for(int j = i; sum[j] - sum[j - i] &lt; 1000000; ++j) if(!vis[sum[j] - sum[j - i]])&#123; ans = sum[j] - sum[j - i]; break ; &#125; if(ans)break ; &#125; printf("%d\n", ans);&#125; 答案：997651 PE51千万看清楚题目！替换的数字一开始就需要相同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748char s[10];bool vis[1000005] = &#123;0&#125;;int yq[6], i;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; &#125;&#125;bool change()&#123; sprintf(s, "%d", i); int cnt = 0, lst = -1; for(int i = 0; i &lt; 5; ++i) if(yq[i])&#123; if(lst &lt; 0)lst = s[i] - '0'; else if(lst &gt; 2 || lst != s[i] - '0')return false; &#125; for(int i = lst; i &lt; 10; ++i)&#123; for(int j = 0; j &lt; 5; ++j) if(yq[j]) s[j] = i + '0'; if(!vis[atoi(s)]) cnt++; &#125; return cnt == 8;&#125;bool get(int d)&#123; if(d == 5)&#123; if(change()) return true; return false; &#125; yq[d] = 0; if(get(d + 1))return true; yq[d] = 1; if(get(d + 1))return true; return false;&#125;void solve()&#123; getP(); for(i = 100001; i &lt; 1000000; i += 2)&#123; if(i % 5 == 0 || vis[i])continue; if(get(0)) break ; &#125; printf("%d\n", i);&#125; 答案：121313 PE52居然真的是142857。。。12345678910111213141516171819int pp[8];void solve()&#123; int i; for(i = 1; i &lt;= 1000000; ++i)&#123; for(int j = 1; j &lt;= 6; ++j)&#123; pp[j] = 0; for(int t = i * j; t; t /= 10) pp[j] |= (1 &lt;&lt; (t % 10)); &#125; int flag = 1; for(int j = 2; j &lt;= 6; ++j) if(pp[j - 1] != pp[j])&#123; flag = 0; break; &#125; if(flag)break ; &#125; printf("%d\n", i);&#125; 答案：142857 PE53递推即可。123456789101112131415int dat[105][105] = &#123;0&#125;;void solve()&#123; dat[1][0] = dat[1][1] = 1; int ans = 0; for(int i = 2; i &lt;= 100; ++i)&#123; dat[i][0] = 1; for(int j = 1; j &lt;= 100; ++j)&#123; if(dat[i - 1][j] + dat[i - 1][j - 1] &gt; 1000000) dat[i][j] = 1000001, ans++; else dat[i][j] = dat[i - 1][j] + dat[i - 1][j - 1]; &#125; &#125; printf("%d\n", ans);&#125; 答案：4075 PE54这就是个模拟题和数学有毛关系123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224int p[2][6][2], ans = 0;int tab[128];int cnt[2][5], vcnt[2][19];void init()&#123; char cd[4]; for(int o = 0; o &lt; 2; ++o)&#123; for(int i = 0; i &lt; 5; ++i)&#123; scanf("%s", cd); p[o][i][1] = tab[cd[1]]; if(cd[0] == 'T') p[o][i][0] = 9; if(cd[0] == 'J') p[o][i][0] = 10; if(cd[0] == 'Q') p[o][i][0] = 11; if(cd[0] == 'K') p[o][i][0] = 12; if(cd[0] == 'A') p[o][i][0] = 13; if(isdigit(cd[0])) p[o][i][0] = cd[0] - '0' - 1; &#125; &#125; memset(cnt, 0, sizeof(cnt)); memset(vcnt, 0, sizeof(vcnt));&#125;int getRank(int o)&#123; for(int i = 0; i &lt; 5; ++i) cnt[o][p[o][i][1]]++, vcnt[o][p[o][i][0]]++; int flag1 = 0, flag2 = 0, flag3 = 0; for(int i = 0; i &lt; 4; ++i) if(cnt[o][i] == 5)&#123; flag1 = 1; if(vcnt[o][9] &amp;&amp; vcnt[o][10] &amp;&amp; vcnt[o][11] &amp;&amp; vcnt[o][12] &amp;&amp; vcnt[o][13]) return 10; else&#123; for(int j = 1; j &lt; 9; ++j) if(vcnt[o][j] &amp;&amp; vcnt[o][j + 1] &amp;&amp; vcnt[o][j + 2] &amp;&amp; vcnt[o][j + 3] &amp;&amp; vcnt[o][j + 4]) return 9; &#125; &#125; for(int i = 1; i &lt;= 13; ++i) if(vcnt[o][i] == 4) return 8; else if(vcnt[o][i] == 3)&#123; flag2 = 1; for(int j = 1; j &lt;= 13; ++j)&#123; if(j == i)continue; if(vcnt[o][j] == 2) return 7; &#125; &#125;else if(vcnt[o][i] == 2) flag3++; if(flag1)return 6; for(int j = 1; j &lt;= 9; ++j) if(vcnt[o][j] &amp;&amp; vcnt[o][j + 1] &amp;&amp; vcnt[o][j + 2] &amp;&amp; vcnt[o][j + 3] &amp;&amp; vcnt[o][j + 4]) return 5; if(flag2)return 4; if(flag3 == 2)return 3; else if(flag3 == 1)return 2; return 1;&#125;bool judge1(int lim)&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == lim)&#123; maxi[i] = j; break; &#125; &#125; return maxi[0] &gt; maxi[1]; &#125;bool judge1(int lim, int lf)&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == lim)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1]) return judge1(lf); else return maxi[0] &gt; maxi[1];&#125;bool judge2()&#123; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] &gt; vcnt[1][j]) return true; else if(vcnt[0][j] &lt; vcnt[1][j]) return false; &#125;&#125;bool judge3()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 3)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; maxi[0] = maxi[1] = 0; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(maxi[0])maxi[1] = j; else maxi[0] = j; &#125; &#125; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[1][j] == 1)&#123; if(maxi[0] &gt; j) return true; else if(maxi[0] &lt; j) return false; else&#123; for(--j; j &gt;= 1; --j) if(vcnt[1][j] == 1) return maxi[1] &gt; j; &#125; &#125; &#125; &#125;else return maxi[0] &gt; maxi[1];&#125;bool judge4()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 2)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; int maxii = maxi[0]; for(int i = maxii - 1; i &gt;= 1; ++i) if(vcnt[0][i] == 2)&#123; if(vcnt[1][i] == 2)&#123; for(int j = 13; j &gt;= 1; --j) if(vcnt[0][j] == 1 || vcnt[1][j] == 1) return vcnt[0][j] &gt; vcnt[1][j]; &#125;else return true; &#125;else if(vcnt[1][i] == 2) return false; &#125;else return maxi[0] &gt; maxi[1];&#125;bool judge5()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 2)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(vcnt[1][j] == 1)&#123; for(--j; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(vcnt[1][j] == 1)&#123; for(--j; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)return true; else if(vcnt[1][j] == 1)return false; &#125; &#125;else return true; &#125;else if(vcnt[1][j] == 1) return false; &#125; &#125;else return true; &#125;else if(vcnt[1][j] == 1) return false; &#125; &#125;else return maxi[0] &gt; maxi[1];&#125;void solve()&#123; int r1 = getRank(0), r2 = getRank(1); if(r1 &gt; r2)ans++; else if(r1 == r2)&#123; int flag = 0; if(r1 == 9 || r1 == 5) flag = judge1(1); if(r1 == 8) flag = judge1(4, 1); if(r1 == 7) flag = judge1(3); if(r1 == 6 || r1 == 1) flag = judge2(); if(r1 == 4) flag = judge3(); if(r1 == 3) flag = judge4(); if(r1 == 2) flag = judge5(); if(flag) ans++; &#125; printf("%d\n", ans);&#125;int main()&#123; freopen("a.in", "r", stdin); tab['C'] = 0, tab['D'] = 1, tab['H'] = 2, tab['S'] = 3; for(int i = 0; i &lt; 1000; ++i)&#123; init(); solve(); &#125; return 0;&#125; 答案：376 PE55还是用python水过1234567891011121314151617181920212223242526ans = 0def rev(x): s = str(x) return s[::-1]def judge(x): s = str(x) l = len(s) for i in range(0, l &gt;&gt; 1, 1): if s[i] != s[l - i - 1]: return 0 return 1for i in range(5, 10000, 1): x = i flag = 0 for j in range(1, 50, 1): x += string.atoi(rev(x)) if judge(x): flag = 1 break if flag == 0: ans += 1print(ans) 答案：249 PE56用python水过12345678910111213ans = 0for i in range(1, 100, 1): for j in range(1, 100, 1): x = i ** j sum = 0 while x &gt; 0: sum += x % 10 x /= 10 if sum &gt; ans: ans = sumprint(ans) 答案：972 PE57用python水过答案：153 PE58相当于PE28的加强版。数据很大！很大！不能模拟！123456789101112131415161718192021bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i)&#123; if(x % i == 0) return false; &#125; return true;&#125;void solve()&#123; int d, cnt = 0, cur = 1; for(d = 1; ; ++d)&#123; for(int i = 0; i &lt; 4; ++i)&#123; cur += d &lt;&lt; 1; if(isP(cur)) cnt++; &#125; double p = 1.0 * cnt / (4 * d + 1); if(p &lt; 0.1) break; &#125; printf("%d\n", d &lt;&lt; 1 | 1);&#125; 答案：26241 PE59用了一个剪枝就ok了。123456789101112131415161718192021222324252627282930313233int s[100005], n = 0, ss[100005];void init()&#123; while(scanf("%d,", &amp;s[n]) == 1) n++;&#125;/*void solve()&#123; int cc[4]; for(int i = 0; i &lt; 26; ++i) for(int j = 0; j &lt; 26; ++j) for(int k = 0; k &lt; 26; ++k)&#123; cc[0] = i + 'a', cc[1] = j + 'a', cc[2] = k + 'a'; int flag = 0; for(int t = 0; t &lt; n; ++t)&#123; ss[t] = (s[t] ^ cc[t % 3]); if(ss[t] == '`' || ss[t] == '|')&#123; flag = 1; break; &#125; &#125; if(!flag)&#123; for(int t = 0; t &lt; n; ++t) printf("%c", ss[t]); printf("\n%c%c%c\n", cc[0], cc[1], cc[2]); &#125; &#125;&#125;*/void solve()&#123; int cc[] = &#123;'g', 'o', 'd'&#125;, ans = 0; for(int i = 0; i &lt; n; ++i) ans += (s[i] ^ cc[i % 3]); printf("%d\n", ans);&#125; 答案：107359（密钥：god） PE60采用一定的枚举策略即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool vis[10005] = &#123;0&#125;;int prime[10005], tot = 2;int ans = INF, c[10];set&lt;int&gt; st[10005];int getL(int x)&#123; if(x &lt; 10)return 10; if(x &lt; 100)return 100; if(x &lt; 1000)return 1000; if(x &lt; 10000)return 10000;&#125;bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool judge(int x1, int x2)&#123; if(st[x1].count(x2)) return false; int l1 = getL(x1), l2 = getL(x2); if(!isP(x1 + l1 * x2) || !isP(x2 + l2 * x1))&#123; st[x1].insert(x2); return false; &#125; return true;&#125;void getP()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; &#125; prime[0] = 3, prime[1] = 7; for(int i = 11; i &lt; 10000; i += 2) if(!vis[i]) prime[tot++] = i;&#125;void getC(int index, int left, int sum)&#123; c[left] = prime[index]; for(int i = left + 1; i &lt; 5; ++i) if(!judge(c[i], prime[index])) return ; if(sum &gt;= ans)return ; if(left == 0)&#123; ans = sum; return ; &#125; for(int i = index + 1; i &lt;= tot - left; ++i) getC(i, left - 1, sum + prime[i]);&#125;void solve()&#123; getP(); for(int i = 0; i &lt;= tot - 5; ++i) getC(i, 4, prime[i]); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ProjectEuler</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待更 斐波那契系列问题]]></title>
    <url>%2F2018%2F08%2F10%2Fproblem-fibonacci%2F</url>
    <content type="text"><![CDATA[我不会数学orz 题解首先看一个喜闻乐见的题目 $\forall x\in \mathbb{N}^*,(x,1)$可行。$x=1$时此数列即为斐波那契数列（以下用$F(n)$代替）。先证：$gcd(F(n),F(n-1)) = 1\quad (1)$证明：由辗转相除：$gcd(F(n), F(n-1))=gcd(F(n-1),F(n-2))=…=gcd(F(2),F(1))=1$ 再证：$F(m+n)=F(n+1)F(m)+F(m-1)F(n)\quad (2)$证明：$F(m+n)=F(m+n-1)+F(m+n-2)$$=2F(m+n-2)+F(m+n-3)$$=3F(m+n-3)+2F(m+n-4)$$=…=F(i+1)F(m+n-i)+F(i)F(m+n-i-1)$$=F(n+1)F(m)+F(m-1)F(n)$ 因此：$gcd(F(m),F(n))$$=gcd(F(n+1)F(m-n)+F(n)F(m-n-1),F(n))$（由$(2)$）$=gcd(F(n+1)F(m-n),F(n))$而由$(1)$，$F(n+1)$和$F(n)$互质故$gcd(F(m),F(n))=gcd(F(m-n),F(n))$相当于对$F$的下标做辗转相除所以最后的答案即为$F(gcd(m,n))$ $x\ge 2$时，$(1)(2)$也均满足$Q.E.D.$ 斐波那契的模问题]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEOI2014 南园满地堆轻絮]]></title>
    <url>%2F2018%2F08%2F10%2Fluogu4105%2F</url>
    <content type="text"><![CDATA[题目链接 题解容易看出$Ans$越大，数列调整的余地越大，数列就越有可能变成一个不下降序列。所以考虑二分答案，然后从头到尾遍历，尽量保持数列的不下降性。无法保持则判断为当前答案过小。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, s[5000005];ll a, b, c, d, mod;int f(ll x)&#123; ll res = (b + a * x) % mod; res = (res * x + c) % mod; res = (res * x + d) % mod; return (int)res;&#125;bool C(int g)&#123; int bef = max(1, s[1] - g); for(int i = 2; i &lt;= n; ++i)&#123; if(s[i] - g &gt;= bef) bef = s[i] - g; else if(s[i] + g &lt; bef) return false; &#125; return true;&#125;void init()&#123; n = read(); a = read(), b = read(), c = read(), d = read(); s[1] = read(), mod = read(); s[0] = 0; for(int i = 2; i &lt;= n; i++) s[i] = (f(s[i - 2]) + f(s[i - 1])) % mod;&#125;void solve()&#123; int l = 0, r = mod; while(r - l)&#123; int mid = (r + l) &gt;&gt; 1; if(C((r + l) &gt;&gt; 1)) r = mid; else l = mid + 1; &#125; printf("%d\n", r);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1382 楼房]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1382%2F</url>
    <content type="text"><![CDATA[题目链接 题解利用线段树进行区间取$max$和单点查询即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, len, x[200005], xx[200005], h[100005];int size, seg[800005] = &#123;0&#125;, tag[800005] = &#123;0&#125;, _a, _b, val;int node[400005][2], tot = 0;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) h[i] = read(), x[i &lt;&lt; 1] = read(), x[i &lt;&lt; 1 | 1] = read(); memcpy(xx, x, sizeof(xx)); sort(xx, xx + n + n); len = unique(xx, xx + n + n) - xx; for(size = 1; size &lt; len; size &lt;&lt;= 1);&#125;void pushdown(int id)&#123; if(tag[id])&#123; seg[id &lt;&lt; 1] = max(seg[id &lt;&lt; 1], tag[id]); tag[id &lt;&lt; 1] = max(tag[id &lt;&lt; 1], tag[id]); seg[id &lt;&lt; 1 | 1] = max(seg[id &lt;&lt; 1 | 1], tag[id]); tag[id &lt;&lt; 1 | 1] = max(tag[id &lt;&lt; 1 | 1], tag[id]); tag[id] = 0; &#125;&#125;void update(int id, int l, int r)&#123; if(l &gt; _b || r &lt; _a)return ; if(l &gt;= _a &amp;&amp; r &lt;= _b)&#123; seg[id] = max(seg[id], val); tag[id] = max(tag[id], val); return ; &#125; pushdown(id); update(id &lt;&lt; 1, l, (l + r) &gt;&gt; 1); update(id &lt;&lt; 1 | 1, (l + r + 1) &gt;&gt; 1, r); seg[id] = max(seg[id &lt;&lt; 1], seg[id &lt;&lt; 1 | 1]);&#125;int query(int id, int l, int r)&#123; if(l &gt; _b || r &lt; _a)return 0; if(l &gt;= _a &amp;&amp; r &lt;= _b)return seg[id]; pushdown(id); return max(query(id &lt;&lt; 1, l, (l + r) &gt;&gt; 1), query(id &lt;&lt; 1 | 1, (l + r + 1) &gt;&gt; 1, r));&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; _a = lower_bound(xx, xx + len, x[i &lt;&lt; 1]) - xx + 1; _b = lower_bound(xx, xx + len, x[i &lt;&lt; 1 | 1]) - xx; val = h[i]; update(1, 1, size); &#125; node[tot][0] = xx[0], node[tot++][1] = 0; _a = _b = 1; int h_last = query(1, 1, size); if(h_last) node[tot][0] = xx[0], node[tot++][1] = h_last; for(int i = 1; i &lt; len; ++i)&#123; _a = _b = i + 1; int h_cur = query(1, 1, size); if(h_cur != h_last) node[tot][0] = xx[i], node[tot++][1] = h_last, node[tot][0] = xx[i], node[tot++][1] = h_cur, h_last = h_cur; &#125; printf("%d\n", tot); for(int i = 0; i &lt; tot; ++i) printf("%d %d\n", node[i][0], node[i][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Balanced Lineup]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2880%2F</url>
    <content type="text"><![CDATA[题目链接 题解ST表模板题…线段树估计会挂，因为询问太多了。12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int f1[16][50005],dat[50005],f2[16][50005],N,Q; int max(int a,int b)&#123;return (a&gt;b)?a:b;&#125;int min(int a,int b)&#123;return (a&lt;b)?a:b;&#125;void sttable(int n)&#123; int i,j,p; memcpy(f1[0],dat,sizeof(dat)); memcpy(f2[0],dat,sizeof(dat)); for(i=1;(1&lt;&lt;i)&lt;=n;i++) for(j=0,p=(1&lt;&lt;(i-1));j&lt;n-p;j++) f1[i][j]=max(f1[i-1][j],f1[i-1][j+p]), f2[i][j]=min(f2[i-1][j],f2[i-1][j+p]);//同时对最大最小两个st表初始化，递推&#125;int rmq(int l,int r)&#123; int k=0;while((1&lt;&lt;(k+1))&lt;(r-l+1))k++; return max(f1[k][l],f1[k][r-(1&lt;&lt;k)+1])-min(f2[k][l],f2[k][r-(1&lt;&lt;k)+1]);//询问部分&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;Q); int i,l,r; for(i=0;i&lt;N;i++) scanf("%d",&amp;dat[i]); sttable(N); for(i=0;i&lt;Q;i++) scanf("%d%d",&amp;l,&amp;r), printf("%d\n",rmq(l-1,r-1)); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 遥远的行星]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3198%2F</url>
    <content type="text"><![CDATA[题目链接 题解看到数据规模就吓傻了这题暴力是根本过不动的。所以我们可以用一些玄学方法在这题中，有一个很关键的提示： 误差不超过$5\%$即可 可以发现在这种条件下正确答案的范围非常宽所以可以采用近似的方法，不必每一个$j-i$都计算，可以用一个值来代替某一个范围内的$j-i$。具体的程序实现是：对于一个$j$，有编号为i\in [1,a_j]的行星给他力将此区间分成$k$段，每段的分母$j-i$近似用该区间中点的分母表示$k$可以自行选一个定值，这里用的是100。可以往小里取，不TLE即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;int n;double a,m[100005],sum[100005],f[100005];void init()&#123; scanf("%d%lf",&amp;n,&amp;a); sum[0]=m[0]=0; for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;m[i]), sum[i]=sum[i-1]+m[i];&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; double s=a*i,mid; int lim=floor(s);//[1,ai] if(lim&lt;=100)&#123;//区间长不足100直接算 for(int j=1;j&lt;=lim;j++) f[i]+=m[i]*m[j]/(i-j); &#125;else&#123; int l2=lim/100; for(int j=l2;j&lt;=l2*100;j+=l2) mid=(i-j+i-j+l2-1)*0.5,//算中点的分母 f[i]+=(sum[j]-sum[j-l2])*m[i]/mid; for(int j=l2*100+1;j&lt;=lim;j++)//不足100直接算 f[i]+=m[i]*m[j]/(i-j); &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%.6lf\n",f[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>非完美算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2009 学校食堂Dining]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2157%2F</url>
    <content type="text"><![CDATA[题目链接 题解“写过小笼包你就会发现这是一道模板题”一开始我是这么想的，结果发现这样可能会出现没有头的情况。并且要找到头是一件非常困难的事。所以就用普通状压，设$f(i,j,k)$表示前$i-1$个人吃完，$i~i+7$个人吃饭的状态是$j$，上一个吃的人是$i+k$。就可以愉快的转移了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000#define offset 8using namespace std;typedef long long ll;int n,d[1005],t[1005],f[1005][257][17];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int val(int x,int y)&#123; return (x&lt;=0)?0:(t[x]^t[y]);&#125;void solve()&#123; for(int i=1;i&lt;=n+1;i++) for(int j=0;j&lt;(1&lt;&lt;8);j++) for(int k=-8;k&lt;=7;k++) f[i][j][k+offset]=INF; f[1][0][-1+offset]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;(1&lt;&lt;8);j++)&#123; for(int k=-8;k&lt;=7;k++)&#123; if(f[i][j][k+offset]&gt;=INF)continue; if(j&amp;1)//自己吃过了 f[i+1][j&gt;&gt;1][k-1+offset]=min(f[i+1][j&gt;&gt;1][k-1+offset],f[i][j][k+offset]); else&#123; int r=n+2; for(int u=1,v=0;v&lt;8;v++,u&lt;&lt;=1)&#123; if((j&amp;u)==0)&#123; if(i+v&gt;r)break; r=min(r,i+v+d[i+v]);//不能在这之后选人 f[i][j|u][v+offset]=min(f[i][j|u][v+offset],f[i][j][k+offset]+val(i+k,i+v)); &#125; &#125; &#125; &#125; &#125; &#125;&#125;void init()&#123; int T=read(); while(T--)&#123; n=read(),d[0]=n+2; for(int i=1;i&lt;=n;i++)t[i]=read(),d[i]=read(); solve(); int ans=INF; for(int i=-8;i&lt;=-1;i++) ans=min(ans,f[n+1][0][i+offset]); printf("%d\n",ans); &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1999 高维正方体]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1999%2F</url>
    <content type="text"><![CDATA[题目链接 题解给出一种这个题的思考方法吧…设$f(i,j)$表示$i$维超立方体中$j$维元素的个数。先思考：点的个数如何变化？很显然，每升一维，点的个数就多一倍，故$f(i,0)=2^i$。而根据规律可以看出，某一维在升维之后，他自己这一维复制了一份，同时原来比他小一维德元素也升为了他这一维。故得到递推关系：$f(i,j)=2f(i-1,j)+f(i-1,j-1)$。结合以上两个方程，很容易想到这是一个$O(n^2)$的dp。但显然不行。这么做复杂度大的太可怕。可以发现，这个递推模型和杨辉三角很像。所以我们写一下：观察发现，每一斜列都构成一个高阶等差数列。换言之，第$q$个斜列上的数都可以表示成一个$q-1$次多项式。计算后可以发现，对于同样的$q$，右边的第$k$个位置的数总是比左边的同样位置的数大$2^{q-1}$倍。根据这个就可以发现，下面每一个数的通项为C_i^j\times 2^{i-j}所以答案就是C_a^b\times 2^{a-b}。之后组合数取模什么的拿线性逆元做即可。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define P 1000000007llusing namespace std;typedef long long ll;ll a,b,inv[100005];ll q_pow(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%P; a=(a*a)%P,b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; scanf("%lld%lld",&amp;a,&amp;b);&#125;void solve()&#123; if(a&lt;b)&#123; printf("0\n"); return ; &#125;//特判 inv[1]=1; for(ll i=2;i&lt;=100000;i++) inv[i]=(P-(P/i))*inv[P%i]%P;//逆元 ll ans=q_pow(2,a-b); for(int i=1;i&lt;=b;i++) ans=ans*(a-i+1)%P, ans=ans*inv[i]%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI2014预选 小笼包]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2808%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题很厉害。我也是看了题解才知道怎么做的。（官网日文真心看不懂）（如果日语学的很6的话可以看这里：链接）我们看到这道题，首先想到的是什么？对！就是爆搜。…先留着这个看似不切实际的想法。我们暴力算排列，然后$O(n^2)$算结果，复杂度不用想，肯定上天。然后观察：$D$最大不过$7$，然后我们又有上面那个算法，所以现在考虑用这个条件来优化转移。设$dp(i,Perm)$，其中$Perm$表示从$i-maxd+1$吃到第$i$个小笼包的顺序，$i$表示当前正在处理第$i$个。则这样就可以状态转移了，每一次向前推进一位，然后对于前面的排列，我们试图插入新的小笼包，并且计算新的小笼包在其中造成的贡献。（被泼到，泼别的）时间复杂度O(D_{max}!P)（官方说是$P$一个多项式，算了也别管了）这种新的状压方式学到了。不过可能看的时候会有疑问：$k$为什么会到$7$呢？还是要考虑到原来整个排列全被枚举的情况。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int f[2][7000000]=&#123;0&#125;,permu[10],permu2[10];//在第i次吃第j个小笼包int n,d[105],a[105]; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init_permu()&#123; for(int j=0;j&lt;7;j++) permu[j]=j;&#125; int ptoi(int *L)&#123; int res=0; for(int i=0;i&lt;7;i++) res=res*10+L[i]; return res;&#125;void init()&#123; n=read(); for(int i=0;i&lt;n;i++)d[i]=read(); for(int i=0;i&lt;n;i++)a[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;n;i++)&#123; init_permu(); int B=(i&amp;1),B_=(B^1),cnt,code1,code2; do&#123; code1=ptoi(permu); for(int k=0;k&lt;=7;k++)&#123; //枚举新加入的位置 cnt=0; int contribution=0; //在第i个被吃掉之前他被泼到的 for(int kk=0;kk&lt;k;kk++)&#123; int loc=i-1-permu[kk]; if(loc&gt;=0&amp;&amp;permu[kk]+1&lt;=d[loc]) contribution+=a[loc]; if(permu[kk]&lt;6) permu2[cnt++]=permu[kk]+1; &#125; permu2[cnt++]=0; //在第i个被吃掉之后他被泼到的 for(int kk=k;kk&lt;7;kk++)&#123; int loc=i-1-permu[kk]; if(loc&gt;=0&amp;&amp;permu[kk]+1&lt;=d[i]) contribution+=a[i]; if(permu[kk]&lt;6) permu2[cnt++]=permu[kk]+1; &#125; code2=ptoi(permu2); f[B_][code2]=max(f[B_][code2],f[B][code1]+contribution); &#125; f[B][code1]=0; &#125;while(next_permutation(permu,permu+7)); &#125; int ans=0; init_permu(); do&#123; ans=max(ans,f[n&amp;1][ptoi(permu)]); &#125;while(next_permutation(permu,permu+7)); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>JOI</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2013 数列]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3228%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题我用了一种不够数学的方法来解。30分做法：DP，设$f(i,j)$表示第$i$天以$j$为当天股价的方案数，则 f(i,j)=\begin{cases} 1\quad (i=1)\\ \sum_{k=1}^M f(i-1,j-k) \quad(i>1)\end{cases}答案为$\sum_{j=1}^N f(K,j)$数据太大，只能拿30分。100分做法：在30分做法上做文章。可以发现，对于所有$i\le N-(K-1)M$的$f(0,i)$而言，他们对最终答案的贡献是一样的。（因为他们可以给出的贡献的上界都是$i+(K-1)M$，下界都是$i+K-1$）但对于更大的$i$，由于要求的答案范围的上界为$N$，所以他们对更高股价的贡献是要去掉的。问题转化为求$N-(K-1)M$个相同的贡献值的和以及$(K-1)M$个不同贡献值的和。对于前一个子问题，我们考虑一个等价的问题：从第一个格子出发，每一个格子有$M$条路通向下一个格子，问走$K-1$步的走法数，一种走法和另外一种走法相同当且仅当两条路径完全相同。由乘法原理知答案为$M^{K-1}$。所以前一个子问题的答案为$[N-(K-1)M]M^{K-1}$。后一个子问题不好办。怎么弄？假设，画图，观察。（这是我的方法，当然有其他方法发现这个规律。）设$M=3,K=4$，则作图：（$i$表示天数，这张表表示开始的某个$f(1,j)$对后面第$i$天答案的贡献）然后依次写出$j=N-(K-1)M+1,N-(K-1)M+2,…,N-(K-1)$时对答案的贡献。（$j&gt;N-(K-1)$时，$j$对答案贡献为$0$。）这是个很对称的图形，沿对角线翻折后发现每一列都变为了完整的一列。一列的和我们之前已经求了出来，就是$M^{K-1}$。设其内部所有数的和为$sum$，则 sum= \frac{(K-1)(M-1)}{2} M^{K-1}总答案即为 \left( N-\frac{(K-1)(M+1)}{2}\right)M^{K-1}使用快速幂和逆元计算即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;ll N,M,K,P;ll Pow(ll a,ll b,ll c)&#123; ll res=1; a%=c; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%lld%lld%lld%lld",&amp;N,&amp;K,&amp;M,&amp;P);&#125;void solve()&#123; ll ans1=Pow(M,K-1,P); ll inv2,ans; N%=P,ans=(N*ans1)%P; if(M&amp;1)inv2=(M+1)/2,inv2=inv2*M%P; else inv2=M/2,inv2=inv2*(M+1)%P; inv2=inv2*(K-1)%P; inv2=inv2*Pow(M,K-2,P)%P; ans+=P,ans=(ans-inv2)%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 彩票]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2236%2F</url>
    <content type="text"><![CDATA[题目链接 题解暴搜加个上下界的判断就A了顺带一题，这题卡精度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,x,y,ans=0;double sum[55]=&#123;0&#125;,lim,EPS=1e-11;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void dfs(int at,int lst,double t)&#123; //再取n-at个数 if(at==n)&#123; if(t-lim&lt;EPS&amp;&amp;t-lim&gt;-EPS)ans++; return ; &#125; if(t+sum[m]-sum[m-n+at]-EPS&gt;lim)return ; //加了最小的还是超过了 for(int i=lst+1;i&lt;=m-n+at+1;i++)&#123; if(t+sum[i+n-at-1]-sum[i-1]+EPS&lt;lim)return ; //加了最大的还是达不到 dfs(at+1,i,t+1.0/(double)i); &#125; &#125;void init()&#123; n=read(),m=read(),x=read(),y=read(); for(int i=1;i&lt;=m;i++) sum[i]=sum[i-1]+1.0/(double)i; lim=x,lim/=(double)y;&#125;void solve()&#123; for(int i=1;i&lt;=m-n+1;i++) dfs(1,i,1.0/(double)i); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2001 求正整数]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1128%2F</url>
    <content type="text"><![CDATA[题目链接 题解一看就是DP按质因数DP，转移的时候保存一下指数即可。对了，还要加上对数的优化。直接保存一个巨大的整数不是什么容易的事。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;double f[20][50005],P_[20];int F[20][50005]=&#123;0&#125;,n,P[17]=&#123;1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;int real_ans[50005]=&#123;0&#125;;int multiply_to_int(int s1[],int s2)&#123; int i,j,x=0; for(i=1;i&lt;=s1[0];i++) x+=s1[i]*s2, s1[i]=x%10000,x/=10000; while(x) s1[++s1[0]]=x%10000,x/=10000;&#125;int main()&#123; scanf("%d",&amp;n); int i,j,k,mini,cnt; double m,ans; for(i=0;i&lt;20;i++) for(j=0;j&lt;=n;j++) f[i][j]=1e9; for(i=0;i&lt;=16;i++) P_[i]=log(P[i]); for(i=1;i&lt;=n;i++) f[1][i]=(i-1)*P_[1],F[1][i]=1; for(i=1;i&lt;=15;i++) for(j=1;j&lt;=n;j++) for(k=1;j*k&lt;=n;k++)&#123; m=f[i][j]+(k-1)*P_[i+1]; if(m&lt;f[i+1][j*k]) f[i+1][j*k]=m,F[i+1][j*k]=j; &#125; for(ans=1e9,i=1;i&lt;=16;i++) if(ans&gt;f[i][n]) ans=f[i][n],mini=i; real_ans[0]=real_ans[1]=1; for(j=mini,k=n;j&gt;0;j--)&#123; cnt=k/F[j][k]; for(i=1;i&lt;cnt;i++) multiply_to_int(real_ans,P[j]); k=F[j][k]; &#125; printf("%d",real_ans[real_ans[0]]); for(i=real_ans[0]-1;i&gt;=1;i--) printf("%04d",real_ans[i]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2004 宠物收养场]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2286%2F</url>
    <content type="text"><![CDATA[题目链接 题解直接用平衡树模拟即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,cnt; int cmp(int x) const &#123; if(x==v)return -1; return x&gt;v; &#125; void maintain()&#123; siz=cnt; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[400005];int n,S=0,ans,ANS=0;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;cnt=1,tr-&gt;v=x; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); return ; &#125; tr-&gt;siz++; if(tr-&gt;v==x)&#123; tr-&gt;cnt++; &#125;else&#123; int d=tr-&gt;cmp(x); insert_tr(tr-&gt;ch[d],x); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1); &#125;&#125;void del(Tr* &amp;tr,int x)&#123; int d=tr-&gt;cmp(x); if(d==-1)&#123; if(tr-&gt;cnt&gt;1)tr-&gt;siz--,tr-&gt;cnt--; else&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),tr-&gt;siz--,del(tr-&gt;ch[d_],x); &#125; &#125; &#125;else tr-&gt;siz--,del(tr-&gt;ch[d],x);&#125; void previous(Tr *tr,int x)&#123; if(tr==NULL)return ; if(x&gt;tr-&gt;v) ans=tr-&gt;v,previous(tr-&gt;ch[1],x); else previous(tr-&gt;ch[0],x);&#125;void success(Tr *tr,int x)&#123; if(tr==NULL)return ; if(x&lt;tr-&gt;v) ans=tr-&gt;v,success(tr-&gt;ch[0],x); else success(tr-&gt;ch[1],x);&#125;void solve()&#123; n=read(); Tr *root=NULL; int cnt1=0,cnt2=0,a,b; for(int i=1;i&lt;=n;i++)&#123; a=read(),b=read(); if(!a)&#123; if(!cnt2)insert_tr(root,b),cnt1++; else&#123; int ans1,ans2,res; ans=-1,previous(root,b),ans1=ans; ans=-1,success(root,b),ans2=ans; if(ans1==-1)res=ans2; else if(ans2==-1)res=ans1; else if(ans2-b&lt;b-ans1)res=ans2; else res=ans1; del(root,res),ANS+=abs(res-b),ANS%=1000000; cnt2--; &#125; &#125;else&#123; if(!cnt1)insert_tr(root,b),cnt2++; else&#123;//有宠物 int ans1,ans2,res; ans=-1,previous(root,b),ans1=ans; ans=-1,success(root,b),ans2=ans; if(ans1==-1)res=ans2; else if(ans2==-1)res=ans1; else if(ans2-b&lt;b-ans1)res=ans2; else res=ans1; del(root,res),ANS+=abs(res-b),ANS%=1000000; cnt1--; &#125; &#125; &#125; printf("%d\n",ANS);&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2009 梦幻布丁]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3201%2F</url>
    <content type="text"><![CDATA[题目链接 题解膜一发启发式合并启发式合并从前我都只在并查集上用到过，但今天是在这种上面…这道题的做法非常暴力：直接对每一个颜色节点构建链式前向星，然后合并的时候短链合并到长链上。为什么这么做是对的呢？因为短链合并之后最少比原来要长一倍，所以合并起来最多合并$logn$次，这样均摊总时间复杂度就是$O(nlogn)$。感觉这种思想跟线段数的区间开方的分析有着异曲同工之妙…有一个细节：要记录合并时操作的真正颜色，因为短合长或者长合短在程序操作上是等价的，但颜色是不等价的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,id[1000005],ans,a[100005]=&#123;0&#125;;int cnt[1000005]=&#123;0&#125;,at[1000005]=&#123;0&#125;,_nex[100005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void _merge(int x,int y)&#123; if(x==y)return ; if(cnt[id[x]]&gt;cnt[id[y]])swap(id[x],id[y]); x=id[x],y=id[y]; if(!cnt[x])return ; //x,y号元素代表的真正颜色（程序操作上） cnt[y]+=cnt[x],cnt[x]=0; //x合并到y上 for(int i=at[x];i;i=_nex[i])&#123; if(a[i-1]==y)ans--; if(a[i+1]==y)ans--; &#125; for(int i=at[x];i;i=_nex[i])&#123; a[i]=y; if(!_nex[i])&#123; _nex[i]=at[y]; break; &#125; &#125; at[y]=at[x],at[x]=0;&#125; void init()&#123; n=read(),m=read(); int col; for(int i=1;i&lt;=n;i++)&#123; a[i]=read(),col=a[i]; if(a[i]!=a[i-1])ans++; cnt[col]++,_nex[i]=at[col],at[col]=i; &#125; for(int i=1;i&lt;=1000000;i++)id[i]=i;&#125;void solve()&#123; int opr,x,y; for(int i=1;i&lt;=m;i++)&#123; opr=read(); if(opr==2)printf("%d\n",ans); else x=read(),y=read(),_merge(x,y); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 营业额统计]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2234%2F</url>
    <content type="text"><![CDATA[题目链接 题解双向链表裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;pair&lt;ll,int&gt; P[100005];int n,nex[100005],pre[100005],id[100005];ll a[100005],ans=0;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); int i=1; while(~scanf("%lld",&amp;a[i]))P[i].first=a[i],P[i].second=i,i++; while(i&lt;=n)P[i].first=0,P[i].second=i,a[i++]=0; sort(P+1,P+n+1); //for(i=1;i&lt;=n;i++)printf("%lld %d\n",P[i].first,P[i].second); for(i=1;i&lt;=n;i++)id[i]=P[i].second; pre[id[1]]=nex[id[n]]=0; for(i=1;i&lt;n;i++) nex[id[i]]=id[i+1],pre[id[i+1]]=id[i];&#125;void solve()&#123; for(int i=n;i&gt;=2;i--)&#123; int tp=pre[i],tn=nex[i]; ll res=INF; if(tp)res=min(res,a[i]-a[tp]); if(tn)res=min(res,a[tn]-a[i]); ans+=res; if(tn)pre[tn]=tp; if(tp)nex[tp]=tn; &#125; printf("%lld\n",ans+a[1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 玩具装箱TOY]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3195%2F</url>
    <content type="text"><![CDATA[题目链接 题解一道很简单的斜率优化DP。设$f(i)$表示装到第$i$个玩具为止的时候，最小的花费。那么 f(i)=\min \limits_{1 \le j]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 越狱]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3197%2F</url>
    <content type="text"><![CDATA[题目链接 题解总共情况有$M^N$种不会越狱的情况有$M\times (M-1)^{N-1}$种。前者减去后者即为答案。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll n,m,P=100003;ll qpow(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%P; a=(a*a)%P,b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; scanf("%lld%lld",&amp;m,&amp;n); m%=P;&#125;void solve()&#123; ll ans=qpow(m,n),ans2=qpow(m-1,n-1); ans2=(ans2*m)%P; ans=(ans+P-ans2)%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2006 公路修建问题]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2323%2F</url>
    <content type="text"><![CDATA[题目链接 题解二分最大限制，kruskal判断。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int u,v,c1,c2;&#125;;Edge edge[20005];int n,k,m,par[10005],q1[20005],q2[20005],vis[20005];bool cmp1(int a,int b)&#123; return edge[a].c1&lt;edge[b].c1;&#125;bool cmp2(int a,int b)&#123; return edge[a].c2&lt;edge[b].c2;&#125;int Find(int t)&#123; if(par[t]==t)return t; return (par[t]=Find(par[t]));&#125;void unite(int a,int b)&#123; if(Find(a)==Find(b))return ; par[Find(a)]=Find(b);&#125;int judge(int M)&#123; int cnt=0,tot=n,at,ans=0,u,v,c; for(int i=1;i&lt;=n;i++)par[i]=i; memset(vis,0,sizeof(vis)); for(at=0;tot&gt;n-k&amp;&amp;at&lt;m;at++)&#123; if(edge[q1[at]].c1&gt;M)continue; u=edge[q1[at]].u,v=edge[q1[at]].v, c=edge[q1[at]].c1; if(Find(u)!=Find(v)) unite(u,v),ans+=c,vis[q1[at]]=1,tot--; &#125; if(at==m&amp;&amp;tot!=n-k)return -1; for(at=0;tot&gt;1&amp;&amp;at&lt;m;at++)&#123; if(edge[q2[at]].c2&gt;M||vis[q2[at]])continue; u=edge[q2[at]].u,v=edge[q2[at]].v, c=edge[q2[at]].c2; if(Find(u)!=Find(v)) unite(u,v),ans+=c,vis[q2[at]]=2,tot--; &#125; if(at==m&amp;&amp;tot!=1)return -1; return ans;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].c1,&amp;edge[i].c2); for(int i=0;i&lt;m;i++) q1[i]=q2[i]=i; sort(q1,q1+m,cmp1); sort(q2,q2+m,cmp2);&#125;void solve()&#123; int L=0,R=INF,M,ans; while(R-L)&#123; M=(L+R)/2; ans=judge(M); if(ans&gt;=0) R=M; else L=M+1; &#125; printf("%d\n",L); judge(L); for(int i=0;i&lt;m;i++) if(vis[i])printf("%d %d\n",i+1,vis[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 GT考试]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3193%2F</url>
    <content type="text"><![CDATA[题目链接 题解构造状态转移图，用矩阵优化DP。状态转移图是现成的，就是KMP的匹配图。按照这个对每一个点处理：把模式串每一位看作一个点，最开始也加一个点（0号点，表示匹配不到模式串的任何一个点）每一个点都有0-9共9条边，每个点（除了最后一个点）都向下一个点连一条相应数字边，然后最初的0号点就只有9个自环边。之后每一个点（除了最后一个）能往前转移就往前转，转不了就转到0号点上去。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,Mod,fail[55],ans=0;char danger[55];struct Mat&#123; int dat[22][22]; int r,c; Mat()&#123; memset(dat,0,sizeof(dat)); &#125;&#125;;Mat mul(Mat &amp;a,Mat &amp;b)&#123; Mat newed; newed.r=a.r,newed.c=b.c; int i,j,k,t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p)&#123; Mat E;E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)E=mul(E,a); a=mul(a,a),p&gt;&gt;=1; &#125; return E;&#125;int mat[21][21];void build_fail(char *pat,int l,int *fail)&#123; fail[0]=-1; for(int i=1,j=-1;i&lt;l;i++)&#123; for(;j&gt;-1&amp;&amp;pat[i]!=pat[j+1];j=fail[j]); if(pat[i]==pat[j+1]&amp;&amp;i&gt;j+1) fail[i]=++j; else fail[i]=-1; &#125;&#125;void init()&#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;Mod,danger); build_fail(danger,m,fail);&#125;void solve()&#123; Mat Ori,Plu,res; Ori.r=Plu.r=Plu.c=m+1; Ori.c=1; Plu.dat[0][0]=9,Plu.dat[1][0]=1; bool used[10]; int CNT=10; for(int i=1;i&lt;m;i++)&#123; int f=i-1,flag=0; memset(used,0,sizeof(used)); CNT=10; do&#123; f=fail[f]; if(danger[f+1]!=danger[i])&#123; if(!used[danger[f+1]-'0']) used[danger[f+1]-'0']=1, Plu.dat[f+2][i]=1, CNT--; &#125; &#125;while(f!=-1); Plu.dat[i+1][i]=1; CNT--; Plu.dat[0][i]=CNT; &#125; for(int i=0;i&lt;=m;i++) Plu.dat[m][i]=0; Ori.dat[0][0]=1; Plu=Pow(Plu,n); res=mul(Plu,Ori); for(int i=0;i&lt;m;i++) ans=(ans+res.dat[i][0])%Mod; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 公交车路线]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2233%2F</url>
    <content type="text"><![CDATA[题目链接 题解构造递推关系，设$f(p,n)$表示换了$n$次车到了$p$点的方案数，发现F点与D点均只能由上一个点转移而来，E点由F与D点转移而来，其余点由两侧的点转移而来。由此得到递推方程，但是$n$太大，故使用矩阵乘法加速。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Mat&#123; int dat[10][10],r,c; Mat(int a,int b)&#123; this-&gt;r=a,this-&gt;c=b, memset(this-&gt;dat,0,sizeof(this-&gt;dat)); &#125;&#125;;int Mod=1000,n,dx[]=&#123;0,0,1,1,2,2,3,3,4,4,5,6,7,7&#125;,dy[]=&#123;1,2,0,3,0,4,1,5,2,6,3,4,5,6&#125;;void mul(Mat &amp;a,Mat &amp;b,Mat &amp;newed)&#123; newed.r=a.r,newed.c=b.c; int i,j,k,t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125;&#125;Mat pow(Mat a,int p)&#123; Mat E(a.c,a.c),F(a.c,a.c); int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)mul(E,a,F),E=F; mul(a,a,F),a=F,p&gt;&gt;=1; &#125; return E;&#125;int main()&#123; n=read(); Mat q(8,8),s(8,1),e(8,1); for(int i=0;i&lt;14;i++) q.dat[dx[i]][dy[i]]=1; s.dat[0][0]=1; q=pow(q,n),mul(q,s,e); printf("%d\n",e.dat[7][0]); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 操作系统]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2278%2F</url>
    <content type="text"><![CDATA[题目链接 题解中心思想就是模拟，堆按优先级大小排序，每次看堆顶元素是否完成，如果完成则就退出，否则等待下一个任务并减去这段等待时间，最后插入下一个任务，循环往复。本题具有一定的实际意义。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef struct&#123; int id,st,ls,pr;&#125;Pro;Pro q[400005];bool operator &lt;(Pro a,Pro b)&#123; if(a.pr==b.pr)return a.st&gt;b.st; else return a.pr&lt;b.pr;&#125;priority_queue&lt;Pro&gt; pq;int at=0,r=0;int s(Pro &amp;x)&#123; if(scanf("%d",&amp;x.id)==1) scanf("%d%d%d",&amp;x.st,&amp;x.ls,&amp;x.pr); else return 0; return 1;&#125;int main()&#123; Pro pre,n,a; while(s(q[r]))r++; pq.push(q[0]); at=q[0].st; for(int i=1;i&lt;r;i++)&#123; while(!pq.empty()&amp;&amp;at+pq.top().ls&lt;=q[i].st) a=pq.top(), printf("%d %d\n",a.id,at+a.ls), at+=a.ls, pq.pop();//若此项目已经完成，则退出 if(!pq.empty()) a=pq.top(), pq.pop(), a.ls-=q[i].st-at, pq.push(a);//结束部分等待时间 at=q[i].st, pq.push(q[i]);//放入优先队列 &#125; while(!pq.empty()) a=pq.top(), printf("%d %d\n",a.id,at+a.ls), at+=a.ls, pq.pop(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2011 数学作业]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3216%2F</url>
    <content type="text"><![CDATA[题目链接 题解\begin{bmatrix} n&ans&1 \end{bmatrix} \begin{bmatrix} 1 & 1 & 0 \\0 & 10^q & 0 \\ 1 & 0 & 1 \end{bmatrix} = \begin{bmatrix} n+1 & ans\times10^q+n &1\end{bmatrix}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef unsigned long long ll;ll n,Mod;struct Mat&#123; ll dat[3][3]; int r,c; Mat(int _r,int _c)&#123; r=_r,c=_c; memset(this-&gt;dat,0,sizeof(this-&gt;dat)); &#125;&#125;;Mat mul(Mat &amp;a,Mat &amp;b)&#123; Mat newed(a.r,b.c); int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p)&#123; Mat E(a.c,a.c); int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)E=mul(E,a); a=mul(a,a),p&gt;&gt;=1; &#125; return E;&#125;void print(Mat q)&#123; for(int i=0;i&lt;q.r;i++)&#123; for(int j=0;j&lt;q.c;j++) printf("%llu ",q.dat[i][j]); printf("\n"); &#125;&#125;void init()&#123; scanf("%llu%llu",&amp;n,&amp;Mod); n++;&#125;void solve()&#123; ll cur=1,nex=10; Mat Ori(1,3),Plu(3,3),Copy(3,3),res(3,3); Ori.dat[0][0]=Ori.dat[0][2]=1; Plu.dat[0][0]=Plu.dat[0][1]= Plu.dat[2][0]=Plu.dat[2][2]=1; Plu.dat[1][1]=10; for(;;)&#123; Copy=Pow(Plu,min(nex,n)-cur); res=mul(Ori,Copy); if(nex&gt;=n)break; Plu.dat[1][1]*=10,Plu.dat[1][1]%=Mod; cur*=10,nex*=10; Ori=res; &#125; printf("%llu\n",res.dat[0][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2006 超级英雄]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2319%2F</url>
    <content type="text"><![CDATA[题目链接 题解裸的二分图匹配洛谷上是强化的版本左边的点代表题目，右边的点代表锦囊用匈牙利算法从上至下匹配即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;bool mat[1005][1005]=&#123;0&#125;;int n,m,op[1005]=&#123;0&#125;,vis[1005];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); mat[i][u]=mat[i][v]=1; &#125;&#125;int dfs(int cur)&#123; for(int j=0;j&lt;n;j++)&#123; if(mat[cur][j]&amp;&amp;!vis[j])&#123; vis[j]=1; if(!op[j]||dfs(op[j]))&#123; op[j]=cur; return 1; &#125; &#125; &#125; return 0;&#125;int Edmonds()&#123; int ret=0; for(int i=1;i&lt;=m;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))ret++; else break; &#125; return ret;&#125;void solve()&#123; int ans=Edmonds(); printf("%d\n",ans); for(int i=1;i&lt;=ans;i++)&#123; int j; for(j=0;j&lt;n;j++) if(op[j]==i)&#123; printf("%d\n",j); break; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最大匹配</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2012 永无乡]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3224%2F</url>
    <content type="text"><![CDATA[题目链接 题解并查集，然后利用启发式合并最多带来一个$log$的代价，暴力拆treap，然后合并。时间复杂度$O(nlog^2 n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,cnt,id; int cmp(int x) const &#123; if(x==v)return -1; return x&gt;v; &#125; void maintain()&#123; siz=cnt; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[1700005],*pos[400005],*root;int S=0,n,m;int par[100005],rk[100005]; void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x,int i_)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;cnt=1,tr-&gt;v=x; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); tr-&gt;id=i_; return ; &#125; tr-&gt;siz++; if(tr-&gt;v==x)&#123; tr-&gt;cnt++; &#125;else&#123; int d=tr-&gt;cmp(x); insert_tr(tr-&gt;ch[d],x,i_); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1); &#125;&#125;int Kth(Tr *tr,int x)&#123; if(tr==NULL||x&lt;=0||x&gt;tr-&gt;siz)return -1; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(x&lt;=evid)return Kth(tr-&gt;ch[0],x); else if(x&gt;evid+tr-&gt;cnt)return Kth(tr-&gt;ch[1],x-evid-tr-&gt;cnt); else return tr-&gt;id;&#125;int Find(int t)&#123; if(par[t]==t)return t; else return (par[t]=Find(par[t]));&#125;int unite(int a,int b)&#123; int x=Find(a),y=Find(b); if(x==y)return -1; if(rk[x]&gt;rk[y])&#123; par[y]=x; return x; &#125;else &#123; par[x]=y; if(rk[x]==rk[y])rk[y]++; return y; &#125;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void dfs(Tr *t)&#123; if(t==NULL)return ; insert_tr(root,t-&gt;v,t-&gt;id); dfs(t-&gt;ch[0]),dfs(t-&gt;ch[1]);&#125;void MMerge(int x,int y)&#123; if(Find(x)==Find(y))return ; int ss=Find(x),tt=Find(y); int res=unite(x,y);//大的 if(res==tt)root=pos[tt],dfs(pos[ss]),pos[tt]=root; else root=pos[ss],dfs(pos[tt]),pos[ss]=root;&#125; void init()&#123; n=read(),m=read(); int pri,u,v; for(int i=1;i&lt;=n;i++) par[i]=i,rk[i]=0,pri=read(), insert_tr(pos[i],pri,i); for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(); MMerge(u,v); &#125;&#125;void solve()&#123; int q=read(),x,y; char ord[3]; while(q--)&#123; scanf("%s%d%d",ord,&amp;x,&amp;y); if(ord[0]=='B')MMerge(x,y); else printf("%d\n",Kth(pos[Find(x)],y)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>BST</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 消防局的设立]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2279%2F</url>
    <content type="text"><![CDATA[题目链接 题解这道题是一个贪心，蓝书上面讲过。就是每次从最大深度的开始向上面走，走2步，然后如果上面的点还没有被覆盖就覆盖上面的点。这么做可以被证明是正确的。实际上从直觉上来看也是正确的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;vector&lt;int&gt; depth[1005];int n,par[1005]=&#123;0&#125;,bro[1005],son[1005],dep[1005]=&#123;0&#125;,maxd=0;bool vis[1005]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); dep[1]=0,depth[0].push_back(1); for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;par[i]); bro[i]=son[par[i]],son[par[i]]=i; dep[i]=dep[par[i]]+1; depth[dep[i]].push_back(i); maxd=max(maxd,dep[i]); &#125;&#125;void dfs(int cur,int k)&#123; if(k==2)return; if(par[cur]&amp;&amp;k&lt;2) vis[par[cur]]=1,dfs(par[cur],k+1); for(int i=son[cur];i;i=bro[i]) if(k&lt;2) vis[i]=1,dfs(i,k+1);&#125; void solve()&#123; int ans=0; for(int i=maxd;i&gt;=0;i--)&#123; int S=depth[i].size(); for(int j=0;j&lt;S;j++)&#123; int u=depth[i][j]; if(vis[u])continue; if(par[par[u]])u=par[par[u]]; else if(par[u])u=par[u]; vis[u]=1,dfs(u,0),ans++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2001 矩阵乘积]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2222%2F</url>
    <content type="text"><![CDATA[题目链接 题解三元组矩阵乘法…数据结构书上一般都会讲到。因为指定了要求的值的位置，所以可以在矩阵$A\times B$的过程中，只保留$A$的$x$一行上的值，然后用$B$中的值去乘。对$B\times C$也如此。这样矩阵乘法的复杂度就会远低于$O(n^3)$，就做完了。复杂度大概是$O(n^2)$?实际上这题更麻烦的是读入…123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int x,y,m,n,o,p;int Am[6005]=&#123;0&#125;,Bm[6005]=&#123;0&#125;;char input[10005];int main()&#123; int i,j,u,v,val; scanf("%d%d%d%d%d%d",&amp;x,&amp;y,&amp;m,&amp;n,&amp;o,&amp;p); fgets(input,10000,stdin); for(;;)&#123; fgets(input,10000,stdin); if(!isdigit(input[0]))break; sscanf(input,"%d%d%d",&amp;u,&amp;v,&amp;val); if(u==x)Am[v]=val; &#125; for(;;)&#123; fgets(input,10000,stdin); if(!isdigit(input[0]))break; sscanf(input,"%d%d%d",&amp;u,&amp;v,&amp;val); Bm[v]+=Am[u]*val; &#125; memcpy(Am,Bm,sizeof(Bm)); memset(Bm,0,sizeof(Bm)); while(~scanf("%d%d%d",&amp;u,&amp;v,&amp;val)) Bm[v]+=Am[u]*val; printf("%d\n",Bm[y]); return 0;&#125; ​]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 激光炸弹]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2280%2F</url>
    <content type="text"><![CDATA[题目链接 题解一开始看错题目，以为有很多个炸弹…暴力即可123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,r,mat[5005][5005]=&#123;0&#125;,x=0,y=0;void init()&#123; n=read(),r=read(); int dx,dy,c; for(int i=1;i&lt;=n;i++) dx=read(),dy=read(),c=read(), dx++,dy++,mat[dx][dy]+=c, x=max(x,dx),y=max(y,dy); x=max(x,r),y=max(y,r); for(int i=1;i&lt;=x;i++) for(int j=1;j&lt;=y;j++) mat[i][j]+=mat[i][j-1]; for(int j=1;j&lt;=y;j++) for(int i=1;i&lt;=x;i++) mat[i][j]+=mat[i-1][j];&#125;void solve()&#123; int ans=0; for(int i=r;i&lt;=x;i++) for(int j=r;j&lt;=y;j++) ans=max(ans,mat[i][j]-mat[i-r][j]-mat[i][j-r]+mat[i-r][j-r]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2004 L语言]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2292%2F</url>
    <content type="text"><![CDATA[题目链接 题解Hash和DP。实际上也可以拿trie做。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef unsigned int ui;char t[1000005];bool able[1000005]=&#123;0&#125;; int n,m,lth[25];ui hsh[25],h[1000005],P=1005257,Pow[1000005];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%s",t); hsh[i]=0,lth[i]=strlen(t); for(int j=0;j&lt;lth[i];j++) hsh[i]=P*hsh[i]+t[j]; &#125; Pow[0]=1; for(int i=1;i&lt;=1000000;i++) Pow[i]=Pow[i-1]*P; for(int i=0;i&lt;m;i++)&#123; scanf("%s",t); int len=strlen(t),ans=0,j,k; h[0]=0,able[0]=1; for(j=1;j&lt;=len;j++)&#123; h[j]=h[j-1]*P+t[j-1]; for(k=0;k&lt;n;k++)&#123; if(lth[k]&lt;=j&amp;&amp;h[j]-Pow[lth[k]]*h[j-lth[k]]==hsh[k]) able[j]|=able[j-lth[k]]; if(able[j])break; &#125; if(able[j])ans=j; &#125; printf("%d\n",ans); memset(able,0,sizeof(able)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>字符串DP</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2010 弹飞绵羊]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3203%2F</url>
    <content type="text"><![CDATA[题目链接 题解LCT模板题。把跳到的点当作是父亲，支持删边和连边即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,fa[200005]=&#123;0&#125;,ch[200005][2],siz[200005]=&#123;0&#125;,rev[200005]=&#123;0&#125;;int val[200005],to[200005];int cmp(int k)&#123; return ch[fa[k]][1]==k;&#125;int isroot(int k)&#123; return ch[fa[k]][0]!=k&amp;&amp;ch[fa[k]][1]!=k;&#125;void Rev(int k)&#123; swap(ch[k][0],ch[k][1]); rev[k]^=1;&#125;void maintain(int k)&#123; siz[k]=siz[ch[k][0]]+siz[ch[k][1]]+1;&#125;void pushdown(int k)&#123; if(k&amp;&amp;rev[k])&#123; rev[k]=0; if(ch[k][0])Rev(ch[k][0]); if(ch[k][1])Rev(ch[k][1]); &#125;&#125;void pushup(int k)&#123; if(!k)return ; if(!isroot(k))pushup(fa[k]); pushdown(k);&#125; void Rotate(int k)&#123; int Fa=fa[k],Gfa=fa[Fa],d=cmp(k); ch[Fa][d]=ch[k][d^1],fa[ch[k][d^1]]=Fa; ch[k][d^1]=Fa,fa[Fa]=k; fa[k]=Gfa; if(!isroot(Fa))&#123; if(Fa==ch[Gfa][0])ch[Gfa][0]=k; else if(Fa==ch[Gfa][1])ch[Gfa][1]=k; &#125; maintain(Fa); &#125;void splay(int k)&#123; pushup(k); for(int Fa=fa[k];!isroot(k);Rotate(k),Fa=fa[k]) if(fa[Fa]&amp;&amp;!isroot(Fa))Rotate(cmp(k)==cmp(Fa)?Fa:k); maintain(k);&#125; void access(int k)&#123; for(int t=0;k;t=k,k=fa[k])splay(k),ch[k][1]=t,maintain(k);&#125; void makeroot(int k)&#123; access(k),splay(k),Rev(k);&#125;int findroot(int k)&#123; while(fa[k])k=fa[k];return k;&#125;void Split(int u,int v)&#123; makeroot(u),access(v),splay(v);&#125;void cut(int u,int v)&#123; Split(u,v); ch[v][0]=fa[u]=0; maintain(v);&#125;void link(int u,int v)&#123; makeroot(u),fa[u]=v;&#125;void init()&#123; n=read(),siz[n+1]=1; for(int i=1;i&lt;=n;i++)val[i]=read(),to[i]=min(n+1,i+val[i]),siz[i]=1; for(int i=1;i&lt;=n;i++)link(i,to[i]); &#125;void solve()&#123; m=read(); int opr,x,y; while(m--)&#123; opr=read(),x=read()+1; if(opr==1) Split(x,n+1),printf("%d\n",siz[n+1]-1); if(opr==2)&#123; y=read(); if(to[x]==n+1&amp;&amp;x+y&gt;n)continue; cut(x,to[x]),val[x]=y,to[x]=min(x+y,n+1),link(x,to[x]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 GameZ游戏排名系统]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2584%2F</url>
    <content type="text"><![CDATA[题目链接 题解双关键字平衡树。其实也没什么，跟排序的时候写两个关键字一样操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt; #define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,tim; char name[12]; int cmp(int x,int tt) const &#123; if(x==v&amp;&amp;tt==tim)return -1; return x==v?tt&gt;tim:x&gt;v; &#125; void maintain()&#123; siz=1; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[400005],*ans;int S=0,n,T;char ord[12];map&lt;unsigned int,int&gt; mp1;//最近一次得分 map&lt;unsigned int,int&gt; mp2;//最近一次插入 void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x,int tt)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;v=x,tr-&gt;tim=tt; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); memcpy(tr-&gt;name,ord,sizeof(ord)); return ; &#125; tr-&gt;siz++; int d=tr-&gt;cmp(x,tt); insert_tr(tr-&gt;ch[d],x,tt); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1);&#125;void del(Tr* &amp;tr,int x,int tt)&#123; int d=tr-&gt;cmp(x,tt); if(d==-1)&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),tr-&gt;siz--,del(tr-&gt;ch[d_],x,tt); &#125; &#125;else tr-&gt;siz--,del(tr-&gt;ch[d],x,tt);&#125; Tr* Kth(Tr *tr,int x)&#123; if(tr==NULL||x&lt;=0||x&gt;tr-&gt;siz)return NULL; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(x&lt;=evid)return Kth(tr-&gt;ch[0],x); else if(x&gt;evid+1)return Kth(tr-&gt;ch[1],x-evid-1); else return tr;&#125;int Rank(Tr *tr,int x,int tt)&#123; if(tr==NULL)return 0; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(tr-&gt;cmp(x,tt)&lt;0)return evid+1; if(!tr-&gt;cmp(x,tt))return Rank(tr-&gt;ch[0],x,tt); else return evid+1+Rank(tr-&gt;ch[1],x,tt);&#125; bool Find(Tr *tr,int x)&#123; while(tr!=NULL)&#123; if(tr-&gt;v==x)return true; else tr=tr-&gt;ch[(tr-&gt;v&lt;x)]; &#125; return false;&#125;unsigned int Hash(char *s)&#123; unsigned int res=0; for(;*s;s++)res=res*133u+*s; return res;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void solve()&#123; n=read(),T=0; Tr *root=NULL; while(n--)&#123; scanf("%s",ord); if(ord[0]=='+')&#123; int u=-read(),pre,close; unsigned int code=Hash(ord+1); pre=mp1[code],close=mp2[code]; //上一次的得分和插入时间 if(pre&amp;&amp;Find(root,pre)) del(root,pre,close); mp1[code]=u,mp2[code]=T,insert_tr(root,u,T); &#125;else if(isdigit(ord[1]))&#123; int rk=atoi(ord+1); for(int i=0;i&lt;10;i++)&#123; ans=Kth(root,rk+i); if(ans==NULL)break; if(i)printf(" "); printf("%s",ans-&gt;name+1); &#125; printf("\n"); &#125;else &#123; unsigned int code=Hash(ord+1); int pre=mp1[code],close=mp2[code]; printf("%d\n",Rank(root,pre,close)); &#125; T++; &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 书架]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2596%2F</url>
    <content type="text"><![CDATA[题目链接 题解平衡树裸题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; int siz,v,pr,l,r,fa;&#125;;Tr tr[400005];int S=0,root=0,n,m,a[200005];int pos[200005];void maintain(int k)&#123; tr[k].siz=1; if(tr[k].l)tr[k].siz+=tr[tr[k].l].siz,tr[tr[k].l].fa=k; if(tr[k].r)tr[k].siz+=tr[tr[k].r].siz,tr[tr[k].r].fa=k;&#125;int newnode(int k)&#123; S++,tr[S].v=k,tr[S].pr=rand(),tr[S].siz=1; tr[S].l=tr[S].r=tr[S].fa=0; return S;&#125;void Split_K(int now,int k,int &amp;x,int &amp;y)&#123; if(!now)x=y=0; else&#123; if(k&gt;tr[tr[now].l].siz) x=now,Split_K(tr[now].r,k-tr[tr[now].l].siz-1,tr[now].r,y); else y=now,Split_K(tr[now].l,k,x,tr[now].l); maintain(now); &#125;&#125;int Merge(int x,int y)&#123; if(!x||!y)return x+y; if(tr[x].pr&lt;tr[y].pr)&#123; tr[x].r=Merge(tr[x].r,y); maintain(x); return x; &#125;else&#123; tr[y].l=Merge(x,tr[y].l); maintain(y); return y; &#125;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int get_pos(int x)&#123; int res=1+tr[tr[x].l].siz; while(tr[x].fa)&#123; if(x==tr[tr[x].fa].r) res+=tr[tr[tr[x].fa].l].siz+1; x=tr[x].fa; &#125; return res;&#125;void init()&#123; srand(12414841); tr[0].siz=tr[0].v=tr[0].fa=0; n=read(),m=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++) pos[a[i]]=newnode(a[i]), root=Merge(root,pos[a[i]]);//rank数组&#125;void solve()&#123; char ord[10]; int x,u,v,w,y,z,t,i1,i2; for(int i=1;i&lt;=m;i++)&#123; scanf("%s",ord); u=v=w=y=z=t=0; if(ord[0]=='A') x=read(), printf("%d\n",get_pos(pos[x])-1); if(ord[0]=='T')&#123; x=read(),u=get_pos(pos[x]); Split_K(root,u-1,w,z); Split_K(z,1,y,v); root=Merge(Merge(y,w),v); &#125; if(ord[0]=='B')&#123; x=read(),u=get_pos(pos[x]); Split_K(root,u-1,w,z); Split_K(z,1,y,v); root=Merge(Merge(w,v),y); &#125; if(ord[0]=='Q')&#123; x=read(); Split_K(root,x-1,w,z); Split_K(z,1,y,v); printf("%d\n",tr[y].v); root=Merge(Merge(w,y),v); &#125; if(ord[0]=='I')&#123; x=read(),y=read(); if(y)&#123; u=get_pos(pos[x]); Split_K(root,u-1,w,v); Split_K(v,1,t,z); if(y==-1)&#123; Split_K(w,u-2,i1,i2); root=Merge(Merge(Merge(i1,t),i2),z); &#125;else&#123; Split_K(z,1,i1,i2); root=Merge(Merge(Merge(w,i1),t),i2); &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 三色二叉树]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2585%2F</url>
    <content type="text"><![CDATA[题目链接 题解水DP。分别给每个点设3个状态即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[10005];int n,l[10005]=&#123;0&#125;,r[10005]=&#123;0&#125;,ans,f[10005][3],o;int dfs(int cur)&#123; if(s[cur]=='0')return cur; if(s[cur]=='1')&#123; l[cur]=cur+1; return dfs(cur+1); &#125; if(s[cur]=='2')&#123; l[cur]=cur+1; int t=dfs(cur+1); r[cur]=t+1; return dfs(t+1); &#125; &#125;int dfs2(int cur)&#123; if(l[cur])dfs2(l[cur]); if(r[cur])dfs2(r[cur]); if(l[cur]&amp;&amp;r[cur])&#123; if(!o)&#123; f[cur][0]=max(f[l[cur]][1]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][1]), f[cur][2]=max(f[l[cur]][1]+f[r[cur]][0],f[l[cur]][0]+f[r[cur]][1]), f[cur][1]=max(f[l[cur]][0]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][0])+1; &#125;else&#123; f[cur][0]=min(f[l[cur]][1]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][1]), f[cur][2]=min(f[l[cur]][1]+f[r[cur]][0],f[l[cur]][0]+f[r[cur]][1]), f[cur][1]=min(f[l[cur]][0]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][0])+1; &#125; &#125;else if(l[cur])&#123; if(!o)&#123; f[cur][0]=max(f[l[cur]][1],f[l[cur]][2]), f[cur][2]=max(f[l[cur]][1],f[l[cur]][0]), f[cur][1]=max(f[l[cur]][0],f[l[cur]][2])+1; &#125;else&#123; f[cur][0]=min(f[l[cur]][1],f[l[cur]][2]), f[cur][2]=min(f[l[cur]][1],f[l[cur]][0]), f[cur][1]=min(f[l[cur]][0],f[l[cur]][2])+1; &#125; &#125;else&#123; f[cur][0]=f[cur][2]=0,f[cur][1]=1; &#125;&#125;void init()&#123; scanf("%s",s+1); n=strlen(s+1),dfs(1);&#125;void solve()&#123; ans=0,o=0,dfs2(1); ans=max(ans,max(f[1][0],max(f[1][1],f[1][2]))); printf("%d ",ans); memset(f,0,sizeof(f)); ans=INF,o=1,dfs2(1); ans=min(ans,min(f[1][0],min(f[1][1],f[1][2]))); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI2014 HOT-Hotels]]></title>
    <url>%2F2018%2F08%2F09%2Fpoi2014-hot%2F</url>
    <content type="text"><![CDATA[题目链接 题解一个比较容易证明的结论是：这三个点必然会经过某一个点，并且该点到他们的距离相等。这样，我们枚举每一个点，然后算一下每层深度有多少个这样的点，计数即可。这样会有重复，不妨这么考虑：一个点是“中心点”的前提是他是另外$3$个点的$LCA$。所以为了避免某$2$个深度相同的点的$LCA$不是当前枚举的点，我们就把每一颗当前枚举点的子树看作是一个集合，集合中深度相同的$2$个点不可同时选取，就转化为了一个组合问题。假设有$n$个集合，大小分别为a_1,a_2,a_3,...,a_n要从其中$3$个集合中各选一个元素组成$3$元组个方案数显然是a_ia_ja_k。这些方案数的和就是当前点的答案。然后考虑加入一个集合，要快速得到这个集合的贡献，就要维护其他集合两两乘积的和，把新集合大小乘上去就是新集合的贡献。维护两两乘积的和又需要维护所有集合大小之和，这就是代码里开了$f,g$2个数组的原因。$f$就是集合大小和，$g$就是两两乘积和。这么做是$O(n^2)$的。容易被卡。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,to[10005],nex[10005],at[10005]=&#123;0&#125;,cnt=0;ll ans=0,f[5005],g[5005],d[5005]=&#123;0&#125;;//次数1 2 3 void dfs(int cur,int fa,int de)&#123; d[de]++; for(int i=at[cur];i;i=nex[i]) if(to[i]!=fa) dfs(to[i],cur,de+1); &#125;void init()&#123; n=read(); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); to[++cnt]=v,nex[cnt]=at[u],at[u]=cnt; to[++cnt]=u,nex[cnt]=at[v],at[v]=cnt; &#125; &#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); for(int j=at[i];j;j=nex[j])&#123; dfs(to[j],i,1); for(int k=1;k&lt;=n;k++)//合并集合 ans+=d[k]*g[k],g[k]+=d[k]*f[k],f[k]+=d[k],d[k]=0; &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POI</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI2014 PTA-Little Bird]]></title>
    <url>%2F2018%2F08%2F09%2Fpoi2014-pta%2F</url>
    <content type="text"><![CDATA[题目链接 题解要用单调队列这一点比较明显，DP也可以看得出来。所以就是单调队列+DP。保证单调队列里的元素相同体力消耗下靠近队首的高度尽量高即可，相当于在维护队列体力消耗值从队首到队尾递增的基础上对高度进行递减的维护。时间复杂度是$O(Nq)$。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[1000005],m,d,que[1000005],f,r,dp[1000005];void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();&#125;void solve()&#123; m=read(); while(m--)&#123; d=read(); f=r=0; dp[1]=0,que[r++]=1; for(int i=2;i&lt;=n;i++)&#123; while(r-f&amp;&amp;i-que[f]&gt;d)f++; dp[i]=dp[que[f]]+(a[que[f]]&lt;=a[i]); while(r-f&amp;&amp;(dp[que[r-1]]&gt;dp[i]||(dp[que[r-1]]==dp[i]&amp;&amp;a[que[r-1]]&lt;a[i]))) r--; que[r++]=i; &#125; printf("%d\n",dp[n]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POI</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2011 兔农]]></title>
    <url>%2F2018%2F08%2F09%2Fnoi2011t1%2F</url>
    <content type="text"><![CDATA[题目链接 题解模拟能拿75分。题目肯定是和斐波那契数列有关，但有关在哪里呢？由于有取模，所以我们看看有没有什么和循环有关的性质。我们设$fib[i]$为斐波那契数列的第$i$项，而设$F[i]$为该数列的第i项。把$k=7$作为例子，观察$F[i]$对$k$取模的序列：$1,1,2,3,5,0, $$5,5,3,0, $$3,3,6,2,0,$$2,2,4,6,3,2,5,0,5,5,3,0,$（之所以这一段前面的$0$不算是一段的结尾，是因为这个$0$不是由于减了一个$1$而产生的）$3,3,6,2,0,…$设$fib[0]=0$，则可以发现： 每一段的开头两个数都是相同的两个数，并且正好就是前面那一个段的最后一个非$0$数。同时只有除$k$和$0$以外的$k-1$种数，所以最多在不超过$k$段的情况下就会出现循环。（假设这个循环是存在的话。） 对于某一段而言，这一段都相当于一段小的斐波那契数列。比如说某一段的开头是$x$，那么这一段就是$x,x,2x,3x,5x,8x,…$换言之，这一段的第$i$个数就是$fib[i]\cdot x$。如果这一段有长度，那么设长度是$Len$，则$fib[Len]\cdot x \mod k=1$.这个时候就是我们要减掉$1$的时候。 有了以上的推导，我们不难得出具体算法： 根据$fib[Len]\cdot x \mod k=1$求出$fib[Len]$ 反推出$Len$ 求出下一段的开头，也就是$fib[Len-1]\cdot x$，转回第1步 第1步里头，不难发现$fib[Len]$就是$x^{-1}(mod\quad k)$，所以如果逆元都不存在的话这就成了裸题。否则，算出逆元。第2步，预处理出对于每个$i$，$fib[Len]=i$的最小$Len$。如果是不存在，那么也变成了矩阵乘法裸题。但是可能这个$Len$很大啊？有2个方法： 估计一下$fib \mod k$的循环节长度，直接算 数学证明。vfk大佬的博客上有证明，我不会证，只知道了结论：$fib \mod k$的循环节是以$0,1,1$为开头的，且长度不超过$6000$。就直接算了。 第3步，由于直接模拟可能超时，所以要用矩阵快速幂。一个数减掉$1$是一个很好写的矩阵，这里就不列了，有兴趣的看代码吧。 剩下的细节还挺好处理的。边算边记录答案即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll n,k,p,ans;ll minlen[1000005],block[1000005][3],vis[1000005]=&#123;0&#125;,top=0;ll sum[1000005]=&#123;0&#125;;ll FIB[3][3]=&#123; &#123;0,1,0&#125;, &#123;1,1,0&#125;, &#123;0,0,1&#125;&#125;,MINUS[3][3]=&#123; &#123;1,0,0&#125;, &#123;0,1,0&#125;, &#123;0,-1,1&#125;&#125;;//vis 总长度为什么时开头变成了i // block保存段长信息 struct Mat&#123; ll dat[3][3]; int r,c; Mat()&#123; memset(dat,0,sizeof(dat)); &#125;&#125;;Mat Minus,Fib;Mat mul(Mat &amp;a,Mat &amp;b,ll Mod)&#123; Mat newed; newed.r=a.r,newed.c=b.c; int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p,ll Mod)&#123; Mat E;E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) E.dat[i][i]=1; while(p)&#123; if(p&amp;1)E=mul(E,a,Mod); a=mul(a,a,Mod),p&gt;&gt;=1; &#125; return E;&#125;ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll d=extgcd(b,a%b,y,x); y-=(a/b)*x; return d;&#125;void setfib(Mat &amp;mat)&#123; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) mat.dat[i][j]=FIB[i][j]; mat.r=mat.c=3;&#125;void setminus(Mat &amp;mat)&#123; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) mat.dat[i][j]=MINUS[i][j]; mat.r=mat.c=3;&#125;void init()&#123; scanf("%lld%lld%lld",&amp;n,&amp;k,&amp;p); memset(minlen,-1,sizeof(minlen)); memset(vis,-1,sizeof(vis)); ll fib1=1,fib2=1,fib3,t; for(ll i=3;i&lt;=6*k;i++)&#123; fib3=(fib1+fib2),t=fib3%k; //printf("\t %lld %lld %lld\n",fib1,fib2,t); if(t==1&amp;&amp;fib2==1&amp;&amp;fib1==0)break; if(minlen[t]&lt;0)minlen[t]=i; fib1=fib2,fib2=t; &#125; MINUS[2][1]=p-1; //计算对应的Len setfib(Fib),setminus(Minus);&#125;void solve()&#123; ll x=1,dx,dy,d,len; ll cyc=-1; Mat Ori,Plu,res; Ori.r=1,Ori.c=3; Ori.dat[0][0]=Ori.dat[0][2]=1, Ori.dat[0][1]=0; for(;;)&#123; d=extgcd(x,k,dx,dy); //ax+bk=1 if(d!=1) break; else&#123; //逆元存在 dx=(dx+k)%k,len=minlen[dx]; if(len==-1)//不存在对应的 break; block[top][0]=x,block[top][1]=len; Plu=Pow(Fib,len-1,k); res=mul(Ori,Plu,k); //求出fib[len-1] block[top++][2]=(x*res.dat[0][1])%k; x=block[top-1][2]; sum[top]=sum[top-1]+len; if(vis[x]&gt;=0)&#123; //说明top-1的后面和cyc是一样的 cyc=vis[x]+1; break; &#125; vis[x]=top-1; &#125; &#125; if(cyc==-1)&#123; //没有最终的循环节，就变成矩阵乘法裸题 for(ll i=0;i&lt;top&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; if(n) Plu=Pow(Fib,n,p), Ori=mul(Ori,Plu,p); ans=Ori.dat[0][1]; &#125;else&#123; for(ll i=0;i&lt;cyc&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; if(!n)&#123; ans=Ori.dat[0][1];goto build_ans; &#125; d=n/(sum[top]-sum[cyc]),n%=(sum[top]-sum[cyc]); if(d)&#123; //至少存在一个循环节 for(ll i=0;i&lt;3;i++) for(ll j=0;j&lt;3;j++) Plu.dat[i][j]=(i==j)?1:0; Plu.r=Plu.c=3; for(ll i=cyc;i&lt;top;i++) res=Pow(Fib,block[i][1],p),res=mul(res,Minus,p),Plu=mul(Plu,res,p); Plu=Pow(Plu,d,p),Ori=mul(Ori,Plu,p); &#125; for(ll i=cyc;i&lt;top&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; ans=Ori.dat[0][1]; &#125; build_ans: printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI2011</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa100 The 3n + 1 problem]]></title>
    <url>%2F2018%2F08%2F07%2Fuva100%2F</url>
    <content type="text"><![CDATA[题目链接 题解模拟即可不需要RMQ也不需要记忆化…因为数据好像超出了1000012345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int rec(int cur)&#123; if(cur == 1)return 1; if(cur &amp; 1) return rec(3 * cur + 1) + 1; else return rec(cur &gt;&gt; 1) + 1;&#125;void init()&#123;&#125;void solve()&#123; int l, r; while(scanf("%d%d", &amp;l, &amp;r) == 2)&#123; int aans = 0; if(l &lt; r)&#123; for(int i = l; i &lt;= r; ++i) aans = max(aans, rec(i)); &#125;else &#123; for(int i = r; i &lt;= l; ++i) aans = max(aans, rec(i)); &#125; printf("%d %d %d\n", l, r, aans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 堆]]></title>
    <url>%2F2018%2F08%2F06%2Ftemplate-heap%2F</url>
    <content type="text"><![CDATA[堆包括二叉堆，二项堆，可并堆，斐波那契堆，等。 普通二叉堆最经典的堆结构。其本身为一颗完全二叉树，并且每一个节点都遵循着自身的值大于（或者小于）父节点的值的规律。至于出现重复的值该怎么办，这就要具体情况具体分析。一般而言不需要手写二叉堆，使用C++自带的即可。 以下操作默认为小根堆： 上浮操作让当前位置为$id$的节点不断与其父节点比较，若其比父节点大则符合小根堆的标准，停止上浮；若其小于父节点则与父节点相交换，实现上浮。12345678910void pushup(int *h, int id)&#123; int tmp = h[id]; while(id &gt;= 1)&#123; int par = id &gt;&gt; 1; if(h[par] &lt; tmp) break; h[id] = h[par], id &gt;&gt;= 1; &#125; h[id] = tmp;&#125; 下沉操作让当前位置为$id$的节点不断与其子节点比较，边界是其自身为叶子。若其只有一个子节点，且其小于子节点则符合堆的要求，停止下沉；否则其与子节点交换，下沉。若其有两个子节点且小于两个子节点，则停止下沉；否则让更小的那个子节点与自身交换，下沉。12345678910111213141516171819202122void pushdown(int *h, int id)&#123;//下称操作 int tmp = h[id]; while(id &lt;= (n &gt;&gt; 1))&#123; int lson = id &lt;&lt; 1, rson = id &lt;&lt; 1 | 1; if(rson &gt; n)&#123; if(tmp &lt; h[lson]) break; else h[id] = h[lson], id = lson; &#125;else&#123; if(tmp &lt; h[lson] &amp;&amp; tmp &lt; h[rson]) break; else &#123; if(h[lson] &lt; h[rson]) h[id] = h[lson], id = lson; else h[id] = h[rson], id = rson; &#125; &#125; &#125; h[id] = tmp;&#125; 插入操作将新数$val$插入堆的最底层中，从左到右第一个空出的位置（即堆的最后一个位置的后面）。然后执行上浮操作。12345void pushin(int *h, int val)&#123;//增加数操作 int id = ++n; h[id] = val; pushup(h, id);&#125; 弹出操作将堆最后一个位置的节点与根节点交换，删去最后一个位置的节点，然后让根下沉。123456int popout(int *h)&#123; int top = heap[1]; heap[1] = heap[n--]; pushdown(h, 1); return top;&#125; 建堆操作从底到顶，一层一层对非叶子节点进行下沉操作。1234void build_heap(int *h, int n)&#123;//建堆 for(int i = n &gt;&gt; 1; i &gt;= 1; --i) pushdown(heap, i);&#125; 斐波那契堆斐波那契堆是一种可并堆，虽然其的写法比较复杂，但是其的摊还时间复杂度比较优秀。许多操作可以做到平摊$O(1)$的时间复杂度。确切地说，一个斐波那契堆是一个具有最小堆序的有根树森林。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷1338 末日的传说]]></title>
    <url>%2F2018%2F08%2F06%2Fluogu1338%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题其实可以这么考虑。我们考虑把这个问题缩小范围。比如$n=5$，在决定了最小的数”$1$”的位置之后，剩下的几个数是$2,3,4,5$，但是他们具体是多少没必要关心，我们只要关心他们的相对大小关系。所以考虑完当前最小的数，算出这个数对答案的贡献，然后减掉这个贡献，就可以转而解决一个更小的子问题。（即$n\rightarrow n-1$）回到题目上，要求是求一个有$m$个逆序对的字典序最小的排列。我们知道一个长度为$n$的排列最多有$\frac {n(n-1)}2$个逆序对，也知道一个排列的逆序对数越多，排列字典序越大。所以如果当前$m$不比当前的$\frac {(n-2)(n-1)}2$（也就是减少一个数之后的最多的逆序对数）大，就可以直接把当前的最小数放在最前面，这肯定是最优的。反之，则考虑最小数的放置位置。假设当前排列长为$n$，最小数为$a$，则$a$有$n$种放法，放在从左到右第$i$个位置时会生成$i-1$个逆序对（因为它左边有$i-1$个比他大）。因为$m$大于$n-1$长度排列最多所能产生的逆序数，所以$a$不可能放在最前面，否则不满足条件。怎么办呢？想到之前说的逆序对越多字典序越大，我们就必须让剩下的数能构成的逆序对数尽量小，所以$a$要放到最后，这样$m$减少的最多。放完了$a$，问题就变成了$n-1$和$m-(a$的贡献$)$的子问题，递归求解即可。时间复杂度$O(n)$。123456789101112131415#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll n,m,a[50005];int main()&#123; scanf("%lld%lld\n",&amp;n,&amp;m); ll lst=n,fst=1; for(int i=1;i&lt;=n;i++)&#123; ll t=(ll)(n-i)*(n-i-1)/2; if(t&gt;=m)a[fst++]=i; else a[lst--]=i,m-=(lst-fst+1); &#125; for(int i=1;i&lt;=n;i++)printf("%d ",a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 排序算法]]></title>
    <url>%2F2018%2F08%2F05%2Ftemplate-sort%2F</url>
    <content type="text"><![CDATA[不能忘的基本排序！ 插入排序重点在于：在排第$k$个元素的时候，前$k-1$个已经有序。因此只要把第$k$个元素放到它应该在的地方即可。123456789101112void sort1(int* a, int n)&#123; for(int i = 1; i &lt; n; ++i)&#123; int tmp = a[i], j; for(j = i; j &gt; 0; --j)&#123; if(tmp &lt; a[j - 1]) a[j] = a[j - 1];//向后面移动 else break; &#125;//寻找位置 a[j] = tmp;//插入 &#125;&#125; 选择排序简单直观的排序方法。始终寻找当前的最小值，放在它应当在的地方。12345void sort2(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = i + 1; j &lt; n; ++j) if(a[i] &gt; a[j])swap(a[i], a[j]);&#125; 冒泡排序比较相邻元素，调整顺序以达到排序的目的。123456void sort3(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = 0; j &lt; n - i; ++j) if(a[j] &gt; a[j + 1]) swap(a[j], a[j + 1]);//交换过程&#125; 希尔排序希尔排序使用了一个序列（称之为增量序列） h_1,h_2,h_3,...,h_n其中h_1=1。排序时将序列划为h_k组，元素之间间隔为h_k，然后每组内部进行一个插入排序。随着增量减小数据间的有序程度也就越高，最终在增量达到$1$时达到有序。增量序列的选择直接与算法的效率挂钩。此处用的为$Hibbard$增量，即$1,3,7,…,2^k-1$。123456789101112131415void sort4(int *a, int n)&#123; int h[] = &#123;1, 3, 7, 15, 31&#125;; for(int i = lower_bound(h, h + 5, n) - h - 1; i &gt;= 0; --i)&#123;//寻找最大增量 for(int j = h[i]; j &lt; n; ++j)&#123; int tmp = a[j], k; for(k = j; k &gt;= h[i]; k -= h[i])&#123; if(tmp &lt; a[k - h[i]]) a[k] = a[k - h[i]]; else break; &#125; a[k] = tmp; &#125; &#125;&#125; 以上为常见的$O(n^2)$排序算法。 归并排序分治算法的典型应用，将数据层层分割，直到最简单的两个一组的情况，然后不断进行二路归并。1234567891011121314151617181920void Merge(int *a, int *tmp, int lhead, int rhead, int rend)&#123; int lpos = lhead, rpos = rhead, tpos = lhead; while(lpos &lt; rhead &amp;&amp; rpos &lt; rend)&#123; if(a[lpos] &lt; a[rpos]) tmp[tpos++] = a[lpos++]; else tmp[tpos++] = a[rpos++]; &#125; while(lpos &lt; rhead)tmp[tpos++] = a[lpos++]; while(rpos &lt; rend)tmp[tpos++] = a[rpos++]; for(int i = lhead; i &lt; rend; ++i) a[i] = tmp[i];&#125;void MergeSort(int *a, int left, int right)&#123;//左闭右开 int n = right - left, mid = (right + left) &gt;&gt; 1; if(n == 1)return ; MergeSort(a, left, mid); MergeSort(a, mid, right); Merge(a, b, left, mid, right);&#125; 快速排序快速排序的关键在于选择基准以及分割策略，其余的工作交给递归即可。一种比较优秀的选择基准的方法是对最左端，最右端，和最中间的三个数排序，选择第二大（即中间大小）的数作为基准。这种选择比纯粹的随机选择和固定的选择更加高明。之后，将基准和当前序列的倒数第二个值交换。分割时，利用两个指针，其中一个（设为$i$）从最左边向右扫，另一个（设为$j$）从倒数第二个位置向左扫。$i$只会在大于或等于基准的位置停下，$j$只会在小于或等于基准的位置停下。此时若$i&lt;j$，那么交换$i$和$j$对应的数；若$i \ge j$，那么指针停止行动，本次分割结束。之后由于$i$指针左右分别为小于等于和大于等于基准的数，故把基准换到$i$所在位置，再对$i$两侧递归执行排序。 以上的做法避免了几个隐患： 基准换到倒数第二个位置，为$i$提供了一个界限；同时选择基准时进行的排序也为$j$提供了一个界限。 $i$和$j$在遇到等于基准的值时都会停下，这是因为当多个相同元素存在时，若$i$和$j$都不停下，那么$i$会一直进行到接近末尾的地方，导致分割出来的左右两边序列长度不均衡，进而导致算法实际运行效率变差。 123456789101112131415161718192021222324252627282930void Median3(int *a, int left, int right)&#123; int mid = (left + right) &gt;&gt; 1; if(a[left] &gt; a[mid])swap(a[left], a[mid]); if(a[mid] &gt; a[right])swap(a[mid], a[right]); if(a[left] &gt; a[mid])swap(a[left], a[mid]); swap(a[mid], a[right - 1]);&#125;void Qsort(int *a, int left, int right)&#123;// 闭区间 int len = right - left + 1, pivot; if(len &lt;= 1)return ; if(len == 2)&#123; if(a[right] &lt; a[left])swap(a[left], a[right]); return ; &#125; Median3(a, left, right); pivot = a[right - 1]; int i = left, j = right - 1; for(;;)&#123; while(a[++i] &lt; pivot) ; while(a[--j] &gt; pivot) ; if(i &gt;= j)break; swap(a[i], a[j]); &#125; swap(a[i], a[right - 1]); Qsort(a, left, i - 1); Qsort(a, i + 1, right);&#125;void QuickSort(int *a, int n)&#123; Qsort(a, 0, n - 1);&#125; 堆排序建立一个堆，直接操作即可。此处不再赘述。 以上为常见的$O(nlogn)$排序算法。 记数排序计数排序的中心思想是：对于每一个输入的元素$x$，确定小于或等于$x$的元素的个数。利用这一信息，即可把该元素放在他应在的位置。12345678910void CountingSort(int *a, int *cnt, int *ans, int n)&#123; for(int i = 0; i &lt;= 10; ++i) cnt[i] = 0; for(int i = 0; i &lt; n; ++i) cnt[a[i]]++; for(int i = 1; i &lt;= 10; ++i) cnt[i] += cnt[i - 1]; for(int i = n - 1; i &gt;= 0; --i) ans[--cnt[a[i]]] = a[i];&#125; 基数排序基数排序执行这样一个过程：对$n$个$d$位数，从最低位开始，一直到最高位，以数的当前位上的数字作为关键字进行排序。 桶排序桶排序将$n$个分布在$[0,1)$上的实数放入$m$个“桶”里，每个桶对应着一个区间，并且对每一个桶里的数据进行排序，以达到总体的有序。 以上为常见的线性时间复杂度排序算法。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷1396 营救]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1396%2F</url>
    <content type="text"><![CDATA[题目地址 题解为什么专门拿出这道题来写一个题解呢？因为这道题考察到了一个我们平时（可能）没有注意到的地方。并查集不仅可以用来做连通性状态的维护，还可以用来解决一些图论上的最值问题。像是这道题，就把二分和并查集结合在一起。二分答案，只把拥挤度小于答案的加入并查集，维护$S$和$T$的联通状态。这个思路真的很妙。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;struct Edge&#123; int u,v,cost; &#125;; Edge edge[20005];bool cmp(int a,int b)&#123; return edge[a].cost&lt;edge[b].cost;&#125;int id[20005],n,m,S,T;int par[10005];int Find(int x)&#123; if(par[x]==x)return x; return par[x]=(Find(par[x]));&#125;void Unite(int u,int v)&#123; par[Find(u)]=Find(v);&#125;bool judge(int M)&#123; for(int i=1;i&lt;=n;i++) par[i]=i; for(int i=0;i&lt;m;i++)&#123; if(edge[id[i]].cost&gt;M)break; Unite(edge[id[i]].u,edge[id[i]].v); if(Find(S)==Find(T))return 1; &#125; return 0;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost), id[i]=i; sort(id,id+m,cmp);&#125;void solve()&#123; int L=0,R=20000,M; while(R-L)&#123; M=(R+L)/2; if(judge(M))//&lt;=M R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2420]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2420%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出每一个点到根的$xor$路径，然后直接$O(1)$回答询问。答案就是$val[u]\quad xor\quad val[v]$，因为$val[lca]$被消去了。这真的是经典问题？我怀疑你就是在水1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[200006];int cnt=0,at[100005]=&#123;0&#125;,n,val[100005]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[++cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int x,int fa)&#123; for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa) val[edge[i].v]=val[x]^edge[i].cost, dfs(edge[i].v,x);&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); dfs(1,0);&#125;void solve()&#123; int m=read(),u,v; while(m--) u=read(),v=read(), printf("%d\n",val[u]^val[v]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1730 最小密度路径]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1730%2F</url>
    <content type="text"><![CDATA[题目地址 题解这是floyd的一个拓展应用。可以求出恰好经过一定数目条路的最短路径长度。也是运用到了动态规划的思想，不过DP数组则变成了3维。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 0x14141414using namespace std;typedef long long ll;int d[1005][105][105],V,E,Q;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; V=read(),E=read(); int u,v,c; memset(d,0x14,sizeof(d)); for(int i=1;i&lt;=E;i++)&#123; u=read(),v=read(),c=read(); if(d[1][u][v]&gt;c)d[1][u][v]=c; &#125; for(int l=2;l&lt;=E;l++) for(int k=1;k&lt;=V;k++) for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) d[l][i][j]=min(d[l][i][j],d[l-1][i][k]+d[1][k][j]); Q=read();&#125;void solve()&#123; int u,v; double ans; for(int i=1;i&lt;=Q;i++)&#123; u=read(),v=read(); ans=INF; for(int l=1;l&lt;=E;l++) if(d[l][u][v]&lt;INF) ans=min(ans,d[l][u][v]/(double)l); if(ans&gt;INF-1)printf("OMG!\n"); else printf("%.3lf\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2758 编辑距离]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2758%2F</url>
    <content type="text"><![CDATA[题目地址 题解非常经典的$DP$题目。转移方程和$LCS$问题非常相似，设$f(i,j)$表示$a$串的第$i$位匹配到$b$串的第$j$位所需要的最少操作数，那么有: f(i,j)=\begin {cases} f(i-1,j-1)\quad (a[i]=b[j])\\ \min \left\{f(i-1,j),f(i-1,j-1),f(i,j-1)\right\}+1 \quad (a[i]\neq b[j]) \end{cases}以上三个数分别对应删除，修改和插入时间复杂度O(l_1l_2)123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char a[2005],b[2005];int f[2005][2005],l1,l2,l3;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b);&#125;void solve()&#123; f[0][0]=0; for(int i=1;i&lt;=l1;i++) f[i][0]=i; for(int i=1;i&lt;=l2;i++) f[0][i]=i; for(int i=1;i&lt;=l1;i++)&#123; for(int j=1;j&lt;=l2;j++)&#123; if(a[i-1]==b[j-1])&#123; f[i][j]=f[i-1][j-1]; &#125;else f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+1; //printf("%d %d:%d\n",i,j,f[i][j]); &#125; &#125; printf("%d\n",f[l1][l2]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>字符串DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1122 最大子树和]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1122%2F</url>
    <content type="text"><![CDATA[题目地址 题解树形DP。主要是体会一下树形DP于树形这种递归结构的关系。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,at[100005],to[100005],_next[100005],cnt=0;bool vis[100005];ll val[100005],dp[100005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int cur)&#123; //包含自己在内 dp[cur]=val[cur]; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]])&#123; vis[to[i]]=1,dfs(to[i]); if(dp[to[i]]&gt;0)dp[cur]+=dp[to[i]]; &#125; &#125;&#125;void init()&#123; n=read(); memset(at,-1,sizeof(at)); int u,v; for(int i=1;i&lt;=n;i++) val[i]=read(); for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); to[cnt]=v,_next[cnt]=at[u],at[u]=cnt++; to[cnt]=u,_next[cnt]=at[v],at[v]=cnt++; &#125;&#125;void solve()&#123; ll ans=-INF; ans*=2ll; vis[1]=1,dfs(1); for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i]); printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待改进 COCI2007 Patrik 音乐会的等待]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1823%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题就是在教你怎么玩单调栈…经典做法就是，维护一个不递增的栈，然后有人比栈顶的人还高的话，就把他加进来，然后因为这个人肯定能看见他与他前面第一个比他高的人之间的人，所以在出栈的时候累加答案。同时还要注意人身高相等的情况。下面我的程序给出的实现方式并不是一个很好的方式，所以有待改进具体的改进方式应该就是令栈单调递减并且维护一段数据的大小…12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll stack[500005],ans=0,tmp,len,lst;int main()&#123; int i,top=1,n,j; scanf("%d%lld",&amp;n,&amp;stack[0]); for(i=1;i&lt;n;i++)&#123; scanf("%lld",&amp;tmp); while(top&amp;&amp;stack[top-1]&lt;tmp) top--,ans++; stack[top++]=tmp; if(top&gt;1)ans++; for(j=top-2;j&amp;&amp;stack[j]==tmp;j--,ans++); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>COCI</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4203 Doubloon Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu4203%2F</url>
    <content type="text"><![CDATA[题目地址 题解先大力打表，看SG函数有没有什么规律发现打表结果非常神奇：当$K$是奇数的时候，SG函数是$010101$变化的。$K$是偶数的时候，每逢$K$的倍数，$SG（x\cdot K）$就为$2$。否则仍然按照$010101$变化。比如$K=2:0,1,2,0,1,2 …$$K=4:0,1,0,1,2,0,1,0,1,2…$之后就简单了。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int S,k,T;int SG(int x)&#123; if(k%2)return x%2; else &#123; int mod=x%(k+1); if(mod&lt;k)return mod%2; else return 2; &#125; &#125;void solve()&#123; T=read(); while(T--)&#123; S=read(),k=read(); int ans=SG(S); if(ans!=2)printf("%d\n",ans); else &#123; for(int j=1;S-j&gt;=0;j*=k) if(!SG(S-j))&#123; printf("%d\n",j); break; &#125; &#125; &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4203 Pythagoras]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu6211%2F</url>
    <content type="text"><![CDATA[题目地址 题解枚举素勾股数。这道题由于数据很大，所以肯定要一开始就枚举好。枚举的时候要注意，使用gcd会超时，所以改为使用枚举素因子判断互质。由于$\sqrt{1000000000} \approx 31622$，而$2\times 3\times 5\times 7\times 11\times 13\times 17 &gt; 31622$，所以素因子最多不会超过6个。这样的话效率就比较好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int cnt[200005] = &#123;0&#125;, tot = 0;int p[10], a[200005];void init()&#123; for(int v = 2; v &lt;= 31622; ++v)&#123; int pcnt = 0, t = v; for(int i = 2; i * i &lt;= v; ++i)&#123; if(t % i == 0)&#123; t /= i; while(t % i == 0) t /= i; p[++pcnt] = i; if(t == 1) break ; &#125; &#125; if(t != 1) p[++pcnt] = t; for(int u = (v % 2 == 0) ? 1 : 2; u &lt; v; u += 2)&#123; int cc = u * u + v * v, flag = 1; if(cc &gt; 1000000000) break; for(int i = 1; i &lt;= pcnt; ++i) if(u % p[i] == 0)&#123; flag = 0; break ; &#125; if(!flag) continue ; int aa = v * v - u * u, bb = 2 * u * v; if(aa &gt; bb) cnt[(aa &amp; 131071)]++; else cnt[(bb &amp; 131071)]++; &#125; &#125;&#125;void solve()&#123; int k = read(), t; k = (1 &lt;&lt; k), t = k - 1; for(int i = 0; i &lt; k; ++i) a[i] = read(); ll ans = 0; for(int i = 0; i &lt; 131072; ++i) ans += 1ll * cnt[i] * a[(i &amp; t)]; printf("%lld\n", ans);&#125;int main()&#123; int T = read(); init(); while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1704 Georgia and Bob]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1704%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个模型，没记错是叫做阶梯博弈。他这个模型可以转化成Nim游戏。把每一对移动的棋子之间的间距看作是石头的数目，就可以依靠Nim游戏的结论进行解答。但是为什么这样的转化是正确的呢？首先两个棋子逼近，就相当于取走若干个石头；如果两个石头远离，那么不要紧，下一步可以把这个多出来的部分减掉去，所以还是相当于没有增加。如果石头个数是奇数就虚拟一个边界上的石头和他配对。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int T,n,a[1005];void solve()&#123; T=read(); while(T--)&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); if(n&amp;1)a[n+1]=0,n++; sort(a+1,a+n+1); int res=0; for(int i=1;i&lt;=n;i+=2) res^=(a[i+1]-a[i]-1); printf("%s\n",res?"Georgia will win":"Bob will win"); &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1079 Calendar Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu1079%2F</url>
    <content type="text"><![CDATA[题目地址 题解写成递推的形式即可。边界条件挺烦的，还好1A了。反正大力码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char dp[200][13][40]=&#123;0&#125;;//1900--&gt;0int days[]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int run(int x,int y)&#123; return (y==2&amp;&amp;x&amp;&amp;x%4==0);&#125;void init()&#123; dp[101][11][3]=1; int r1=0,r2=0; for(int i=101;i&gt;=0;i--) for(int j=12;j&gt;=1;j--) for(int d=31;d&gt;=1;d--)&#123; if(i==101&amp;&amp;(j==12||(j==11&amp;&amp;d&gt;=3)))continue; if(d&gt;days[j]+run(i,j))continue; if(i==101&amp;&amp;(j&gt;=11||(j==10&amp;&amp;d&gt;4)))r1=-1; else&#123; if(j==12)r1=dp[i+1][1][d]; else if(d&lt;=days[j+1]+run(i,j+1))r1=dp[i][j+1][d]; else r1=-1; &#125; if(d==days[j]+run(i,j))&#123; if(j==12)r2=dp[i+1][1][1]; else r2=dp[i][j+1][1]; &#125;else r2=dp[i][j][d+1]; if(!r1||!r2)dp[i][j][d]=1; else dp[i][j][d]=0; &#125;&#125;void solve()&#123; int T=read(),yy,mm,dd; while(T--)&#123; yy=read(),mm=read(),dd=read(); printf("%s\n",dp[yy-1900][mm][dd]==1?"YES":"NO"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1740 A New Stone Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1740%2F</url>
    <content type="text"><![CDATA[题目地址 题解一般而言，这种题目都需要一定的找规律的技巧。首先$n=1$，先手必胜，这是显然的。$n=2$,如果两堆石头一样多，那么先手必败，因为后手可以不断模仿先手的操作来使石头数始终相同，达到自己不败的目的。如果石头数不相等，那么先手可以转移到石头相同的状态。$n=3$，可以构造出$2$堆相同的情况，只要去掉最多的那一堆就行。$n=4$，只要可以拆成$2$个完全一样的子局面，先手就是必败态，其余是必胜态。归纳一下，$n$是奇数，先手必胜；$n$是偶数，除非局面对称，否则先手必胜。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int n,a[1005];void init()&#123; &#125;void solve()&#123; for(;;)&#123; n=read(); if(!n)break; for(int i=1;i&lt;=n;i++)a[i]=read(); if(n%2)&#123; printf("1\n"); continue; &#125; sort(a+1,a+1+n); int flag=0; for(int i=1;i+i&lt;=n;i+=2) if(a[i]!=a[i+1])&#123; flag=1;break; &#125; printf("%d\n",flag); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3863 No Gambling]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu3863%2F</url>
    <content type="text"><![CDATA[题目地址 题解由于后手只能不断采取行动去堵先手的路，而先手一定可以采取方式突破，所以先手必胜。1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; for(int n;;)&#123; n=read(); if(n&lt;0)break; printf("I bet on Oregon Maple~\n"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2234 Matches Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2234%2F</url>
    <content type="text"><![CDATA[题目地址 题解简单的Nim游戏。推荐看国家集训队2002年张一飞的论文，他的论文深入浅出地用集合的观点解释了nim游戏和的原理。之后的很多博弈论的题目都建立在这么一个基本模型的基础上。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; int M,a[25],res; while(~scanf("%d",&amp;M))&#123; res=0; for(int i=1;i&lt;=M;i++)a[i]=read(),res^=a[i]; printf("%s\n",res?"Yes":"No"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1442 Black Box]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1442%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一无脑平衡树。 方法二堆的神奇操作。发现这个求第$k$小$k$是递增的，所以可以维护一个大根堆和一个小根堆，然后在其中一个堆上维护前$k$个数，另一个堆上维护剩下的数，这样只要关注第$k$个数是什么即可，而不需要管在他前面的或者在他后面的是不是有序的。所以操作就很简单了，$k$加$1$的时候从某个堆弹一个走就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define l(x) (x&lt;&lt;1)+1#define r(x) (x&lt;&lt;1)+2using namespace std;int h[200005]=&#123;0&#125;,size=0,n,m,k[200005];priority_queue&lt;int&gt; pq;//pq下&lt;pq顶&lt;h顶&lt;h底 void up(int s)&#123; int at,tmp=h[s]; while(s&gt;0)&#123; at=(s-1)/2; if(h[at]&lt;=tmp)break; h[s]=h[at],s=at; &#125; h[s]=tmp;&#125;void down(int s,int e)&#123; int lch,rch,tmp=h[s]; while(l(s)&lt;e)&#123; lch=l(s),rch=r(s); if(rch&lt;e&amp;&amp;h[rch]&lt;h[lch]) lch=rch; if(tmp&lt;=h[lch])break; h[s]=h[lch],s=lch; &#125; h[s]=tmp;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int i,j,at; for(i=0;i&lt;m;i++) scanf("%d",&amp;k[i]); pq.push(k[0]); for(i=0,j=1;i&lt;n;i++)&#123; scanf("%d",&amp;at); while(j&lt;at)&#123; if(pq.top()&gt;k[j])&#123; h[size++]=pq.top(),pq.pop(); pq.push(k[j]),up(size-1); &#125;else h[size++]=k[j],up(size-1); j++; &#125; printf("%d\n",pq.top()); if(!size)h[size++]=k[j++]; pq.push(h[0]),h[0]=h[--size],down(0,size); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2823 Sliding Window]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2823%2F</url>
    <content type="text"><![CDATA[题目地址 题解经典的单调队列入门题。思路很简单，就是先判断队头是否“过期”，然后再在队尾进行比较。这里的代码是可以进行空间上的优化的。注意一个点：$k=1$时最好特判。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; int n,k,a[1000005],d1[1000005][2],d2[1000005][2],f1=0,f2=0,r1=1,r2=1,ans[1000005][2];void in(int at,int p)&#123; while(r1&gt;f1&amp;&amp;d1[f1][1]&lt;=at-k) f1++; while(r2&gt;f2&amp;&amp;d2[f2][1]&lt;=at-k) f2++; while(r1&gt;f1&amp;&amp;d1[r1-1][0]&gt;p) d1[r1-1][0]=d1[r1-1][1]=0,r1--; while(r2&gt;f2&amp;&amp;d2[r2-1][0]&lt;p) d2[r2-1][0]=d2[r2-1][1]=0,r2--; d1[r1][0]=p,d1[r1++][1]=at; d2[r2][0]=p,d2[r2++][1]=at;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); i=(k==1)?0:1; d1[0][0]=d2[0][0]=a[0]; d1[0][1]=d2[0][1]=0; for(;i&lt;n;i++)&#123; in(i,a[i]); ans[i][0]=d1[f1][0]; ans[i][1]=d2[f2][0]; &#125; for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][0]); printf("%d\n",ans[n-1][0]); for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][1]); printf("%d\n",ans[n-1][1]); return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3017 Cut the Sequence]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3017%2F</url>
    <content type="text"><![CDATA[题目地址 题解第一次做这样的利用决策单调性来优化DP的题目。设$f(i)$表示分割到第$i$个元素时，最大和的最小值。很容易得到方程： f(i)=\min \limits_{sum[j+1...i]]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2918 Tudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2918%2F</url>
    <content type="text"><![CDATA[题目地址 题解基本同26761234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); for(int TT=1;TT&lt;=T;TT++)&#123; printf("Scenario #%d:\n",TT); tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); if(!tot&amp;&amp;!flag)print(); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2676 Sudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2676%2F</url>
    <content type="text"><![CDATA[题目地址 题解一道很经典的题。用的是NOIP2009的程序，没加修改就过了。总体上来说有2个大优化 记录了每一个空的位置 每次找可能的数字最少的空搜 0ms过，还行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); while(T--)&#123; tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3764 The xor-longest Path]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3764%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出从根出发到每一个点的异或距离，然后问题转化为在这些距离中找两个异或值最大的。这是个经典问题，只需要在用trie树查询时进行反向行走即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt;using namespace std;typedef unsigned int ll;struct Tree&#123; int l,r; Tree()&#123;l=r=-1;&#125;&#125;;typedef struct&#123; int v,_next; ll cost;&#125;Edge;Edge edge[200005];int cnt=0,at[100005]; void addedge(int _u,int _v,ll _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int n,siz=1;Tree tr[3000005];ll vx[100005];bool vis[100005];void Trie_insert(ll num)&#123; //printf("%u\n",num); for(ll j=(1&lt;&lt;31),cur=0;j;j&gt;&gt;=1) if((j&amp;num)==0)&#123;//l:0 r:1 if(tr[cur].l&lt;0) tr[cur].l=siz++; cur=tr[cur].l; &#125;else&#123; if(tr[cur].r&lt;0) tr[cur].r=siz++; cur=tr[cur].r; &#125;&#125;ll Trie_search(ll x)&#123; ll res=0; for(ll j=1&lt;&lt;31,cur=0;j;j&gt;&gt;=1)&#123; if(x&amp;j)&#123; if(tr[cur].l&gt;0)res+=j,cur=tr[cur].l; else cur=tr[cur].r; &#125;else&#123; if(tr[cur].r&gt;0)res+=j,cur=tr[cur].r; else cur=tr[cur].l; &#125; &#125; return res;&#125;void dfs(int cur,ll val)&#123; for(int i=at[cur];i!=-1;i=edge[i]._next)&#123; int _v=edge[i].v; if(!vis[_v]) vis[_v]=1, vx[_v]=val^edge[i].cost, Trie_insert(vx[_v]), dfs(_v,vx[_v]); &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=0;i&lt;siz;i++) tr[i].l=tr[i].r=-1; siz=1,cnt=0; memset(at,-1,sizeof(at)); memset(vis,0,sizeof(vis)); int u,v;ll c; for(int i=0;i&lt;n-1;i++) scanf("%d%d%u",&amp;u,&amp;v,&amp;c), addedge(u,v,c), addedge(v,u,c); dfs(0,0); vx[0]=0; //Trie_insert(0u); ll ans=0; for(int i=0;i&lt;n;i++) ans=max(ans,Trie_search(vx[i])); printf("%u\n",ans); &#125; return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2142 The Balance]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2142%2F</url>
    <content type="text"><![CDATA[题目地址 题解注意$a$,$b$可以交换位置。之后就是简单的解方程了。要使$|x|+|y|$最小，需要保证$x$最小，之后保证$y$最小即可。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,d,x1,x2,y1,y2;ll gcd(ll aa,ll bb)&#123; return bb?gcd(bb,aa%bb):aa;&#125;ll extgcd(ll aa,ll bb,ll &amp;xx,ll &amp;yy)&#123; if(!bb)&#123; xx=1,yy=0; return aa; &#125; ll dd=extgcd(bb,aa%bb,yy,xx); yy-=(aa/bb)*xx; return dd;&#125;ll Abs(ll x)&#123; return (x&lt;0)?(-x):x;&#125;void work(ll a_,ll b_,ll &amp;x,ll &amp;y)&#123; ll g=extgcd(a_,b_,x,y),t=b_/g; x*=d/g,x=(x%t+t)%t; y=Abs((a_*x-d)/b_);&#125;int main()&#123; for(;;)&#123; scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;d); if(!a&amp;&amp;!b&amp;&amp;!d)break; work(a,b,x1,y1); work(b,a,x2,y2); if(x1+y1&lt;x2+y2)printf("%lld %lld\n",x1,y1); else printf("%lld %lld\n",y2,x2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1811 Prime Test]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1811%2F</url>
    <content type="text"><![CDATA[题目地址 题解算导上面有讲解。用MillerRabin和PollardRho合力解决。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int T;ll prime[]=&#123;2,3,5,7,11,13,17,19,23,61&#125;;ll gcd(ll a,ll b)&#123; return (!b)?a:gcd(b,a%b);&#125;ll mul(ll a,ll b,ll c)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%c; a=(a+a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll Pow(ll a,ll b,ll c)&#123; ll res=1; a%=c; while(b)&#123; if(b&amp;1)res=mul(res,a,c); a=mul(a,a,c),b&gt;&gt;=1; &#125; return res;&#125;bool witness(ll a,ll n,ll d,ll r)&#123; ll t=Pow(a,d,n),_t=t; for(ll i=1;i&lt;=r;i++)&#123; t=mul(t,t,n); if(t==1&amp;&amp;_t!=1&amp;&amp;_t!=n-1) return 1; _t=t;//基于二次探测定理的操作 &#125; if(t!=1)return 1;//基于费马小定理的操作 return 0;&#125;bool Miller_Rabin(ll n)&#123;//1:质数 if(n==2)return 1; if(n&lt;=1||n%2==0)return 0; for(int i=0;i&lt;10;i++) if(n==prime[i])return 1; ll R=n-1,S=0; for(;R%2==0;R&gt;&gt;=1,S++);//n-1=d*2^r for(int i=0;i&lt;10;i++)//10:测试次数 if(witness(prime[i],n,R,S)) return 0; return 1;&#125;//根据算导，c最好不要是0或者2...//为什么呢？ ll Pollard_Rho(ll n,ll c)&#123; ll x=Pow(rand(),rand(),n),y=x,k=2,d=1,t; for(ll i=1;d==1;i++)&#123; x=(mul(x,x,n)+c)%n; if(x-y&lt;0)t=y-x; else t=x-y; d=gcd(t,n); if(i==k)y=x,k&lt;&lt;=1; &#125; return d;&#125;ll dfs(ll n)&#123; if(n==1)return 1; if(Miller_Rabin(n))return n; ll fac=n,Lans,Rans; while(fac==n) fac=Pollard_Rho(n,rand()%(n-1)+1); Lans=dfs(fac),Rans=dfs(n/fac); return min(Lans,Rans);&#125;void init()&#123; scanf("%d",&amp;T); srand('z'+'q'+'y'+'1'+'0'+'1'+'8'+1);&#125;void solve()&#123; while(T--)&#123; ll N; scanf("%lld",&amp;N); ll ans=dfs(N); if(ans==N)printf("Prime\n"); else printf("%lld\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2774 Long Long Message]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2774%2F</url>
    <content type="text"><![CDATA[题目地址 题解就是求最长公共子串哈希+排序+二分=暴力卡过哈希要用unsigned long long，用unsigned int极其容易撞车12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef unsigned long long ui;char a[200005],b[200005];ui P=1000000007,list[200005],h1[200005],h2[200005],pow1[200005];int l1,l2;bool check(int c)&#123; int i,j;ui t; for(i=1;i&lt;=l1-c+1;i++) list[i-1]=h1[i+c-1]-h1[i-1]*pow1[c]; sort(list,list+l1-c); for(i=1;i&lt;=l2-c+1;i++)&#123; t=h2[i+c-1]-h2[i-1]*pow1[c]; if((*lower_bound(list,list+l1-c,t))==t) return true; &#125; return false;&#125;int main()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b); int i,j,l,r,md; for(pow1[0]=1,i=1;i&lt;=200000;i++) pow1[i]=pow1[i-1]*P; for(i=1;i&lt;=l1;i++) h1[i]=h1[i-1]*P+a[i-1]; for(i=1;i&lt;=l2;i++) h2[i]=h2[i-1]*P+b[i-1]; l=0,r=min(l1,l2); //用b匹配a while(l&lt;r)&#123; md=l+(r-l+1)/2; if(check(md)) l=md; else r=md-1; &#125; printf("%d\n",r); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2348 Euclid's Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2348%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设$a&gt;b$。显然当$a\mod b=0$时，先手必胜。当$a\mod b\neq 0$时，若$a&gt;2b$，则可以证明在接下来先手所有可以采取的$k$种策略中必有必胜策略，故这个也是必胜态。我讲的比较浅显，各位不妨看下《挑战程序设计竞赛》的P310。123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,f;int main()&#123; for(;;)&#123; scanf("%lld%lld",&amp;a,&amp;b); if(!a&amp;&amp;!b)break; f=1; for(;;)&#123; if(a&lt;b)swap(a,b); if(a%b==0)break; if(a&gt;2*b)break; a-=b,f^=1; &#125; if(f)printf("Stan wins\n"); else printf("Ollie wins\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2484 A Funny Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2484%2F</url>
    <content type="text"><![CDATA[题目地址 题解 当$n=1$或者$n=2$时，明显先手必胜。当$n=3$时，明显先手必败。由于每次只可取$1$或$2$个，而取$2$个时，$2$个必须相邻，推断有：当$n&gt;3$时，若$n$为偶数，先手无论如何取，后手可在先手对称的位置上取同等数量，于是先手必败。若$n$为奇数，先手取$1$个时，后手可在先手对称的位置上取$2$个，之后无论先手如何取，后手都可在先手对称的位置上取同等数量，先手必败。如果先手一开始取$2$个时，后手可在先手对称的位置上取$1$个,之后还剩下偶数个,可如上推出先手必败。故当$n&gt;3$时,先手必败(来自链接) 这种模仿对手以判断是否是必胜的思想方式很有效，学到了。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int main()&#123; int n; for(;;)&#123; scanf("%d",&amp;n); if(!n)break; printf("%s\n",(n&lt;=2)?"Alice":"Bob"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1306 Combinations]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1306%2F</url>
    <content type="text"><![CDATA[题目地址 题解计算组合数即可12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef unsigned long long ll;ll C[105][105];ll read()&#123; ll x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void build()&#123; for(ll i=0;i&lt;=100;i++) C[i][0]=1; for(ll i=1;i&lt;=100;i++) for(ll j=1;j&lt;=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];&#125; int main()&#123; build(); ll u,v; for(;;)&#123; u=read(),v=read(); if(!u&amp;&amp;!v)return 0; printf("%llu things taken %llu at a time is %llu exactly.\n",u,v,C[u][v]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1285 Combinations, Once Again]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1285%2F</url>
    <content type="text"><![CDATA[题目地址 题解用基本的背包处理即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n[56],N,q,r;ll f[56];void packX(int d)&#123; int p=1,_n,j; for(j=N;j&gt;=0;j--) for(_n=1;_n&lt;=min(n[d],j);_n++) f[j]+=f[j-_n];&#125; int main()&#123; int i,j,T=1; for(;;T++)&#123; memset(n,0,sizeof(n)); memset(f,0,sizeof(f)); scanf("%d%d",&amp;N,&amp;q); if(!N&amp;&amp;!q)break; for(i=0;i&lt;N;i++) scanf("%d",&amp;j), n[j-1]++; for(f[0]=1ll,i=0;i&lt;N;i++) packX(i); printf("Case %d:\n",T); for(i=0;i&lt;q;i++) scanf("%d",&amp;r), printf("%lld\n",f[r]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Paired Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3669%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。按照产奶时间从大到小排序，然后小的和大的配对，更新最长时间即可。这不是普及组原题么123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P p[100005];int n,ans=0;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)p[i].second=read(),p[i].first=read(); sort(p+1,p+1+n);&#125;void solve()&#123; int po=n; for(int i=1;i&lt;=n;i++)&#123; while(po&gt;i&amp;&amp;p[i].second&gt;=p[po].second)&#123; if(p[po].second) p[i].second-=p[po].second,ans=max(ans,p[i].first+p[po].first); po--; &#125; if(po==i)break; p[po].second-=p[i].second; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Bovine Genomics S]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3670%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟吧。没想到更加优秀的做法。时间复杂度：$O(nm^3)$123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,ans=0,vis[100],key[256];char dna[1005][55];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n+n;i++)scanf("%s",dna[i]); key['A']=0,key['C']=1,key['G']=2,key['T']=3;&#125;void solve()&#123; int code,tot=0,flag=0; for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=j+1;k&lt;m;k++)&#123; tot++,flag=0; for(int t=1;t&lt;=n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; vis[code]=tot; &#125; for(int t=n+1;t&lt;=n+n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; if(vis[code]==tot)&#123; flag=1;break; &#125; &#125; if(!flag)ans++; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16JAN Radio Contact]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3133%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP。按照时间变化递推即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,pos1[1005][2],pos2[1005][2],f[1005][1005];char s1[1005],s2[1005];void movement(char c,int &amp;x,int &amp;y)&#123; if(c=='N')y++;if(c=='S')y--; if(c=='E')x++;if(c=='W')x--;&#125;int sqr(int a,int b)&#123; return (pos1[a][0]-pos2[b][0])*(pos1[a][0]-pos2[b][0])+ (pos1[a][1]-pos2[b][1])*(pos1[a][1]-pos2[b][1]);&#125;void init()&#123; n=read(),m=read(); pos1[0][0]=read(),pos1[0][1]=read(); pos2[0][0]=read(),pos2[0][1]=read(); scanf("%s%s",s1+1,s2+1); for(int i=1,x=pos1[0][0],y=pos1[0][1];i&lt;=n;i++) movement(s1[i],x,y), pos1[i][0]=x,pos1[i][1]=y; for(int i=1,x=pos2[0][0],y=pos2[0][1];i&lt;=m;i++) movement(s2[i],x,y), pos2[i][0]=x,pos2[i][1]=y;&#125;void solve()&#123; memset(f,0x14,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++) f[i][0]=f[i-1][0]+sqr(i,0); for(int i=1;i&lt;=m;i++) f[0][i]=f[0][i-1]+sqr(0,i); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[i][j]=min(f[i-1][j],f[i][j-1]), f[i][j]=min(f[i][j],f[i-1][j-1]), f[i][j]+=sqr(i,j); printf("%d\n",f[n][m]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16FEB Load Balancing]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3138%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。拿线扫描，然后直接模拟。可以二分，套上线段树可以做到$O(nlogn)$的复杂度。实际上应该不需要离散化。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P pp[1005],p1[1005],p2[1005];int n;int cmp(P a,P b)&#123; return a.second&lt;b.second||(a.second==b.second&amp;&amp;a.first&lt;b.first);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)pp[i].first=read(),pp[i].second=read(); sort(pp+1,pp+n+1); int cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].first==pp[i].first) pp[i-1].first=cnt; else pp[i-1].first=cnt,cnt+=2; &#125; pp[n].first=cnt; memcpy(p1+1,pp+1,sizeof(P)*n); sort(pp+1,pp+n+1,cmp); cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].second==pp[i].second) pp[i-1].second=cnt; else pp[i-1].second=cnt,cnt+=2; &#125; pp[n].second=cnt; memcpy(p2+1,pp+1,sizeof(P)*n); //离散化之后分别按照x,y坐标排序，进行扫描。。。 &#125;void solve()&#123; //a | c //------- //b | d //一开始放在最左点左边，最下点下面 int a=0,b=0,c=0,d=0,A=0,B=n,sep,ans=n,maxi; p1[0].first=0,p2[0].second=0; for(int i=1;i&lt;=n;i++,A++,B--)&#123; if(p1[i].first==p1[i-1].first)continue; a=A,c=B,b=d=0; sep=p1[i].first-1; for(int j=1;j&lt;=n;j++)&#123; if(p2[j].second!=p2[j-1].second)&#123; maxi=0; if(maxi&lt;a)maxi=a;if(maxi&lt;b)maxi=b; if(maxi&lt;c)maxi=c;if(maxi&lt;d)maxi=d; if(maxi&lt;ans)ans=maxi; &#125; if(p2[j].first&lt;sep) a--,b++; else c--,d++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN Diamond Collector]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3143%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。先排序，对于每一个钻石枚举他能到的最长区间，然后看他之前的和他这个区间不相交的最长区间。统计答案即可，时间复杂度$O(nlogn)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int a[100005],n,k,b[100005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1);&#125;void solve()&#123; int lst=0,ans=0,maxi=0; for(int i=1;i&lt;=n;i++)&#123; int loc=lower_bound(a+1,a+n+1,a[i]+k+1)-a-i; b[i]=loc; while(lst+b[lst+1]&lt;i) lst++,maxi=max(maxi,b[lst]); ans=max(ans,maxi+loc); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN 262144]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3147%2F</url>
    <content type="text"><![CDATA[题目地址 题解奇妙的做法。考虑倍增，由于合并必然是一整段连续的序列，所以设$f(i,j)$表示从$j$开始一直合并，直到出现$i$时的下标（开）。然后就可以倍增了。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int f[65][270000]=&#123;0&#125;,n,ans=0;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int u; scanf("%d",&amp;u),f[u][i]=i+1;//左闭右开 ans=max(ans,u); &#125;&#125;void solve()&#123; for(int i=2;i&lt;=60;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(!f[i][j]&amp;&amp;f[i-1][j]&amp;&amp;f[i-1][f[i-1][j]]) f[i][j]=f[i-1][f[i-1][j]], ans=max(ans,i); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO15OPEN Bessie Goes Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3123%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力枚举…单纯从经验上来说，这道题有背包的解法，但是讨论极其复杂，还不如套一堆循环。注意负数的处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//1B2E2S1I GOES 1M2Oll ans=0,cnt[7][7]=&#123;0&#125;;int n,mp[256];void init()&#123; n=read(); mp['B']=0,mp['E']=1,mp['S']=2, mp['I']=3,mp['G']=4,mp['O']=5, mp['M']=6; char ord[3]; ll u; for(int i=1;i&lt;=n;i++)&#123; scanf("%s%lld",ord,&amp;u); cnt[mp[ord[0]]][(u%7+7)%7]++; &#125;&#125;void solve()&#123; ll t1,t2,t3; for(int A=0;A&lt;7;A++) for(int B=0;B&lt;7;B++) for(int C=0;C&lt;7;C++) for(int D=0;D&lt;7;D++) for(int E=0;E&lt;7;E++) for(int F=0;F&lt;7;F++) for(int G=0;G&lt;7;G++)&#123; t1=A+B+B+C+C+D,t2=B+C+E+F,t3=G+F+F; if(t1%7==0||t2%7==0||t3%7==0) ans+=cnt[0][A]*cnt[1][B]*cnt[2][C]*cnt[3][D] *cnt[4][E]*cnt[5][F]*cnt[6][G]; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14FEB Roadblock]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2176%2F</url>
    <content type="text"><![CDATA[题目地址 题解先跑一次最短路，然后对最短路上的边进行操作即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;int mp[105][105],E,V,vis[105],d[105],pre[105];void dijkstra(int o)&#123; int lst,at,i,j; fill(d,d+V,INF); memset(vis,0,sizeof(vis)); if(o)memset(pre,-1,sizeof(pre)); d[0]=0; for(i=0;i&lt;V;i++)&#123; for(lst=INF,j=0;j&lt;V;j++) if(!vis[j]&amp;&amp;d[j]&lt;lst)at=j,lst=d[j]; vis[at]=1; for(j=0;j&lt;V;j++) if(d[j]&gt;d[at]+mp[at][j])&#123; d[j]=d[at]+mp[at][j]; if(o)pre[j]=at; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); memset(mp,0x3f,sizeof(mp)); int i,j,u,v,ans=0,rec; for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;j), u--,v--,mp[u][v]=mp[v][u]=j; dijkstra(1),rec=d[V-1]; for(i=V-1;i!=-1;i=pre[i]) if(pre[i]!=-1) mp[i][pre[i]]&lt;&lt;=1, mp[pre[i]][i]&lt;&lt;=1, dijkstra(0), ans=max(ans,d[V-1]-rec), mp[i][pre[i]]&gt;&gt;=1, mp[pre[i]][i]&gt;&gt;=1; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Sabotage]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2115%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分答案，设为$ans$，那么判定条件 C(ans):\exists [i,j],\frac {sum[n]-sum[i...j]}{n-(j-i+1)}\le ans移项，等价于 sum[n]-ans\times n\le sum[j]-ans\times j-(sum[i-1]-ans\times (i-1))求右边的最大值即可。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[100005];double eps=1e-4,sum[100005]=&#123;0&#125;; bool C(double ans)&#123; double mini=sum[1]-ans,maxi=sum[2]-2*ans-(sum[1]-ans); for(int i=2;i&lt;n;i++)&#123; maxi=max(maxi,sum[i]-(double)i*ans-mini); mini=min(mini,sum[i]-(double)i*ans); &#125; return (sum[n]-(double)n*ans&lt;=maxi);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];&#125;void solve()&#123; double L=0,R=(a[1]+a[n])*0.5,M; while(R-L&gt;eps)&#123; M=(R+L)*0.5; if(C(M))R=M;else L=M; &#125; printf("%.3lf\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Mooo Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2214%2F</url>
    <content type="text"><![CDATA[题目地址 题解一开始很智障的每一步都求了一个背包…实际上只要求一次，然后$O(1)$回答询问。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,b,v[1005],s[100005],a[1005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125; void init()&#123; n=read(),b=read(); for(int i=1;i&lt;=b;i++)v[i]=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); &#125;void solve()&#123; int ans=0,cur=a[1]; memset(s,0x7f,sizeof(s)); s[0]=0; for(int j=1;j&lt;=b;j++)&#123; int *A=s,*B=s+v[j]; for(;B-s&lt;=100000;A++,B++)&#123; *B=min(*B,*A+1); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cur=a[i]-a[i-1]; if(a[i-1])cur++; if(s[cur]==0x7f7f7f7f)&#123; ans=-1;break; &#125;else ans+=s[cur]; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12JAN Video Game Combos]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3041%2F</url>
    <content type="text"><![CDATA[题目地址 题解AC自动机学了一天之后，终于想明白了一件事：为什么有时候按照AC图的递推形式不用$fail$?因为在$buildfail$的时候，已经利用了“指向的点要打上同样结束标记的性质”。这样貌似就无形之中运用了$fail$数组。真是神奇的东西啊。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,que[10005],f,r;char T[10005],tmp[10005];int trie[10005][26]=&#123;0&#125;,cnt=0;int val[10005];int fail[10005],SIG_SIZE=26;int dp[1005][305]=&#123;0&#125;;bool vis[1005][305]=&#123;0&#125;;//0-&gt;rootvoid trie_insert(char *a)&#123; int p=0; for(;*a;a++)&#123; if(!trie[p][*a-'A']) trie[p][*a-'A']=++cnt; p=trie[p][*a-'A']; &#125; val[p]++;&#125;void getFail()&#123; f=r=0,fail[0]=0; for(int i=0;i&lt;SIG_SIZE;i++)&#123; int h=trie[0][i]; if(h) fail[h]=0,que[r++]=h; &#125; while(r-f)&#123; int h=que[f++],i,_v,f; for(i=0;i&lt;SIG_SIZE;i++)&#123; _v=trie[h][i]; if(!_v)&#123; trie[h][i]=trie[fail[h]][i]; continue; &#125; que[r++]=_v,f=fail[h]; for(;f&amp;&amp;!trie[f][i];f=fail[f]); fail[_v]=trie[f][i]; val[_v]+=val[fail[_v]];// &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",tmp),trie_insert(tmp); getFail(); for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=cnt;j++) dp[i][j]=-2000000000; dp[0][0]=0; for(int i=1;i&lt;=m;i++)&#123; for(int j=0;j&lt;=cnt;j++)&#123; int x; for(int k=0;k&lt;3;k++)&#123; x=trie[j][k]; dp[i][x]=max(dp[i][x],dp[i-1][j]+val[x]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;=cnt;i++) ans=max(ans,dp[m][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12OPEN Bookshelf]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1848%2F</url>
    <content type="text"><![CDATA[题目地址 题解同poj cut the sequence然而开始我还没发现这是原题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,l=1,r=1,que[100005];ll m,h[100005],w[100005],f[100005];multiset&lt;ll&gt; s;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;h[i],&amp;w[i]);&#125;void solve()&#123; ll cnt=0,ans_; int j=0;//左边是开区间,que[l...r]递减 for(int i=1;i&lt;=n;i++)&#123; cnt+=w[i]; while(cnt&gt;m)cnt-=w[++j]; while(r-l&amp;&amp;que[l]&lt;=j)&#123; if(r-l&gt;1) s.erase(h[que[l+1]]+f[que[l]]); //在读这一段代码的时候，请仔细思考。 //有两个，更大的在l，更小的在l+1 l++; &#125; while(r-l&amp;&amp;h[que[r-1]]&lt;=h[i])&#123; if(r-l&gt;1) s.erase(h[que[r-1]]+f[que[r-2]]); r--; &#125; que[r++]=i; if(r-l&gt;1&amp;&amp;i&gt;que[r-2])s.insert(h[i]+f[que[r-2]]); ans_=*s.begin(); f[i]=h[que[l]]+f[j]; if(r-l&gt;1&amp;&amp;ans_&lt;f[i])f[i]=ans_; &#125; printf("%lld\n",f[n]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Cow Line]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3014%2F</url>
    <content type="text"><![CDATA[题目地址 题解虽然可以用高中数学题的思路，但也可以用康拓展开。实现上估计差别不会很大。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40],vis[30];ll fac[40];void makep()&#123; ll x,t;int rk,j,k; scanf("%lld",&amp;x); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; t=0; for(j=1;j&lt;=n-i+1;j++)&#123; if(x&lt;=t+fac[n-i])break; t+=fac[n-i]; &#125; x-=t,rk=0; for(k=1;k&lt;=n;k++)&#123; if(!vis[k])rk++; if(rk==j)break; &#125; printf("%d ",k); vis[k]=1; &#125; for(int i=1;i&lt;=n;i++) if(!vis[i])printf("%d\n",i);&#125;ll query()&#123; ll ans=0;int rk,j,k; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; rk=0; for(k=1;k&lt;a[i];k++) if(!vis[k])rk++; vis[a[i]]=1; ans+=(ll)rk*fac[n-i]; &#125; return ans+1;&#125;void init()&#123; n=read(),m=read(); fac[1]=fac[0]=1; for(int i=2;i&lt;=20;i++)fac[i]=fac[i-1]*(ll)i;&#125;void solve()&#123; char ord[3]; while(m--)&#123; scanf("%s",ord); if(ord[0]=='P')makep(); else&#123; for(int i=1;i&lt;=n;i++)a[i]=read(); printf("%lld\n",query()); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Generic Cow Protest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1569%2F</url>
    <content type="text"><![CDATA[题目地址 题解水$DP$，设$f(i)$为以$i$为某一组结尾的最大组数，那么 f(i)=\max \limits_{0\le j]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11DEC Grass Planting]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3038%2F</url>
    <content type="text"><![CDATA[题目地址 题解树剖，不过是边问题，所以把边问题改成边的下面那个点的问题。处理的时候注意一下即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int v,_next; &#125;; Edge edge[200005];int cnt=0,at[100005]=&#123;0&#125;;int fa[100005],son[100005]=&#123;0&#125;,siz[100005],top[100005],depth[100005],pos[100005],fp[100005],val[100005];int S,nows=0,n,m,_a,_b,C[400005];int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int k,int v)&#123; while(k&lt;=S)C[k]+=v,k+=lowbit(k);&#125;int query(int r)&#123; int res=0; while(r)res+=C[r],r-=lowbit(r); return res;&#125;void addedge(int _u,int _v)&#123; edge[++cnt].v=_v, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; void dfs1(int x,int par,int d)&#123; depth[x]=d,fa[x]=par,siz[x]=1; for(int i=at[x];i;i=edge[i]._next)&#123; if(edge[i].v==par)continue; int _v=edge[i].v; dfs1(_v,x,d+1); siz[x]+=siz[_v]; if(!son[x]||siz[_v]&gt;siz[son[x]]) son[x]=_v; &#125;&#125;void dfs2(int x,int tp)&#123; top[x]=tp,pos[x]=++nows,fp[nows]=x; if(!son[x])return; dfs2(son[x],tp); for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa[x]&amp;&amp;edge[i].v!=son[x]) dfs2(edge[i].v,edge[i].v);&#125;void update_tr(int u,int v)&#123; while(top[u]!=top[v])&#123; if(depth[top[u]]&lt;depth[top[v]]) swap(u,v); update(pos[top[u]],1); update(pos[u]+1,-1); u=fa[top[u]]; &#125; if(depth[u]&lt;depth[v])swap(u,v); if(u==v)return ; v=son[v]; update(pos[u]+1,-1); update(pos[v],1);&#125;int query_tr(int u,int v)&#123; if(depth[u]&lt;depth[v])swap(u,v); return query(pos[u]);&#125;void init()&#123; n=read(),m=read(); for(S=1;S&lt;=n;S&lt;&lt;=1); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; dfs1(1,0,1); dfs2(1,1);&#125;void solve()&#123; char ord[3]; int x,y; while(m--)&#123; scanf("%s%d%d",ord,&amp;x,&amp;y); if(ord[0]=='P')update_tr(x,y); else printf("%d\n",query_tr(x,y)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11NOV Cow Steeplechase]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3033%2F</url>
    <content type="text"><![CDATA[题目地址 题解把线段抽象成点，线段相交就连一条边，然后求一个最大独立集。由于在二分图中，最大匹配就等于最小顶点覆盖，并且对于图来说，最大独立集加上最小顶点覆盖就等于点个数，所以直接上二分图匹配就行了。线段求交…计算几何123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,vis[255],match[255]=&#123;0&#125;,seg[255][4];int X[255],Y[255],cx=0,cy=0;bool mat[255][255]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int Edmond(int S)&#123; for(int i=1;i&lt;=cy;i++)&#123; if(mat[S][i]&amp;&amp;!vis[i])&#123; vis[i]=1; if(!match[i]||Edmond(match[i]))&#123; match[i]=S; return 1; &#125; &#125; &#125; return 0;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=4;j++) seg[i][j]=read(); if(seg[i][1]==seg[i][3])&#123; Y[++cy]=i;//竖直 if(seg[i][2]&gt;seg[i][4]) swap(seg[i][2],seg[i][4]); &#125;else &#123; X[++cx]=i;//水平 if(seg[i][1]&gt;seg[i][3]) swap(seg[i][1],seg[i][3]); &#125; &#125; for(int i=1;i&lt;=cx;i++) for(int j=1;j&lt;=cy;j++) if(seg[Y[j]][1]&gt;=seg[X[i]][1]&amp;&amp;seg[Y[j]][1]&lt;=seg[X[i]][3]&amp;&amp; seg[X[i]][2]&gt;=seg[Y[j]][2]&amp;&amp;seg[X[i]][2]&lt;=seg[Y[j]][4]) mat[i][j]=1;&#125;void solve()&#123; int ans=0; for(int i=1;i&lt;=cx;i++)&#123; memset(vis,0,sizeof(vis)); if(Edmond(i))ans++; &#125; printf("%d\n",n-ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最大匹配</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Chocolate buying]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2983%2F</url>
    <content type="text"><![CDATA[题目地址 题解差点写成多重背包，好险好险其实就是水贪心…1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n;ll b;pair&lt;ll,ll&gt; P[100005];void init()&#123; scanf("%d%lld",&amp;n,&amp;b); for(int i=0;i&lt;n;i++) scanf("%lld%lld",&amp;P[i].first,&amp;P[i].second);&#125;void solve()&#123; ll ans=0; sort(P,P+n); for(int i=0;i&lt;n;i++)&#123; if(b&lt;P[i].first)break; ll res=min(b/P[i].first,P[i].second); ans+=res; b-=res*P[i].first; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Treasure Chest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3004%2F</url>
    <content type="text"><![CDATA[题目地址 题解$DP$。时间复杂度为$O(n^2)$。我的方法是设$f(i,j)$表示从$i$到$j$先手最高分数，然后转移方程就是 f(i,j)=\max \left\{ c[i]+\min\left\{f(i+2,j),f(i+1,j-1)\right\} ,c[j]+\min\left\{f(i+1,j-1),f(i,j-2)\right\}\right\}但不知道为什么本机过了,洛谷上T了。当然本题的官方做法更巧妙。观察前面带有$\min$的式子，我们发现里面的$\min$可以拿掉，因为我们刚好也算出了第二个人作为先手的最大解。所以上面的$\min$就可以表示为$f$的形式，即 \min \left\{ f(i+2,j),f(i+1,j-1) \right\} =sum(i+1,j)-f(i+1,j)这样常数貌似很小，就可以过，还可以干掉一维空间。 修改前：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005][5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=0;i&lt;n;i++)c[i]=read();&#125;void solve()&#123; int d1,d2,d3,b1,b2,lim; for(int i=0;i&lt;n;i++) dp[i][i]=c[i]; for(int j=0;j&lt;n-1;j++) dp[j][j+1]=max(c[j],c[j+1]); for(int j=2;j&lt;n;j++)&#123; d1=dp[0][j-2],d2=dp[1][j-1],d3=dp[2][j]; lim=n-j; for(int i=0;i&lt;lim;i++)&#123; b1=d3;if(d2&lt;d3)b1=d2;b1+=c[i]; b2=d1;if(d2&lt;d1)b2=d2;b2+=c[i+j]; dp[i][i+j]=b1;if(b1&lt;b2)dp[i][i+j]=b2; d1=d2,d2=d3,d3=dp[i+3][i+1+j]; &#125; &#125; printf("%d\n",dp[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125; 修改后：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005]=&#123;0&#125;,sum[5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)c[i]=read(),sum[i]=sum[i-1]+c[i];&#125;void solve()&#123; for(int j=0;j&lt;n;j++) for(int i=1;i+j&lt;=n;i++) dp[i]=sum[i+j]-sum[i-1]-min(dp[i],dp[i+1]); printf("%d\n",dp[1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09MAR Look Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2947%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力肯定行不通，考虑到无用元素的去除以及单调性的维护，我们使用单调栈这一数据结构。实际上这题跟06年那道题一个意思，所以要看的话可以去前面找一下我写的另一篇题解。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int n,s[100005][2],dat[100005],top=0,ans[100005];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;dat[i]); s[top][0]=dat[n-1], s[top++][1]=n-1, ans[n-1]=-1; for(int i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;dat[i]&gt;=s[top-1][0]) top--; if(!top)ans[i]=-1; else ans[i]=s[top-1][1]; s[top][0]=dat[i], s[top++][1]=i; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09OPEN Cow Digit Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2953%2F</url>
    <content type="text"><![CDATA[题目地址 题解很标准的博弈论递推。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool sg[1000005];void init()&#123; sg[0]=0; int bit[9]=&#123;0&#125;,maxi,mini,len=1; for(int i=1;i&lt;=1000000;i++)&#123; bit[0]++; for(int j=0;bit[j]==10&amp;&amp;j&lt;len;j++) bit[j]=0,bit[j+1]++; if(bit[len])len++; mini=10,maxi=0; for(int j=0;j&lt;len;j++)&#123; if(bit[j]&gt;maxi)maxi=bit[j]; if(bit[j]&lt;mini&amp;&amp;bit[j])mini=bit[j]; &#125; if(!sg[i-maxi]||!sg[i-mini])sg[i]=1; &#125;&#125;void solve()&#123; int T=read(),n; while(T--) n=read(),printf("%s\n",sg[n]?"YES":"NO");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09NOV A Coin Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2964%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$dp(i,j)$表示还剩$i$个，之前选了$j$个的状态。正面非常不好做，所以要用这个倒着推的状态。转移只要$2$个，因为其他转移之前已经包含了。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int dp[2005][2005],n,a[2005],sum[2005],que[4000005][2],f=0,r=0;void init()&#123; n=read(); sum[0]=0; for(int i=n;i&gt;=1;i--)a[i]=read(); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; //正面不好写 &#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=dp[i][j-1]; if(i-2*j&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j][2*j]); if(i-2*j+1&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j+1][2*j-1]); &#125; &#125; printf("%d\n",dp[n][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09FEB Revamping Trails]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2939%2F</url>
    <content type="text"><![CDATA[题目地址 题解最短路模型，这很显然。顺带一提，不要用SPFA，真心卡成狗。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 1010000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int to,_next,cost;&#125;;struct Node&#123; int h,e,dis; Node(int h_,int e_,int d_)&#123; h=h_,e=e_,dis=d_; &#125; Node()&#123;&#125;&#125;;bool operator &lt;(const Node &amp;n1,const Node &amp;n2)&#123; return n1.dis&gt;n2.dis;&#125;priority_queue&lt;Node&gt; pq;Edge edge[100005];int n,m,k,at[10005]=&#123;0&#125;,F[10005][21]=&#123;0&#125;,cnt=0;void addedge(int u,int v,int c)&#123; edge[++cnt].to=v, edge[cnt].cost=c, edge[cnt]._next=at[u], at[u]=cnt;&#125;void Dij()&#123; F[1][0]=0,pq.push(Node(1,0,0)); Node tmp; int h_,e_,d_,v_,c_; while(!pq.empty())&#123; tmp=pq.top(),pq.pop(); if(tmp.dis&gt;F[tmp.h][tmp.e])continue; h_=tmp.h,e_=tmp.e,d_=tmp.dis; for(int i=at[h_];i;i=edge[i]._next)&#123; v_=edge[i].to,c_=edge[i].cost; if(F[v_][e_]&gt;F[h_][e_]+c_) F[v_][e_]=F[h_][e_]+c_, pq.push(Node(v_,e_,F[v_][e_])); if(e_&lt;k&amp;&amp;F[v_][e_+1]&gt;F[h_][e_]) F[v_][e_+1]=F[h_][e_], pq.push(Node(v_,e_+1,F[v_][e_+1])); &#125; &#125;&#125;void init()&#123; n=read(),m=read(),k=read(); int u,v,c; for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),c=read(); addedge(u,v,c),addedge(v,u,c); &#125;&#125;void solve()&#123; memset(F,0x3F,sizeof(F)); Dij(); int ans=INF*2; for(int i=0;i&lt;=k;i++)ans=min(ans,F[n][i]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08DEC Patting Heads]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2926%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力筛倍数即可。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,a[100005],cnt[1000005]=&#123;0&#125;,ans[1000005]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]),cnt[a[i]]++;&#125;void solve()&#123; for(int i=1;i&lt;=1000000;i++)&#123; if(cnt[i])&#123; for(int j=i;j&lt;=1000000;j+=i) ans[j]+=cnt[i]; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[a[i]]-1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08JAN Telephone Lines]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu1948%2F</url>
    <content type="text"><![CDATA[题目地址 题解一看就知道是二分答案的类型。二分最小费用$x$，然后看路上最少经过几条费用比他多的路。这题就一个地方有点绕：怎么求$1$-$n$之间路上有几条这样的路？要么边跑最短路边特判，要么把边分类，大于$x$的边权设$1$，小于的设$0$。这样就解决了这道题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next;&#125;;Edge edge[20005],_edge[20005];int V,E,K,at[1005],cnt=0,maxi=0;int d[1005],que[50005],f,r,in[1005]=&#123;0&#125;;void addedge(int _u,int _v,int _c)&#123; edge[cnt].v=_v, edge[cnt].cost=_c, edge[cnt]._next=at[_u], at[_u]=cnt++; &#125;void spfa_bfs(int S)&#123; fill(d,d+V,INF); d[S]=0; f=r=0,que[r++]=S,in[S]=1; while(r-f)&#123; int h=que[f++],_v,_c; for(int i=at[h];i!=-1;i=_edge[i]._next)&#123; _v=_edge[i].v,_c=_edge[i].cost; if(d[_v]&gt;d[h]+_c)&#123; d[_v]=d[h]+_c; if(!in[_v]) in[_v]=1,que[r++]=_v; &#125; &#125; in[h]=0; &#125;&#125;void init()&#123; scanf("%d%d%d",&amp;V,&amp;E,&amp;K); memset(at,-1,sizeof(at)); int u,v,c; for(int i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;c), addedge(u-1,v-1,c), addedge(v-1,u-1,c), maxi=max(maxi,c);&#125;void solve()&#123; int L=0,R=maxi,M; memcpy(_edge,edge,sizeof(edge)); while(R-L)&#123; int M=(R+L)/2; for(int i=0;i&lt;cnt;i++) _edge[i].cost=(edge[i].cost&gt;M); spfa_bfs(0); if(d[V-1]==INF)&#123; printf("-1\n"); return ; &#125; if(d[V-1]&gt;K)L=M+1; else R=M; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Time Management]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2920%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分+贪心每次优先完成期限最短且时间最短的任务。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,t[1005],s[1005],mini=INF;pair&lt;int,int&gt; P[1005];bool judge(int M)&#123; for(int i=0;i&lt;n;i++)&#123; if(M+P[i].second&lt;=P[i].first) M+=P[i].second; else return 0; &#125; return 1;&#125;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;t[i],&amp;s[i]), P[i].first=s[i],P[i].second=t[i], mini=min(mini,s[i]); sort(P,P+n);&#125;void solve()&#123; int L=0,R=mini,M; while(R-L)&#123; M=(R+L+1)/2; if(judge(M)) L=M; else R=M-1; &#125; if(!judge(0))L=-1; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR River Crossing]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2904%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP注意划船回来的时间12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int sum[2505],n,f[2505]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%d",&amp;n,&amp;sum[0]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;sum[i]), sum[i]+=sum[i-1];&#125;void solve()&#123; fill(f,f+n+1,INF); f[0]=0; for(int i=1;i&lt;=n;i++) for(int j=i-1;j&gt;=0;j--) f[i]=min(f[i],f[j]+sum[i-j]+sum[0]); printf("%d\n",f[n]-sum[0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OPEN Cow Neighborhoods]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2906%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个绝对值很难搞啊。拆开来试试看？ |x_1-x_2|+|y_1-y_2|=x_1-x_2+y_1-y_2或x_2-x_1+y_1-y_2或x_1-x_2+y_2-y_1或x_2-x_1+y_2-y_1发现前两个是相反数，中间俩也是。原式=|x_1+y_1-(x_ 2+y_2)|或|(x_1-y_1)-(x_2-y_2)|。这时候发现两个式子里面都是只与下标有关值的差，就设xx_i=x_i+y_i,yy_i=x_i-y_i。原式=|xx_1-xx_2|或|yy_1-yy_2|。我怎么知道取哪个?不知道，就让他们都满足。即使\max \left\{|xx_1-xx_2|,|yy_1-yy_2|\right\}\le c。之后就是乱搞了，维护一下差即可，用并查集合并可行部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,C,x[100005],y[100005],xx[100005],yy[100005],rk[100005];int par[100005],cnt[100005],ans1=0,ans2=0,S=0,ans,loc;int que[100005],f,r;struct Tr&#123; Tr *ch[2]; int r,v,id; int cmp(int w,int z) const &#123; if(w==v&amp;&amp;z==id)return -1; return w&gt;v||(w==v&amp;&amp;z&gt;id); &#125;&#125;;Tr tree[400005],*root=NULL;void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr,tr=k;&#125;void insert_tr(Tr* &amp;tr,int _v,int _id)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;v=_v,tr-&gt;id=_id; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); return ; &#125; int d=tr-&gt;cmp(_v,_id); insert_tr(tr-&gt;ch[d],_v,_id); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1);&#125;void delete_tr(Tr* &amp;tr,int _v,int _id)&#123; int d=tr-&gt;cmp(_v,_id); if(d==-1)&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),delete_tr(tr-&gt;ch[d_],_v,_id); &#125; &#125;else delete_tr(tr-&gt;ch[d],_v,_id);&#125; void previous(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&gt;=tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,previous(tr-&gt;ch[1],_v); else previous(tr-&gt;ch[0],_v);&#125;void success(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&lt;tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,success(tr-&gt;ch[0],_v); else success(tr-&gt;ch[1],_v);&#125;int Find(int k)&#123; if(k==par[k])return k; return (par[k]=(Find(par[k])));&#125;void Unite(int u,int v)&#123; if(Find(u)==Find(v))return; par[Find(u)]=Find(v);&#125;bool cmp(int ia,int ib)&#123; return xx[ia]&lt;xx[ib]||(xx[ia]==xx[ib]&amp;&amp;yy[ia]&lt;yy[ib]);&#125;void init()&#123; srand(21451); n=read(),C=read(); for(int i=1;i&lt;=n;i++) x[i]=read(),y[i]=read(),xx[i]=x[i]+y[i],yy[i]=x[i]-y[i],rk[i]=par[i]=i; sort(rk+1,rk+1+n,cmp);&#125;void solve()&#123; f=r=0,que[r++]=rk[1],insert_tr(root,yy[rk[1]],rk[1]); for(int i=2;i&lt;=n;i++)&#123; int index=rk[i]; while(r&gt;f&amp;&amp;xx[index]-xx[que[f]]&gt;C) delete_tr(root,yy[que[f]],que[f]),f++; ans=-INF,success(root,yy[index]);//查后缀 if(ans&gt;-INF&amp;&amp;ans-yy[index]&lt;=C)Unite(loc,index); ans=INF,previous(root,yy[index]);//查前缀 if(ans&lt;INF&amp;&amp;yy[index]-ans&lt;=C)Unite(loc,index); insert_tr(root,yy[index],index); que[r++]=index; &#125; for(int i=1;i&lt;=n;i++)cnt[Find(i)]++; for(int i=1;i&lt;=n;i++)ans1+=(cnt[i]!=0),ans2=max(ans2,cnt[i]); printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Eating Together]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2896%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一大力$O(nlogn)LIS$。优点：不容易错，缺点：时间复杂度高。 方法二运用特殊性质，分段$DP$，分别用$f(x),g(x),h(x)$表示以$1,2,3$为结尾的一段的最小修改次数。优点：时间复杂度线性缺点：容易错容易错容易错难调难调难调123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[30005],f[30005],g[30005],h[30005];void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();&#125;int dp()&#123; int mini,dif=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=1),f[i]=dif; dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=2),g[i]=mini+dif,mini=min(mini,f[i]-dif); dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=3),h[i]=mini+dif,mini=min(mini,min(g[i]-dif,f[i]-dif)); return min(f[n],min(g[n],h[n]));&#125;void solve()&#123; int ans=dp(); reverse(a+1,a+n+1); ans=min(ans,dp()); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Game of Lines]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2665%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力统计即可。wa了2次的我就是sb啊12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,x[205],y[205],tot=0;double lis[40005],eps=1e-8;double slope(int a,int b)&#123; if(x[a]==x[b])return 1e9; return (double)(y[b]-y[a])/(x[b]-x[a]);&#125;int cmp(double a,double b)&#123; return (a-b)&gt;-eps&amp;&amp;(a-b)&lt;eps;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)x[i]=read(),y[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;i;j++) lis[++tot]=slope(i,j); sort(lis+1,lis+tot+1); int ans=0; for(int i=2;i&lt;=tot;i++)&#123; while(cmp(lis[i],lis[i-1])&amp;&amp;i&lt;=tot) i++; ans++; &#125; if(!cmp(lis[tot],lis[tot-1]))ans++; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Watering Hole]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1550%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果没说全部连通的话就会形成一个特殊的局面：森林。把一个无向森林结合起来的常用方法就是加点。加一个超级源，使打井变成这个源到节点的边权，再MST即可。数据小，貌似暴力也行？12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int mat[405][405],w[405],n;int vis[405],mini[405];int prim(int S)&#123; memset(mini,0x3f,sizeof(mini)); mini[S]=0; int i,j,_min,at,ans=0; for(i=0;i&lt;n;i++)&#123; for(at=-1,j=0;j&lt;n;j++) if(!vis[j]&amp;&amp;(at&lt;0||mini[j]&lt;mini[at])) at=j; vis[at]=1,ans+=mini[at]; for(j=0;j&lt;n;j++) mini[j]=min(mini[j],mat[at][j]); &#125; return ans; &#125;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;w[i]); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(int i=0;i&lt;n;i++) mat[i][n]=mat[n][i]=w[i]; mat[n][n]=0; n++; printf("%d\n",prim(n-1)); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR Land Acquisition]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2900%2F</url>
    <content type="text"><![CDATA[题目地址 题解斜率优化。 合并部分土地，使$y$递减，$x$递增 注意单调队列的增减性。 决策的单调性… 凸壳的中间点在什么情况下一定不优？考虑不同的限定条件，可以证明两端分别在2种情况下都更优。这是单调队列单调的理由。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; P;P a[50005],b[50005];int n,cnt=0,que[50005]=&#123;0&#125;,l=1,r=1; ll f[50005];double slope(int j,int k)&#123; return (f[k]-f[j])/(b[j+1].second-b[k+1].second);&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i].first=read(),a[i].second=read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; //printf("%d %d\n",a[i].first,a[i].second); while(cnt&amp;&amp;a[i].second&gt;=b[cnt].second) cnt--; b[++cnt]=a[i]; &#125;&#125;void solve()&#123; que[r++]=0; for(int i=1;i&lt;=cnt;i++)&#123; while(r-l&gt;1&amp;&amp;slope(que[l],que[l+1])&lt;b[i].first) l++; f[i]=f[que[l]]+b[que[l]+1].second*b[i].first; while(r-l&gt;1&amp;&amp;slope(que[r-2],que[r-1])&gt;slope(que[r-1],i)) r--; que[r++]=i; &#125; printf("%lld\n",f[cnt]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OPEN Cheapest Palindrome]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2890%2F</url>
    <content type="text"><![CDATA[题目地址 题解区间DP没想出来的我该去看脑科12345678910111213141516171819202122232425262728293031323334353637 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,add[30],rem[30],dp[2005][2005];char s[2005],ord[3],is[2005][2005]=&#123;0&#125;;void init()&#123; scanf("%d%d%s",&amp;n,&amp;m,s); for(int i=0;i&lt;n;i++)&#123; scanf("%s",ord); scanf("%d%d",&amp;add[ord[0]-'a'],&amp;rem[ord[0]-'a']); &#125; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) dp[i][j]=(i&lt;j)?INF:0;&#125;void solve()&#123; for(int j=0;j&lt;m;j++) for(int i=0;i+j&lt;m;i++) if(s[i]==s[i+j])dp[i][i+j]=dp[i+1][i+j-1]; else&#123; dp[i][i+j]=min(dp[i+1][i+j]+rem[s[i]-'a'], min(dp[i+1][i+j]+add[s[i]-'a'], min(dp[i][i+j-1]+rem[s[i+j]-'a'], dp[i][i+j-1]+add[s[i+j]-'a']))); &#125; printf("%d\n",dp[0][m-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Protecting the Flowers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2878%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设牛$i$和牛$j$相邻，那么比较他们谁先送走更划算的依据是$T_iD_j$和$T_jD_i$。$T_iD_j&gt;T_jD_i$那么$j$先走，否则$i$先走。由此得判断依据：$\frac {T_i}{D_i}$与$\frac {T_j}{D_j}$。小的先走。之后排序贪心即可。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll n,t[100005],d[100005],ans=0,sum=0;pair&lt;double,ll&gt; P[100005];void init()&#123; scanf("%lld",&amp;n); for(ll i=0;i&lt;n;i++) scanf("%lld%lld",&amp;t[i],&amp;d[i]), P[i].first=(double)t[i]/d[i], P[i].second=i; sort(P,P+n); for(ll i=0;i&lt;n;i++) sum+=d[i];&#125;void solve()&#123; for(ll i=0;i&lt;n;i++)&#123; ll id=P[i].second; sum-=d[id]; ans+=2*t[id]*sum; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待考察 USACO07JAN Problem Solving]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2876%2F</url>
    <content type="text"><![CDATA[题目地址 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,b,f[605][305],A[305],B[305],sum[305],sumb[305],ans;void init()&#123; b=read(),n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(),B[i]=read(),sum[i]=sum[i-1]+A[i],sumb[i]=sumb[i-1]+B[i];&#125;void solve()&#123; f[2][0]=b; for(int i=1;i&lt;=n;i++) if(b&gt;=sum[i]&amp;&amp;b&gt;=sumb[i])f[2][i]=b-sumb[i]; else f[2][i]=-INF; for(int i=3;i&lt;=2*n;i++)&#123; f[i][0]=b; for(int j=1;j&lt;=n;j++)&#123; f[i][j]=-INF; for(int k=0;k&lt;=j;k++) if(f[i-1][k]-(sum[j]-sum[k])&gt;=0) f[i][j]=max(f[i][j],b-(sumb[j]-sumb[k])); &#125; if(f[i][n]&gt;=0)&#123; ans=i;break; &#125; &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OCT Obstacle Course]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1649%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力建图跑SPFA即可。就是要注意建图的方式：一个点拆成4个。同时注意输入，有坑！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[2000005];int cnt=0,at[40005],n,V;int d[40005],in[40005],que[500005],f=0,r=0;void spfa_bfs(int s)&#123; fill(d+1,d+4*V+1,INF); for(int i=0;i&lt;4;i++) d[s+i*V]=0,in[s+i*V]=1,que[r++]=s+i*V; int i,_u,_v,_co; while(r-f)&#123; _u=que[f++],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r++]=_v; &#125; &#125; &#125; &#125;&#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int xa,xb,ya,yb;char mat[105][105];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); char ord[1005]; int tot,len; for(int i=1;i&lt;=n;i++)&#123; fgets(ord,300,stdin); len=strlen(ord),tot=1; for(int j=0;j&lt;len;j++) if(!isspace(ord[j]))mat[i][tot++]=ord[j]; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(mat[i][j]=='A')xa=i,ya=j; else if(mat[i][j]=='B')xb=i,yb=j; V=n*n; memset(at,-1,sizeof(at)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(mat[i][j]=='x') continue; //1上2下3左4右 int id=(i-1)*n+j; addedge(id,2*V+id,1),addedge(2*V+id,id,1), addedge(id,V+id,2),addedge(V+id,id,2), addedge(id,3*V+id,1),addedge(3*V+id,id,1), addedge(2*V+id,V+id,1),addedge(V+id,2*V+id,1), addedge(3*V+id,V+id,1),addedge(V+id,3*V+id,1), addedge(2*V+id,3*V+id,2),addedge(3*V+id,2*V+id,2); if(i!=1&amp;&amp;mat[i-1][j]!='x')addedge(id,id-n,0); if(i!=n&amp;&amp;mat[i+1][j]!='x')addedge(V+id,V+(id+n),0); if(j!=1&amp;&amp;mat[i][j-1]!='x')addedge(2*V+id,2*V+(id-1),0); if(j!=n&amp;&amp;mat[i][j+1]!='x')addedge(3*V+id,3*V+(id+1),0); &#125;&#125;void solve()&#123; int id=(xa-1)*n+ya; spfa_bfs(id); id=(xb-1)*n+yb; int ans=min(min(min(d[id],d[V+id]),d[2*V+id]),d[3*V+id]); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07DEC Gourmet Grazers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2869%2F</url>
    <content type="text"><![CDATA[题目地址 题解STL大法好multiset水题按照贪心的思想，每次给牛中对草的质量最高的安排一个草的质量比他高的，且最便宜的。用平衡树维护即可。时限宽松，所以用multiset暴力水过123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;multiset&lt;int&gt; s;pair&lt;int,int&gt; P[100005],C[100005];ll ans=0; int n,m;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)C[i].second=read(),C[i].first=read(); for(int i=1;i&lt;=m;i++)P[i].second=read(),P[i].first=read(); sort(P+1,P+m+1); sort(C+1,C+n+1);&#125;void solve()&#123; for(int i=n,j=m;i&gt;=1;i--)&#123; while(j&gt;=1&amp;&amp;P[j].first&gt;=C[i].first) s.insert(P[j].second),j--; if(s.empty())&#123; printf("-1\n"); return ; &#125;else&#123; int ans_=*s.lower_bound(C[i].second); ans+=ans_,s.erase(s.find(ans_)); &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06FEB Treats for the Cows]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2858%2F</url>
    <content type="text"><![CDATA[题目地址 题解傻DP…区间转移形式12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,v[2005],f[2005][2005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=0;i&lt;n;i++) v[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;n;i++) f[i][i]=v[i]*n; for(int j=1;j&lt;n;j++) for(int i=0;i+j&lt;n;i++)&#123; f[i][i+j]=max(f[i+1][i+j]+v[i]*(n-j),f[i][i+j-1]+v[i+j]*(n-j)); &#125; printf("%d\n",f[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06NOV Bad Hair Day]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2866%2F</url>
    <content type="text"><![CDATA[题目地址 题解单调栈模板题。从右到左记录一个递减的序列即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; #include &lt;cstdlib&gt;using namespace std;int st[80005][2],top=0,n,h[80005];long long ans=0;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;h[i]); st[top][0]=h[n-1],st[top++][1]=n-1; for(i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;h[i]&gt;st[top-1][0]) top--; if(!top) ans+=(n-1-i); else ans+=(st[top-1][1]-i-1); st[top][0]=h[i],st[top++][1]=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06DEC Cow Roller Coaster]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2854%2F</url>
    <content type="text"><![CDATA[题目地址 题解先排序，把整个轨道考虑的顺序弄起来，再做01背包。注意状态的可行性。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,B,dp[1005][1005];struct C&#123; int l,r,fun,cost; bool operator &lt;(C &amp;a)&#123; return l&lt;a.l||(l==a.l&amp;&amp;r&lt;a.r); &#125;&#125;comp[10005];void init()&#123; L=read(),n=read(),B=read(); for(int i=1;i&lt;=n;i++) comp[i].l=read(),comp[i].r=read()+comp[i].l, comp[i].fun=read(),comp[i].cost=read(); sort(comp+1,comp+1+n);&#125;void solve()&#123; int c_,l_,r_,f_; memset(dp,-1,sizeof(dp)); for(int i=0;i&lt;=B;i++)dp[i][0]=0; for(int i=1;i&lt;=n;i++)&#123; c_=comp[i].cost,l_=comp[i].l,r_=comp[i].r,f_=comp[i].fun; for(int j=B;j&gt;=c_;j--) if(dp[j-c_][l_]&gt;=0) dp[j][r_]=max(dp[j][r_],dp[j-c_][l_]+f_); &#125; printf("%d\n",dp[B][L]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2012 随机数生成器]]></title>
    <url>%2F2018%2F08%2F02%2Fnoi2012t1%2F</url>
    <content type="text"><![CDATA[题目地址 题解水矩乘。唯一要注意的是爆炸的乘法运算。快速乘解决即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;typedef struct&#123; ll dat[3][3]; int r,c;&#125;Mat;ll M,A,C,x0,n,G;Mat mid,tmp;ll mulll(ll a,ll b)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%M; a=(a+a)%M;b&gt;&gt;=1; &#125; return res;&#125; void mul(Mat &amp;a,Mat &amp;b,Mat *to)&#123; to-&gt;r=a.r,to-&gt;c=b.c; int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; t=0;for(k=0;k&lt;a.c;k++)t+=mulll(a.dat[i][k],b.dat[k][j]),t%=M; to-&gt;dat[i][j]=t%M; &#125;&#125;Mat pow(Mat a,ll p)&#123; Mat E,F; E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)mul(E,a,&amp;F),E=F; mul(a,a,&amp;F),a=F;p&gt;&gt;=1; &#125;return E;&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;M,&amp;A,&amp;C,&amp;x0,&amp;n,&amp;G); Mat fib,d,u,v; fib.r=fib.c=2; fib.dat[0][0]=A%M; fib.dat[0][1]=fib.dat[1][1]=1; fib.dat[1][0]=0; u=pow(fib,n); d.r=2,d.c=1; d.dat[0][0]=x0%M,d.dat[1][0]=C%M; mul(u,d,&amp;v); printf("%lld\n",v.dat[0][0]%G); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI2012</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>快速乘</tag>
      </tags>
  </entry>
</search>
