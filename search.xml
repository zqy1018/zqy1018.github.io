<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round 511 (Div. 2) 题解]]></title>
    <url>%2F2018%2F09%2F22%2Fcontest-cf1047%2F</url>
    <content type="text"><![CDATA[人傻题不会.jpg A题目链接 分类讨论。可以分成$(a, a, b)$的形式，但是实际上还是分成$(1, 1, n-2)$或者$(1, 2, n-3)$更快。我是很蠢的选了前者。12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int k = n / 3, p = n - k - k; if(k % 3 == 0) &#123; if(p % 3 == 1) k++, p -= 2; else k--, p += 2; &#125;else if(p % 3 == 0) &#123; if(k % 3 == 1) k++, p -= 2; else k--, p += 2; &#125; printf("%d %d %d\n", k, k, p); return 0;&#125; B题目链接 观察可以发现，直线方程可以写成$y=-x+d$。而直线过点的时候可以保证答案最小，所以只要计算所有点中横纵坐标和的最大值即可。12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int n, ans = 0;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)&#123; int x, y; scanf("%d%d", &amp;x, &amp;y); ans = max(ans, x + y); &#125; printf("%d\n", ans); return 0;&#125; C题目链接 先求出这个GCD，然后： 方法一对每一个数除掉GCD，这样新的GCD就变成了$1$。我们只要让去掉一些数之后GCD大于$1$即可。可以枚举小于等于N=\sqrt{\max \left\{a_n\right\} }的质数，然后对每一个数判断是不是这个质数的倍数。保证尽量多的数是某一个质数的倍数即可。本质上是做质因数分解。这么做会超时。 方法二在方法一的基础上变换思路，考虑所有大于GCD的数，利用埃氏筛法求出其倍数的个数，和答案比较。 方法三在方法一的基础上用线性筛优化质因数分解的过程。 在这一题中我们可以看出筛法和质因数分解之间的紧密联系，这对于某一类的数论题目很有启发意义。以下代码基于方法二。1234567891011121314151617181920212223242526272829303132#pragma G++ optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;int n, maxi = 0, mk[15000005] = &#123;0&#125;;bool vd[15000005] = &#123;0&#125;;int gcd(int x, int y)&#123; return (!y) ? x : gcd(y, x % y);&#125;int main()&#123; int g; scanf("%d%d", &amp;n, &amp;g); maxi = g, mk[g]++; for(int i = 2; i &lt;= n; ++i) &#123; int t; scanf("%d", &amp;t); if(g != 1) g = gcd(t, g); maxi = max(maxi, t); mk[t]++; &#125; int ans = n; for(int i = g + 1; i &lt;= maxi; ++i)&#123; if(!vd[i])&#123; int cnt = 0; for(int j = i; j &lt;= maxi; j += i) vd[j] = 1, cnt += mk[j]; ans = min(ans, n - cnt); &#125; &#125; if(ans == n) printf("-1\n"); else printf("%d\n", ans); return 0;&#125; D题目链接 可以发现在格子处于一定大小，如$1\times 6$和$2\times 4$$的时候是可以做到基本填满的。所以我们就可以把整个棋盘切成多个小格，用这些小格的答案作为基去凑出整个棋盘的答案。我用的$7\times 7$以下所有格子的答案作为基，用这个应该就够了。12]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块学习记录]]></title>
    <url>%2F2018%2F09%2F15%2Fwriting%2Fbuildblock%2F</url>
    <content type="text"><![CDATA[本文主要记录了我做题时对分块算法的一些感觉。分块在处理一些奇奇怪怪的区间处理问题时常常十分有用。 普通线性分块——以区间加法为例问题1：给出一个长度为$N$的序列，共有$M$个操作，操作为区间加法或者区间求和。 考虑将序列分成$T$块，每一块长均为$S = \frac{N}{T}$，然后处理一系列的操作。对于区间加法，我们分两种情况： 若目标区间长度不足一个块，则对区间内每一个元素进行暴力修改。 若区间跨了多个块，那么对区间内的所有完整的块进行遍历，依次打上加法标记；对于区间端点所在的两个块，只对其中在区间内的元素进行暴力修改，换言之，对左右两端两个不完整的块进行暴力修改。对于区间求和，同样分两种情况： 若目标区间长度不足一个块，则对区间内每一个元素进行暴力统计。 若区间跨了多个块，那么对区间内的所有完整的块进行遍历，依次累加上它们的和；对于区间端点所在的两个块，只对其中在区间内的元素进行暴力统计，换言之，对左右两端两个不完整的块进行暴力统计。 这么做的时间复杂度是$O(M(S+T))$。根据均值不等式，当$S=T=\sqrt{N}$时括号内的值最小。因此选择的块数和块长都为$\sqrt{N}$时可以做到理论上的时间复杂度最优。打标记的做法和线段树相似，因此扩展到区间乘法，区间赋值的时候可以依照线段树的规则进行扩展，原理则基本相同。事实上，这种分块方式是最常见的。有时会根据具体的算法调整块的大小已达到理论最优时间复杂度。 特殊线性分块1——使用特殊方法（数据结构）维护块问题2：题目链接 考虑分块，发现区间加法虽然好做，但是求区间有多少个满足条件的人是不好办的，只有序列有序的时候才可以用二分这样时间复杂度稍低的方法求出答案，但在执行了区间加法后有序性就有可能被破坏。继续观察可以发现，分块后区间加法导致有序性被破坏的情况只有“区间加法没有覆盖完整的一块”这一种情况。因此事先对每一个块内部排序，区间加法除按照之前所述方法进行外，还要对不完整的块打上一个“有序性破坏”的标记。区间查询时，对有序性存在的完整块直接二分出答案，对有序性被破坏的完整块先排序再求解，对不完整的块暴力统计。因为一个区间加法最多导致2个块的有序性被破坏，所以排序的总次数为$O(\sqrt{N} + Q)$，总时间复杂度为$O(n\log n + q \sqrt{N} \log n)$。 在这类问题中，某些操作不能使用打标记之类的简单，普适的方法去解决时，就可以考虑用其他一些高明的方法（在本题中表现为排序，有时也表现为用数据结构维护块）——毕竟分块本身就算的上是一种相当高明的暴力方法嘛。（当然，要看数据规模） 特殊线性分块2——块状链表和暴力重构问题3：题目链接 这个题目像是NOI2003 文本编辑器的弱化。事实上这个题目是可以用块状链表实现的，但因为这里是分块的讲解，所以还是考虑分块。由于本题的操作比较简单，就只有插入，所以可以直接用一个链表来模拟。将链表分成$O(\sqrt {N})$段，每一段都保存段的长度（因为段会因为插入而变长）和段的开头，在理想情况下可以利用长度在$O(\sqrt {N})$时间内找到插入的位置并且完成插入。询问同理。这样总时间复杂度就是$O(N\sqrt {N})$。但是数据经过特殊构造后可以形成一个段特别长的情况，此时分块链表退化成为普通链表，时间复杂度最坏会达到$O(N^2)$。为了避免这种情况，需要在插入达到一定次数之后及时对链表进行重构，即重新分块。令插入次数的限制为$O(\sqrt {N})$，因为重构花费的时间是$O(n)$，而每次重构之后插入的时间复杂度都会恢复为原来水平，因此重构+插入+询问的总时间复杂度就是$O(N\sqrt {N})$。 这类问题一般有着大量的插入和删除操作，对应的是链表这样能够快速执行插入和删除的链状结构，因此使用有着分块思想的块状链表可以快速准确的完成这些操作。同时当操作简单时直接对所有的块进行重构也是一个不错的选择。 特殊线性分块3——以区间众数为例特殊线性分块4——带修改分块]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国家集训队2009 小Z的袜子]]></title>
    <url>%2F2018%2F09%2F15%2Fluogu1494%2F</url>
    <content type="text"><![CDATA[题目链接 题解莫队算法的一个典型应用。对所有询问的左端点所在块的编号排序，块内对右端点排序，然后按顺序处理所有询问。由于$(l, r)$的情况可以在$O(1)$的情况下转移到$(l, r + 1), (l, r - 1), (l - 1, r), (l + 1, r)$的情况，因此根据一定的复杂度分析，该算法的时间复杂度是$O(n \sqrt{n})$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1e9using namespace std;typedef long long ll;struct Q&#123; ll l,r,sqi,id;&#125;;bool cmp(Q u,Q v)&#123; if(u.sqi==v.sqi)return u.r&lt;v.r; return u.sqi&lt;v.sqi;&#125;Q query[50005];ll a[50005],ans[50005][2],n,m,size;ll cnt[50005]=&#123;0&#125;,tot=0;ll sqr(ll t)&#123;return t*t;&#125; void update(ll o,ll id)&#123; tot-=sqr(cnt[a[id]]), cnt[a[id]]+=o, tot+=sqr(cnt[a[id]]);&#125;ll gcd(ll a,ll b)&#123; return (!b)?a:gcd(b,a%b);&#125;void init()&#123; ll i,j; scanf("%lld%lld",&amp;n,&amp;m); for(size=1;size*size&lt;n;size++); for(i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(i=1;i&lt;=m;i++) scanf("%lld%lld",&amp;query[i].l,&amp;query[i].r), query[i].sqi=(query[i].l-1)/size, query[i].id=i; sort(query+1,query+m+1,cmp);&#125;void solve()&#123; ll L=1,R=0,_l,_r,_id,fz,fm,p; for(int i=1;i&lt;=m;i++)&#123; _l=query[i].l,_r=query[i].r; _id=query[i].id; for(;R&lt;_r;R++) update(1,R+1); for(;R&gt;_r;R--) update(-1,R); for(;L&lt;_l;L++) update(-1,L); for(;L&gt;_l;L--) update(1,L-1); if(_l==_r)&#123; ans[_id][0]=0,ans[_id][1]=1; continue; &#125; fz=tot-(_r-_l+1),fm=(_r-_l+1)*(_r-_l); p=gcd(fm,fz); fz/=p,fm/=p; ans[_id][0]=fz,ans[_id][1]=fm; &#125; for(int i=1;i&lt;=m;i++) printf("%lld/%lld\n",ans[i][0],ans[i][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 教主的魔法]]></title>
    <url>%2F2018%2F09%2F15%2Fluogu2801%2F</url>
    <content type="text"><![CDATA[题目链接 题解分块。先分块，然后对每一个块内排序。修改时对于处于一个块内的暴力修改后重新排序，对于处于不同块的把最左最右两个不完整的块暴力修改，然后对中间的块打标记。查询时对整个块直接二分查询，对不完整的块就暴力查询。时间复杂度：$O(Q\sqrt{N} \log N)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,h[1000005],bid[1000005],siz;//偷懒的做法。int t[1005][1005],add[1005],vis[1005],S[1005]=&#123;0&#125;; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int query(int L,int R,int C)&#123; int ans=0; for(;bid[L]==bid[L-1];L++) if(h[L]&gt;=C-add[bid[L]])ans++; for(;bid[R]==bid[R+1];R--) if(h[R]&gt;=C-add[bid[R]])ans++; for(int i=bid[L];i&lt;=bid[R];i++)&#123; if(vis[i])&#123; for(int j=0;bid[L]==i;L++) t[i][j++]=h[L]; sort(t[i],t[i]+S[i]); ans+=(t[i]+S[i])-lower_bound(t[i],t[i]+S[i],C-add[i]); vis[i]=0; &#125;else ans+=(t[i]+S[i])-lower_bound(t[i],t[i]+S[i],C-add[i]); &#125; return ans;&#125;void update(int L,int R,int W)&#123; for(;bid[L]==bid[L-1];L++)h[L]+=W; vis[bid[L-1]]=1; for(;bid[R]==bid[R+1];R--)h[R]+=W; vis[bid[R+1]]=1; for(int i=bid[L];i&lt;=bid[R];i++) add[i]+=W;&#125;void init()&#123; n=read(),m=read(); for(siz=1;siz*siz&lt;n;siz++); for(int i=1;i&lt;=n;i++) h[i]=read(), bid[i]=(i-1)/siz+1, S[bid[i]]++; bid[n+1]=siz+1;&#125;void solve()&#123; int x,y,z; char ord[3]; fill(vis+1,vis+siz+1,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%s%d%d%d",ord,&amp;x,&amp;y,&amp;z); if(ord[0]=='A') printf("%d\n",query(x,y,z)); else update(x,y,z); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨氏矩阵和勾长公式]]></title>
    <url>%2F2018%2F09%2F11%2Fyoung-tableau%2F</url>
    <content type="text"><![CDATA[本文讨论杨氏矩阵以及和其密切相关的勾长公式。 杨氏矩阵]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ2279 Mr. Young's Picture Permutations]]></title>
    <url>%2F2018%2F09%2F11%2Fpoj2279%2F</url>
    <content type="text"><![CDATA[题目链接 题解容易发现最高的人只能站在最左上角，然后后面的人从高到低必须要站在已经有的人的附近，不然就不合法。以此为依据，以人数为阶段，每一排的人数为状态转移即可。可以使用队列保证状态转移顺序正确。事实上这个题考的是一个叫做杨氏矩阵的数据结构，另外一篇文章里会介绍。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef unsigned int ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int k, n[6], g;ll f[32][32][32][32][32];int que[500000][5], l, r, cur[6];bool vis[32][32][32][32][32];void init()&#123; g = 0; for(int i = 0; i &lt; k; ++i) n[i] = read(), g += n[i]; for(int i = k; i &lt; 5; ++i) n[i] = 0; sort(n, n + 5); reverse(n, n + 5);&#125;void solve()&#123; memset(vis, 0, sizeof(vis)); f[0][0][0][0][0] = 1; vis[0][0][0][0][0] = true; l = 0, r = 1; for(int i = 0; i &lt; 5; ++i) que[0][i] = 0; ll ans = 0; while(r - l)&#123; int sum = 0; for(int i = 0; i &lt; 5; ++i) cur[i] = que[l][i], sum += cur[i]; l++; if(sum == g)&#123; ans += f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]]; continue; &#125; for(int i = 0; i &lt; k; ++i)&#123; if(cur[i] &lt; n[i] &amp;&amp; (i == 0 || cur[i - 1] &gt; cur[i]))&#123; int addi = f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]]; cur[i]++; if(!vis[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]])&#123; f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] = 0; for(int j = 0; j &lt; k; ++j) que[r][j] = cur[j]; for(int j = k; j &lt; 5; ++j) que[r][j] = 0; r++; vis[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] = 1; &#125; f[cur[0]][cur[1]][cur[2]][cur[3]][cur[4]] += addi; cur[i]--; &#125; &#125; &#125; printf("%u\n", ans);&#125;int main()&#123; while(k = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1434]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu1434%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[luogu2909]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2909%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[AHOI2005 矿藏编码]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2539%2F</url>
    <content type="text"><![CDATA[题目链接 题解标准的递归定义。按照递归定义处理即可。答案很大，要用int128或者double。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef __int128 ll;int n;ll ans = 0;void init()&#123; scanf("%d", &amp;n);&#125;void get(ll d)&#123; int p; scanf("%1d", &amp;p); if(p == 0) ans += d * d; else if(p == 2)&#123; for(int i = 0; i &lt; 4; ++i) get(d &gt;&gt; 1); &#125;&#125;void solve()&#123; ll a = 1; for(int i = 1; i &lt;= n; ++i) a *= 2ll; get(a); int num[50], len = 0; while(ans) num[++len] = ans % 10, ans /= 10; for(int i = len; i &gt;= 1; --i) printf("%d", num[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2005 位图]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu2335%2F</url>
    <content type="text"><![CDATA[题目链接 题解从每一个白块周围扩展即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, mp[155][155], ans[155][155];int que[22505][2], r, l;int dx[] = &#123;0, 0, -1, 1&#125;, dy[] = &#123;-1, 1, 0, 0&#125;;void init()&#123; n = read(), m = read(); memset(ans, -1, sizeof(ans)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) mp[i][j] = read(); r = l = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j)&#123; if(mp[i][j]) ans[i][j] = 0; else&#123; for(int k = 0; k &lt; 4; ++k)&#123; int ex = i + dx[k], ey = j + dy[k]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; mp[ex][ey])&#123; que[r][0] = i, que[r++][1] = j; ans[i][j] = 1; break; &#125; &#125; &#125; &#125;&#125;void solve()&#123; while(r - l)&#123; int cx = que[l][0], cy = que[l++][1]; for(int i = 0; i &lt; 4; ++i)&#123; int ex = cx + dx[i], ey = cy + dy[i]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; ans[ex][ey] &lt; 0)&#123; ans[ex][ey] = ans[cx][cy] + 1; que[r][0] = ex, que[r++][1] = ey; &#125; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m - 1; ++j) printf("%d ", ans[i][j]); printf("%d\n", ans[i][m - 1]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06FEB Stall Reservations]]></title>
    <url>%2F2018%2F09%2F02%2Fluogu2859%2F</url>
    <content type="text"><![CDATA[题目链接 题解线段覆盖类型的题目。先对端点排序，然后从左到右扫描，对线段依次分配。用一个堆来管理空出来的牛棚。当端点重合时先分配再释放。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;struct Q&#123; int id, x;&#125;;struct cmp&#123; bool operator ()(const Q&amp; q1, const Q&amp; q2)&#123; return q1.x &lt; q2.x; &#125;&#125;;int n, l[50005], r[50005], ans[50005] = &#123;0&#125;;Q q[100005];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) l[i] = read(), r[i] = read(), q[i &lt;&lt; 1].id = q[i &lt;&lt; 1 | 1].id = i, q[i &lt;&lt; 1].x = l[i], q[i &lt;&lt; 1 | 1].x = r[i]; sort(q, q + n + n, cmp());&#125;void solve()&#123; int ans_ = 0; for(int i = 0; i &lt; n + n; )&#123; int j; for(j = i; j &lt; n + n &amp;&amp; q[j].x == q[i].x; ++j) if(!ans[q[j].id]) &#123; if(pq.empty()) ans_++, ans[q[j].id] = -ans_; else ans[q[j].id] = -pq.top(), pq.pop(); &#125; for(j = i; j &lt; n + n &amp;&amp; q[j].x == q[i].x; ++j)&#123; if(ans[q[j].id] &lt; 0) ans[q[j].id] = -ans[q[j].id]; else pq.push(ans[q[j].id]); &#125; i = j; &#125; printf("%d\n", ans_); for(int i = 0; i &lt; n; ++i) printf("%d\n", ans[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09DEC Selfish Grazing]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu2970%2F</url>
    <content type="text"><![CDATA[题目链接 题解贪心入门题。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[50005];int main()&#123; int n,i,j,u,v,ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d%d",&amp;u,&amp;v), p[i].first=v,p[i].second=u; sort(p,p+n); ans++,u=p[0].second,v=p[0].first; for(i=1;i&lt;n;)&#123; while(i&lt;n&amp;&amp;p[i].second&lt;v) i++; if(i==n)break; ans++,u=p[i].second,v=p[i].first; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17FEB Why Did the Cow Cross the Road II S]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu3662%2F</url>
    <content type="text"><![CDATA[题目链接 题解记录每一个长为$k$的一段中有几个坏灯，找出答案。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;bool vis[100005] = &#123;0&#125;;int n, k, b;void init()&#123; scanf("%d%d%d", &amp;n, &amp;k, &amp;b); for(int i = 0; i &lt; b; ++i)&#123; int t; scanf("%d", &amp;t); vis[t] = true; &#125;&#125;void solve()&#123; int cnt = 0, ans = n; for(int i = 1; i &lt;= k; ++i) if(vis[i]) cnt++; for(int i = k; i &lt;= n; ++i)&#123; ans = min(ans, cnt); if(!ans) break; if(vis[i - k + 1]) cnt--; if(vis[i + 1]) cnt++; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08JAN Cow Contest]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu2419%2F</url>
    <content type="text"><![CDATA[题目链接 题解用Floyd算法补全胜负关系，然后如果能够确定一个牛对所有其他牛的胜负关系就认为名次可确认。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, d[105][105];void init()&#123; memset(d, -1, sizeof(d)); n = read(), m = read(); for(int i = 0; i &lt; m; ++i)&#123; int u = read(), v = read(); d[u][v] = 1, d[v][u] = 0; &#125; for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) if(d[i][k] != -1 &amp;&amp; d[k][j] != -1 &amp;&amp; d[i][k] == d[k][j]) d[i][j] = d[i][k];&#125;void solve()&#123; int ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; int w = 0, f = 0; for(int j = 1; j &lt;= n; ++j) if(d[i][j] == 1) w++; else if(d[i][j] == 0) f++; if(w + f == n - 1) ans++; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12NOV Clumsy Cows]]></title>
    <url>%2F2018%2F09%2F01%2Fluogu3056%2F</url>
    <content type="text"><![CDATA[题目链接 题解先把能配对的配掉，然后因为剩下的长度一定是偶数，所以可以根据左边)的数目和右边(的数目判断答案。当两者均为偶数时两边各改一半即可，均为奇数则分割处的)(要改成()，之后就转化为偶数的情况。123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[100005];void init()&#123; scanf("%s", s);&#125;void solve()&#123; int l = 0, r = 0, len = strlen(s); for(int i = 0; i &lt; len; ++i)&#123; if(s[i] == '(') l++; else&#123; if(l) l--; else r++; &#125; &#125; printf("%d\n", ((l + 1) &gt;&gt; 1) + ((r + 1) &gt;&gt; 1));&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1574]]></title>
    <url>%2F2018%2F08%2F31%2Fluogu1574%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[POJ2689 Prime Distance]]></title>
    <url>%2F2018%2F08%2F31%2Fpoj2689%2F</url>
    <content type="text"><![CDATA[题目链接 题解区间筛质数模板题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;unsigned int L, R, prime[35005], cnt = 0;bool vis1[70005] = &#123;0&#125;, vis2[1000005] = &#123;0&#125;;void getP()&#123; vis1[1] = true; for(int i = 2; i &lt;= 65536; ++i) if(!vis1[i])&#123; for(int j = i + i; j &lt;= 65536; j += i) vis1[j] = true; prime[++cnt] = i; &#125;&#125;void init()&#123; if(L &lt;= 1) L = 2; for(int i = 1; i &lt;= cnt; ++i)&#123; unsigned int p = prime[i]; if(R &lt; p) break; for(unsigned int j = max((L - 1 + p) / p, 2u); j &lt;= R / p; ++j) vis2[j * p - L] = 1; &#125;&#125;void solve()&#123; unsigned int lst = 0, mind = 1000001, maxd = 0; pair&lt;int, int&gt; ans1, ans2; for(unsigned int i = L; i &lt;= (unsigned int)R; ++i)&#123; if(!vis2[i - L])&#123; if(lst &gt; 0)&#123; if(i - lst &lt; mind)&#123; mind = i - lst; ans1.first = lst, ans1.second = i; &#125; if(i - lst &gt; maxd)&#123; maxd = i - lst; ans2.first = lst, ans2.second = i; &#125; &#125; lst = i; &#125; &#125; if(!maxd) printf("There are no adjacent primes.\n"); else printf("%d,%d are closest, %d,%d are most distant.\n", ans1.first, ans1.second, ans2.first, ans2.second); memset(vis2, 0, sizeof(vis2));&#125;int main()&#123; getP(); while(scanf("%d%d", &amp;L, &amp;R) == 2)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2005 午餐]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2577%2F</url>
    <content type="text"><![CDATA[题目链接 题解按时间DP。如果只有一个窗口那就是贪心了，按照吃饭时间从大到小排即可。两个窗口就DP，设$f[i][j]$表示前$i$个人在窗口1花了$j$时间打饭，最短的用餐时间。这样的话就可以转移了。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;pair&lt;int,int&gt; P[205];int n,A[205],B[205],f[205][40005],sum[205];int cmp(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b)&#123; return a.second&gt;b.second;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)P[i].first=read(),P[i].second=read(); sort(P+1,P+n+1,cmp); for(int i=1;i&lt;=n;i++)A[i]=P[i].first,B[i]=P[i].second; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+A[i];&#125;void solve()&#123; memset(f,0x3f,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;=sum[i-1];j++)&#123;//只有这段时间有意义 f[i][j]=min(f[i][j],max(f[i-1][j],sum[i-1]-j+A[i]+B[i])); f[i][j+A[i]]=min(f[i][j+A[i]],max(f[i-1][j],j+A[i]+B[i])); &#125; &#125; int ans=INF; for(int i=0;i&lt;=sum[n];i++)ans=min(ans,f[n][i]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI2016初中组 迷宫]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2778%2F</url>
    <content type="text"><![CDATA[题目链接 题解大部分人是用几何性质去枚举的。标算貌似用了线性求LCA，常数很大的样子。我是暴力建树，然后用了类似于LCA的方法求最长公共路径，然后再求不同的路。本质上可能是一样的，不过我这个居然更快？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,x_1,x_2,y_1,y_2,par[8005],son[8005],bro[8005];int cx,cy,rec[2][8005],tot[2]=&#123;0&#125;;struct C&#123; int id,x,y,r; bool operator&lt;(C c)&#123; return r&gt;c.r; &#125;&#125;;C cir[8005];void dfs(int id,int o)&#123; int dx,dy,dr; for(int i=son[id];i!=-1;i=bro[i])&#123; dx=cir[i-1].x,dy=cir[i-1].y,dr=cir[i-1].r; if((cx-dx)*(cx-dx)+(cy-dy)*(cy-dy)&lt;=dr*dr)&#123; rec[o][tot[o]++]=id; dfs(i,o); return ; &#125; &#125; rec[o][tot[o]++]=id; return ;&#125;void insert_(int cur,int id)&#123; int dx,dy,dr; for(int i=son[cur];i!=-1;i=bro[i])&#123; dx=cir[i-1].x,dy=cir[i-1].y,dr=cir[i-1].r; if((cx-dx)*(cx-dx)+(cy-dy)*(cy-dy)&lt;=dr*dr)&#123; insert_(i,id); return ; &#125; &#125; par[id]=cur,bro[id]=son[cur], son[cur]=id;&#125;void init()&#123; memset(son,-1,sizeof(son)); memset(par,-1,sizeof(par)); memset(bro,-1,sizeof(bro)); int i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d%d%d",&amp;cir[i].x,&amp;cir[i].y,&amp;cir[i].r); sort(cir,cir+n); scanf("%d",&amp;m); //建树 for(i=0;i&lt;n;i++) cx=cir[i].x,cy=cir[i].y, insert_(0,i+1);&#125;void solve()&#123; int i,j,lim,ans; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d",&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); tot[0]=tot[1]=0; cx=x_1,cy=y_1,dfs(0,0); cx=x_2,cy=y_2,dfs(0,1); lim=min(tot[0],tot[1]); for(j=0;j&lt;lim;j++) if(rec[0][j]!=rec[1][j])break; ans=tot[0]+tot[1]-2*j; printf("%d\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI2009 中国象棋]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2051%2F</url>
    <content type="text"><![CDATA[题目链接 题解不好形容的DP。设$f(i,j,k)$表示当前在第$i$行，有$j$列没炮，$k$列$1$个炮。就可以愉快的转移了。转移的时候注意系数。（也就是组合数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define Mod 9999973llusing namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll n,m,f[105][105][105]=&#123;0&#125;;//f(i,j,k) 第i行 j列0个 k列1个 void init()&#123; n=read(),m=read(); f[1][m][0]=1,f[1][m-1][1]=m; if(m!=1)f[1][m-2][2]=m*(m-1)/2;&#125;void solve()&#123; for(int i=2;i&lt;=n;i++) for(ll j=0;j&lt;=m;j++) for(ll k=0;k+j&lt;=m;k++)&#123; f[i][j][k]+=f[i-1][j][k]; if(k&gt;=2)f[i][j][k]+=f[i-1][j+2][k-2]*(j+2)*(j+1)/2; if(j+1&lt;=m)f[i][j][k]+=f[i-1][j+1][k]*(j+1)*k; if(k+2&lt;=m)f[i][j][k]+=f[i-1][j][k+2]*(k+2)*(k+1)/2; if(k&gt;=1)f[i][j][k]+=f[i-1][j+1][k-1]*(j+1); if(k+1&lt;=m)f[i][j][k]+=f[i-1][j][k+1]*(k+1); f[i][j][k]%=Mod; &#125; ll ans=0; for(int j=0;j&lt;=m;j++) for(int k=0;k+j&lt;=m;k++) ans=(ans+f[n][j][k])%Mod; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1984]]></title>
    <url>%2F2018%2F08%2F30%2Fwriting%2Fluogu1984%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[USACO13JAN Painting the Fence]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu2205%2F</url>
    <content type="text"><![CDATA[题目地址 题解对线段左右端点坐标排序，模拟加入和删除线段，同时维护线段覆盖层数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;bool in[100005] = &#123;0&#125;;int n, k, ans = 0;pair&lt;int, int&gt; p[200005];void init()&#123; n = read(), k = read(); char ord[3]; for(int i = 0, cur = 0; i &lt; n; ++i)&#123; int st; scanf("%d%s", &amp;st, ord); if(ord[0] == 'R') p[i &lt;&lt; 1].first = cur, p[i &lt;&lt; 1 | 1].first = cur + st, cur += st; if(ord[0] == 'L') p[i &lt;&lt; 1].first = cur, p[i &lt;&lt; 1 | 1].first = cur - st, cur -= st; p[i &lt;&lt; 1].second = p[i &lt;&lt; 1 | 1].second = i; &#125; sort(p, p + n + n);&#125;void solve()&#123; int cnt = 1, lst = p[0].first; in[p[0].second] = 1; for(int i = 1; i &lt; n + n; ++i)&#123; int id = p[i].second; if(cnt &gt;= k) ans += p[i].first - lst; if(!in[id]) in[id] = 1, cnt++; else in[id] = 0, cnt--; lst = p[i].first; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI2009 中位数]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu1627%2F</url>
    <content type="text"><![CDATA[题目链接 题解设$b$所在位置是$k$，那么对于$k$及$b$左边的所有位置求一个$d[i]$，表示$i$到$k-1$有几个小于$b$的数。那么对于$k$及其右边的位置$j$我们定义$d[j]$为$k+1$到$j$有几个小于$b$的数，这样对于一个$j$我们想要找到所有的$i$，使得 d[j]+d[i]=j-k-d[j]+k-i-d[i]整理为 2d[j]-j=-i-2d[i]用map实现。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;map&lt;int, int&gt; mp;int n, a[100005], b, k, ans = 0;void init()&#123; n = read(), b = read(); for(int i = 1; i &lt;= n; ++i)&#123; a[i] = read(); if(a[i] == b) k = i; &#125;&#125;void solve()&#123; int cnt = 0; for(int i = k; i &gt;= 1; --i)&#123; if(a[i] &lt; b) cnt++; mp[0 - i - 2 * cnt]++; &#125; cnt = 0; for(int i = k; i &lt;= n; ++i)&#123; if(a[i] &lt; b) cnt++; ans += mp[2 * cnt - i]; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHOI2002 百事世界杯之旅]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu1291%2F</url>
    <content type="text"><![CDATA[题目地址 题解]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3917 异或序列]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu3917%2F</url>
    <content type="text"><![CDATA[题目链接 题解考虑每一位的贡献，发现每一个数包括它自己在内，向左不断异或得到的$1$的个数是可以递推的，而这个数这一位的贡献次数就等于它左边的数的个数$+1$，于是就可以做了。某种意义上的前缀和。事实上可以当作前缀和来做。一般这种奇怪的位运算题都要分别考虑贡献1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll sum = 0;int n, a[100005], cntl[100005];void init()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read();&#125;void solve()&#123; cntl[0] = 0; for(int i = 1, j = 0; j &lt; 30; i &lt;&lt;= 1, ++j)&#123; for(int k = 1; k &lt;= n; ++k) if(a[k] &amp; i) cntl[k] = k - cntl[k - 1], sum += 1ll * i * cntl[k]; else cntl[k] = cntl[k - 1], sum += 1ll * i * cntl[k]; &#125; printf("%lld\n", sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2016 食物链]]></title>
    <url>%2F2018%2F08%2F30%2Fluogu3183%2F</url>
    <content type="text"><![CDATA[题目链接 题解拓扑排序即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;typedef struct&#123; int v,_next; &#125;Edge; Edge edge[200005];int cnt=0,at[100005],ru[100005]=&#123;0&#125;,V,E,ans[100005]=&#123;0&#125;;int q[100005],f=0,r=0;void addedge(int _u,int _v)&#123; edge[cnt].v=_v, ru[_v]++, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; void init()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,u,v; memset(at,-1,sizeof(at)); for(i=0;i&lt;E;i++) scanf("%d%d",&amp;u,&amp;v), addedge(u-1,v-1);&#125;void solve()&#123; int Ans=0; for(int i=0;i&lt;V;i++) if(!ru[i]&amp;&amp;at[i]!=-1) ans[i]=1,q[r++]=i; while(r-f)&#123; int h=q[f++],i,_v; for(i=at[h];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v; ru[_v]--; ans[_v]+=ans[h]; if(!ru[_v]) q[r++]=_v; &#125; &#125; for(int i=0;i&lt;V;i++) if(at[i]==-1) Ans+=ans[i]; printf("%d\n",Ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1724 Ellipse]]></title>
    <url>%2F2018%2F08%2F30%2Fhdu1724%2F</url>
    <content type="text"><![CDATA[题目链接 题解可以直接用数值积分，也可以查积分表。 (\frac {x}{2}\sqrt{a^2 - x ^2}+\frac {a^2}{2}\arcsin {\frac{x}{a}})' = \sqrt{a^2 - x^2}123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std; double a, b, L, R;void init()&#123; scanf("%lf%lf%lf%lf", &amp;a, &amp;b, &amp;L, &amp;R);&#125;double FF(double x)&#123; return b * (x * sqrt(a * a - x * x) / 2 + a * a * asin(x / a) / 2) / a;&#125;void solve()&#123; if(L &lt; -a) L = -a; if(R &gt; a) R = a; printf("%.3lf\n", (FF(R) - FF(L)) * 2);&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3908 异或之和]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu3908%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一对每一位统计这一位上有多少个1。1234567891011121314151617181920212223#include &lt;iostream&gt;#define INF 2000000000using namespace std;typedef unsigned long long ll;ll n;void init()&#123; cin &gt;&gt; n;&#125;void solve()&#123; ll t = n, ans = 0; for(ll c = 1; ; c &lt;&lt;= 1)&#123; ll cnt = c * ((t / c + 1) &gt;&gt; 1) + (t % c) * ((t / c + 1) &amp; 1); if(cnt &amp; 1) ans |= c; if(t &gt; c) t -= c; else break; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; 方法二两个相邻（从0,1开始）的数异或必然为1。所以统计一下即可。如果$n$是偶数只要在$n$是奇数的情况上异或即可。]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2388 阶乘之乘]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu2388%2F</url>
    <content type="text"><![CDATA[题目链接 题解可以知道阶乘$n!$中因子$p$的次数是 \sum_{k = 1} \lfloor \frac{n}{p^k}\rfloor而末尾$0$的个数就要看因子$10$的次数，而$10$的次数要看$2$和$5$的次数。因为本题中容易看出$2$的次数远大于$5$的次数，所以只要算出后者即可。这里我用了一点等差数列的技巧。。。123456789101112131415161718192021#include &lt;cstdio&gt;#define INF 2000000000using namespace std;typedef long long ll;ll n;void init()&#123; scanf("%lld", &amp;n);&#125;void solve()&#123; ll n5 = 0; for(ll i = 5; i &lt;= n; i *= 5)&#123; ll clos = (n % i == i - 1) ? n : (n - (n + 1) % i); n5 += ((clos + 1) / i - 1) * (clos + 1) / 2 + (n - clos) * (clos + 1) / i; &#125; printf("%lld\n", n5);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 高精度整数]]></title>
    <url>%2F2018%2F08%2F29%2Ftemplate-biginteger%2F</url>
    <content type="text"><![CDATA[高精度整数运算的模板。为了节省空间，此处不将运算封装成为一个类。 字符串变为高精度数高精度整数用的比较多的是将大数变成一个万进制数，用一个数组储存。数组的第一位为万进制数的长度。1234567891011int ten[] = &#123;1, 10, 100, 1000&#125;;inline void clearZero(int *bi)&#123; while(bi[0] &amp;&amp; !bi[bi[0]]) --bi[0];&#125;void build(char *src, int *dst)&#123; int len = strlen(src); dst[0] = (len - 1) / 4 + 1; for(int i = len - 1, j = 0; i &gt;= 0; --i, ++j) dst[(j &gt;&gt; 2) + 1] = (src[i] - '0') * ten[j &amp; 3]; clearZero(dst);&#125; 高精度比较和字符串比大小差不多。1234567891011121314151617181920//前者小于后者？bool cmp1(int *s1, int *s2)&#123; if(s1[0] != s2[0]) return s1[0] &lt; s2[0]; for(int i = s1[0]; i &gt;= 1; --i) if(s1[i] != s2[i]) return s1[i] &lt; s2[i]; return false;&#125;//小于等于bool cmp2(int *s1, int *s2)&#123; if(s1[0] != s2[0]) return s1[0] &lt; s2[0]; for(int i = s1[0]; i &gt;= 1; --i) if(s1[i] != s2[i]) return s1[i] &lt; s2[i]; return true;&#125;//等于bool cmp3(int *s1, int *s2)&#123; for(int i = 0; i &lt;= s1[0]; ++i) if(s1[i] != s2[i]) return false; return true;&#125; 高精度加法从最低位开始加，一直加到更大数的最高位。1234567void add(int *s1, int *s2, int *dst)&#123; int len = max(s1[0], s2[0]), x = 0; dst[0] = len; for(int i = 1; i &lt;= len; ++i) x += s1[i] + s2[i], dst[i] = x % 10000, x /= 10000; if(x &gt; 0) dst[++dst[0]] = x;&#125; 如果不支持不停的memset那就改写成这样：123456789101112void add(int *s1, int *s2, int *dst)&#123; int len1 = max(s1[0], s2[0]), len2 = s1[0] + s2[0] - len1, x = 0; dst[0] = len1; int *smax; if(s1[0] == len1) smax = s1; else smax = s2; for(int i = 1; i &lt;= len2; ++i) x += s1[i] + s2[i], dst[i] = x % 10000, x /= 10000; for(int i = len2 + 1; i &lt;= len1; ++i) x += smax[i], dst[i] = x % 10000, x /= 10000; if(x &gt; 0) dst[++dst[0]] = x;&#125; 高精度减法默认为$a-b$，因为负数不太好实现。 高精度乘法乘一个小于10000的数乘一个大数高精度左移直接执行对该数乘上2。 高精度幂高精度除法高精度开方高精度GCD直接使用Stein算法。void gcd(int s1, int s2, int *dst){ dst[0] = dst[1] = 1;}]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BJWC2008 雷涛的小猫]]></title>
    <url>%2F2018%2F08%2F29%2Fluogu1107%2F</url>
    <content type="text"><![CDATA[题目链接 题解水DP记录每一层的最大值用于优化转移。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, h, d, dp[2005][2005] = &#123;0&#125;, maxi[2005] = &#123;0&#125;, cnt[2005][2005] = &#123;0&#125;;void init()&#123; n = read(), h = read(), d = read(); for(int i = 0; i &lt; n; ++i)&#123; int ni = read(); for(int j = 0; j &lt; ni; ++j) cnt[i][read()]++; &#125;&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i) dp[i][h] = cnt[i][h], maxi[h] = max(maxi[h], cnt[i][h]); for(int i = h - 1; i &gt;= 0; --i) for(int j = 0; j &lt; n; ++j)&#123; dp[j][i] = dp[j][i + 1]; if(h - i &gt;= d) dp[j][i] = max(dp[j][i], maxi[i + d]); dp[j][i] += cnt[j][i]; maxi[i] = max(maxi[i], dp[j][i]); &#125; printf("%d\n", maxi[0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数降幂定理]]></title>
    <url>%2F2018%2F08%2F28%2Fproblem-eulerjiangmi%2F</url>
    <content type="text"><![CDATA[问题证明： a^x \equiv a^{x\mod \phi(c) + \phi(c)} \pmod c \quad (x\ge \phi(c))求解容易知道，数列$a^0, a^1, a^2, …, a^x,…$一定有一段长度不超过$c$的循环节。设这段循环节从$r$开始，长度为$l$，那么$a^r \equiv a^{r+l} \pmod c$。而定理中有一个$\mod \phi(c)$，这提示我们考虑循环的性质。根据定理，我们不妨猜想$\phi(c)$就是一个循环节的长度的倍数，即$l\mid \phi(c)$，并且从数列的前$\phi(c)$项中的某一项开始就已经开始循环了。首先对于$r$有2个性质： 数列前$r$项和后面所有项分别处于两个不同的集合中。因为如果两个集合相交，那么说明可以改变$r$的大小使得两个集合不相交，这样就不符合循环从$r$开始。 前$r$项没有重复的项。因为如果有，说明循环在$r$之前就已经开始，这也不符合$r$的定义。 对于$\gcd(a, c) = 1$的情况，由于欧拉定理，该式子显然成立。对于其他更为平凡的情况，则有： $a$是质数，则$a\mid c$。则设$c=ka^e$，则$\phi(c)=\phi(k) \times a^{e-1}\times (a-1)$。则$a^{\phi(k)} \equiv 1 \pmod k$，则$a^{\phi(c)} \equiv 1 \pmod k$。令$a^{\phi(c)}=sk + 1$，则$a^{\phi(c)+e}=ska^e+a^e=sc+a^e$，即$a^{e+\phi(c)} \equiv a^e \pmod c$。因此可知$r\le e$。易证$\phi(c)\ge e$。（考虑构造不等式） $a$是质数的幂，则设$a=p^e$，$c=kp^w$。则$\phi(c)=\phi(k)\times p^{w-1}\times (p-1)$。则$p^{\phi(k)} \equiv 1 \pmod k$，则$p^{\phi(c) \frac{e}{\gcd(e, \phi(c))}} \equiv 1 \pmod k$。令$l’ = \frac{\phi(c)}{\gcd(e, \phi(c))}$,$p^{e l’}=sk+1$，则$p^{(l’+w)e }=a^{w+l’}=skp^{ew}+p^{ew}=sp^{(e-1)w}c+a^w$，即$a^{w+l’} \equiv a^w \pmod c$。因此可知$r\le w$，$l’\mid \phi(c)$，即$\phi(c)$可以构成一个周期。同样，易证$\phi(c)\ge w$。（考虑构造不等式） $a$是2个质数的幂的积，则设a=p_1^{e_1} p_2^{e_2}，那么由2可得p_1^{e_1 (w_1+\phi(c))} \equiv p_1^{e_1 w_1}\pmod c,p_2^{e_2 (w_2+\phi(c))} \equiv p_2^{e_2 w_2} \pmod c。对前一个式子两边乘以p_1^{e_1 w_2}，对后一个式子两边乘上p_2^{e_2 w_1}，将两个式子合并就有a^{w_1+w_2+\phi(c)} \equiv a^{w_1+w_2} \pmod c。同样，令c=kp_1^{w_1}p_2^{w_2}，就有\phi(c)=\phi(k)\times p_1^{w_1 - 1} \times (p_1 - 1) \times p_2^{w_2 - 1} \times (p_2 - 1)，因此利用上式即可证明w_1 + w_2 \le \phi(c)。 $a$为多个质数的幂的积，则依照3进行即可。 由此就完成了证明。（如果证错了请和我说！） 参考资料]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTSC2014 企鹅QQ]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4503%2F</url>
    <content type="text"><![CDATA[题目链接 题解裸hash的命中率太低了。还是要开unsigned long long，而且要搞2个模数。反正大概就是枚举删去哪一位，然后排序找不同。千万不要用传统的Hash，会疯狂wa。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define INF 2000000000#define P 390791ull#define P_ 323591ullusing namespace std;typedef unsigned long long ll;int n,L,S,ans=0,cnt[11179120]=&#123;0&#125;;ll hsh[11179120]=&#123;0&#125;,ppow1[306],ppow2[306],H[30005],T[30005];bool vis[11179120]=&#123;0&#125;;char Str[30005][205];ll Hash(char *s)&#123; ll resa=0,resb=0; //给某一个特殊位置赋值0 for(int i=0;i&lt;L;i++) resa=P*resa+s[i],resb=P_*resb+s[i]; resa+=resb; return resa;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),L=read(),S=read(); ppow1[0]=ppow2[0]=1; for(int i=1;i&lt;=L;i++) ppow1[i]=ppow1[i-1]*P,ppow2[i]=ppow2[i-1]*P_;&#125;void solve()&#123; int tmp; ll valu; for(int i=1;i&lt;=n;i++) scanf("%s",Str[i]), H[i]=Hash(Str[i]); for(int j=0;j&lt;L;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; valu=H[i],valu-=Str[i][j]*ppow1[L-j-1], valu-=Str[i][j]*ppow2[L-j-1]; T[i]=valu; &#125; sort(T+1,T+n+1); int cur=1; for(int i=2;i&lt;=n;i++)&#123; if(T[i]==T[i-1])ans+=cur,cur++; else cur=1; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>CTSC</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3884 上帝与集合的正确用法]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4139%2F</url>
    <content type="text"><![CDATA[题目链接 题解直接上欧拉定理降幂公式。 a^x \equiv a^{x\mod \phi(c) + \phi(c)} \pmod c \quad (x\ge \phi(c))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll P,phi[10000005]=&#123;0&#125;;ll Pow(ll a,ll b,ll c)&#123; a%=c; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll getphi(ll N)&#123; ll res=N,t=N; for(ll i=2;i*i&lt;=N;i++)&#123; if(t%i==0)&#123; while(t%i==0)t/=i; res/=i,res*=(i-1); &#125; if(t==1)break; &#125; if(t!=1)res/=t,res*=(t-1); return res;&#125;ll dfs(ll p)&#123; if(p==1)return 0; //S=2^S=2^S mod phi P，what is S? if(!phi[p])phi[p]=getphi(p); return (Pow(2,dfs(phi[p])+phi[p],p));&#125;void init()&#123; phi[1]=1;&#125;void solve()&#123; int T=read(); while(T--)&#123; P=read(),printf("%lld\n",dfs(P)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2429 GCD & LCM Inverse]]></title>
    <url>%2F2018%2F08%2F28%2Fpoj2429%2F</url>
    <content type="text"><![CDATA[题目地址 题解找质因子用Miller-Rabin和Pollard-Rho实现，然后求解的时候考虑对勾函数，当$a$和$b$越接近$\sqrt{ab}$时$a+b$越小。就做完了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;ll g, l, prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;ll dd[55], ans = -1;int e1[55] = &#123;0&#125;, e2[55] = &#123;0&#125;, cnt = 0;double lev, dis;ll gcd(ll a, ll b)&#123; return (!b) ? a : gcd(b, a % b);&#125;ll mul(ll a, ll b, ll M)&#123; ll res = 0; while(b)&#123; if(b &amp; 1ll) &#123; res += a; if(res &gt;= M) res -= M; &#125; a &lt;&lt;= 1, b &gt;&gt;= 1; if(a &gt;= M) a -= M; &#125; return res;&#125;ll modpow(ll a, ll b, ll M)&#123; a %= M; ll res = 1; while(b)&#123; if(b &amp; 1ll) res = mul(res, a, M); a = mul(a, a, M), b &gt;&gt;= 1; &#125; return res;&#125;bool witness(ll a, ll n, ll t, ll u)&#123; ll x = modpow(a, u, n); for(ll i = 1; i &lt;= t; ++i)&#123; ll xx = mul(x, x, n); if(xx == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return true; x = xx; &#125; if(x != 1) return true; return false;&#125;bool miller_rabin(ll n)&#123; for(int i = 0; i &lt; 10; ++i)&#123; if(n == prime[i]) return true; else if(n % prime[i] == 0) return false; &#125; ll t, u; for(t = 1; ; ++t) if((n - 1) % (1 &lt;&lt; t) == 0) break; u = (n - 1) / (1 &lt;&lt; t); for(int i = 0; i &lt; 10; ++i) if(witness(rand() % (n - 1) + 1, n, t, u)) return false; return true;&#125;ll rho(ll n, ll c)&#123; ll x = modpow(rand(), rand(), n), y = x, d = 1; int k = 2; for(int i = 1; d == 1; ++i)&#123; x = mul(x, x, n) + c; if(x &gt;= n) x -= n; if(x &gt; y) d = gcd(x - y, n); else d = gcd(y - x, n); if(i == k) y = x, k &lt;&lt;= 1; &#125; return d;&#125;ll Pollard(ll n)&#123; ll d = n; while(d == n) d = rho(n, rand() % (n - 1) + 1); return d;&#125;void addFac(ll &amp;x, ll d, int *e)&#123; int cur; for(cur = 0; cur &lt; cnt; ++cur) if(dd[cur] == d) break; dd[cur] = d; do&#123; x /= d, e[cur]++; &#125;while(x % d == 0); if(cur == cnt) cnt++;&#125;void getFac(ll x, int *e)&#123; if(!miller_rabin(x))&#123; ll d = Pollard(x); getFac(d, e), getFac(x / d, e); &#125;else&#123; addFac(x, x, e); &#125;&#125;void dfs(int ind, ll x)&#123; if(ind == cnt)&#123; if(1.0 * x &gt; lev &amp;&amp; ans &gt; x) ans = x; return ; &#125; ll res = 1; for(int i = 0; i &lt; e2[ind]; ++i) res *= dd[ind]; dfs(ind + 1, x * res); for(int i = e2[ind]; i &lt; e1[ind]; ++i) res *= dd[ind]; dfs(ind + 1, x * res);&#125;void init()&#123; srand(122144);&#125;void solve()&#123; cnt = 0; memset(dd, 0, sizeof(dd)); memset(e1, 0, sizeof(e1)); memset(e2, 0, sizeof(e2)); if(g == l) cout &lt;&lt; g &lt;&lt; " " &lt;&lt; l &lt;&lt; endl; else&#123; getFac(l, e1); if(g != 1) getFac(g, e2); lev = sqrt(1.0 * l * g); ans = l, dfs(0, 1); cout &lt;&lt; (l / ans) * g &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl; &#125;&#125;int main()&#123; while(scanf("%lld %lld", &amp;g, &amp;l) == 2)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2006 狼抓兔子]]></title>
    <url>%2F2018%2F08%2F28%2Fluogu4001%2F</url>
    <content type="text"><![CDATA[题目链接 题解平面图最小割转对偶图最短路裸题。数组要开大！开大！开大！要特判！特判！特判！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; struct Edge&#123; int v,cost,_next; &#125;; Edge edge[7000005];int cnt=0,at[2000005],n,m,S,T,sq,d[2010005];int que[7000005];bool in[2000005]=&#123;0&#125;;int id(int i,int j)&#123;return (i-1)*(m-1)+j;&#125;void addedge(int _u,int _v,int _cost)&#123; edge[++cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt; edge[++cnt].v=_u, edge[cnt].cost=_cost, edge[cnt]._next=at[_v], at[_v]=cnt;&#125; void spfa_bfs()&#123; fill(d+1,d+sq*2+10000,INF); int i,_u,_v,_co,r=0,f=0,qc=0; d[S]=0,que[r++]=S,in[S]=1,qc++; while(qc&amp;&amp;qc&lt;=7000000)&#123; _u=que[f],in[_u]=0; f=(f==7000000)?0:f+1; qc--; for(i=at[_u];i;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r]=_v; r=(r==7000000)?0:r+1; qc++; &#125; &#125; &#125; &#125;&#125;void init()&#123; n=read(),m=read(),sq=(n-1)*(m-1); if(n==1||m==1)&#123; int ans=INF,c; for(int i=1;i&lt;=m+n-2;i++) c=read(),ans=min(ans,c); printf("%d\n",ans); return ; &#125; S=2*sq+1,T=2*sq+2; int u,v,c; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++)&#123; c=read(); if(i==1)addedge(id(i,j),T,c); else if(i==n)addedge(id(i-1,j)+sq,S,c); else addedge(id(i-1,j)+sq,id(i,j),c); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++)&#123; c=read(); if(j==1)addedge(id(i,j)+sq,S,c); else if(j==m)addedge(id(i,j-1),T,c); else addedge(id(i,j-1),id(i,j)+sq,c); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++)&#123; c=read(); addedge(id(i,j),id(i,j)+sq,c); &#125; spfa_bfs(); printf("%d\n",d[T]);&#125;void solve()&#123; &#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最小割</tag>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判圈问题]]></title>
    <url>%2F2018%2F08%2F28%2Fwriting%2Fproblem-findcycle%2F</url>
    <content type="text"><![CDATA[这里讨论主流的判圈算法。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（3）]]></title>
    <url>%2F2018%2F08%2F28%2Fwriting%2Ftemplate-math-3%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于数值，高精度计算相关的问题。 积分计算自适应Simpson方法Romberg方法]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018多校第一场 题解]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Fcontest-2018multischool%2F</url>
    <content type="text"><![CDATA[题目链接 A一个很神奇的数学题…我个人只会观察，发现当$n=3k$时可以利用均值不等式直接输出最大值，$n=4k$时答案就是$2k^3$，其他的手算了几个，估计没有，就直接$-1$。居然对了。这是为什么呢？题解里面只写了一个等式，我看不太懂 1=\frac{1}{2}+\frac{1}{3}+\frac{1}{6}=\frac{1}{3}+\frac{1}{3}+\frac{1}{3}=\frac{1}{2}+\frac{1}{4}+\frac{1}{4}12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll n;void init()&#123; n = read();&#125;void solve()&#123; if(n % 3 == 0) n /= 3, printf("%lld\n", n * n * n); else if(n % 4 == 0) n &gt;&gt;= 2, printf("%lld\n", n * n * n * 2ll); else printf("-1\n");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; B首先先把可以匹配的弄掉，最后剩一堆$pair(a, b)$，表示该字符串有$a$个’)’，$b$个’(‘。然后贪心，用一种迷之方法排序。。。排序的中心要求是让)少(多的在前面，)多(少的在后面，由前者过渡到后者。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef pair&lt;int, int&gt; pp;int n, st[100005], top, ans;pp p[100005];char s[100005];void init()&#123; ans = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", s); int r = 0, l = 0, len = strlen(s); top = 0; for(int j = 0; j &lt; len; ++j)&#123; if(s[j] == ')')&#123; if(top &amp;&amp; st[top - 1] == '(') top--, l--, ans += 2; else st[top++] = ')', r++; &#125;else st[top++] = '(', l++; &#125; p[i].first = r, p[i].second = l; &#125;&#125;bool cmp(const pp&amp; p1, const pp&amp; p2)&#123; if(!p1.first) return 1; if(!p2.first) return 0; int f1 = p1.first - p1.second, f2 = p2.first - p2.second; if(f1 * f2 &lt;= 0) return f1 &lt; f2; if(f1 &lt; 0) return p1.first &lt;= p2.first; return p1.second &gt;= p2.second;&#125;void solve()&#123; sort(p, p + n, cmp); int l = p[0].first, r = p[0].second; for(int i = 1; i &lt; n; ++i)&#123; int ll = p[i].first, rr = p[i].second; ans += min(r, ll) * 2; if(r &gt; ll) r = r - ll + rr; else l = ll - r + l, r = rr; &#125; printf("%d\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; C]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2559]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Fpoj2559%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（2）]]></title>
    <url>%2F2018%2F08%2F26%2Fwriting%2Ftemplate-math-2%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于模相关的问题。 求$\gcd$欧几里得算法（辗转相除法）辗转相除法基于GCD递归定理： \gcd(a, b) = \gcd(b, a\mod b)该定理可以用反证法进行证明，也可以通过证明左右两数分别被对方整除证明。此处不列出证法。123int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125; Stein算法该算法相对欧几里得算法而言，在计算机上实现的效率更高，尤其是对于一些大数的计算。该算法的步骤也非常简单，即为以下式子： \gcd(a, b) = \begin{cases}2\gcd(\frac {a}{2}, \frac{b}{2}) \quad (a为偶数,b为偶数)\\ \gcd(\frac{a}{2}, b) \quad (a为偶数,b为奇数) \\ \gcd(\frac{\left| a- b\right|}{2}, b)\quad (a为奇数,b为奇数)\end{cases}以上式子的正确性可以用同余式的性质证明，此处不给出。1234567891011int gcd(int a, int b)&#123; if(!b) return a; if(!a) return b; if(a &amp; 1)&#123; if(b &amp; 1) return gcd(b, abs(a - b) &gt;&gt; 1); else return gcd(a, b &gt;&gt; 1); &#125;else&#123; if(b &amp; 1) return gcd(a &gt;&gt; 1, b); else return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; &#125;&#125; 扩展欧几里得 123456789int extgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b)&#123; x = 1, y = 0; return a; &#125; int d = extgcd(b, a % b, y, x); y -= x * (a / b); return d;&#125; 欧拉函数欧拉定理欧拉定理降幂公式]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板 数学（1）]]></title>
    <url>%2F2018%2F08%2F26%2Ftemplate-math-1%2F</url>
    <content type="text"><![CDATA[一些简单的数学相关算法模板。本文主要集中于快速幂和快速乘，与质数相关的问题。 快速幂对于$a^b$，把$b$展开成为二进制形式，然后按位乘，同时让$a$反复平方。时间复杂度：$O(\log n)$12345678int modpow(int a, int b, int M)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (res * a) % M; a = (a * a) % M, b &gt;&gt;= 1; &#125; return res;&#125; 特化版本：12345678ll modpow(ll a, ll b, ll M)&#123; ll res = 1; while(b)&#123; if(b &amp; 1) res = fstmul(res, a, M); a = fstmul(a, a, M), b &gt;&gt;= 1; &#125; return res;&#125; 快速乘实现一当$a\times b \mod M$可能超过当前类型限制时，可以将$b$展开成为二进制，然后根据乘法分配律让$a$按位乘，即可避免溢出。时间复杂度：$O(\log n)$12345678int fstmul(int a, int b, int M)&#123; int res = 0; while(b)&#123; if(b &amp; 1) res = (res + a) % M; a &lt;&lt;= 1, a %= M, b &gt;&gt;= 1; &#125; return res;&#125; 特化版本：123456789101112ll fstmul(ll a, ll b, ll M)&#123; ll res = 0; while(b)&#123; if(b &amp; 1) &#123; res += a; if(res &gt;= M) res -= M; &#125; a &lt;&lt;= 1, b &gt;&gt;= 1; if(a &gt;= M) a -= M; &#125; return res;&#125; 实现二因为$a\times b \mod M = a\times b - \lfloor \frac{a\times b}{M} \rfloor \times M$，因此可以用(long) double来存$\frac{a\times b}{M}$，然后再化成整数去乘$M$，再算出对应的结果。时间复杂度：$O(1)$123456int fstmul_2(int a, int b, int M)&#123; int c = (double)a * b / M; int res = a * b - c * M; //此时res由于溢出，可能为负数 if(res &lt; 0) res += M; return res;&#125; 素数定理\pi(x) \sim \frac{N}{\ln N} 质数判断试除法一个数$N$为合数，那么一定有一个数$T$，使得$T|N,2\le T \le \sqrt{N}$。根据这个可以用时间复杂度$O(\sqrt n)$判断质数。123456bool isP(int x)&#123; if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125; Miller-Rabin算法由费马小定理，当$p$为一个质数，对于$gcd(a, p) = 1$，有$a^{p - 1} \equiv 1 \pmod p$。反过来说，当我们知道有$gcd(a, p) = 1$，并且$a^{p - 1} \equiv 1 \pmod p$时，那么$p$就有可能是质数。理论上，要认定一个数$p$为一个质数，我们可以用所有小于它的和它互质的数$a$做一个判定，即判断是否有$a^{p - 1} \equiv 1 \pmod p$。如果全部成立，那么$p$几乎就是一个质数。可惜的是，存在这样的合数——卡迈克尔数(Carmicheal Number)。因此，必须要做出一些改进，使得判定更为准确。下面先直接给出Miller-Rabin算法的代码：123456789101112131415161718192021bool witness(int a, int n, int t, int u)&#123; int x = modpow(a, u, n); for(int i = 0; i &lt; t; ++i)&#123; int xx = (x * x) % n; if(xx == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return true; x = xx; &#125; if(x != 1) return true; return false;&#125;bool isP_miller_rabin(int n, int times)&#123;//执行times次 int t = 1, u; while((n - 1) % (2 &lt;&lt; t) == 0) t++; u = (n - 1) / (1 &lt;&lt; t); while(times--)&#123; int a = rand() % (n - 1) + 1; if(witness(a, n, t, u)) return false; &#125; return true;&#125; 该算法的另一个理论基础是二次探测定理：若$x^2 \equiv 1\pmod p$，$p$为质数，那么$x\equiv 1 \pmod p$或者$x \equiv -1 \pmod p$。这是因为上式可以化成$(x+1)(x-1)\equiv 0 \pmod p$，而$p$是一个质数，由质数的锐利性质可得。当$p$为质数时，令$p-1= 2^tu$，那么对于序列$a^u, a^{2u}, a^{2^2u}, …, a^{2^tu}$，由于最后一项一定为$1$，那么必然有以下条件中的一个： $a^u \equiv 1 \pmod p$ $\exists i \in \left{ 0, 1, 2, … , t\right}, a^{2^iu} \equiv -1 \pmod p$ 若这两个性质都不符合，那么就能够确认$p$是合数。可以证明，这样的$a$占了$1$到$p-1$的$75\%$左右，因此做$T$次判断，失误率近似在$4^{-T}$。要取得更加优秀的结果，可以先根据质数表，看看几个小质数是不是程序中$n$的因子，然后再进行Miller-Rabin验证。 求质数埃氏筛法基于“合数一定有一个大于$1$，小于自身的质因数”的想法，可以直接从$2$向$N$扫描，遇到没有被标记的数就认为它是质数，然后把它的倍数全部标记。这样没有被标记的数就全部都是质数了。时间复杂度：$O(n\log \log n)$。（小于$n$的质数的倒数和约为$\log \log n$，参见此处）1234567void getP(int N)&#123; for(int i = 2; i &lt;= N; ++i) if(!vis[i])&#123; for(int j = i + i; j &lt;= N; j += i) vis[j] = 1; &#125;&#125; 欧拉筛法也称线性筛法。观察上面的埃氏筛法程序容易发现，一个数常常会被多个质数筛掉，这样会影响效率。如果一个数只会被筛一次，那么就可以做到线性的时间复杂度。考虑每一个数的最小质因数$mindiv[i]$，从$2$到$N$扫描。如果一个数未被访问过，那就把它加入质数里面。然后对于当前的数，利用所有小于或者等于$mindiv[i]$的质数$p$，标记$mindiv[i]\times p$为合数，同时置其最小质因数为$p$。这样每一个合数就都被它的最小质因数筛掉了。时间复杂度：$O(n)$1234567891011121314// 本代码未显式保存mindivint prime[N &gt;&gt; 1], tot = 0;bool vis[N];void getP(int N)&#123; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i]) prime[tot++] = i; for(int j = 0; j &lt; tot; ++j)&#123; if(i * prime[j] &gt; N) break; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; //这一步起到的是让p不大于最小质因数 &#125; &#125;&#125; 质因数分解试除法实现上和判断质数差不多，原理上和埃氏筛法相似。令$i$从$2$到$\sqrt n$扫描，如果$i\mid n$，那么就一直除到$i \nmid n$，然后记录对应的质因子及次数。时间复杂度：$O(\sqrt n)$。123456789101112131415void getPs(int x)&#123; int t = x; for(int i = 2; i * i &lt;= x; ++i)&#123; if(t % i == 0)&#123; do&#123; //do something... t /= i; &#125;while(t % i == 0); &#125; if(t == 1) break; &#125; if(t != 1)&#123; //do something... &#125;&#125; Pollard’s Rho算法Pollard’s Rho算法是一种不太完美，但却比较快的算法。它基于生日悖论：因为一个合数$N$必然有一个质因子$p$满足$p\le \sqrt N$，所以在选择$N^{\frac 1 4}$个随机数时，就有比较大的概率得到一个$p$。而Rho算法对此做出了一些改进，使得得到$p$的概率增加：它不局限于寻找$p$，而是对$p$的倍数也加以关注。它选取一系列随机数\left\{ x_n\right\}，看是否有N>\gcd(x_i-x_j, N)>1，如果有就说明找到了这样一个因子。Rho算法生成随机数时使用了一个函数$f(x)$，它的一般形式是$f(x)=(x^2+c)\mod N$。用这样的函数生成的序列具有一定的随机性，但是也会存在闭环的问题，即从一个数开始生成后，在某一处得到的数在这之前已经生成过，那么之后生成的序列就和之前的一段相同了。把这样的序列写出来，就和字母$\rho$一样。 如果此时仍然没有找到一个质因子，那么本次寻找失败。要判断环的出现有2种算法，一种是广为人知的Floyd判环算法，另一种则是Brent的判环算法。后者的表现要优于前者。这里的代码基于后者实现：1234567891011121314151617int rho(int n, int c)&#123; int x = modpow(rand(), rand(), n); int y = x, k = 2, d = 1; for(int i = 1; d == 1; ++i)&#123; x = modpow(x, x, n) + c; if(x &gt; n) x -= n; d = gcd(abs(x - y), n); if(i == k) y = x, k &lt;&lt;= 1; &#125; return d;&#125;int Pollard(int n)&#123; int d = n; while(d == n) d = rho(n, rand() % (n - 3) + 3); return d;&#125; 特别优化：1234567891011121314151617ll rho(ll n, ll c)&#123; ll x = rand(); ll y = x, d = 1, q = 1; for(int k = 2; d == 1; k &lt;&lt;= 1, y = x, q = 1)&#123; for(int i = 0; i &lt; k; ++i)&#123; x = fstmul(x, x, n) + c; if(x &gt;= n) x -= n; ll Abs = (x &gt; y) ? x - y : y - x; q = fstmul(q, Abs, n);//这一步是保证因子的积累？？？ if(i &gt;= 128 &amp;&amp; (!(i &amp; 31))) d = gcd(q, n); &#125; d = gcd(q, n); &#125; return d;&#125; 时间复杂度：$O(N^{\frac 1 4})$（最好情况下） 求第$n$个质数基本方法筛到第$n$个为止。 容斥黑科技 参考资料 维基百科 《算法竞赛进阶指南》 《算法导论》 《数论概论》 论文Computing π(x): The Meissel-Lehmer Method]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NOI1997-2002 题解]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fnoi1997-2002%2F</url>
    <content type="text"><![CDATA[包含了NOI1997-2002六年部分题目的题解。 NOI1997D1T2 最优乘车题目链接 单源最短路问题。考输入。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='\n'||c==EOF)return -1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;bool mp[505][505]=&#123;0&#125;;int n,m,q[5005],f=0,r=0,d[505];void solve()&#123; q[r++]=0,d[0]=-1; int h,v; while(r-f)&#123; h=q[f++]; for(v=0;v&lt;n;v++) if(mp[h][v]&amp;&amp;d[v]&gt;d[h]+1)d[v]=d[h]+1,q[r++]=v; &#125;&#125;int main()&#123; m=read(),read();n=read(),read(); fill(d,d+n,10000000); int i,j,u,v; for(i=0;i&lt;m;i++)&#123; j=0;while((v=read())&gt;0)q[j++]=v; for(u=0;u&lt;j;u++) for(v=u+1;v&lt;j;v++) mp[q[u]-1][q[v]-1]=1; &#125; solve(); if(d[n-1]&gt;=1000000)printf("NO\n"); else printf("%d\n",d[n-1]); return 0;&#125; NOI1998D1T1 个人所得税题目链接 模拟即可。开数组存每个员工每个月的收入，最后再计算；遇到单个的就直接计算。本题读入很神奇，需注意。还有就是负数的处理问题，应交税的部分不能为负。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int m,money[50005][20]=&#123;0&#125;;char typ[10],tim[10],PAY[]="PAY",INC[]="INCOME";double ans=0,pay_l[]=&#123;0,500,2000,5000,20000,40000,60000,80000,100000,999999999&#125;,inc_l[]=&#123;0,20000,50000,999999999&#125;;void init()&#123; scanf("%d",&amp;m);&#125;double Count_pay(int pr)&#123; double left=max(0,pr-800),_ans=0; for(int i=1;i&lt;=9;i++) if(left&lt;pay_l[i])&#123; _ans+=i*0.05*(left-pay_l[i-1]); break; &#125;else _ans+=i*0.05*(pay_l[i]-pay_l[i-1]); return _ans;&#125;double Count_income(int pr)&#123; double left,_ans=0; left=(pr&gt;4000)?(pr*0.8):(max(0,pr-800)); for(int i=1;i&lt;=3;i++)&#123; if(left&lt;inc_l[i])&#123; _ans+=(i+1)*0.1*(left-inc_l[i-1]); break; &#125;else _ans+=(i+1)*0.1*(inc_l[i]-inc_l[i-1]); &#125; return _ans;&#125;void solve()&#123; int id,pr,mon; for(;;)&#123; scanf("%s",typ); if(typ[0]=='#')break; scanf("%d%s%d",&amp;id,tim,&amp;pr); if(!strcmp(PAY,typ))&#123; if(tim[1]=='/')mon=tim[0]-'0'; else mon=10*(tim[0]-'0')+tim[1]-'0'; money[id][mon]+=pr; &#125;else&#123; ans+=Count_income(pr); &#125; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=12;j++) if(money[i][j]) ans+=Count_pay(money[i][j]); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; NOI2000D1T1 瓷片项链题目链接 二次函数。12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int v,v0;int main()&#123; if((v%v0==0&amp;&amp;v%(v0+v0))||v==0) printf("0\n"); else &#123; double a=v,b=v0,ans,d=v/(v0+v0); if(ceil(d)-d&gt;d-floor(d)) ans=floor(d); else ans=ceil(d); printf("%d\n",(int)ans); &#125; return 0;&#125; D1T3 古城之谜题目链接 这题怎么想的。。。看了byvoid的题解还是有点晕晕乎乎。要先对给出的形式进行简化。 句子：是名词、动词短语交替出现的，且开头必定为名词短语。名词短语：相当于任意多个副词+名词。动词短语：相当于任意多个副词+动词。 考虑刻画状态，字母要算进去，当前词性要算进去，还要考虑最少的句子数和单词数。所以设$f(i,j,k)$表示前$i$个字母，最后一个单词词性为$j$，组成$k$个句子的最小单词数量。$j$有$3$种，用$0,1,2$表示名，动，副。但是还要考虑到副词的链接问题。所以加一种情况：$j=3$，表明是副词，并且前面最近的非副词是动词。$j=2$时前面最近的非副词是名词。然后就大力转移即可。直接开数组会MLE，但是可以发现$k$的转移来源只会是$k$和$k-1$，所以用滚动数组压掉这一维。匹配串我用的是hash，大概不会被卡掉…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000#define Mod 10000007ullusing namespace std;typedef unsigned long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,len,f[5005][4][2],maxl=0;char word[1005][25],tex[50005];ll hsh[50005],Pow[50005];bool t1[10000007],t2[10000007],t3[10000007];ll getHash(int i,int j)&#123; return hsh[j]-(hsh[i-1]*Pow[j-i+1]);&#125; void init()&#123; n=read(); int l;ll Hash; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",word[i]); l=strlen(word[i]),Hash=0,maxl=max(maxl,l-2); for(int j=2;j&lt;l;j++) Hash=Hash*137ull+(ll)word[i][j]+157ull; if(word[i][0]=='n')t1[Hash%Mod]=1; if(word[i][0]=='v')t2[Hash%Mod]=1; if(word[i][0]=='a')t3[Hash%Mod]=1; &#125; scanf("%s",tex+1); len=strlen(tex+1)-1,hsh[0]=0,Pow[0]=1; for(int i=1;i&lt;=len;i++) hsh[i]=hsh[i-1]*137ull+(ll)tex[i]+157ull,Pow[i]=Pow[i-1]*137ull;&#125;void solve()&#123; memset(f,0x3f,sizeof(f)); f[0][0][0]=0; int B,B_,ans1,ans2; ll tmp; for(int k=1;k&lt;=len;k++)&#123; B=(k&amp;1),B_=B^1; for(int i=1;i&lt;=len;i++)&#123; f[i][0][B]=f[i][1][B]=f[i][2][B]=f[i][3][B]=0x3f3f3f3f; for(int t=i;t&gt;i-maxl&amp;&amp;t&gt;=1;t--)&#123; tmp=getHash(t,i)%Mod; if(t1[tmp])&#123; int &amp;T=f[i][0][B]; T=min(T,min(f[t-1][1][B]+1,f[t-1][3][B]+1)); T=min(T,min(f[t-1][0][B_]+1,f[t-1][1][B_]+1)); &#125; if(t2[tmp])&#123; int &amp;T=f[i][1][B]; T=min(T,min(f[t-1][0][B]+1,f[t-1][2][B]+1)); &#125; if(t3[tmp])&#123; int &amp;T=f[i][2][B]; T=min(T,min(f[t-1][0][B]+1,f[t-1][2][B]+1)); T=min(T,f[t-1][0][B_]+1); int &amp;T2=f[i][3][B]; T2=min(T2,min(f[t-1][1][B]+1,f[t-1][3][B]+1)); T2=min(T2,min(f[t-1][0][B_]+1,f[t-1][1][B_]+1)); &#125; &#125; &#125; if(f[len][0][B]&lt;INF||f[len][1][B]&lt;INF)&#123; ans1=k,ans2=min(f[len][0][B],f[len][1][B]); break; &#125; &#125; printf("%d\n%d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T1 单词查找树题目链接 trie树模板题？123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int trie[100005][29]=&#123;0&#125;;char wd[1005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void solve()&#123; int ans=1,p; char *s; while(~scanf("%s",wd))&#123; p=1; for(s=wd;*s;s++)&#123; if(!trie[p][*s-'A']) trie[p][*s-'A']=++ans; p=trie[p][*s-'A']; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; solve(); return 0;&#125; D2T2 青蛙过河题目链接 设$f(h,k)$为答案。则显然的是$f(0,k)=k+1$。我们加一个石墩，那么可以先把最上面一波青蛙送到新加的上面去，然后把下面那一拨送到对岸，再把石墩上的送走。所以$f(1,k)=2f(0,k)$。再加一个。我们又把一波青蛙送到其中一个石墩上，然后问题变成了$f(1,k)$的形式，所以$f(2,k)=2f(1,k)$。换言之，加一个石墩，送青蛙的能力就增强一倍。所以$f(h,k)=2^h (k+1)$。12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll h,k;void init()&#123; scanf("%lld%lld",&amp;h,&amp;k);&#125;void solve()&#123; printf("%lld\n",(k+1)*(1&lt;&lt;h));&#125;int main()&#123; init(); solve(); return 0;&#125; D2T3 算符破译NOI2001D1T1 食物链题目链接 设$a,2a,3a$分别表示$a$属于$A,B,C$。则对于1，判断$a$与$2b$和$a$与$3b$是否在同一集合对于2，判断$a$吃不吃自己与$b$吃不吃$a$即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int rank[150010],parent[150010],t,ans=0,k,n,x,y;int same(int a,int b),find(int a);void init(int n),joint(int x,int y);void init(int n)&#123; int i;for(i=1;i&lt;=n;i++)&#123; parent[i]=i; rank[i]=0; &#125;&#125;void joint(int x,int y)&#123; int a=find(x),b=find(y); if(a==b)return; if(rank[a]&lt;rank[b])&#123; parent[a]=b; &#125;else&#123; parent[b]=a; if(rank[a]==rank[b])rank[a]++; &#125;&#125;int find(int a)&#123; if(parent[a]==a)return a; else return (parent[a]=find(parent[a]));&#125;int same(int a,int b)&#123;return find(a)==find(b);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k);int i; init(n*3);for(i=0;i&lt;k;i++)&#123; scanf("%d%d%d",&amp;t,&amp;x,&amp;y); if(x&gt;n||y&gt;n||x&lt;1||y&lt;1)ans++; else&#123; if(t==1)&#123; if(same(x,y+n)||same(x,y+2*n))ans++; else &#123;joint(x,y);joint(x+n,y+n);joint(x+n*2,y+n*2);&#125; &#125;else&#123; if(same(x,y+2*n)||same(x,y))ans++; else&#123; joint(x,y+n);joint(x+n,y+2*n);joint(x+n*2,y); &#125; &#125; &#125; &#125;printf("%d\n",ans); return 0;&#125; D1T2 反正切函数的应用题目链接 $O(\sqrt n)$乱搞。利用$(a-b)(a-c)=a^2+1$12345678910111213141516#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned int uint;uint a,ans=4000000000u,d;int main()&#123; scanf("%u",&amp;a); d=a*a+1; for(uint i=1;i*i&lt;=d;i++) if(d%i==0)ans=min(ans,a+a+i+d/i); printf("%u\n",ans); return 0;&#125; D1T3 聪明的打字员题目链接 标准的广搜。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char vis[1000000][6]=&#123;0&#125;;int S,T,ans[1000005][6],ten[10];queue&lt;int&gt; q1,q2;//000000-999999int ptoi(int *L)&#123; int res=0; for(int i=0;i&lt;6;i++)res=res*10+L[i]; return res;&#125;void itop(int *L,int x)&#123; for(int i=5;i&gt;=0;i--)L[i]=x%10,x/=10;&#125;void init()&#123; S=read(),T=read(); memset(ans,0x3f,sizeof(ans)); ans[S][0]=0; ten[5]=1; for(int i=4;i&gt;=0;i--)ten[i]=ten[i+1]*10;&#125;void solve()&#123; vis[S][0]=1,q1.push(S),q2.push(0); int h,pos,permu[10],Ans=INF,now,to; while(!q1.empty())&#123; h=q1.front(),q1.pop(),pos=q2.front(),q2.pop(); if(h==T)break; now=ans[h][pos],itop(permu,h); if(pos&amp;&amp;!vis[h][pos-1])//left vis[h][pos-1]=1,ans[h][pos-1]=now+1, q1.push(h),q2.push(pos-1); if(pos!=5&amp;&amp;!vis[h][pos+1])//right vis[h][pos+1]=1,ans[h][pos+1]=now+1, q1.push(h),q2.push(pos+1); if(permu[pos]!=9)&#123;//up to=h+ten[pos]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(permu[pos])&#123;//down to=h-ten[pos]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(pos&amp;&amp;permu[0]!=permu[pos])&#123; to=h-permu[0]*ten[0]-permu[pos]*ten[pos]+permu[0]*ten[pos]+permu[pos]*ten[0]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; if(pos!=5&amp;&amp;permu[5]!=permu[pos])&#123; to=h-permu[5]*ten[5]-permu[pos]*ten[pos]+permu[5]*ten[pos]+permu[pos]*ten[5]; if(!vis[to][pos]) vis[to][pos]=1,ans[to][pos]=now+1, q1.push(to),q2.push(pos); if(to==T)break; &#125; &#125; for(int i=0;i&lt;6;i++)Ans=min(Ans,ans[T][i]); printf("%d\n",Ans);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T1 炮兵阵地题目链接 标准的状压DP。 D2T2 方程的解数题目链接 meet in the middle。拆成两半，$O(M^3)$枚举+核对。用map会MLE，干脆hash。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define P 4000037using namespace std;typedef long long ll;int n,m;ll k[15],p[15],ppow[155][40]=&#123;0&#125;,half,ans=0;ll LIM=2147483647;int hsh[4000060],cnt[4000060];bool vis[4000060]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;k[i],&amp;p[i]); for(ll i=1;i&lt;=m;i++)&#123; ppow[i][0]=1; ll lim=1; for(int j=1;j&lt;=35;j++)&#123; lim*=i; if(lim&gt;=LIM)break; ppow[i][j]=ppow[i][j-1]*i; &#125; &#125;&#125;int locate(int val)&#123; int q=abs(val); for(q%=P;vis[q]&amp;&amp;hsh[q]!=val;q=(q==P-1)?0:q+1); return q;&#125;void build(int at,ll val)&#123; if(at&gt;half)&#123; int loc=locate((int)val); cnt[loc]++,hsh[loc]=(int)val,vis[loc]=1; return ; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!ppow[i][p[at]])break; ll lim=val+ppow[i][p[at]]*k[at]; if(lim&gt;=LIM||lim&lt;=-LIM)break;//爆了 build(at+1,lim); &#125;&#125;void Search(int at,ll val)&#123; if(at==n+1)&#123; int _val=(int)(-val); int loc=locate(_val); if(hsh[loc]==_val)ans+=cnt[loc]; return ; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!ppow[i][p[at]])break; ll lim=val+ppow[i][p[at]]*k[at]; if(lim&gt;=LIM||lim&lt;=-LIM)break;//爆了 Search(at+1,lim); &#125;&#125;void solve()&#123; half=n/2; build(1,0); Search(half+1,0); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; D2T3 陨石的秘密题目链接可以发现SS表达式的定义是递归形式的，而且SS表达式形成了一个树形结构（有深度，还有儿子）。设$f(i,j,k,d)$为$i$对大括号，$j$对中括号，$k$对小括号，树深度$&lt;=d$的方案总数。对于同一层而言，决策有： 分出一支，深度变大。 同一层上增加。对于第一种情况，我们再加一个状态：设$g(i,j,k,d)$为$i$对大括号，$j$对中括号，$k$对小括号，树深度$\le d$，且表达式构成一棵树的方案总数。他从$f$转移而来，决策是给$f$加一个根。这样就可以转移了。初始：$f(0,0,0,0…D)=1$。答案：f(L_1,L_2,L_3,D)-f(L_1,L_2,L_3,D-1)（相当于容斥）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define Mod 11380using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int l1,l2,l3,D,f[11][11][11][31]=&#123;0&#125;,g[11][11][11][31]=&#123;0&#125;;char vis1[11][11][11][31]=&#123;0&#125;,vis2[11][11][11][31]=&#123;0&#125;;int dp_g(int a,int b,int c,int d);int dp_f(int a,int b,int c,int d);int dp_g(int a,int b,int c,int d)&#123; if(vis2[a][b][c][d])return g[a][b][c][d]; int t=0; if(!a&amp;&amp;!b&amp;&amp;c&gt;=1)(t+=dp_f(a,b,c-1,d-1))%=Mod; if(!a&amp;&amp;b&gt;=1)(t+=dp_f(a,b-1,c,d-1))%=Mod; if(a&gt;=1)(t+=dp_f(a-1,b,c,d-1))%=Mod; vis2[a][b][c][d]=1; return (g[a][b][c][d]=t);&#125;int dp_f(int a,int b,int c,int d)&#123; if(vis1[a][b][c][d])return f[a][b][c][d]; int t=0; for(int i=0;i&lt;=a;i++) for(int j=0;j&lt;=b;j++) for(int k=0;k&lt;=c;k++) if(i||j||k)(t+=dp_g(i,j,k,d)*dp_f(a-i,b-j,c-k,d))%=Mod; vis1[a][b][c][d]=1; return (f[a][b][c][d]=t);&#125;void init()&#123; l1=read(),l2=read(),l3=read(),D=read(); for(int i=0;i&lt;=D;i++) vis1[0][0][0][i]=1,f[0][0][0][i]=1, vis2[0][0][0][i]=1,g[0][0][0][i]=0;&#125;void solve()&#123; printf("%d\n",(dp_f(l1,l2,l3,D)-dp_f(l1,l2,l3,D-1)+Mod)%Mod);&#125;int main()&#123; init(); solve(); return 0;&#125; NOI2002D1T2 调皮的小孩（题目暂缺） 显然你最多只能问一个人$2$遍。显然你问裁判同样问题$2$次他就会自爆。那就分类讨论。先随便找个人，然后对其他人问他是不是0队的。 $N$个人Yes$M$个No，那么这个人就有可能是0队的。（1）$N\neq M$，他就是0队的。（2）$N=M$，让他问1队的任意一个人是不是1队的$2$次，答案一样这个人就是0队的，反之就是裁判。 $N+1$个人No$M-1$个人Yes，那么这个人是1队的，去另外$N+1$个人问他是不是1队的即可。 $N$个人No$M$个人Yes，$N\neq M$他就是裁判，$N=M$就套用1的解决方法。]]></content>
      <categories>
        <category>NOI题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>模拟</tag>
        <tag>其他DP</tag>
        <tag>并查集</tag>
        <tag>最短路</tag>
        <tag>递推</tag>
        <tag>BFS</tag>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2440 完全平方数]]></title>
    <url>%2F2018%2F08%2F25%2Fbzoj2440%2F</url>
    <content type="text"><![CDATA[题目链接 题解我觉得这题比较简单= =对于这种难以直接求解的问题一般采用二分解决。先二分一个答案$x$，然后看$[1,x]$间有多少个这样的数。直接算算不出，由于是完全平方数，考虑补集转化，求是完全平方数倍数的个数。有重叠，考虑容斥。答案就是$n-$只有一个质因子的平方数倍数个数$+$有$2$个质因子的$-$有$3$个质因子的…但是质因子太多，会TLE。我们知道容斥和莫比乌斯函数有关，所以利用莫比乌斯函数优化。这样答案就是 \sum_{i = 1}^{\sqrt{x}}\mu(i)\times \lfloor \frac{x}{i^2}\rfloor二分范围？观察样例，猜测不会超过2k_i。。。话说这个题 二分有点奇怪 改了一下改成这样才能过？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int mu[100005];int prime[100005],tot=0,n,k;bool vis[100005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int judge(int x)&#123; int res=0,l=(int)sqrt(x); for(int i=1;i*i&lt;=x;i++)&#123; res+=mu[i]*(x/(i*i)); &#125; return res;&#125;void init()&#123; mu[1]=1,vis[1]=1; for(int i=2;i&lt;=100000;i++)&#123; if(!vis[i]) mu[i]=-1,prime[tot++]=i; for(int j=0;j&lt;tot;j++)&#123; ll t=i;t*=(ll)prime[j]; if(t&gt;100000)break; vis[i*prime[j]]=1,mu[i*prime[j]]=-mu[i]; if(i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; &#125; &#125;&#125;void solve()&#123; n=read(); while(n--)&#123; k=read(); int L=1,R=2*k,M; while(R-L)&#123; M=L+(R-L)/2; if(judge(M)&gt;=k)R=M; else L=M+1; &#125; printf("%d\n",L); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3614]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fpoj3614%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 506 (Div. 3) 题解]]></title>
    <url>%2F2018%2F08%2F25%2Fwriting%2Fcontest-cf1029%2F</url>
    <content type="text"><![CDATA[A题目链接 观察样例可以发现，只要找到最长的和后缀相同的前缀，然后重复该前缀$k$次，再输出剩下的即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, k;char s[105];void init()&#123; n = read(), k = read(); scanf("%s", s);&#125;void solve()&#123; int st; for(st = 1; st &lt; n; st++)&#123; int flag = 1; for(int j = 0; j &lt; n - st; ++j) if(s[st + j] != s[j])&#123; flag = 0; break; &#125; if(flag) break; &#125; if(st == n)&#123; for(int i = 0; i &lt; k; ++i) printf("%s", s); &#125;else&#123; for(int i = 0; i &lt; k; ++i) for(int j = 0; j &lt; st; ++j) putchar(s[j]); for(int i = st; i &lt; n; ++i) putchar(s[i]); &#125; printf("\n");&#125;int main()&#123; init(); solve(); return 0;&#125; B题目链接 C题目链接]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4317]]></title>
    <url>%2F2018%2F08%2F24%2Fwriting%2Fluogu4317%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 405C Unusual Product]]></title>
    <url>%2F2018%2F08%2F24%2Fcf405c%2F</url>
    <content type="text"><![CDATA[题目链接 题解因为觉得这是一道出的很好的模拟题，所以拿过来了。上文中提到的flip操作其实就是取反。暴力做法是$O(nq)$的，挂。看数据，考虑有没有什么接近线性的做法：我们将整个结果展开。比如这么一个方阵： \begin{bmatrix} a_1 & b _1 & c_1 \\ a_2 & b_2 & c_2 \\ a_3 & b_3 & c_3 \end{bmatrix}他的unusual square 就是a_1^2 + b_2^2 + c_3^2 + 2(a_2b_1+a_3c_1+b_3c_2)由于是在模$2$的环境下进行，这个式子后半部分都是没有用的东西。所以只要时时刻刻维护前面平方项的和即可。然而…每一次操作都必然改变一项且仅改变一个平方项，使之从0变1或从1变0.所以做法就是 读入时不保留矩阵，只算平方项 更新时只要知道它更新了即可，然后把平方和异或1。这个算法的复杂度就是$O(n^2+q)-O(1)$的。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,sum=0,lg[1005],q,jc;//保留对角线只是我无聊...int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;((i==j)?lg[i]:jc)); for(int i=0;i&lt;n;i++) sum^=lg[i];&#125;void solve()&#123; scanf("%d",&amp;q); int op; for(int i=0;i&lt;q;i++)&#123; scanf("%d",&amp;op); if(op==3)printf("%d",sum); else scanf("%d",&amp;jc),sum^=1; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 438D The Child and Sequence]]></title>
    <url>%2F2018%2F08%2F24%2Fcf438d%2F</url>
    <content type="text"><![CDATA[题目链接 题解第一次写这种靠数学分析来找特定规律的题目…观察区间取模的问题，我们可以发现一个数最多会被取模log_2 n次。（因为一次取模至少会缩小一半，和启发式合并相似）所以没什么顾虑，暴力做就是了。操作一用lazytag解决，操作二的话维护区间内最大值及其下标，每次暴力找最大的，如果大于模数就单点修改。操作三就是单点修改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll seg[400005]=&#123;0&#125;,tag[400005]=&#123;0&#125;,_v,sum[400005],loc[400005];int _a,_b,m,n,siz;pair&lt;int,ll&gt; Nulll;void maintain(int id)&#123; if(seg[id&lt;&lt;1]&gt;seg[id&lt;&lt;1|1]) seg[id]=seg[id&lt;&lt;1],loc[id]=loc[id&lt;&lt;1]; else seg[id]=seg[id&lt;&lt;1|1],loc[id]=loc[id&lt;&lt;1|1]; sum[id]=sum[id&lt;&lt;1]+sum[id&lt;&lt;1|1];&#125;void build_seg()&#123; for(siz=1;siz&lt;n;siz&lt;&lt;=1); int i; for(i=siz;i&lt;siz+n;i++) scanf("%lld",&amp;seg[i]), tag[i]=0,sum[i]=seg[i],loc[i]=i-siz+1; //seg最大值，sum和，tag标记，loc最大值位置 for(;i&lt;(siz&lt;&lt;1);i++) seg[i]=sum[i]=tag[i]=loc[i]=0; for(i=siz-1;i&gt;=1;i--) maintain(i);&#125;void pushdown(int id,ll len)&#123; if(!tag[id])return ; seg[id&lt;&lt;1]+=tag[id],seg[id&lt;&lt;1|1]+=tag[id]; tag[id&lt;&lt;1]+=tag[id],tag[id&lt;&lt;1|1]+=tag[id]; sum[id&lt;&lt;1]+=tag[id]*(len&gt;&gt;1),sum[id&lt;&lt;1|1]+=tag[id]*(len&gt;&gt;1); tag[id]=0;&#125;void update(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(l&gt;=_a&amp;&amp;r&lt;=_b)&#123; seg[id]+=_v,tag[id]+=_v,sum[id]+=(r-l+1)*_v; return ; &#125; pushdown(id,(ll)(r-l+1)); update(id&lt;&lt;1,l,(l+r)&gt;&gt;1); update(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); maintain(id);&#125;pair&lt;int,ll&gt; query_p(int id,int l,int r)&#123; //查询区间最大值 pair&lt;int,ll&gt; P,p1; P.first=P.second=-1; if(l&gt;_b||r&lt;_a)return Nulll; if(l&gt;=_a&amp;&amp;r&lt;=_b)&#123; P.first=loc[id],P.second=seg[id]; return P; &#125; pushdown(id,(ll)(r-l+1)); p1=query_p(id&lt;&lt;1,l,(l+r)&gt;&gt;1); if(p1.second&gt;P.second)P=p1; p1=query_p(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); if(p1.second&gt;P.second)P=p1; return P; &#125;ll query(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return 0; if(l&gt;=_a&amp;&amp;r&lt;=_b)return sum[id]; pushdown(id,(ll)(r-l+1)); return query(id&lt;&lt;1,l,(l+r)&gt;&gt;1)+query(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r);&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); build_seg(); Nulll.first=-1,Nulll.second=-1; &#125;void solve()&#123; for(int i=0;i&lt;m;i++)&#123; int typ,_c,_d; scanf("%d",&amp;typ); if(typ==1) scanf("%d%d",&amp;_a,&amp;_b), printf("%lld\n",query(1,1,siz)); else if(typ==2)&#123; scanf("%d%d%lld",&amp;_c,&amp;_d,&amp;_v); ll Mod=_v; pair&lt;int,ll&gt; P; for(;;)&#123; _a=_c,_b=_d; P=query_p(1,1,siz); if(P.second&lt;Mod)break; _a=_b=P.first,_v=P.second%Mod-P.second; update(1,1,siz); &#125; //for(int i=0;i&lt;5;i++) // _a=_b=i+1, // printf("%lld ",query(1,1,siz)); //printf("\n"); &#125;else&#123; scanf("%d%lld",&amp;_a,&amp;_v), _b=_a,_v-=query(1,1,siz),update(1,1,siz); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 670C Cinema]]></title>
    <url>%2F2018%2F08%2F24%2Fcf670c%2F</url>
    <content type="text"><![CDATA[题目链接 题解对于每一个影片分别统计一下看的很满意的人和比较满意的人数，维护答案即可。数据很大，需要离散化一下。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[200005], b[200005], c[200005];void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) a[i] = read(); m = read(); for(int i = 0; i &lt; m; ++i) b[i] = read(); for(int i = 0; i &lt; m; ++i) c[i] = read();&#125;void solve()&#123; sort(a, a + n); int max1 = 0, max2 = 0, ans = 1; for(int i = 0; i &lt; m; ++i)&#123; int r1 = upper_bound(a, a + n, b[i]) - lower_bound(a, a + n, b[i]); int r2 = upper_bound(a, a + n, c[i]) - lower_bound(a, a + n, c[i]); if(r1 &gt; max1) max1 = r1, max2 = r2, ans = i + 1; else if(r1 == max1 &amp;&amp; r2 &gt; max2) max2 = r2, ans = i + 1; &#125; printf("%d\n", ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 813C The Tag Game]]></title>
    <url>%2F2018%2F08%2F24%2Fcf813c%2F</url>
    <content type="text"><![CDATA[题目链接 题解显然这是一个追逐的局面。Alice的棋追着Bob的跑。要保证时间拖得最长，就必须使得Bob逃离的越远。算出AB两个棋子到这棵树上每一个其他点的时间t_A和t_B，然后dfs，看B棋子能到达哪一个点使得t_A>t_B且t_A最大。答案就是最大的这个2t_A。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,x,at[200005],to[400005],_next[400005],cnt=0;int ldis[200005]=&#123;0&#125;,rdis[200005]=&#123;0&#125;,ans=0;bool vis[200005]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;x); int u,v; memset(at,-1,sizeof(at)); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v); u--,v--; to[cnt]=v,_next[cnt]=at[u],at[u]=cnt++; to[cnt]=u,_next[cnt]=at[v],at[v]=cnt++; &#125;&#125;void dfs(int cur,int *dis)&#123; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]]) vis[to[i]]=1, dis[to[i]]=dis[cur]+1, dfs(to[i],dis); &#125;&#125;void dfs2(int cur)&#123; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]]&amp;&amp;ldis[to[i]]&gt;rdis[to[i]]) vis[to[i]]=1,dfs2(to[i]); &#125; ans=max(ans,ldis[cur]);&#125;void solve()&#123; vis[0]=1,dfs(0,ldis); memset(vis,0,sizeof(vis)); vis[x-1]=1,dfs(x-1,rdis); memset(vis,0,sizeof(vis)); dfs2(x-1); printf("%d\n",ans*2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 二分法和三分法]]></title>
    <url>%2F2018%2F08%2F24%2Fwriting%2Ftemplate-bi-or-trinary%2F</url>
    <content type="text"><![CDATA[简单的算法有时候也要仔细考量。 二分整数域上的二分二分很好写，但总是有一些坑，容易写的TLE或者是要额外判断。我个人推荐（也是某本书上给出的）的一种写法是：版本A:12345while (r - l)&#123; int mid = (r + l + 1) &gt;&gt; 1; if(judge(mid)) l = mid; else r = mid - 1;&#125; 版本B:12345while (r - l)&#123; int mid = (r + l) &gt;&gt; 1; if(judge(mid)) r = mid; else l = mid + 1;&#125; 这种写法的好处是最后$l$和$r$会回到一个数上面去，就不用担心后续特判的操作。两种版本都是正确的，只是使用的对象不一样。考虑好可行域的划分问题即可。（一般我都是用$[4,5]$这个区间当例子来考虑的）还有一点就是：这两个版本的二分对于负数域也是行得通的。因为一般右移都是算术右移，实现的是向下取整，所以可以正常工作。（不妨考虑$[-3,-2]$）从代码也可以看出版本A更接近左边，版本B更接近右边。 实数域上的二分比起整数域上的二分，实数域由于没有向哪里取整的问题，所以更加容易实现。只需要用一个$eps$判断是否足够接近即可。12345while (r - l &gt; eps)&#123; double mid = (r + l) / 2; if(judge(mid)) r = mid; else l = mid;&#125; 或者可以迭代一定次数，获得一个相对更高的精度。12345for(int i = 0; i &lt; 100; ++i)&#123; double mid = (r + l) / 2; if(judge(mid)) r = mid; else l = mid;&#125; STLlower_bound和upper_bound已经是广为人知了。 参考资料 《算法竞赛进阶指南》]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Tallest Cow]]></title>
    <url>%2F2018%2F08%2F24%2Fluogu2879%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果不存在任何大小关系，不妨认为所有牛的高度都达到了最高。存在大小关系，就不妨一步一步满足。由于最小的单位是1，就让两个牛之间的高度相对两边少1，这样就在满足尽量高的前提下满足了限制条件。这一步可以用区间减法或者差分实现。需要注意的是可能两个牛的关系会重复出现，此时需要去重。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, id, h, m, hi[10005] = &#123;0&#125;;pair&lt;int, int&gt; p[10005];void init()&#123; n = read(), id = read(), h = read(), m = read(); for(int i = 0; i &lt; m; ++i)&#123; p[i].first = read(), p[i].second = read(); if(p[i].first &gt; p[i].second) swap(p[i].first, p[i].second); &#125; sort(p, p + m); m = unique(p, p + m) - p;&#125;void solve()&#123; for(int i = 0; i &lt; m; ++i)&#123; int l = p[i].first, r = p[i].second; hi[l + 1]--, hi[r]++; &#125; int sum = 0; for(int i = 1; i &lt;= n; ++i) sum += hi[i], printf("%d\n", h + sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1958 Strange Towers of Hanoi]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj1958%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$f(i)$为$i$个盘子时候的情况，那么当把$j$个盘子移到另一个柱子上，然后将剩下的用3根柱子汉诺塔形式移动，再将$j$个移回去时，就可以推导出$f(i)$的表达式： f(i) = \min \limits_{1 \le j < i}\left\{2 f(j) + d(i - j) \right\}其中$d(i)$为3根柱子汉诺塔中有$i$个盘子的步数。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;ll d[15], f[15] = &#123;0&#125;;void init()&#123; d[1] = 1, f[1] = 1; for(int i = 2; i &lt;= 12; ++i) d[i] = d[i - 1] &lt;&lt; 1 | 1;&#125;void solve()&#123; printf("1\n"); for(int i = 2; i &lt;= 12; ++i)&#123; f[i] = INF; for(int j = 1; j &lt; i; ++j) f[i] = min(f[i], (f[j] &lt;&lt; 1) + d[i - j]); printf("%lld\n", f[i]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1458 Sumdiv]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj1845%2F</url>
    <content type="text"><![CDATA[题目地址 题解分治法求解等比数列和的一个运用。每次把数列分成两半，就可以做到$O(logn)$了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int a, b, sum = 1;int poww(int d, int e)&#123; int res = 1; while(e)&#123; if(e &amp; 1) res = (res * d) % 9901; d = (d * d) % 9901; e &gt;&gt;= 1; &#125; return res;&#125;int f(int p, int c)&#123; if(c == 0) return 1; if(c == 1) return (1 + p) % 9901; if(c &amp; 1) return f(p, c &gt;&gt; 1) * (1 + poww(p, (c + 1) &gt;&gt; 1)) % 9901; else return ((f(p, c &gt;&gt; 1) + 9900) * (1 + poww(p, c &gt;&gt; 1)) + 1) % 9901;&#125;void init()&#123; a = read(), b = read();&#125;void solve()&#123; int t = a; for(int i = 2; i * i &lt;= a; ++i)&#123; if(t % i == 0)&#123; int cc = 0; do&#123; t /= i, cc++; &#125;while(t % i == 0); sum = sum * f(i % 9901, cc * b) % 9901; &#125; if(t == 1) break; &#125; if(t != 1) sum = sum * f(t % 9901, b) % 9901; printf("%d\n", sum);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2018 Best Cow Fences]]></title>
    <url>%2F2018%2F08%2F24%2Fpoj2018%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题精度高的一批…总之想到直接求解比较困难，联想到这样平均值的题目一般要用上二分，所以二分一个最大平均值，然后根据判定条件来就行了。 C(S):\exists l, r ,r - l \ge F,sum[r]-rS\ge sum[l] - lS12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, L, a[100005], sum[100005], maxi = 0;void init()&#123; n = read(), L = read(); sum[0] = 0; for(int i = 1; i &lt;= n; ++i) a[i] = read(), maxi = max(maxi, a[i]), sum[i] = sum[i - 1] + a[i];&#125;bool judge(double x)&#123; double mini = 0; for(int i = L; i &lt;= n; ++i)&#123; double cur = 1.0 * sum[i] - i * x; if(cur &gt; mini || abs(cur - mini) &lt; 1e-5) return true; mini = min(mini, 1.0 * sum[i + 1 - L] - (i + 1 - L) * x); &#125; return false;&#125;void solve()&#123; double l = 1.0 * sum[n] / n, r = 1.0 * maxi; for(int i = 0; i &lt; 60; ++i)&#123; double mid = (l + r) / 2; if(judge(mid)) l = mid; else r = mid; &#125; printf("%d\n", (int)(1000 * l));&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3468 A Simple Problem with Integers]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[题目地址 题解线段树水题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long ll;ll sum[400005],add[400005]=&#123;0&#125;,mul[400005]=&#123;0&#125;,_v;int n,size,_a,_b,m;void pushdown(int id,int len)&#123; if(id&gt;=size||!add[id])return ; sum[id&lt;&lt;1]+=add[id]*(ll)(len&gt;&gt;1); sum[id&lt;&lt;1|1]+=add[id]*(ll)(len&gt;&gt;1); add[id&lt;&lt;1]+=add[id]; add[id&lt;&lt;1|1]+=add[id]; add[id]=0;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); int i; for(size=1;size&lt;n;size&lt;&lt;=1); for(i=size;i-size&lt;n;i++) scanf("%lld",&amp;sum[i]); for(;i&lt;(size&lt;&lt;1);i++)sum[i]=0; for(i=size-1;i&gt;=1;i--) sum[i]=sum[i&lt;&lt;1]+sum[i&lt;&lt;1|1];&#125;void update(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(_a&lt;=l&amp;&amp;r&lt;=_b)&#123; sum[id]+=_v*(ll)(r-l+1),add[id]+=_v; return ; &#125; pushdown(id,r-l+1); update(id&lt;&lt;1,l,(l+r)&gt;&gt;1); update(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); sum[id]=sum[id&lt;&lt;1]+sum[id&lt;&lt;1|1];&#125;ll query(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return 0ll; if(_a&lt;=l&amp;&amp;r&lt;=_b)return sum[id]; pushdown(id,r-l+1); return query(id&lt;&lt;1,l,(l+r)&gt;&gt;1)+query(id&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;void solve()&#123; int i,j,o,u,v; char ord[3]; for(i=0;i&lt;m;i++)&#123; scanf("%s%d%d",ord,&amp;_a,&amp;_b); if(ord[0]=='C') scanf("%lld",&amp;_v), update(1,1,size); else printf("%lld\n",query(1,1,size)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2893 M × N Puzzle]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj2893%2F</url>
    <content type="text"><![CDATA[题目地址 题解将这个拼图展开，可以发现：0左右移动不改变序列的逆序对数，上下移动改变的逆序对数和列数的奇偶性相反。因此当列数是奇数时可以直接根据原序列逆序对数是不是偶数判断，列数是偶数时由于0上下移动引起对数的变化的奇偶性只和它始态行和终态行之间的距离有关，因此只需判断原序列逆序对数和这个距离的奇偶性是否相同即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, a[1000005], b[1000005], dis;ll ans;void init()&#123; int cnt = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j)&#123; a[cnt++] = read(); if(a[cnt - 1] == 0) cnt--, dis = n - 1 - i; &#125;&#125;void Merge(int ls, int rs, int re)&#123; int lp = ls, rp = rs, tp = ls; while(lp &lt; rs &amp;&amp; rp &lt; re)&#123; if(a[lp] &lt;= a[rp]) b[tp++] = a[lp++]; else b[tp++] = a[rp++], ans += 1ll * (rs - lp); &#125; while(lp &lt; rs) b[tp++] = a[lp++]; while(rp &lt; re) b[tp++] = a[rp++]; memcpy(a + ls, b + ls, sizeof(int) * (re - ls));&#125;void ms(int l, int r)&#123; int len = r - l, mid = (r + l) &gt;&gt; 1; if(len == 1) return ; ms(l, mid), ms(mid, r); Merge(l, mid, r);&#125;void solve()&#123; ans = 0; ms(0, n * m - 1); if(m &amp; 1) printf("%s\n", (ans % 2) ? "NO" : "YES"); else printf("%s\n", (ans % 2 == dis % 2) ? "YES" : "NO");&#125;int main()&#123; while(n = read(), m = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1995 Raising Modulo Numbers]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj1995%2F</url>
    <content type="text"><![CDATA[题目地址 题解快速幂。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int poww(int a, int b, int m)&#123; int res = 1; while(b)&#123; if(b &amp; 1) res = (res * a) % m; a = (a * a) % m; b &gt;&gt;= 1; &#125; return res;&#125;int m, h, dd[45005], ex[45005];void init()&#123; m = read(), h = read(); for(int i = 0; i &lt; h; ++i) dd[i] = read(), ex[i] = read();&#125;void solve()&#123; int sum = 0; for(int i = 0; i &lt; h; ++i) sum = (sum + poww(dd[i] % m, ex[i], m)) % m; printf("%d\n", sum);&#125;int main()&#123; int T = read(); while(T--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2299 Ultra-QuickSort]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[题目地址 题解逆序对。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[500005], b[500005];ll ans;void init()&#123; for(int i = 0; i &lt; n; ++i) a[i] = read();&#125;void Merge(int ls, int rs, int re)&#123; int lp = ls, rp = rs, tp = ls; while(lp &lt; rs &amp;&amp; rp &lt; re)&#123; if(a[lp] &lt;= a[rp]) b[tp++] = a[lp++]; else b[tp++] = a[rp++], ans += 1ll * (rs - lp); &#125; while(lp &lt; rs) b[tp++] = a[lp++]; while(rp &lt; re) b[tp++] = a[rp++]; memcpy(a + ls, b + ls, sizeof(int) * (re - ls));&#125;void ms(int l, int r)&#123; int len = r - l, mid = (r + l) &gt;&gt; 1; if(len == 1) return ; ms(l, mid), ms(mid, r); Merge(l, mid, r);&#125;void solve()&#123; ans = 0; ms(0, n); printf("%lld\n", ans);&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3784 Running Median]]></title>
    <url>%2F2018%2F08%2F23%2Fpoj3784%2F</url>
    <content type="text"><![CDATA[题目地址 题解对顶堆技巧。就是把序列拆成两个部分，使得要维护的特定的数恰好处于被堆分割的部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq1;priority_queue&lt;int&gt; pq2;int n;void init()&#123; int snum = read(); n = read(); printf("%d %d\n", snum, (n + 1) &gt;&gt; 1);&#125;void solve()&#123; if(n == 1)&#123; printf("%d", read()); return ; &#125; int hd = read(), cnt = 2; printf("%d ", hd); pq2.push(hd); for(int i = 2; i &lt;= n; ++i)&#123; hd = read(); if(hd &lt;= pq2.top()) pq2.push(hd); else pq1.push(hd); if(i &amp; 1)&#123; while(pq2.size() &gt; pq1.size() + 1) pq1.push(pq2.top()), pq2.pop(); while(pq2.size() &lt; pq1.size() + 1) pq2.push(pq1.top()), pq1.pop(); printf("%d", pq2.top()); if(cnt == 10 &amp;&amp; i != n) cnt = 0, printf("\n"); else if(i != n) printf(" "); cnt++; &#125; &#125; while(!pq1.empty()) pq1.pop(); while(!pq2.empty()) pq2.pop();&#125;int main()&#123; int T = read(); for(int i = 1; i &lt;= T; ++i)&#123; init(); solve(); if(i != T) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第九章]]></title>
    <url>%2F2018%2F08%2F23%2Faoapc-chapter9%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第九章部分习题的整合。 例9-1 UVa1025 A Spy in the Metro题目链接 每一个时刻都有3个决策：在当前车站等一下，从向左开的车上下车，从向右开的车上下车。由于“坐在车上”这个状态不好表示，因此相应的替换为后两个状态。由于要表示当前时刻和当前车站，因此用$dp(i, j)$表示当前在$i$时刻，$j$车站，最少的在车站的时间。这样的话整个dp的时间复杂度为$O(nT)$。注意越界！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, T, m1, m2;int dp[255][55], t[55];bool has[255][55][2];void init()&#123; T = read(); t[0] = t[n] = 0; for(int i = 1; i &lt; n; ++i) t[i] = read(); memset(has, 0, sizeof(has)); m1 = read(); for(int i = 0; i &lt; m1; ++i) &#123; int tt = read(); for(int j = 1; j &lt;= n; ++j)&#123; if(tt &gt; T) break; has[tt][j][0] = 1, tt += t[j]; &#125; &#125; m2 = read(); for(int i = 0; i &lt; m2; ++i) &#123; int tt = read(); for(int j = n; j &gt;= 1; --j)&#123; if(tt &gt; T) break; has[tt][j][1] = 1, tt += t[j - 1]; &#125; &#125;&#125;void solve()&#123; memset(dp, 0x3f, sizeof(dp)); dp[0][1] = 0; for(int i = 1; i &lt;= T; ++i) for(int j = 1; j &lt;= n; ++j)&#123; int&amp; d = dp[i][j]; d = dp[i - 1][j] + 1; if(j &gt; 1 &amp;&amp; has[i][j][0] &amp;&amp; i &gt;= t[j - 1]) d = min(d, dp[i - t[j - 1]][j - 1]); if(j &lt; n &amp;&amp; has[i][j][1] &amp;&amp; i &gt;= t[j]) d = min(d, dp[i - t[j]][j + 1]); &#125; if(dp[T][n] &gt; T) printf("impossible\n"); else printf("%d\n", dp[T][n]);&#125;int main()&#123; int kase = 1; while(n = read())&#123; printf("Case Number %d: ", kase++); init(); solve(); &#125; return 0;&#125; 例9-2 UVa437 The Tower of Babylon题目链接 一个扩展性的矩阵嵌套问题？我设计的状态是$dp(i, j, id)$表示塔的第$i$块砖为第$j$个方块，并且高的编号为$id$时塔的最高高度。这样由于每一次转移只需要枚举之前一次放上去的方块，就可以判断是否合法。由于至多需要$2n$层，每一层的决策数都为$O(n)$，故总的时间复杂度为$O(n^2)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int dp[63][33][3], n, ord[33][3];void init()&#123; int x[3]; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; 3; ++j) x[j] = read(); sort(x, x + 3); for(int j = 0; j &lt; 3; ++j) ord[i][j] = x[2 - j]; &#125;&#125;void solve()&#123; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; 3; ++j) dp[1][i][j] = ord[i][j]; int ans = 0; for(int i = 2; ; ++i)&#123; int flag = 0; for(int j = 0; j &lt; n; ++j) for(int k = 0; k &lt; 3; ++k)&#123; int &amp;d = dp[i][j][k]; int a, b; if(k == 0) a = ord[j][1], b = ord[j][2]; if(k == 1) a = ord[j][0], b = ord[j][2]; if(k == 2) a = ord[j][0], b = ord[j][1]; for(int jj = 0; jj &lt; n; ++jj) for(int kk = 0; kk &lt; 3; ++kk)&#123; if(!dp[i - 1][jj][kk]) continue; int aa, bb; if(kk == 0) aa = ord[jj][1], bb = ord[jj][2]; if(kk == 1) aa = ord[jj][0], bb = ord[jj][2]; if(kk == 2) aa = ord[jj][0], bb = ord[jj][1]; if(aa &gt; a &amp;&amp; bb &gt; b) d = max(d, dp[i - 1][jj][kk] + ord[j][k]), ans = max(ans, d), flag = 1; &#125; &#125; if(!flag) break; &#125; printf("%d\n", ans);&#125;int main()&#123; int kase = 1; while(n = read())&#123; printf("Case %d: maximum height = ", kase++); init(); solve(); &#125; return 0;&#125; 例9-5 UVa12563 Jin Ge Jin Qu hao题目链接 先对前$t-1$秒跑一个背包，然后再检查一下最多的方案和对应的时间，并且加上劲歌金曲即可。原因是因为劲歌金曲唱了一定比不唱好，所以$t$要减掉一。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, t, len[55], dp[10005];void init()&#123; n = read(), t = read(); for(int i = 0; i &lt; n; ++i) len[i] = read();&#125;void solve()&#123; memset(dp, -1, sizeof(dp)); dp[0] = 0; t--; for(int i = 0; i &lt; n; ++i) for(int j = t; j &gt;= len[i]; --j) if(dp[j - len[i]] &gt;= 0) dp[j] = max(dp[j], dp[j - len[i]] + 1); int ans = -1, maxi; for(int i = t; i &gt;= 0; --i) if(dp[i] &gt; ans) ans = dp[i], maxi = i; printf("%d %d\n", ans + 1, maxi + 678);&#125;int main()&#123; int T = read(); for(int i = 1; i &lt;= T; ++i)&#123; printf("Case %d: ", i); init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第八章]]></title>
    <url>%2F2018%2F08%2F23%2Faoapc-chapter8%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第八章部分习题的整合。 例8-1 UVa120 Stacks of Flapjacks题目链接 显然，直接把对应的数放到它应该在的地方的排序方式是最快的。所以可以先对整个序列排一个序，然后从底向上判断某个位置上的数是否是排序后对应的数，不是的话就先把该数翻到最顶上，然后再翻到对应位置。这么做就是最快的排序方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[10005];int st[10005], n, p[10005], cur;int read()&#123; int x = 0; char c = s[cur]; while(c &lt; '0' || c &gt; '9')&#123; if(c == '\n' || c == EOF) return 0; c = s[++cur]; &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = s[++cur]; return x; &#125;void init()&#123; cur = n = 0; while(st[n] = read()) p[n] = st[n], n++; sort(p, p + n);&#125;void solve()&#123; for(int i = 0; i &lt; n - 1; ++i) printf("%d ", st[i]); printf("%d\n", st[n - 1]); for(int i = n - 1; i &gt; 0; --i)&#123; if(p[i] == st[i]) continue; int j; for(j = i - 1; st[j] != p[i]; --j) ; if(j) reverse(st, st + j + 1), printf("%d ", n - j); reverse(st, st + i + 1), printf("%d ", n - i); &#125; printf("0\n");&#125;int main()&#123; while(fgets(s, 10000, stdin) != NULL)&#123; init(); solve(); &#125; return 0;&#125; 例8-3 UVa1152 4 Values whose Sum is 0题目链接 这题神烦，哈希表几乎不可能过得了。所以还是直接排序后二分比较快。即所谓中途相遇法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, a[4005], b[4005], c[4005], d[4005];int q[16000005];ll ans;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) a[i] = read(), b[i] = read(), c[i] = -read(), d[i] = -read(); int cnt = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) q[cnt++] = c[i] + d[j]; sort(q, q + cnt);&#125;void solve()&#123; ans = 0; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) ans += upper_bound(q, q + n * n, a[i] + b[j]) - lower_bound(q, q + n * n, a[i] + b[j]); printf("%lld\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); if(T &gt; 0) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2001-2005 题解]]></title>
    <url>%2F2018%2F08%2F23%2Fnoip2001-2005%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2001-2005题目的题解。 NOIP2001普及T1 数的计算题目地址 \mathcal dp\left(i\right) = 1+ \sum_{j=1}^{\lfloor i/2\rfloor} dp\left(j\right) (i>1) \\ dp\left(1\right) = 11234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;typedef long long ll;int dp[1005]=&#123;0&#125;,n;int main()&#123; dp[2]=2,dp[1]=1; scanf("%d",&amp;n); int i,j; for(i=3;i&lt;=n;i++)&#123; for(j=i/2;j&gt;=1;j--) dp[i]+=dp[j]; dp[i]++; &#125; printf("%d\n",dp[n]); return 0;&#125; 普及T2 最大公约数与最小公倍数问题题目地址 我们知道$\mathcal x_0$必须是$\mathcal y_0$的约数。所以记$\mathcal t=\frac{y_0}{x_0}$，则$\mathcal 2^u$（$\mathcal u$为$\mathcal t$不同质因子的个数）即为答案。（集合划分）很巧妙的数学方法。爆搜会TLE来着。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int isP(int a)&#123;for(int i=2;i*i&lt;=a;i++)if(a%i==0)return 0;return 1;&#125;int main()&#123; int x0,y0,i,ans=1; scanf("%d%d",&amp;x0,&amp;y0); if(y0%x0)&#123;printf("0\n");return 0;&#125; for(i=2,y0/=x0;i&lt;=y0;i++) if(y0%i==0&amp;&amp;isP(i))ans&lt;&lt;=1; printf("%d\n",ans); return 0;&#125; 普及T3 求先序排列题目链接 由后序得根，然后中序的两半继续分治。递归建立一颗树。具体过程是，在中序中找到根，然后由于左右子树分别在其左右，故可以再为左右子树建树。如果到了树为空的情况就返回。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s1[30], s2[30];int root, lc[250], rc[250];int get(int il, int ir, int pl, int pr)&#123; if(ir - il &lt; 0) return 0; int id = s2[pr], i; for(i = il; i &lt;= ir; ++i) if(s1[i] == id) break; int len = i - il; lc[id] = get(il, i - 1, pl, pl + len - 1); rc[id] = get(i + 1, ir, pl + len, pr - 1); return id;&#125;void getP(int id)&#123; printf("%c", id); if(lc[id]) getP(lc[id]); if(rc[id]) getP(rc[id]);&#125;void solve()&#123; int len = strlen(s1); root = get(0, len - 1, 0, len - 1); getP(root);&#125;int main()&#123; scanf("%s%s", s1, s2); solve(); return 0;&#125; 普及T4 装箱问题题目地址 一个简单的背包问题。不过稍微要做一些处理，只要考虑状态的合法性即可。初始合法的状态就是箱子为空，随后按照01背包扩展到其他状态。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int V, n, f[20005] = &#123;0&#125;, v[35];void init()&#123; V = read(), n = read(); for(int i = 0; i &lt; n; ++i) v[i] = read();&#125;void solve()&#123; f[0] = 1; for(int i = 0; i &lt; n; ++i) for(int j = V; j &gt;= v[i]; --j) f[j] |= f[j - v[i]]; int ans; for(ans = V; !f[ans]; --ans) ; printf("%d\n", V - ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 一元三次方程求解题目地址 有4种方法： 暴力，按$0.01$步长枚举 二分，按照单调性求解 数学公式 导数 这里用的是二分，感觉还不错。1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef double D;D a,b,c,d,t1,t2,epi=0.01;D get(D k)&#123; return k*a*k*k+b*k*k+c*k+d;&#125;D C(int ll,int rr)&#123; D tmp,mid,l=(D)ll,r=(D)rr; int i=(get(l)&gt;get(r))?1:0; for(;;)&#123; mid=(l+r)/2.0; tmp=get(mid); if(r-l&lt;epi&amp;&amp;r-l&gt;-epi)break; if(tmp&gt;0)&#123; if(i)l=mid; else r=mid; &#125;else&#123; if(i)r=mid; else l=mid; &#125; &#125; printf("%.2lf ",mid);&#125;int main()&#123; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); int i;for(i=-100;i&lt;=100;i++)&#123; t1=(D)i,t2=t1+0.99; t1=get(t1),t2=get(t2); if(t1*t2&lt;0)C(i,i+1); else if(t1&lt;epi&amp;&amp;t1&gt;-epi)printf("%.2lf ",(D)i); &#125; return 0; &#125; 提高T2 数的划分题目地址 一个经典的递推问题。 方法一我的方法是设$f(n, m, k)$为数$n$划分为$k$个小于或等于$m$的数的方法数。那么有 f(n, m, k) = f(n, m - 1, k) + f(n - m, m, k - 1)这么做是$O(n ^2 k)$的。1234567891011121314#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int f[205][7]=&#123;0&#125;,n,k;int main()&#123; f[0][0]=1; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) for(int p=1;p&lt;=n;p++) if(p-i&gt;=0)f[p][j]+=f[p-i][j-1]; printf("%d\n",f[n][k]); return 0;&#125; 方法二设$f(n, k)$为题意所求，那么： 划分里面有$1$，那么包含$f(n - 1, k - 1)$&gt; 划分里面没有$1$，那么给划分里面所有的数添上一个$1$，即包含$f(n - k, k)$。因此得到f(n, k) = f(n - 1, k - 1) + f(n - k, k)时间复杂度$O(nk)$。 提高T3 统计单词个数题目地址 提高T4 Car的旅行路线题目地址 非常简单的最短路，非常难的建图。出发地和到达地每个机场间道路权值设为0即可。建图就是暴力用勾股求矩形顶点。在下面的代码中，我将顶点拆成了4个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#define rep(e) for(e=0;e&lt;4;e++)using namespace std;typedef double db;int T,s,t,A,B,rec[405][2],pr[105],vis[405];db ds[405][405],d[405][405],l[405];db dis(int a,int b)&#123; return (rec[a][0]-rec[b][0])*(rec[a][0]-rec[b][0])+ (rec[a][1]-rec[b][1])*(rec[a][1]-rec[b][1]);&#125;bool eq(db a,db b)&#123;return a-b&gt;(-1e-6)&amp;&amp;a-b&lt;(1e-6);&#125;void make(int i)&#123; db q1=dis(i,i+2),q2=dis(i,i+1),q3=dis(i+1,i+2); if(eq(q1+q2,q3))rec[i+3][0]=rec[i+2][0]+rec[i+1][0]-rec[i][0], rec[i+3][1]=rec[i+2][1]+rec[i+1][1]-rec[i][1]; else if(eq(q2+q3,q1))rec[i+3][0]=rec[i+2][0]+rec[i][0]-rec[i+1][0], rec[i+3][1]=rec[i+2][1]+rec[i][1]-rec[i+1][1]; else if(eq(q1+q3,q2))rec[i+3][0]=rec[i+1][0]+rec[i][0]-rec[i+2][0], rec[i+3][1]=rec[i+1][1]+rec[i][1]-rec[i+2][1];&#125;void dijkstra()&#123; int at,i=A&lt;&lt;2,j;db lst; fill(l,l+s,1e10); fill(vis,vis+s,0); l[i]=l[i+1]=l[i+2]=l[i+3]=0.0; for(i=0;i&lt;s;i++)&#123; for(lst=1e10,j=0;j&lt;s;j++) if(!vis[j]&amp;&amp;l[j]&lt;lst)at=j,lst=l[j]; vis[at]=1; for(j=0;j&lt;s;j++) l[j]=min(l[at]+d[at][j],l[j]); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v;db price; while(T--)&#123; scanf("%d%d%d%d",&amp;s,&amp;t,&amp;A,&amp;B); A--,B--,s&lt;&lt;=2; for(i=0;i&lt;s;i+=4)&#123; scanf("%d%d%d%d%d%d%d",&amp;rec[i][0],&amp;rec[i][1],&amp; rec[i+1][0],&amp;rec[i+1][1],&amp;rec[i+2][0],&amp; rec[i+2][1],&amp;pr[i]),make(i); if(i/4==A||i/4==B)pr[i]=0; &#125; for(i=0;i&lt;s;i+=4)&#123; for(j=0;j&lt;s;j+=4)&#123; price=(i!=j)?t:pr[i]; rep(u)rep(v) ds[i+u][j+v]=sqrt(dis(i+u,j+v)), d[i+u][j+v]=price*ds[i+u][j+v]; &#125; &#125; dijkstra(); printf("%.1lf\n",l[B&lt;&lt;2]); &#125; return 0;&#125; NOIP2002普及T2 选数题目地址 用DFS构造出所有的组合即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,x[24],ans=0;bool isPrime(int t)&#123; if(t&amp;1)&#123; if(t==1)return false; else&#123; for(int i=3;i*i&lt;=t;i+=2) if(t%i==0)return false; return true; &#125; &#125;else return t==2;&#125;void dfs(int index,int used,int sum)&#123; sum+=x[index]; if(used==k)&#123; if(isPrime(sum))ans++; return ; &#125; for(int i=index+1;i&lt;=n-k+used;i++) dfs(i,used+1,sum);&#125;void init()&#123; n=read(),k=read(); for(int i=0;i&lt;n;i++) x[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;=n-k;i++) dfs(i,1,0); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; NOIP2003提高T1 神经网络题目地址 拓扑排序。按照题意模拟即可。注意，只有一个神经元的情况要特判。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int mp[105][105],c[105]=&#123;0&#125;,u[105],V,E,d[105]=&#123;0&#125;;int que[105],f=0,r=0,vis[105]=&#123;0&#125;,mat[105][105]=&#123;0&#125;;void topo()&#123; int du[105]=&#123;0&#125;,i,j,o=0; for(i=1;i&lt;=V;i++)&#123; for(j=1;j&lt;=V;j++) if(mat[j][i])du[i]++,d[j]++; if(!du[i])vis[i]=1,que[r++]=i; &#125; while(r-f)&#123; i=que[f++]; if(du[i])c[i]-=u[i]; if(c[i]&gt;0)&#123; for(j=1;j&lt;=V;j++) if(mat[i][j])&#123; c[j]+=mp[i][j]*c[i]; if(!vis[j]) vis[j]=1,que[r++]=j; &#125; &#125; &#125; for(i=1;i&lt;=V;i++) if(!d[i]&amp;&amp;c[i]&gt;0) o=1,printf("%d %d\n",i,c[i]); if(!o)printf("NULL\n");&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); int i,j,_u,v,_c; for(i=1;i&lt;=V;i++) scanf("%d%d",&amp;c[i],&amp;u[i]); for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;_u,&amp;v,&amp;_c), mat[_u][v]=1, mp[_u][v]=_c; if(V==1&amp;&amp;c[1]&gt;0) printf("%d %d\n",1,c[1]); else topo(); return 0;&#125; NOIP2004提高T1 津津的储蓄计划题目地址 模拟神题。123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int saved = 0, cur = 0;int main()&#123; int flag = 1; for(int i = 1; i &lt;= 12; ++i)&#123; cur += 300; int curm; scanf("%d", &amp;curm); if(curm &gt; cur)&#123; printf("-%d\n", i), flag = 0; break; &#125; cur -= curm; saved += cur - (cur % 100); cur %= 100; &#125; if(flag) printf("%d\n", cur + saved * 6 / 5); return 0;&#125; NOIP2005提高T4 等价表达式题目地址 表达式求值。然而数据可以很大，直接比较答案和原式的做法不大现实。所以我们可以采用NOIP2014解方程的做法，把$a$带入一个数，再模一个质数，看结果是不是相同的。实际上为了保证准确性是可以模多个质数的，但这题数据很水，就没有这么做。最好还是多模几个质数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define A 1189using namespace std;int stack[2][10005],top[2]=&#123;0&#125;,pro[300],lim,targ,M=10009;char _exp[10000];int poww(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125; return res; &#125;void opr()&#123; int a1,a2,b; a2=stack[0][--top[0]], a1=stack[0][--top[0]], b=stack[1][--top[1]]; if(b=='+')stack[0][top[0]++]=(a1+a2)%M; if(b=='-')stack[0][top[0]++]=(a1-a2+M)%M; if(b=='*')stack[0][top[0]++]=(a1*a2)%M; if(b=='^')stack[0][top[0]++]=poww(a1,a2);&#125;void calc()&#123; int i,j,t=-1,cnt=0; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='a') stack[0][top[0]++]=A; else if(isdigit(_exp[i]))&#123; if(t&lt;0)t=_exp[i]-'0'; else t=t*10+_exp[i]-'0'; &#125;else if(_exp[i]!=' ')&#123; if(t!=-1) stack[0][top[0]++]=t, t=-1; if(_exp[i]=='(') stack[1][top[1]++]='(',cnt++; else if(_exp[i]==')')&#123; if(!cnt)continue; while(stack[1][top[1]-1]!='(') opr(); top[1]--,cnt--; &#125;else&#123; while(top[1]&amp;&amp;stack[1][top[1]-1]!='('&amp;&amp; pro[stack[1][top[1]-1]]&gt;=pro[_exp[i]]) opr(); stack[1][top[1]++]=_exp[i]; &#125; &#125; &#125;&#125;void init()&#123; pro['+']=pro['-']=1, pro['*']=2, pro['^']=3; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; calc(); targ=stack[0][0];&#125;void solve()&#123; int m,i; fgets(_exp,99,stdin); sscanf(_exp,"%d",&amp;m); for(i=0;i&lt;m;i++)&#123; fgets(&amp;_exp[1],99,stdin); _exp[0]='('; lim=strlen(_exp); _exp[lim++]=')'; top[0]=top[1]=0; memset(stack,0,sizeof(stack)); calc(); if(stack[0][0]==targ) printf("%c",'A'+i); &#125; printf("\n");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DFS</tag>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>栈</tag>
        <tag>树形结构</tag>
        <tag>拓扑排序</tag>
        <tag>数论</tag>
        <tag>背包DP</tag>
        <tag>最短路</tag>
        <tag>递推</tag>
        <tag>非完美算法</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP1996-2000 题解]]></title>
    <url>%2F2018%2F08%2F21%2Fnoip1996-2000%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP1996-2001部分题目的题解。 NOIP1996提高T3 挖地雷题目地址 题目已经帮你拓扑排序完了，直接转移就可以。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,V,mp[25][25]=&#123;0&#125;,m[25],dp[25]=&#123;0&#125;,pre[25],ans[25],maxi=0,at;int main()&#123; scanf("%d",&amp;n); int i,j; fill(pre,pre+n,-1);//记录路径 for(i=0;i&lt;n;i++) scanf("%d",&amp;m[i]); for(i=0;i&lt;n-1;i++) for(j=i+1;j&lt;n;j++) scanf("%d",&amp;mp[i][j]); dp[0]=maxi=m[0],at=0; for(i=1;i&lt;n;i++)&#123; for(j=i-1;j&gt;=0;j--) if(mp[j][i]&amp;&amp;dp[j]&gt;=dp[i]) dp[i]=dp[j],pre[i]=j; dp[i]+=m[i]; if(dp[i]&gt;maxi) maxi=dp[i],at=i; &#125; for(j=0,i=at;i!=-1;i=pre[i]) ans[j++]=i+1; for(i=j-1;i&gt;=0;i--)&#123; printf("%d",ans[i]); if(i)printf(" "); &#125; printf("\n%d\n",maxi); return 0;&#125; 提高T4 砝码称重题目地址 用了完全背包，但是数据很弱，好像没有必要。可以暴力枚举。123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int f[1005]=&#123;0&#125;,n,v[6],ans=0;void packX(int vv)&#123;//二进制枚举版本 int p=1,vi=vv,j; while(n&gt;=p)&#123; for(j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); n-=p,p&lt;&lt;=1,vi&lt;&lt;=1; &#125; if(n)&#123; for(vi=n*vv,j=1000;j&gt;=vi;j--) f[j]=max(f[j],f[j-vi]); &#125;&#125;int main()&#123; v[0]=1,v[1]=2,v[2]=3,v[3]=5,v[4]=10,v[5]=20; f[0]=1; for(int i=0;i&lt;6;i++)&#123; scanf("%d",&amp;n); if(n)packX(v[i]); &#125; for(int i=1;i&lt;=1000;i++) ans+=f[i]; printf("Total=%d\n",ans); return 0;&#125; NOIP1997普及T1 棋盘题目地址 自己推一下就行了。长方形（含正方形）个数为 \frac {nm(n+1)(m+1) }{4}正方形个数为 \mathcal \sum_{i=1}^m {i \left( n-m+i \right) \left( m \le n \right)}1234567891011121314#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll n,m,a1=0,a2=0;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(n&lt;m)swap(n,m); a1=m*n*(n+1)*(m+1)/4; for(int i=1;i&lt;=m;i++) a2+=(n-m+i)*i; printf("%lld %lld\n",a2,a1-a2); return 0; &#125; 普及T2 三角形题目地址 暴力枚举即可。用了全排列。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int ans=0,p,rec[20],now[20]=&#123;1,2,3,4,5,6,7,8,9&#125;;void cmp()&#123; if(!ans||memcmp(now,rec,sizeof(int)*9)&lt;0) memcpy(rec,now,sizeof(rec)); ans++;&#125;int ok()&#123; return ((now[0]&lt;now[5]&amp;&amp;now[5]&lt;now[8]) &amp;&amp;(now[1]&lt;now[3]&amp;&amp;now[6]&lt;now[7]&amp;&amp;now[2]&lt;now[4]) &amp;&amp;(now[0]+now[1]+now[3]+now[5]==p) &amp;&amp;(now[6]+now[7]+now[8]+now[5]==p) &amp;&amp;(now[0]+now[2]+now[4]+now[8]==p));&#125;int main()&#123; scanf("%d",&amp;p); do&#123; if(ok())cmp(); &#125;while(next_permutation(now,now+9)); if(!ans)&#123; printf("NO\n"); return 0; &#125; printf("%d\n",ans); printf("%d\n%d %d\n%d %d\n%d %d %d %d\n",rec[0], rec[1],rec[2],rec[3],rec[4],rec[5],rec[6], rec[7],rec[8]); return 0; &#125; 普及T3 街道题目地址 就是非常正常的DP。递推式 \mathcal dp(i,j) = dp(i-1,j)+dp(i,j-1)之后再用一个简单的高精度就可以了。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll M=1000000000000000,dp[55][55][2]=&#123;0&#125;,n,m,x1,x2,y1,y2,ok=1;void add(ll u1,ll v1,ll u2,ll v2)&#123; ll a=dp[u1][v1][0]+dp[u2][v2][0]; dp[u2][v2][0]=a%M,a/=M; a+=dp[u1][v1][1]+dp[u2][v2][1]; dp[u2][v2][1]=a%M;//简单的高精度&#125;void solve()&#123; dp[1][1][0]=1; for(ll i=1;i&lt;=n;i++) for(ll j=1;j&lt;=m;j++) if((ok&amp;&amp;(i&lt;x1||i&gt;x2||j&lt;y1||j&gt;y2))||(!ok)) add(i-1,j,i,j), add(i,j-1,i,j); //递推过程 dp[n][m][1]%=100000; if(dp[n][m][1]&gt;0)printf("%lld%015lld\n",dp[n][m][1],dp[n][m][0]); else printf("%lld\n",dp[n][m][0]);&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(!x1&amp;&amp;!x2&amp;&amp;!y1&amp;&amp;!y2)ok=0; else&#123; if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); &#125; solve(); return 0;&#125; 提高T1 棋盘问题2（待考察？）题目地址 本题我只想出来了一种比较简单的搜索方法。。。实际上原题数据很小，基本上各种搜索方法都可以过，但是当$N = 10$的时候就很难卡过去了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,sqr,mat[15][15]=&#123;0&#125;,dx[]=&#123;0,0,-1,1&#125;,dy[]=&#123;-1,1,0,0&#125;,ans=0;bool isprime[205]=&#123;0&#125;,used[105]=&#123;0&#125;;void dfs(int x,int y)&#123; if(ans)return ; for(int i=2;!ans&amp;&amp;i&lt;=sqr;i++)&#123; if(!used[i]&amp;&amp;(!x||isprime[i+mat[x-1][y]])&amp;&amp;(!y||isprime[i+mat[x][y-1]]))&#123; mat[x][y]=i,used[i]=1; if(x==y)&#123; if(x==n-1)&#123;ans=1;return;&#125; else dfs(x,y+1); &#125;else if(y==n-1)dfs(x+1,x); else if(x==n-1)dfs(y+1,y+1); else if(y&gt;x)dfs(x,y+1); else if(x&gt;y)dfs(x+1,y); if(!ans)mat[x][y]=0,used[i]=0; &#125; &#125;&#125;void init()&#123; n=read(); sqr=n*n; for(int i=3;i&lt;=200;i+=2)&#123; isprime[i]=1; for(int j=3;j*j&lt;=i;j+=2) if(i%j==0)&#123; isprime[i]=0;break; &#125; &#125;&#125;void solve()&#123; mat[0][0]=1,used[1]=1; dfs(0,1); if(!ans)printf("NO\n"); else&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n-1;j++) printf("%d ",mat[i][j]); printf("%d\n",mat[i][n-1]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; NOIP1998普及T1 寻找三位数题目地址 很简单的枚举。只要从101枚举到333即可，然后记录每一位。可以采用特殊策略优化，比如当前数字必须不是5的倍数。1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char k[10];int main()&#123; int a,b,c,d,fl,i; for(a=101;a&lt;=333;a++)&#123; if(a%5==0)continue; memset(k,0,sizeof(k)); fl=1,b=a,c=a*2,d=a*3; k[b%10]++,k[c%10]++,k[d%10]++; k[(b/10)%10]++,k[(c/10)%10]++,k[(d/10)%10]++; k[b/100]++,k[c/100]++,k[d/100]++; for(i=1;i&lt;=9;i++) if(k[i]!=1) fl=0; if(fl)printf("%d %d %d\n",b,c,d); &#125; return 0;&#125; 普及T2 阶乘之和题目地址 高精度乘法+加法水过。12 普及T3 幂次方题目地址 递归计算即可。12 提高T1 火车站题目地址 设第二站上的人数是$p$，则：容易看出每一站上下车的人都等于$fib[i]a+fib[j]p$，其中$i$和$j$为相邻正整数。那么只需要算出最终车上的人等于多少$a$加多少$p$，解出$p$，然后带入第$x$站的数据即可。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int a,n,m,x,fib[25],xs1[25],xs2[25];void init()&#123; a=read(),n=read(),m=read(),x=read(); fib[0]=0,fib[1]=1; for(int i=2;i&lt;=24;i++) fib[i]=fib[i-1]+fib[i-2];&#125;void solve()&#123; xs1[1]=xs1[2]=1,xs2[1]=xs2[2]=0; for(int i=3;i&lt;n;i++) xs1[i]=xs1[i-1]+fib[i-2]-fib[i-3], xs2[i]=xs2[i-1]+fib[i-1]-fib[i-2]; printf("%d\n",xs1[x]*a+xs2[x]*(m-xs1[n-1]*a)/xs2[n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T2 拼数题目地址 NOIP1999普及T1 Cantor表题目地址 找规律，分奇偶讨论，最后$ \mathcal O(1)$计算。12345678#include &lt;cstdio&gt;using namespace std;int main()&#123; int n,i;scanf("%d",&amp;n); for(i=1;n&gt;(i*i+i)/2;i++); if(i%2==0)n=i*i+1-n; printf("%d/%d\n",i+(i*i-i)/2+1-n,n-(i*i-i)/2);&#125; 普及T2 回文数题目地址 套用高精度加法模板即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n, s1[1005], s2[1005];char s[1005];void init()&#123; scanf("%d%s", &amp;n, &amp;s);&#125;bool judge(int len)&#123; for(int i = 1; i &lt;= (len &gt;&gt; 1); ++i) if(s1[i] != s1[len - i + 1]) return false; return true;&#125;void add()&#123; memset(s2, 0, sizeof(s2)); int x = 0; s2[0] = s1[0]; for(int i = 1; i &lt;= s1[0]; ++i)&#123; x += s1[i] + s1[s1[0] - i + 1]; s2[i] = x % n; x /= n; &#125; if(x &gt; 0) s2[++s2[0]] = x;&#125;void solve()&#123; int len = strlen(s); s1[0] = len; for(int i = len - 1; i &gt;= 0; --i)&#123; if(isdigit(s[i])) s1[len - i] = s[i] - '0'; else s1[len - i] = s[i] - 'A' + 10; &#125; int flag = 0; for(int i = 0; i &lt;= 30; ++i)&#123; if(judge(s1[0]))&#123; flag = 1; printf("STEP=%d\n", i); break; &#125; add(); memcpy(s1, s2, sizeof(s2)); &#125; if(!flag) printf("Impossible!");&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 导弹拦截题目地址 先求最长不上升子序列，再求最长上升子序列。（Dilworth定理，最长链和最长反链）或者因为数据小，贪心的做法也能接受。所以我无聊的写了三个版本： $O(nlogn)$动态规划123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int high[50],tot=0,ans=0,dp[50]=&#123;0&#125;,tmp; int main()&#123; int i,j; while(scanf("%d",&amp;high[tot])==1)tot++; for(i=0;i&lt;tot;i++)&#123; for(tmp=1,j=0;j&lt;i;j++)&#123; if(high[j]&gt;=high[i])tmp=max(tmp,dp[j]+1); &#125;dp[i]=tmp; &#125;for(i=0;i&lt;tot;i++)ans=max(ans,dp[i]); fill(dp,dp+tot,0x7FFFFFFF);for(i=0;i&lt;tot;i++) *lower_bound(dp,dp+tot,high[i])=high[i]; tmp=lower_bound(dp,dp+tot,0x7FFFFFFF)-dp; printf("%d\n%d\n",ans,tmp); return 0; &#125; $O(n^2)$动态规划12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dat[55],n;int dp(int o)&#123; int dpp[55],ans=1; fill(dpp,dpp+n,1); for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++) if(o&amp;&amp;dat[j]&lt;=dat[i])dpp[i]=max(dpp[i],dpp[j]+1); else if(dat[j]&lt;dat[i])dpp[i]=max(dpp[i],dpp[j]+1); ans=max(ans,dpp[i]); &#125;return ans;&#125;int main()&#123; n=0;while(~scanf("%d",&amp;dat[n]))n++; reverse(dat,dat+n); printf("%d\n",dp(1)); reverse(dat,dat+n); printf("%d\n",dp(0)); return 0;&#125; $O(n^2)$贪心123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int h[25],low[25],n=0,ans,f[25];int main()&#123; int i,j,t; while(~scanf("%d",&amp;h[n]))n++; for(f[0]=1,ans=i=1;i&lt;n;i++)&#123; f[i]=1; for(j=0;j&lt;i;j++) if(h[j]&gt;=h[i])f[i]=max(f[i],f[j]+1); ans=max(ans,f[i]); &#125; printf("%d\n",ans); for(low[0]=h[0],ans=0,i=1;i&lt;n;i++)&#123; for(j=0;j&lt;=ans;j++) if(low[j]&gt;=h[i])&#123;low[j]=h[i];break;&#125; if(j&gt;ans)low[++ans]=h[i]; &#125; printf("%d\n",ans+1); return 0;&#125; 普及/提高T3 旅行家的预算题目地址 尽量选最便宜的，如果油满了就换次便宜的，这样递归（循环下去）。最后油全满了就No solution。这里使用了优先队列来取最优值。只是懒得手写堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;typedef double db;typedef struct&#123; int id;db count,dis,pri;&#125;Pp;bool operator&lt;(Pp a,Pp b)&#123;return a.pri&gt;b.pri;&#125;Pp dat[105];int n;db ans=0,C,D,per;priority_queue&lt;Pp&gt; pq;void solve()&#123; pq.push(dat[0]); int i,j,k; Pp tmp; for(i=1;i&lt;=n;i++)&#123; db need=(dat[i].dis-dat[i-1].dis)/per,mini; for(;!pq.empty();)&#123; tmp=pq.top(); for(mini=need,j=tmp.id;j&lt;i;j++) mini=min(C-dat[j].count,mini); for(j=tmp.id;j&lt;i;j++) dat[j].count+=mini; ans+=mini*tmp.pri; if(mini&lt;need) need-=mini,pq.pop(); else break; &#125; if(pq.empty())&#123;ans=-1;return ;&#125; pq.push(dat[i]); &#125; &#125;int main()&#123; int i,j; scanf("%lf%lf%lf%lf%d",&amp;D,&amp;C,&amp;per,&amp;dat[0].pri,&amp;n); for(i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;dat[i].dis,&amp;dat[i].pri); dat[0].dis=0; for(n++,i=0;i&lt;=n;i++) dat[i].count=0,dat[i].id=i; dat[n].dis=D; solve(); if(ans&lt;0)printf("No Solution\n"); else printf("%.2lf\n",ans); return 0;&#125; 提高T4 邮票面值设计题目链接]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>堆</tag>
        <tag>贪心</tag>
        <tag>背包DP</tag>
        <tag>线性DP</tag>
        <tag>图上DP</tag>
        <tag>生成函数</tag>
        <tag>棋盘DP</tag>
        <tag>部分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2006 题解]]></title>
    <url>%2F2018%2F08%2F21%2Fnoip2006%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2006八道题目的题解。 普及T1 明明的随机数题目链接 排序去重即可。 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n;vector&lt;int&gt; v;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; int j; scanf("%d",&amp;j); v.push_back(j); &#125; sort(v.begin(),v.end()); vector&lt;int&gt;::iterator it=unique(v.begin(),v.end()); printf("%d\n",it-v.begin()); for(int i=0;i&lt;it-v.begin();i++) printf("%d ",v[i]); return 0; &#125; 普及T2 开心的金明题目链接 最基本的01背包。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int V, n, f[30005] = &#123;0&#125;, v[30], w[30];void init()&#123; V = read(), n = read(); for(int i = 0; i &lt; n; ++i) v[i] = read(), w[i] = read();&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i) for(int j = V; j &gt;= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + w[i] * v[i]); printf("%d\n", f[V]);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T3 Jam的计数法题目链接 自己手写一个生成下一个组合的函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int s, t, l;char p[30];void init()&#123; s = read() - 1, t = read() - 1, l = read(); scanf("%s", p); for(int i = 0; i &lt; l; ++i) p[i] -= 'a';&#125;bool getC()&#123; int cur = l - 1; while(cur &gt;= 0 &amp;&amp; p[cur] == t - l + 1 + cur) cur--; if(cur == -1) return false; p[cur]++, cur++; while(cur &lt; l) p[cur] = p[cur - 1] + 1, cur++; for(int i = 0; i &lt; l; ++i) putchar(p[i] + 'a'); putchar('\n'); return true;&#125;void solve()&#123; for(int i = 0; i &lt; 5; ++i) if(!getC()) break;&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 数列题目链接 容易证明 \forall b \in \mathbb{N}^*, k^b>\sum_{i=0}^{b-1} k^i令(N)_{10}=(a_na_{n-1}...a_1a_0)_2可以推出 \sum_{i=0}^n a_i \cdot k^i随着$N$递增。而$N$从$1$开始增加，因此该数列的第$N$项即为上式。12345678910111213141516#include &lt;cstdio&gt;int n,k,m=0,s=0;int p(int w)&#123; int res=1; for(int i=1;i&lt;=w;i++)res*=n; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); while(k)&#123; if(k&amp;1)s+=p(m); m++,k&gt;&gt;=1; &#125; printf("%d\n",s); return 0;&#125; 提高T1 能量项链题目链接 和石子合并差不多。由于是环状，所以需要把原来的项链复制一遍。很经典的区间DP。123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[205][205]=&#123;0&#125;,n,dat[205][2];int main()&#123; scanf("%d",&amp;n); n&lt;&lt;=1; int _n=n; for(int i=0;i&lt;_n;i++) scanf("%d",&amp;dat[i][0]), dat[i+_n][0]=dat[i][0]; dat[n-1][1]=dat[0][0]; for(int i=0;i&lt;n-1;i++) dat[i][1]=dat[i+1][0]; for(int i=1;i&lt;_n;i++)//i:length for(int j=0;j+i&lt;n;j++) for(int k=j;k&lt;i+j;k++) dp[j][i+j]=max(dp[j][j+i],dp[j][k]+dp[k+1][i+j]+ dat[j][0]*dat[k][1]*dat[i+j][1]); int ans=dp[0][_n-1]; for(int i=1;i&lt;_n;i++) ans=max(ans,dp[i][i+_n-1]); printf("%d\n",ans); return 0;&#125; 提高T2 金明的预算方案题目链接 一个很不寻常的背包DP。由于有附件的存在，我们需要将购买不同的附件相分开。即将购买0到多个附件分别作为不同的决策考虑。由于附件数不超过2个，所以我们购买某一个主件和其附件的时候至多只有4种决策：只购买主件，或者买主件和两个附件中的一个，或者主附件全买。这样的话就归化成了一个普通的01背包问题。1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int dp[32005]=&#123;0&#125;,n,W,w[62][5]=&#123;0&#125;,v[62][5]=&#123;0&#125;;int main()&#123; scanf("%d%d", &amp;W, &amp;n); for(int i = 1; i &lt;= n; ++i)&#123; int j, p, k; scanf("%d%d%d", &amp;j, &amp;p, &amp;k); if(k)&#123; if(w[k][0] &gt; 1) w[k][3] += j, w[k][4] += j, w[k][0] += 2, v[k][3] += p * j, v[k][4] += p * j; else w[k][2] += j, w[k][3] += j, w[k][0]++, v[k][3] += p * j, v[k][2] += p * j; &#125;else&#123; w[i][0]++, w[i][1] += j, w[i][2] += j, w[i][3] += j, w[i][4] += j; v[i][3] += p * j, v[i][4] += p * j, v[i][1] = p * j, v[i][2] += p * j; &#125; &#125; for(int i = 1; i &lt;= n; ++i) if(w[i][0]) for(int j = W; j &gt;= w[i][1]; --j) for(int k = 1; k &lt;= w[i][0]; ++k) if(j - w[i][k] &gt;= 0) dp[j] = max(dp[j], dp[j - w[i][k]] + v[i][k]); printf("%d\n", dp[W]); return 0;&#125; 提高T3 作业调度方案题目链接 模拟即可…千万不要考虑什么奇奇怪怪的优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int gid,_id,p[2]; &#125;Move;Move move[405],*pt[25][25];int mac[25][455]=&#123;0&#125;,cnt[25]=&#123;0&#125;,m,n;int ok(int id,int l,int r)&#123; for(int i=l;i&lt;=r;i++) if(mac[id][i])return i; for(int i=l;i&lt;=r;i++) mac[id][i]=1; return 0;&#125; int solve()&#123; int i,j,k,u,v,id,ans=0; fill(cnt,cnt+24,1); for(i=1;i&lt;=m*n;i++)&#123; u=move[i].p[0],v=move[i].p[1], id=move[i].gid; for(j=cnt[id];;)&#123; k=ok(u,j,j+v-1); if(!k)&#123;cnt[id]=j+v;break;&#125; else j=k+1; &#125; &#125; for(i=1;i&lt;=n;i++) ans=max(ans,cnt[i]); return ans-1;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int i,j,k; for(i=1;i&lt;=m*n;i++) scanf("%d",&amp;j), move[i].gid=j, move[i]._id=++cnt[j], pt[j][cnt[j]]=&amp;move[i]; for(k=0;k&lt;2;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) scanf("%d",&amp;pt[i][j]-&gt;p[k]); printf("%d\n",solve()); return 0;&#125; 提高T4 $2^k$进制数题目地址 组合数问题。数码递增视为一个组合。这样一个数，数码只有$\mathcal 2^k-1$个，故长度至多为$\mathcal 2^k-1$。因此当$\mathcal w \ge \left(2^k-1\right) \times k $的时候，多出的那部分没有意义。此时令$\mathcal w = \left(2^k-1\right) \times k $。对于一个$\mathcal w$，一个$\mathcal 2^k$进制数除去最高位至多有$\mathcal \lfloor \frac {w}{k} \rfloor$位。考虑$\mathcal 2$到$\mathcal \lfloor \frac {w}{k} \rfloor$位，由于数码有$\mathcal 2^k-1$个，故此部分答案为 \mathcal \sum_{i=2}^{ \lfloor \frac {w}{k} \rfloor} C_{2^k-1}^{i}考虑最高位，由于最高位可能的最大数我们可以算出，设其为$\mathcal u$，则 \mathcal u=2^{w \mod k}-1最高位已经确定，剩下的只有$\mathcal \lfloor \frac {w}{k} \rfloor$个数字要选，备选的数字有$\mathcal 2^k-1-o \left( 1\le o \le u\right)$个，故此部分答案为 \mathcal \sum_{o=1}^u C_{2^k-1-o}^{\lfloor \frac {w}{k} \rfloor}两部分相加即为本题答案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define p 10000using namespace std;int c[520][25],ans[56]=&#123;0&#125;,k,w,k1,k2;void mul(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=1;i&lt;=s1[0];i++) x+=s1[i]*s2,to[i]=x%p,x/=p; for(;x&gt;0;)to[++to[0]]=x%p,x/=p; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void add(int s1[],int s2[])&#123; s2[0]=max(s1[0],s2[0]); int x=0; for(int i=1;i&lt;=s2[0];i++) x+=s1[i]+s2[i],s2[i]=x%p,x/=p; for(;x!=0;)s2[++s2[0]]=x%p,x/=p;&#125;void divide(int s1[],int s2)&#123; int x=0; for(int i=s1[0];i&gt;=1;i--)&#123; x=x*p+s1[i],s1[i]=x/s2,x%=s2; &#125; for(;s1[0]&gt;1&amp;&amp;s1[s1[0]]==0;)s1[0]--;&#125;void C(int m,int n)&#123; c[0][0]=c[0][1]=1; for(int i=1;i&lt;=m;i++) mul(c[i-1],n-i+1,c[i]),divide(c[i],i);&#125;int output(int big[])&#123; printf("%d",big[big[0]]); for(int i=big[0]-1;i&gt;=1;i--) printf("%04d",big[i]); printf("\n");&#125;int main()&#123; scanf("%d%d",&amp;k,&amp;w); k1=1&lt;&lt;k; if(w&gt;k*(k1-1))w=k*(k1-1); C(w/k,k1-1); for(int i=2;i&lt;=w/k;i++)add(c[i],ans); k2=1&lt;&lt;(w%k); for(int i=1;i&lt;k2;i++) C(w/k,k1-1-i),add(c[w/k],ans); output(ans); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>背包DP</tag>
        <tag>区间DP</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hanoi]]></title>
    <url>%2F2018%2F08%2F21%2Fwriting%2FHanoi%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP2007 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2007%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2007八道题目的题解。 普及T1 奖学金题目链接 按照题意排序即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;struct Stu&#123; int all, chi, id;&#125;;struct cmp&#123; inline bool operator()(const Stu&amp; s1, const Stu&amp; s2)&#123; if(s1.all != s2.all)return s1.all &gt; s2.all; if(s1.chi != s2.chi)return s1.chi &gt; s2.chi; return s1.id &lt; s2.id; &#125;&#125;;Stu s[505];int n;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) s[i].id = i + 1, s[i].all = s[i].chi = read(), s[i].all += read() + read(); sort(s, s + n, cmp());&#125;void solve()&#123; for(int i = 0; i &lt; 5; ++i) printf("%d %d\n", s[i].id, s[i].all);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T2 纪念品分组题目链接 排序后大的尽量和小的组合，无法组合则直接退出。123456789101112131415#include &lt;cstdio&gt;#include &lt;algorithm&gt;int limit,n,k[30005],ans=0;int main()&#123; scanf("%d%d",&amp;limit,&amp;n); int i,at,o=0; for(i=0;i&lt;n;i++)scanf("%d",&amp;k[i]); std::sort(k,k+n); for(i=0;i&lt;n;i++)&#123; for(o=0,at=n-1;at&gt;i;at--) if(k[at]&lt;=limit-k[i])&#123;o=1;break;&#125; if(o)&#123;ans+=n-at;n=at;&#125;else&#123;ans+=n-i;break;&#125; &#125;printf("%d\n",ans); return 0;&#125; 普及T3 守望者的逃离题目链接 方法一分类讨论。。尽量采取最优的策略。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;int m, s, t, ts, lim;int get()&#123; if((10 - m) % 4) return (10 - m) / 4 + 1; return (10 - m) / 4;&#125;int main()&#123; scanf("%d%d%d", &amp;m, &amp;s, &amp;t); for(int i = t, ts = s; i &gt; 0; )&#123; if(ts &lt;= 0) break; if(m &gt;= 10) m -= 10, ts -= 60, i--; else&#123; if(ts &lt;= 17) i--, ts=0;//跑一下就跑的到 else&#123; if((lim = get()) &lt; 3)&#123; if(i &gt;= lim + 1)&#123; if(ts &lt;= 34)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else i = i - (lim + 1), ts -= 60, m -= 10, m += lim * 4; &#125;else &#123; if(ts &lt;= i * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else ts -= i * 17, i = 0;//尽量跑 &#125; &#125;else&#123; if(i &gt;= 7)&#123; if(ts &lt;= 7 * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else i -= 7, ts -= 120; &#125;else &#123; if(ts &lt;= i * 17)&#123; i -= ts / 17; if(ts % 17) i--; ts = 0;//跑完全程 &#125;else ts -= i * 17, i = 0;//尽量跑 &#125; &#125; &#125; &#125; if(ts &gt; 0) printf("No\n%d\n", s - ts); else printf("Yes\n%d\n", t - i); return 0; &#125; 方法二我们将法术和跑步分开来，跑一遍DP。一开始只有法术，然后修改决策为跑步。（来自洛谷上的神奇方法）该方法之所以成立，就在于恢复完全是为了放出法术，而和跑步无关。因此可以将两者视为不同的决策。12345678910111213141516171819int dp[300005];void solve()&#123; int m = read(), s = read(), T = read(); dp[0] = 0; for(int i = 1; i &lt;= T; ++i)&#123; if(m &gt;= 10) dp[i] = dp[i - 1] + 60, m -= 10; else dp[i] = dp[i - 1], m += 4; &#125; for(int i = 1; i &lt;= T; ++i)&#123; dp[i] = max(dp[i], dp[i - 1] + 17); if(dp[i] &gt;= s)&#123; printf("Yes\n%d\n", i); break; &#125; &#125; printf("No\n%d\n", dp[T]);&#125; 普及T4 Hanoi双塔问题题目链接 可以证明最短的次数一定是原汉诺塔问题的答案的两倍。（因为最优情况下就是每一次要移动2个同样大小的盘子）所以…加个高精度就完了。 提高T1 统计数字题目链接 模拟即可。123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; int n,k[200005],tot=1,last;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;k[i]); sort(k,k+n); last=k[0]; for(int i=1;i&lt;n;i++)&#123; if(last!=k[i]) printf("%d %d\n",last,tot),tot=1,last=k[i]; else tot++; &#125; printf("%d %d\n",last,tot); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第七章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter7%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第七章部分习题的整合。 例7-1 UVa725 Division题目链接 直接枚举除数即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, cnt[20];void solve()&#123; int flag = 0; for(int i = 1234; ; ++i)&#123; int j = i * n; if(j &lt; 10000 &amp;&amp; i &lt; 10000) continue; int tot = 0; while(j) cnt[tot++] = j % 10, j /= 10; j = i; while(j) cnt[tot++] = j % 10, j /= 10; if(i &lt; 10000)cnt[tot++] = 0; if(tot &gt; 10)break; sort(cnt, cnt + 10); for(j = 0; j &lt; 10; ++j) if(cnt[j] != j) break; if(j == 10) printf("%d / %05d = %d\n", i * n, i, n), flag = 1; &#125; if(!flag) printf("There are no solutions for %d.\n", n);&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(); if(!n)break; if(T &gt; 1)printf("\n"); solve(); &#125; return 0;&#125; 例7-2 UVa11059 Maximum Product题目链接 枚举两端即可。数据比较小，直接用long long。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;ll seq[50];void init()&#123; for(int i = 0; i &lt; n; ++i) seq[i] = read();&#125;void solve()&#123; ll ans = 0; for(int i = 0; i &lt; n; ++i) for(int j = i; j &lt; n; ++j)&#123; ll st = 1; for(int k = i; k &lt;= j; ++k) st *= seq[k]; ans = max(ans, st); &#125; printf("%lld.\n\n", ans);&#125;int main()&#123; int T = 0; while(scanf("%d", &amp;n) == 1)&#123; T++; printf("Case #%d: The maximum product is ", T); init(); solve(); &#125; return 0;&#125; 例7-3 UVa10976 Fractions Again?!题目链接 由于$x \ge y$可以发现$\frac{1}{x} \le \frac{1}{y}$。故$y$的下限为$k+1$，上限为$2k$。将$y$从$k+1$开始枚举到$2k$即可。12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, ans[10005][2], cnt;void solve()&#123; cnt = 0; for(int i = n + 1; i &lt;= n + n; ++i)&#123; int fz = i - n, fm = n * i; if(fm % fz == 0) ans[cnt][0] = fm / fz, ans[cnt++][1] = i; &#125; printf("%d\n", cnt); for(int i = 0; i &lt; cnt; ++i) printf("1/%d = 1/%d + 1/%d\n", n, ans[i][0], ans[i][1]);&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; solve(); &#125; return 0;&#125; 例7-4 UVa524 Prime Ring Problem题目链接 直接DFS即可。回溯法的入门型题目。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, ring[20];bool isnt[50] = &#123;0&#125;, vis[20] = &#123;0&#125;;void init()&#123; isnt[1] = 1; for(int i = 2; i &lt;= 32; ++i) if(!isnt[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 32; j += i) isnt[j] = 1; &#125;&#125;void dfs(int index, int cur)&#123; ring[cur] = index; if(cur == n)&#123; if(!isnt[ring[1] + index])&#123; for(int i = 1; i &lt; n; ++i) printf("%d ", ring[i]); printf("%d\n", ring[n]); &#125; return ; &#125; vis[index] = 1; for(int i = 2; i &lt;= n; ++i) if(!vis[i] &amp;&amp; !isnt[i + ring[cur]]) dfs(i, cur + 1); vis[index] = 0;&#125;void solve()&#123; dfs(1, 1);&#125;int main()&#123; init(); int T = 1; while(scanf("%d", &amp;n) == 1)&#123; if(T &gt; 1)printf("\n"); printf("Case %d:\n", T); solve(); T++; &#125; return 0;&#125; 例7-6 UVa140 Bandwidth题目链接 枚举全排列，然后模拟即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005];bool mat[50][50], vis[50];int p[10], n, b[10], ansp[10];void init()&#123; memset(mat, 0, sizeof(mat)); memset(vis, 0, sizeof(vis)); for(int i = 0; isalpha(s[i]); ++i)&#123; int cur = s[i++] - 'A'; vis[cur] = 1; for(i++; isalpha(s[i]); ++i)&#123; int to = s[i] - 'A'; mat[cur][to] = mat[to][cur] = 1; vis[to] = 1; &#125; &#125;&#125;void solve()&#123; n = 0; for(int i = 0; i &lt; 26; ++i) if(vis[i]) p[n++] = i; int ans = INF; do&#123; int cur = 0; memset(b, 0, sizeof(b)); for(int i = 0; i &lt; n; ++i)&#123; for(int j = i - 1; j &gt;= 0; --j) if(mat[p[i]][p[j]]) b[i] = max(b[i], i - j); for(int j = i + 1; j &lt; n; ++j) if(mat[p[i]][p[j]]) b[i] = max(b[i], j - i); cur = max(cur, b[i]); if(cur &gt;= ans) break; &#125; if(cur &lt; ans)&#123; memcpy(ansp, p, sizeof(p)); ans = cur; &#125; &#125;while(next_permutation(p, p + n)); for(int i = 0; i &lt; n; ++i) printf("%c ", ansp[i] + 'A'); printf("-&gt; %d\n", ans);&#125;int main()&#123; for(; ; )&#123; scanf("%s", s); if(s[0] == '#')break; init(); solve(); memset(s, 0, sizeof(s)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第六章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter6%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第六章部分习题的整合。 例6-2 UVa514 Rails题目链接 用栈模拟即可。对于要求顺序的第$i$项，只有$2$种可能： 它不在栈里，那么把它前面的全部入栈。 它在栈里，那么除非它在栈顶，不然不可能满足此顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, permu[1005], st[1005], top, in[1005];void solve()&#123; top = 0; memset(in, 0, sizeof(in)); int cur = 1, ans = 1; for(int i = 1; i &lt;= n; ++i)&#123; if(!in[permu[i]])&#123; for(; cur &lt; permu[i]; ++cur) st[top++] = cur, in[cur] = 1; cur++; &#125;else&#123; if(st[top - 1] == permu[i]) top--, in[permu[i]] = 0; else&#123; ans = 0; break; &#125; &#125; &#125; printf("%s\n", ans ? "Yes" : "No");&#125;void init()&#123; for(; ; )&#123; if(permu[1] = read())&#123; for(int i = 2; i &lt;= n; ++i) permu[i] = read(); solve(); &#125;else &#123; printf("\n"); break ; &#125; &#125;&#125;int main()&#123; for(; ; )&#123; n = read(); if(!n)break ; init(); &#125; return 0;&#125; 例6-4 UVa11988 Broken Keyboard (a.k.a. Beiju Text)题目链接 直接用链表模拟即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[5000005];int cur, nxt[5000005], lst;void solve()&#123; cur = lst = 0; nxt[0] = -1; int len = strlen(s + 1); for(int i = 1; i &lt;= len; ++i)&#123; if(s[i] == '[')&#123; cur = 0; &#125;else if(s[i] == ']')&#123; cur = lst; &#125;else&#123; nxt[i] = nxt[cur]; nxt[cur] = i; cur = i; if(nxt[cur] == -1) lst = cur; &#125; &#125; for(int i = nxt[0]; i != -1; i = nxt[i]) putchar(s[i]); putchar('\n');&#125;int main()&#123; while(scanf("%s", s + 1) == 1) solve(); return 0;&#125; 例6-6 UVa679 Dropping Balls题目链接 可以根据奇偶判断一个球在一个节点应该是向左还是向右走，同时算出有多少个球走到了下一个节点。这样的话就可以递归计算。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int d, id, ans;void init()&#123; d = read(), id = read();&#125;void get(int curd, int curi, int curp)&#123; if(curd == d)&#123; ans = curp; return ; &#125; if(curi &amp; 1) get(curd + 1, curi / 2 + 1, curp &lt;&lt; 1); else get(curd + 1, curi / 2, curp &lt;&lt; 1 | 1);&#125;void solve()&#123; get(1, id, 1); printf("%d\n", ans);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; scanf("%d", &amp;T); return 0;&#125; 例6-8 UVa548 Tree题目链接 根据中序遍历和后序遍历构造树即可。细节有一点多。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char s[2000005];int cur, p1[10005], p2[10005], n;int lc[10005], rc[10005], key[10005], mini[10005], ans;int read()&#123; int x = 0; char c = s[cur]; while(c &lt; '0' || c &gt; '9')&#123; if(c == '\n' || c == EOF) return -1; c = s[++cur]; &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = s[++cur]; return x; &#125;void init()&#123; n = 0; for(cur = 0; ; ++n)&#123; p1[n] = read(); if(p1[n] &lt; 0) break; &#125; fgets(s, 2000000, stdin); cur = 0; for(int i = 0; i &lt; n; ++i) p2[i] = read();&#125;int get(int il, int ir, int pl, int pr)&#123; if(ir - il &lt; 0) return 0; int i, id = p2[pr]; for(i = il; i &lt;= ir; ++i) if(p1[i] == id) break; int len = i - il; lc[id] = get(il, i - 1, pl, pl + len - 1); rc[id] = get(i + 1, ir, pl + len, pr - 1); key[id] = id; if(lc[id] &amp;&amp; rc[id])&#123; if(key[lc[id]] &gt; key[rc[id]]) key[id] += key[rc[id]], mini[id] = mini[rc[id]]; else if(key[lc[id]] &lt; key[rc[id]]) key[id] += key[lc[id]], mini[id] = mini[lc[id]]; else key[id] += key[rc[id]], mini[id] = mini[rc[id]], mini[id] = min(mini[lc[id]], mini[rc[id]]); &#125;else if(lc[id]) key[id] += key[lc[id]], mini[id] = mini[lc[id]]; else if(rc[id]) key[id] += key[rc[id]], mini[id] = mini[rc[id]]; else mini[id] = id; return id;&#125;void solve()&#123; int root = get(0, n - 1, 0, n - 1); printf("%d\n", mini[root]);&#125;int main()&#123; while(fgets(s, 2000000, stdin) != NULL)&#123; init(); solve(); &#125; return 0;&#125; 例6-9 UVa839 Not so Mobile题目链接 按照递归顺序生成整个天平即可。例题给出的代码中get函数的返回值是天平是否平衡，这里我稍微做了一些调整。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int ans = 1;int get()&#123; int wl = read(), dl = read(), wr = read(), dr = read(); if(!wl) wl = get(); if(!wr) wr = get(); if(wl * dl != wr * dr) ans = 0; return wl + wr;&#125;void solve()&#123; ans = 1; get(); printf("%s\n", ans ? "YES" : "NO");&#125;int main()&#123; int T = read(); while(T--)&#123; solve(); if(T &gt; 0) printf("\n"); &#125; return 0;&#125; 例6-10 UVa699 The Falling Leaves题目链接 也是利用递归构造出整个树的结构。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int root, lc[100005], rc[100005];int cntl[100005], cntr[100005], maxl, maxr;void build(int id, int pos)&#123; if(pos &gt;= 0) cntr[pos] += id, maxr = max(maxr, pos); else cntl[-pos] += id, maxl = min(maxl, pos); lc[id] = read(); if(lc[id] &gt; 0) build(lc[id], pos - 1); rc[id] = read(); if(rc[id] &gt; 0) build(rc[id], pos + 1);&#125;void solve()&#123; memset(cntl, 0, sizeof(cntl)); memset(cntr, 0, sizeof(cntr)); maxl = maxr = 0; build(root, 0);&#125;int main()&#123; int T = 1; while((root = read()) != -1)&#123; solve(); printf("Case %d:\n", T); for(int i = -maxl; i &gt;= 1; --i) printf("%d ", cntl[i]); for(int i = 0; i &lt; maxr; ++i) printf("%d ", cntr[i]); printf("%d\n\n", cntr[maxr]); T++; &#125; return 0;&#125; 例6-13 UVa1103 Ancient Messages题目链接 搜索联通块即可。这里用了一点技巧：先把所有符号外围的白色填充掉，然后再对符号框架部分搜索。在搜索框架时发现了没有访问过的白色块就说明这个符号有洞，用这种方法统计出洞的个数即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m;int dx[] = &#123;0, 0, 1, -1&#125;, dy[] = &#123;1, -1, 0, 0&#125;, lis[] = &#123;'W', 'A', 'K', 'J', 'S', 'D'&#125;;int dat[205][205], tot, cnt;bool vis[205][205];char ans[1005];void init()&#123; memset(dat, 0, sizeof(dat)); for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; int d; scanf("%1x", &amp;d); if(d &amp; 8)dat[i][j &lt;&lt; 2] = 1; if(d &amp; 4)dat[i][j &lt;&lt; 2 | 1] = 1; if(d &amp; 2)dat[i][j &lt;&lt; 2 | 2] = 1; if(d &amp; 1)dat[i][j &lt;&lt; 2 | 3] = 1; &#125; &#125; m &lt;&lt;= 2;&#125;void dfs(int cx, int cy, int o)&#123;//o代表当前填充的是框架还是白色块 vis[cx][cy] = 1; for(int i = 0; i &lt; 4; ++i)&#123; int ex = cx + dx[i], ey = cy + dy[i]; if(ex &gt;= 0 &amp;&amp; ex &lt; n &amp;&amp; ey &gt;= 0 &amp;&amp; ey &lt; m &amp;&amp; !vis[ex][ey])&#123; if(o)&#123; if(!dat[ex][ey]) dat[ex][ey] = ++tot, dfs(ex, ey, 0); else if(dat[ex][ey] == 1) dfs(ex, ey, 1); &#125;else if(!dat[ex][ey]) dat[ex][ey] = tot, dfs(ex, ey, 0); &#125; &#125;&#125;void solve()&#123; memset(vis, 0, sizeof(vis)); tot = 2, cnt = 0; for(int i = 0; i &lt; n; ++i)&#123; if(!vis[i][0] &amp;&amp; !dat[i][0]) dfs(i, 0, 0); if(!vis[i][m - 1] &amp;&amp; !dat[i][m - 1]) dfs(i, m - 1, 0); &#125; for(int i = 0; i &lt; m; ++i)&#123; if(!vis[0][i] &amp;&amp; !dat[0][i]) dfs(0, i, 0); if(!vis[n - 1][i] &amp;&amp; !dat[n - 1][i]) dfs(n - 1, i, 0); &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; if(!vis[i][j] &amp;&amp; dat[i][j] == 1)&#123; int his = tot; dfs(i, j, 1); ans[cnt++] = lis[tot - his]; &#125; &#125; &#125; sort(ans, ans + cnt); ans[cnt] = '\0'; printf("%s\n", ans);&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), m = read(); if(!n &amp;&amp; !m) break; printf("Case %d: ", T); init(); solve(); &#125; return 0;&#125; 例6-15 UVa10305 Ordering Tasks题目链接 直接拓扑排序即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, du[105];int que[105], f, r, lis[105];bool e[105][105];void init()&#123; memset(du, 0, sizeof(du)); for(int i = 0; i &lt; m; ++i)&#123; int u = read(), v = read(); du[v]++; e[u][v] = 1; &#125;&#125;void solve()&#123; f = r = 0; for(int i = 1; i &lt;= n; ++i) if(!du[i]) que[r++] = i; int cnt = 0; while(r - f)&#123; int cur = que[f++]; lis[cnt++] = cur; for(int i = 1; i &lt;= n; ++i) if(e[cur][i])&#123; du[i]--; if(!du[i]) que[r++] = i; &#125; &#125; for(int i = 0; i &lt; n - 1; ++i) printf("%d ", lis[i]); printf("%d\n", lis[n - 1]); memset(e, 0, sizeof(e));&#125;int main()&#123; for(; ; ) &#123; n = read(), m = read(); if (!n &amp;&amp; !m) break; init(); solve(); &#125; return 0;&#125; 6-1 UVa673 Parentheses Balance题目链接 括号序列的匹配。。用栈模拟即可。我一开始没看清题，以为只要能配对即可，结果疯狂WA。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005];int st[10005], top;void init()&#123; fgets(s, 1000, stdin);&#125;void solve()&#123; int len = strlen(s), flag = 1; top = 0; for(int i = 0; i &lt; len; ++i)&#123; if(s[i] == '(' || s[i] == '[') st[top++] = s[i]; else if(s[i] == ')')&#123; if(top &amp;&amp; st[top - 1] == '(') top--; else&#123; flag = 0; break; &#125; &#125;else if(s[i] == ']')&#123; if(top &amp;&amp; st[top - 1] == '[') top--; else&#123; flag = 0; break; &#125; &#125; &#125; if(top) flag = 0; printf("%s\n", flag ? "Yes" : "No");&#125;int main()&#123; fgets(s, 1000, stdin); int T; sscanf(s, "%d", &amp;T); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 6-3 UVa536 Tree Recovery题目链接 和根据后序和中序求先序一样。只要知道先序的根在开头，后序的根在末尾即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s1[30], s2[30];int root, lc[250], rc[250];int get(int pl, int pr, int il, int ir)&#123; if(ir - il &lt; 0) return 0; int id = s1[pl], i; for(i = il; i &lt;= ir; ++i) if(s2[i] == id) break; int len = i - il; lc[id] = get(pl + 1, pl + len, il, i - 1); rc[id] = get(pl + len + 1, pr, i + 1, ir); return id;&#125;void getP(int id)&#123; if(lc[id]) getP(lc[id]); if(rc[id]) getP(rc[id]); printf("%c", id);&#125;void solve()&#123; int len = strlen(s1); root = get(0, len - 1, 0, len - 1); getP(root); printf("\n");&#125;int main()&#123; while(scanf("%s%s", s1, s2) == 2) solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>链表</tag>
        <tag>树形结构</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第五章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter5%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第五章部分习题的整合。 例5-1 UVa10474 Where is the Marble?题目链接 排序后二分查找即可。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, q, st[10005];void init()&#123; for(int i = 0; i &lt; n; ++i) st[i] = read(); sort(st, st + n);&#125;void solve()&#123; int x; for(int i = 0; i &lt; q; ++i)&#123; x = read(); int index = lower_bound(st, st + n, x) - st; if(st[index] == x) printf("%d found at %d\n", x, index + 1); else printf("%d not found\n", x); &#125;&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), q = read(); if(!n &amp;&amp; !q)break ; printf("CASE# %d:\n", T); init(); solve(); &#125; return 0;&#125; 例5-5 UVa12096 The SetStack Computer题目链接 将集合映射成数，然后进行操作。非常好的练习STL的题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef set&lt;int&gt; Set;map&lt;Set, int&gt; mp;int n, stack[10005], top, tot;Set st[2005];int getID(Set *s)&#123; if(!mp.count(*s))&#123; mp[*s] = tot, tot++; return tot - 1; &#125; return mp[*s];&#125;void push()&#123; stack[top++] = 0;&#125;void dup()&#123; stack[top] = stack[top - 1]; top++;&#125;void _union()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss; set_union(st[xa].begin(), st[xa].end(), st[xb].begin(), st[xb].end(), inserter(ss, ss.begin())); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void _inter()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss; set_intersection(st[xa].begin(), st[xa].end(), st[xb].begin(), st[xb].end(), inserter(ss, ss.begin())); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void add()&#123; int xa, xb, id; xa = stack[--top], xb = stack[--top]; Set ss = st[xb]; ss.insert(xa); id = getID(&amp;ss); st[id] = ss; stack[top++] = id;&#125;void init()&#123; n = read(); top = tot = 1; mp.clear(); Set s; mp[s] = 0, st[0] = s;&#125;void solve()&#123; char opr[12]; for(int i = 0; i &lt; n; ++i)&#123; scanf("%s", opr); if(opr[0] == 'P')push(); if(opr[0] == 'D')dup(); if(opr[0] == 'U')_union(); if(opr[0] == 'I')_inter(); if(opr[0] == 'A')add(); printf("%d\n", st[stack[top - 1]].size()); &#125; printf("***\n");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 例5-7 UVa136 Ugly Numbers题目链接 用一个堆，每次取出最小的丑数，然后生成新的丑数。本题在其他地方有多个变种，故不在此贴出代码。答案：859963392 例5-8 UVa1592 Database题目链接 先对每一个字符串进行处理，将字符串映射为数后枚举c_1,c_2，然后从上到下扫描每一行，对同一行的两个格子打包成一个pair，然后再对pair进行映射，映射为当前的行号。之后即可判断是否有符合条件的r_1,r_2。和集合栈计算机那道题有异曲同工之妙。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#include &lt;string&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m, tab[10005][11];char s[110];map&lt;string, int&gt; mp1;map&lt;pair&lt;int, int&gt;, int&gt; mp2;void init()&#123; mp1.clear(); int tots = 0; for(int i = 0; i &lt; n; ++i)&#123; fgets(s, 99, stdin); int len = strlen(s); for(; isspace(s[len - 1]); --len) s[len - 1] = '\0'; for(int j = 0, k = 0, l = 0; j &lt; len; j = k, ++l)&#123; while(s[j] != ',' &amp;&amp; s[j] != '\0') ++j; s[j] = '\0'; string ss(s + k); if(!mp1.count(ss)) tab[i][l] = mp1[ss] = ++tots; else tab[i][l] = mp1[ss]; k = j + 1; &#125; &#125;&#125;void solve()&#123; int r1, r2, c1, c2; for(int i = 0; i &lt; m - 1; ++i) for(int j = i + 1; j &lt; m; ++j)&#123; mp2.clear(); for(int k = 0; k &lt; n; ++k)&#123; pair&lt;int,int&gt; pp(tab[k][i], tab[k][j]); if(!mp2.count(pp)) mp2[pp] = k + 1; else&#123; r1 = mp2[pp], r2 = k + 1, c1 = i + 1, c2 = j + 1; goto printans; &#125; &#125; &#125; printf("YES\n"); return ; printans: printf("NO\n%d %d\n%d %d\n", r1, r2, c1, c2);&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; m = read(); init(); solve(); &#125; return 0;&#125; 例5-12 UVa221 Urban Elevations题目链接 类似于扫描？对每一个建筑物左右两端的$x$坐标构成的序列排序去重，然后由于每两个$x$坐标之间的建筑物只会有一段，故使用一个数组保存坐标x_i右边这一段的高度。然后对建筑物从前往后（即按照$y$坐标升序）判断是否可见即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;double eps = 1e-5, xx[2005], zz[2005];struct City&#123; double x, y, lx, lz; int id, vis;&#125;;struct cmp&#123; inline bool operator()(const City&amp; c1, const City&amp; c2)&#123; if(c1.y - c2.y &lt; eps &amp;&amp; c1.y - c2.y &gt; -eps)return c1.x &lt; c2.x; return c1.y &lt; c2.y; &#125;&#125;;int n, len;City c[1005];void init()&#123; double tmp; for(int i = 0; i &lt; n; ++i) scanf("%lf%lf%lf%lf%lf", &amp;c[i].x, &amp;c[i].y, &amp;c[i].lx, &amp;tmp, &amp;c[i].lz), c[i].id = i + 1, c[i].vis = 0, xx[i &lt;&lt; 1] = c[i].x, xx[i &lt;&lt; 1 | 1] = c[i].x + c[i].lx; sort(c, c + n, cmp()); sort(xx, xx + n + n); len = unique(xx, xx + n + n) - xx; fill(zz, zz + len, 0.0);&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; int flag = 0, st = lower_bound(xx, xx + len, c[i].x) - xx; for(int j = st; xx[j] &lt; c[i].x + c[i].lx; ++j) if(c[i].lz &gt; zz[j]) flag = 1, zz[j] = c[i].lz; if(flag) c[i].vis = 1; &#125; for(int i = 0; i &lt; n; ++i) swap(c[i].x, c[i].y); sort(c, c + n, cmp()); int f = 0; for(int i = 0; i &lt; n; ++i) if(c[i].vis)&#123; if(f)printf(" "); printf("%d", c[i].id); if(!f)f = 1; &#125; printf("\n");&#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(); if(!n)break ; else if(T &gt; 1)printf("\n"); printf("For map #%d, the visible buildings are numbered as follows:\n", T); init(); solve(); &#125; return 0;&#125; 5-2 UVa1594 Ducci Sequence题目链接直接模拟1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, d[20], dd[20];void init()&#123; n = read();&#125;void solve()&#123; bool ans = 0; for(int i = 0; i &lt; n; ++i) d[i] = read(); for(int i = 0; i &lt; 1001; ++i)&#123; int flag = 1; for(int j = 0; j &lt; n; ++j) if(d[j])&#123; flag = 0; break; &#125; if(flag)&#123; ans = 1; break; &#125;else &#123; for(int j = 0; j &lt; n - 1; ++j) dd[j] = abs(d[j] - d[j + 1]); dd[n - 1] = abs(d[n - 1] - d[0]); memcpy(d, dd, sizeof(d)); &#125; &#125; printf("%s\n", ans ? "ZERO" : "LOOP");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-3 UVa10935 Throwing cards away I题目链接 用队列模拟即可123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, que[505], l, r;void init()&#123; for(int i = 0; i &lt; n; ++i) que[i] = i + 1; l = 0, r = n;&#125;void solve()&#123; printf("Discarded cards:"); while(r - l &gt; 1)&#123; int a = que[l++]; printf(" %d", a); if(r - l &gt;= 2)printf(","); int b = que[l++]; que[r++] = b; &#125; printf("\nRemaining card: %d\n", que[l]);&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125; 5-4 UVa10763 Foreign Exchange题目链接 用multiset模拟即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;pair&lt;int, int&gt; p[500005];multiset&lt;pair&lt;int, int&gt; &gt; s;void init()&#123; for(int i = 0; i &lt; n; i++) p[i].first = read(), p[i].second = read();&#125;void solve()&#123; if(n &amp; 1)printf("NO\n"); else&#123; for(int i = 0; i &lt; n; ++i)&#123; pair&lt;int, int&gt; pp; pp.first = p[i].second, pp.second = p[i].first; if(!s.count(pp)) s.insert(p[i]); else s.erase(s.find(pp)); &#125; if(s.empty())printf("YES\n"); else printf("NO\n"); s.clear(); &#125;&#125;int main()&#123; while(n = read())&#123; init(); solve(); &#125; return 0;&#125; 5-5 UVa10391 Compound Words题目链接 用string类提供的各种方法即可。从每个词开始向下遍历，看看下面的词是不是以自己为前缀。如果不是就停止遍历，如果是那就看以自己为前缀的那个词的后缀是不是一个词（用set判断）。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#include &lt;string&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;string s[120005];bool vis[120005] = &#123;0&#125;;int n;set&lt;string&gt; ss;void init()&#123; n = 0; while(cin &gt;&gt; s[n]) n++, ss.insert(s[n - 1]);&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; if(s[j].find(s[i]) == 0)&#123; string suff(s[j], s[i].length()); if(ss.count(suff)) vis[j] = 1; &#125;else break; &#125; &#125; for(int i = 0; i &lt; n; ++i) if(vis[i])cout &lt;&lt; s[i] &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125; 5-6 UVa1595 Symmetry题目链接 先判断是否有这么一条竖线可以使得点的左右分布对称，再看是不是完全对称。方法很多，我采用了一个比较简单的写法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n;pair&lt;int, int&gt; p[1005];void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) p[i].first = read(), p[i].second = read(); sort(p, p + n);&#125;void solve()&#123; int flag = 1, half; if(n &amp; 1) half = p[n &gt;&gt; 1].first &lt;&lt; 1; else half = p[(n &gt;&gt; 1) - 1].first + p[n &gt;&gt; 1].first ; for(int i = 0; i &lt; (n &gt;&gt; 1); ++i) if(p[n - i - 1].first + p[i].first != half)&#123; flag = 0; break; &#125; if(flag)&#123; for(int i = (n &gt;&gt; 1); i &lt; n; ++i) p[i].second = -p[i].second; sort(p + (n &gt;&gt; 1), p + n); for(int i = (n &gt;&gt; 1); i &lt; n; ++i) if(p[i].second + p[n - i - 1].second != 0 &amp;&amp; p[i].first * 2 != half)&#123; flag = 0; break; &#125; &#125; printf("%s\n", flag ? "YES" : "NO");&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-7 UVa12100 Printer Queue题目链接 用一个队列模拟即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int pcnt[11], n, m;int que[10005][2], l, r;void init()&#123; n = read(), m = read(); memset(pcnt, 0, sizeof(pcnt)); for(int i = 0; i &lt; n; ++i) que[i][1] = i, pcnt[que[i][0] = read()]++; l = 0, r = n;&#125;void solve()&#123; int t; for(t = 1; r &gt; l; t++)&#123; for(; ; )&#123; int cur = que[l][0], flag = 0; for(int i = cur + 1; i &lt; 10; ++i) if(pcnt[i])&#123; flag = 1; break; &#125; if(flag) que[r][0] = cur, que[r++][1] = que[l][1], l++; else break; &#125; if(que[l][1] == m)break; pcnt[que[l][0]]--, l++; &#125; printf("%d\n", t);&#125;int main()&#123; int T = read(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 5-9 UVa1596 Bug Hunt题目链接 很神奇的模拟题。注意细节即可。在bug里找bug其乐无穷12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;char s[1005][85];int line;struct Arr&#123; int size; map&lt;int, int&gt; mp;&#125;;Arr arr[130];int getVal(int id, int st)&#123; if(isalpha(s[id][st + 1]))&#123; int _val = getVal(id, st + 2); char c = s[id][st + 1]; if(_val &lt; 0 || arr[c].size &lt; 0 || _val &gt;= arr[c].size || !arr[c].mp.count(_val)) return -1; else return arr[c].mp[_val]; &#125;else&#123; int x = 0; for(st++; s[id][st] != ']'; ++st) x = x * 10 + s[id][st] - '0'; return x; &#125;&#125;bool getInitalized(int id)&#123; char c = s[id][0]; arr[c].mp.clear(); int val = getVal(id, 1); if(val &lt; 0)return false; arr[c].size = val; //printf("%d\n", val); return true;&#125;void solve()&#123; for(int i = 0; i &lt; 127; ++i) arr[i].size = -1; int ans; for(ans = 0; ans &lt; line; ++ans)&#123; char *sp = strchr(s[ans], '='); if(sp != NULL)&#123; int index = getVal(ans, 1); char c = s[ans][0]; if(index &lt; 0 || arr[c].size &lt; 0 || index &gt;= arr[c].size) break; else&#123; if(isalpha(*(sp + 1)))&#123; char cc = *(sp + 1); int x = getVal(ans, sp - s[ans] + 2); if(x &lt; 0 || arr[cc].size &lt; 0 || x &gt;= arr[cc].size || !arr[cc].mp.count(x)) break; else arr[c].mp[index] = arr[cc].mp[x]; &#125;else&#123; int x = 0; for(int st = sp - s[ans] + 1; isdigit(s[ans][st]); ++st) x = x * 10 + s[ans][st] - '0'; arr[c].mp[index] = x; &#125; &#125; &#125;else&#123; if(!getInitalized(ans)) break ; &#125; &#125; printf("%d\n", ans == line ? 0 : (ans + 1));&#125;int main()&#123; for(; ; )&#123; line = 0; for(; ; )&#123; fgets(s[line], 82, stdin); if(s[line][0] == '.') break; line++; &#125; if(!line)break; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>STL</tag>
        <tag>二分</tag>
        <tag>栈</tag>
        <tag>堆</tag>
        <tag>离散化</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第四章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter4%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第四章部分习题的整合。 例4-2 UVa489 Hangman Judge题目链接 模拟即可。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; #include &lt;math.h&gt; char b1[27]=&#123;0&#125;,n1[100005],n2[100005];int n=-1,solve(),res,lim1,i;int solve()&#123; int chance=6,all=0; lim1=strlen(n1); for(i=0;i&lt;lim1;i++)&#123; if(!b1[n1[i]-'a'])&#123; b1[n1[i]-'a']++;all++; &#125; &#125; lim1=strlen(n2); for(i=0;i&lt;lim1;i++)&#123; if(b1[n2[i]-'a'])&#123; b1[n2[i]-'a']--;all--; if(all==0&amp;&amp;(chance&gt;=0))return 1; &#125; else chance--; &#125; if(chance&lt;0)return -1; if(all&gt;0)return 0;&#125;int main()&#123; for(scanf("%d",&amp;n);n!=-1;n=-1,scanf("%d",&amp;n))&#123; scanf("%s%s",n1,n2); res=solve(); printf("Round %d\n",n); if(res==1)printf("You win.\n"); if(res==0)printf("You chickened out.\n"); if(res==-1)printf("You lose.\n"); memset(b1,0,sizeof(b1)); &#125; return 0; &#125; 例4-3 UVa133 The Dole Queue题目链接 按照题意模拟即可。1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;int p[25], n, k, m;int main()&#123; for(n = 0,scanf("%d%d%d", &amp;n, &amp;k, &amp;m); n != 0; n = 0,scanf("%d%d%d", &amp;n, &amp;k, &amp;m))&#123; for(int i = 1; i &lt;= n; ++i) p[i] = i; for(int l = 0, tmp = n, r = n + 1; tmp; )&#123; int s = k % tmp; if(!s)s = tmp; for(; s; )&#123; ++l; if(l &gt; n)l = 1; if(p[l])s--; &#125; s = m % tmp; if(!s)s = tmp; for(; s; )&#123; --r; if(r &lt; 1)r = n; if(p[r])s--; &#125; if(l != r) printf("%3d%3d", p[l], p[r]), tmp -= 2; else printf("%3d", p[l]), tmp--; p[l] = p[r] = 0; if(tmp)putchar(','); &#125; putchar('\n'); &#125; return 0;&#125; 4-1 UVa1589 Xiangqi题目链接 长的模拟注意当开始就将帅碰头的时候，不能认为黑方必胜。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,bx,by,loc[10][3],puz[15][15];//g 0 c 1 h 2 r 3int dx[]=&#123;-1,0,0,1&#125;,dy[]=&#123;0,1,-1,0&#125;;int ddx[]=&#123;-2,-2,-1,1,-1,1,2,2&#125;,ddy[]=&#123;-1,1,2,2,-2,-2,-1,1&#125;;bool ask(int cx,int cy)&#123; for(int i=0;i&lt;n;i++)&#123; int kx=loc[i][1],ky=loc[i][2]; if(kx==cx&amp;&amp;cy==ky)continue; if(loc[i][0]==0)&#123; int flag=1; if(cy!=ky)continue; for(int j=cx+1;j&lt;kx;j++) if(puz[j][cy])&#123; flag=0;break; &#125; if(flag)return true; &#125;else if(loc[i][0]==1)&#123; int cnt=0; if(cx==kx)&#123; for(int j=min(cy,ky)+1;j&lt;max(cy,ky);j++) if(puz[cx][j])cnt++; &#125;else if(cy==ky)&#123; for(int j=min(cx,kx)+1;j&lt;max(cx,kx);j++) if(puz[j][cy])cnt++; &#125; if(cnt==1)return true; &#125;else if(loc[i][0]==2)&#123; for(int j=0;j&lt;8;j++)&#123; int ccx=kx+ddx[j],ccy=ky+ddy[j]; if(ccx==cx&amp;&amp;ccy==cy&amp;&amp;!puz[kx+dx[j&gt;&gt;1]][ky+dy[j&gt;&gt;1]]) return true; &#125; &#125;else&#123; int flag=1; if(cx==kx)&#123; for(int j=min(cy,ky)+1;j&lt;max(cy,ky);j++) if(puz[cx][j])&#123; flag=0;break; &#125; &#125;else if(cy==ky)&#123; for(int j=min(cx,kx)+1;j&lt;max(cx,kx);j++) if(puz[j][cy])&#123; flag=0;break; &#125; &#125;else flag=0; if(flag)return true; &#125; &#125; return false;&#125;void init()&#123; memset(puz,0,sizeof(puz)); bx=read(),by=read(); char s[3]; for(int i=0;i&lt;n;i++)&#123; scanf("%s%d%d",s,&amp;loc[i][1],&amp;loc[i][2]); if(s[0]=='G')loc[i][0]=0; if(s[0]=='C')loc[i][0]=1; if(s[0]=='H')loc[i][0]=2; if(s[0]=='R')loc[i][0]=3; puz[loc[i][1]][loc[i][2]]=1; &#125;&#125;void solve()&#123; int ans=1; for(int i=0;i&lt;4;i++)&#123; int cx=bx+dx[i],cy=by+dy[i]; if(!cx||cx&gt;3||cy&lt;4||cy&gt;6)continue; puz[cx][cy]=1; if(!ask(cx,cy))&#123; ans=0;break; &#125; puz[cx][cy]=0; &#125; if(!ans)printf("NO\n"); else printf("YES\n");&#125;int main()&#123; while(n=read())&#123; init(); solve(); &#125; return 0;&#125; 4-4 UVa253 Cube painting题目链接 让第一个骰子不断向左/向上翻转，直到所有视图均被翻出位置。若此时所有翻出的可能的视图中没有第二个骰子的视图则认为两个骰子不等价。反之等价。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool vis[1000];char s[15];int h2,k1[]=&#123;4,0,2,3,5,1&#125;,k2[]=&#123;0,2,4,1,3,5&#125;;int cg(char c)&#123; if(c=='r')return 0; if(c=='g')return 1; if(c=='b')return 2;&#125;void dfs(int hs)&#123; int bs[7],hh1=0,hh2=0; for(int i=5;i&gt;=0;i--)bs[i]=hs%3,hs/=3; for(int i=0;i&lt;6;i++)hh1=hh1*3+bs[k1[i]]; for(int i=0;i&lt;6;i++)hh2=hh2*3+bs[k2[i]]; if(!vis[hh1])vis[hh1]=1,dfs(hh1); if(!vis[hh2])vis[hh2]=1,dfs(hh2);&#125;void init()&#123; memset(vis,0,sizeof(vis)); int h1=0;h2=0; for(int i=0;i&lt;6;i++)h1=h1*3+cg(s[i]); for(int i=6;i&lt;12;i++)h2=h2*3+cg(s[i]); vis[h1]=1; dfs(h1);&#125;void solve()&#123; if(vis[h2])printf("TRUE\n"); else printf("FALSE\n");&#125;int main()&#123; while(scanf("%s",s)==1)&#123; init(); solve(); &#125; return 0;&#125; 4-5 UVa1590 IP Networks题目链接 模拟即可熟悉位运算的好题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;typedef unsigned int u_int;u_int ip[1005] = &#123;0&#125;;int m;void init()&#123; memset(ip, 0, sizeof(ip)); for(int i = 0; i &lt; m; ++i) for(int j = 3; j &gt;= 0; --j)&#123; u_int t = read(); ip[i] += (t &lt;&lt; (j * 8)); &#125;&#125;void solve()&#123; int n = 0, i; for(; n &lt;= 31; ++n)&#123; u_int pp = ~((1 &lt;&lt; n) - 1); for(i = 1; i &lt; m; ++i) if((pp &amp; ip[i]) != (pp &amp; ip[i - 1]))break ; if(i == m)break ; &#125; u_int ans = ~((1 &lt;&lt; n) - 1), t = 0xff000000; ip[0] &amp;= ans; for(int j = 3; j &gt;= 0; --j) printf("%u%s", (ip[0] &amp; t) &gt;&gt; (j * 8), j ? "." : "\n"), t &gt;&gt;= 8; t = 0xff000000; for(int j = 3; j &gt;= 0; --j) printf("%u%s", (ans &amp; t) &gt;&gt; (j * 8), j ? "." : "\n"), t &gt;&gt;= 8;&#125;int main()&#123; while(scanf("%d", &amp;m) == 1)&#123; init(); solve(); &#125; return 0;&#125; 4-7 UVa509 RAID!题目链接 模拟…即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int d, s, b, val, seq[100005];char data[7][6500];void init()&#123; char ord[3]; s = read(), b = read(); scanf("%s", ord); val = (ord[0] == 'E' ? 0 : 1); for(int i = 0; i &lt; d; ++i) scanf("%s", data[i]);&#125;void solve()&#123; int cur = 0, tot = 0; for(int i = 0; i &lt; b; ++i)&#123; for(int j = 0; j &lt; s; ++j)&#123; //当前的校验块在磁盘号为cur int c = 0, cnt = 0, id; for(int k = 0; k &lt; d; ++k)&#123; if(data[k][i * s + j] == 'x') cnt++, id = k;//坏的在id处 else c ^= (data[k][i * s + j] - '0'); &#125; if(cnt &gt;= 2) goto failed; else if(cnt == 1) data[id][i * s + j] = (c ^ val) + '0'; else&#123; if(c != val)//校验错误 goto failed; &#125; &#125; for(int j = 0; j &lt; d; ++j)&#123; if(j == cur)continue ; for(int k = 0; k &lt; s; ++k)&#123; if(data[j][i * s + k] - '0') seq[tot &gt;&gt; 2] += (1 &lt;&lt; (3 - (tot % 4))); tot++; &#125; &#125; cur = (cur + 1) % d; &#125; printf("valid, contents are: "); while(tot % 4)tot++; tot &gt;&gt;= 2; for(int i = 0; i &lt; tot; ++i)&#123; if(seq[i] &lt; 10)printf("%d", seq[i]); else putchar(seq[i] - 10 + 'A'); &#125; printf("\n"); return ; failed: printf("invalid.\n");&#125;int main()&#123; for(int T = 1; ; ++T)&#123; d = read(); if(!d)break ; printf("Disk set %d is ", T); init(); solve(); memset(seq, 0, sizeof(seq)); &#125; return 0;&#125; 4-9 Uva1591 Data Mining（待补充） 4-10 UVa815 Flooded!题目链接 先对高度排一个序，然后从最下方向上面淹即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, m;double h[905], V;void init()&#123; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) h[i * m + j] = read(); V = read(), V /= 100.0; sort(h, h + n * m); h[n * m] = 100000000;&#125;void solve()&#123; double tot = 0.0, ans1, ans2; int i; for(i = 1; i &lt;= n * m; ++i)&#123; tot += h[i - 1]; if(V &lt; i * h[i] - tot) break; &#125; ans1 = (V + tot) / (double)i, ans2 = 100.0 * i / (n * m); printf("Water level is %.2lf meters.\n%.2lf percent of the region is under water.\n\n", ans1, ans2); &#125;int main()&#123; for(int T = 1; ; ++T)&#123; n = read(), m = read(); if(!n &amp;&amp; !m)break ; printf("Region %d\n", T); init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书习题 第三章]]></title>
    <url>%2F2018%2F08%2F20%2Faoapc-chapter3%2F</url>
    <content type="text"><![CDATA[我自己做的紫书第三章部分习题的整合。 例3-1 TEX Quotes题目链接 简单模拟123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void init()&#123; &#125;void solve()&#123; char c; int flag=0; while((c=getchar())!=EOF)&#123; if(c!='"')putchar(c); else&#123; if(flag)putchar('\''),putchar('\''),flag=0; else putchar('`'),putchar('`'),flag=1; &#125; &#125;&#125;int main()&#123;、 init(); solve(); return 0;&#125; 例3-2 UVa10082 WERTYU题目链接 模拟12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[]="`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./'";void init()&#123; &#125;void solve()&#123; char c; while((c=getchar())!=EOF)&#123; int ind; if(isspace(c))putchar(c); else&#123; for(ind=0;s[ind]!=c;ind++); putchar(s[ind-1]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-3 UVa401 Palindromes题目链接 常量数组技巧！123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char rev_al[]="A 3 HIL JM O 2TUVWXY5",rev_num[]="1SE Z 8 ";char ask(char c)&#123; if(isalpha(c))return rev_al[c-'A']; if(isdigit(c))return rev_num[c-'1'];&#125;void init()&#123; &#125;void solve()&#123; char s[30]; while(scanf("%s",s)==1)&#123; int len=strlen(s),f1=1,f2=1; for(int i=0;i&lt;(len+1)/2;i++) if(s[i]!=s[len-i-1])&#123;f1=0;break;&#125; for(int i=0;i&lt;(len+1)/2;i++) if(s[len-i-1]!=ask(s[i]))&#123;f2=0;break;&#125; if(f1&amp;&amp;f2)printf("%s -- is a mirrored palindrome.\n",s); if((!f1)&amp;&amp;f2)printf("%s -- is a mirrored string.\n",s); if(f1&amp;&amp;(!f2))printf("%s -- is a regular palindrome.\n",s); if((!f1)&amp;&amp;(!f2))printf("%s -- is not a palindrome.\n",s); putchar('\n'); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-4 UVa340 Master-Mind Hints题目链接 模拟123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,numa[1005],numb[1005],co[10],ca[10],cb[10];void init()&#123; memset(co,0,sizeof(co)); for(int i=0;i&lt;n;i++) numa[i]=read(),co[numa[i]]++;&#125;void solve()&#123; for(;;)&#123; memset(cb,0,sizeof(cb)); memcpy(ca,co,sizeof(co)); int ans1=0,ans2=0; for(int i=0;i&lt;n;i++)&#123; numb[i]=read(),cb[numb[i]]++; if(numa[i]==numb[i])ans1++,ca[numa[i]]--,cb[numb[i]]--; &#125; if(!numb[0])break; for(int i=1;i&lt;=9;i++) ans2+=min(ca[i],cb[i]); printf(" (%d,%d)\n",ans1,ans2); &#125;&#125;int main()&#123; for(int T=1;;T++)&#123; n=read(); if(!n)break; printf("Game %d:\n",T); init(); solve(); &#125; return 0;&#125; 例3-5 UVa1583 Digit Generator题目链接 模拟123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int tab[100005]=&#123;0&#125;;void init()&#123; for(int i=1;i&lt;=100000;i++)&#123; int tmp=i,tot=i; while(tmp)tot+=tmp%10,tmp/=10; if(tot&lt;=100000&amp;&amp;!tab[tot])tab[tot]=i; &#125;&#125;void solve()&#123; for(int n=read();n;n--)printf("%d\n",tab[read()]);&#125;int main()&#123; init(); solve(); return 0;&#125; 例3-6 UVa1584 Circular Sequence题目链接 模拟12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[1005];int len;void init()&#123; scanf("%s",s); len=strlen(s),memcpy(s+len,s,sizeof(char)*len);&#125;void solve()&#123; int ans=0; for(int t=1;t&lt;len;t++)&#123; int flag=1; for(int j=0;j&lt;len;j++) if(s[t+j]&lt;s[ans+j])&#123;flag=0;break;&#125; else if(s[t+j]&gt;s[ans+j])break; if(!flag)ans=t; &#125; for(int i=0;i&lt;len;i++) putchar(s[i+ans]); putchar('\n');&#125;int main()&#123; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-1 UVa1585 Score题目链接 模拟123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[100];void init()&#123; scanf("%s",s);&#125;void solve()&#123; int len=strlen(s),tot=0,sc=0; for(int i=0;i&lt;len;i++)&#123; if(s[i]=='O')tot++,sc+=tot; else tot=0; &#125; printf("%d\n",sc);&#125;int main()&#123; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-2 UVa1586 Score题目链接 模拟123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[100];double mass[26];void init()&#123; scanf("%s",s);&#125;void solve()&#123; double ans=0.0; int len=strlen(s),tot=0,ind=0; for(int i=0;i&lt;len;i++)&#123; if(isalpha(s[i]))&#123; if(ind&amp;&amp;!tot)tot=1; ans+=tot*mass[ind],tot=0,ind=s[i]-'A'; &#125;else tot=tot*10+s[i]-'0'; &#125; if(ind&amp;&amp;!tot)tot=1; ans+=tot*mass[ind]; printf("%.3lf\n",ans);&#125;int main()&#123; mass[0]=0; mass[2]=12.010,mass[7]=1.008,mass[14]=16.000,mass[13]=14.010; for(int T=read();T;T--)&#123; init(); solve(); &#125; return 0;&#125; 3-3 UVa1225 Digit Counting题目链接 模拟1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int T,tab[10005]=&#123;0&#125;,ans[22][11],cnt[11]=&#123;0&#125;,maxn=0;void init()&#123; T=read(); for(int i=0;i&lt;T;i++)&#123; int t=read(); tab[t]=i+1,maxn=max(maxn,t); &#125;&#125;void solve()&#123; for(int i=1;i&lt;=maxn;i++)&#123; int tmp=i; while(tmp)cnt[tmp%10]++,tmp/=10; if(tab[i])&#123; int ind=tab[i]; for(int j=0;j&lt;10;j++)ans[ind][j]=cnt[j]; &#125; &#125; for(int i=1;i&lt;=T;i++)&#123; for(int j=0;j&lt;9;j++)printf("%d ",ans[i][j]); printf("%d\n",ans[i][9]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125; 3-4 UVA455 Periodic Strings题目链接 这题有多种做法，这里选的是最容易想到的一种。123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[1005];int main()&#123; int N=read(),flag=0; while(N--)&#123; scanf("%s",s); int len=strlen(s),ans=len; for(int i=1;i&lt;len;i++) if(len%i==0)&#123; int fl=1; for(int j=i;j&lt;len;j++) if(s[j]!=s[j%i])&#123;fl=0;break;&#125; if(fl)&#123;ans=i;break;&#125; &#125; if(!flag)flag=1; else putchar('\n'); printf("%d\n",ans); &#125;; return 0;&#125; 3-5 UVa227 Puzzle题目链接 这题神坑 有可能拼图里面有字母Z 最后一行的空行不能有，不然无限WA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char puz[7][7],list[100005],tmp[100005];int len,x,y;bool readPuzzle()&#123; char c[10]; for(int i=0;i&lt;5;i++)&#123; fgets(c,10,stdin); if(c[0]=='Z'&amp;&amp;strlen(c)&lt;5)return false; for(int j=0;j&lt;5;j++) if(isalpha(c[j]))puz[i][j]=c[j]; else if(c[j]==' ')puz[(x=i)][(y=j)]=c[j]; &#125; return true;&#125;bool move(int id)&#123; if(list[id]=='A')&#123; if(!x)return false; swap(puz[x-1][y],puz[x][y]),x--; return true; &#125; if(list[id]=='B')&#123; if(x==4)return false; swap(puz[x+1][y],puz[x][y]),x++; return true; &#125; if(list[id]=='L')&#123; if(!y)return false; swap(puz[x][y],puz[x][y-1]),y--; return true; &#125; if(list[id]=='R')&#123; if(y==4)return false; swap(puz[x][y+1],puz[x][y]),y++; return true; &#125; return false;&#125;void solve()&#123; int flag=1; for(int _flag=1;_flag;)&#123; fgets(list,100000,stdin); int len=strlen(list); for(int i=0;i&lt;len;i++)&#123; //printf("%c",list[i]); if(isalpha(list[i]))&#123; if(!move(i)&amp;&amp;flag)&#123; printf("This puzzle has no final configuration.\n"); flag=0; &#125; &#125;else if(list[i]=='0')&#123; _flag=0; break; &#125;else if(!isspace(list[i]))&#123; if(flag) printf("This puzzle has no final configuration.\n"),flag=0; &#125; &#125; &#125; if(flag)&#123; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;4;j++) printf("%c ",puz[i][j]); printf("%c\n",puz[i][4]); &#125; &#125;&#125;int main()&#123; int T=1; while(readPuzzle())&#123; if(T!=1)putchar('\n'); printf("Puzzle #%d:\n",T++); solve(); memset(puz,0,sizeof(puz)); &#125; return 0;&#125; 3-8 UVa202 Repeating Decimals题目链接 模拟只要除出来了一样的余数就停止因为除数不是很大，所以余数不算多，可以完成12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int m,n,vis[3005]=&#123;0&#125;,lis[3105];void init()&#123; printf("%d/%d = %d.",m,n,m/n); m%=n;&#125;void solve()&#123; int ans=1,pace=1; memset(vis,0,sizeof(vis)); for(;m;pace++)&#123; if(vis[m])break; vis[m]=pace,m*=10; lis[pace]=m/n,m%=n; &#125; if(!m)&#123; for(int i=1;i&lt;pace;i++) printf("%d",lis[i]); printf("(0)\n"); &#125;else &#123; for(int i=1;i&lt;vis[m];i++) printf("%d",lis[i]); printf("("); if(pace&lt;=50)&#123; for(int i=vis[m];i&lt;pace;i++) printf("%d",lis[i]); printf(")\n"); &#125;else&#123; for(int i=vis[m];i&lt;=50;i++) printf("%d",lis[i]); printf("...)\n"); &#125; ans=pace-vis[m]; &#125; printf(" %d = number of digits in repeating cycle\n\n",ans);&#125;int main()&#123; while(scanf("%d%d",&amp;m,&amp;n)==2)&#123; init(); solve(); &#125; return 0;&#125; 3-10 UVa1587 Box题目链接保证构成一个长方体需要： 有3组相同的面 有3组长宽高 判断即可。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;pair&lt;int,int&gt; p[7];int a[19];void init()&#123; for(int i=1;i&lt;6;i++) scanf("%d%d",&amp;p[i].first,&amp;p[i].second); for(int i=0;i&lt;6;i++)&#123; if(p[i].first&lt;p[i].second) swap(p[i].first,p[i].second); a[i&lt;&lt;1]=p[i].first,a[i&lt;&lt;1|1]=p[i].second; &#125; sort(a,a+12); sort(p,p+6);&#125;void solve()&#123; int ans=1; for(int i=0;i&lt;6;i+=2) if(p[i].first!=p[i+1].first||p[i].second!=p[i+1].second)&#123; ans=0;break; &#125; for(int i=0;i&lt;12;i+=4) if(a[i]!=a[i+1]||a[i]!=a[i+2]||a[i]!=a[i+3])&#123; ans=0;break; &#125; if(!ans)printf("IM"); printf("POSSIBLE\n");&#125;int main()&#123; while(scanf("%d%d",&amp;p[0].first,&amp;p[0].second)==2)&#123; init(); solve(); &#125; return 0;&#125; 3-12 UVa11809 Floating-Point Numbers题目链接 数字都很大，用数字的对数比较。事先对不同M和E打个表，然后比即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;double tab[11][50],eps=1e-6;//M Evoid init()&#123; double t=0.5,u=0.5; for(int i=0;i&lt;=9;i++)&#123; for(int j=1;j&lt;=30;j++)&#123; double k=(double)((1&lt;&lt;j)-1); tab[i][j]=k*log(2.0)+log(t); &#125; u*=0.5,t+=u; &#125;&#125;void solve()&#123; char s[50]; while(scanf("%s",s)==1)&#123; if(strlen(s)==3)break; s[17]=' '; double t,u,g; sscanf(s,"%lf%lf",&amp;t,&amp;u); g=u*log(10.0)+log(t); for(int i=0;i&lt;=9;i++) for(int j=1;j&lt;=30;j++) if(g-tab[i][j]&lt;eps&amp;&amp;g-tab[i][j]&gt;-eps)&#123; printf("%d %d\n",i,j); break; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fwriting%2Fnoip2017%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2017十道题目的题解。 提高D1T1 小凯的疑惑题目链接 和USACO上的麦香牛块差不多，套上公式即可。最大的数即为$ab-a-b$。12345678910111213141516#include &lt;iostream&gt;#define INF 2000000000using namespace std;typedef unsigned long long ll;ll s, t;void init()&#123; cin &gt;&gt; s &gt;&gt; t;&#125;void solve()&#123; cout &lt;&lt; s * t - s - t &lt;&lt; endl;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2009%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2009八道题目的题解。 普及T1 多项式输出题目地址 只要读懂了题就不难了。模拟即可，代码可能有点长。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int n,xs;int main()&#123; scanf("%d",&amp;n); for(int i=n;i&gt;=0;i--)&#123; scanf("%d",&amp;xs); if(xs!=0)&#123; if(i==n)&#123; if(abs(xs)==1)&#123; if(xs==-1)putchar('-'); &#125;else printf("%d",xs); &#125;else if(i==1)&#123; if(xs==1)printf("+x"); else if(xs==-1)printf("-x"); else printf("%+dx",xs); continue; &#125;else if(i==0)&#123; printf("%+d",xs); break; &#125;else &#123; if(xs==1)printf("+"); else if(xs==-1)printf("-"); else printf("%+d",xs); &#125; printf("x^%d",i); &#125; &#125; printf("\n"); return 0;&#125; 普及T2 分数线划定题目地址 根据题目描述来模拟和排序即可。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[10005];bool cmp(const P &amp;pa,const P &amp;pb)&#123; return pa.first&gt;pb.first||(pa.first==pb.first&amp;&amp;pa.second&lt;pb.second);&#125;int n,m,lim;int main()&#123; scanf("%d%d",&amp;n,&amp;m); lim=m*150/100; for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;p[i].second,&amp;p[i].first); sort(p,p+n,cmp); int sc=p[lim-1].first,extra=0; for(int i=lim;i&lt;n;i++) if(p[i].first==sc)extra++; else break; printf("%d %d\n",sc,lim+extra); for(int i=0;i&lt;lim+extra;i++) printf("%d %d\n",p[i].second,p[i].first); return 0; &#125; 普及T3 细胞分裂题目地址 题意：找出某一个数$S_i$，使得$\mathcal S_i^T=M={m_1}^{m_2}$，且$T$最小。考虑$S_i$的唯一分解，只要使得每一个质因数对应的次数都能超过$M$的唯一分解中这个质因数对应的次数即可。这样就可以算出对应的时间$T$来。由于一个数的质因数个数大约是$O(logn)$级别的，使用以上算法的时间复杂度约为$O(nlogm_1)$。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll m1,m2,ans=-1,lis[10][2],a,tot,p,k;int n,t=0;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;m1,&amp;m2); ll e=m1; for(ll b=2;b&lt;=m1;b++) if(e%b==0)&#123; lis[t++][0]=b,lis[t-1][1]=0; while(e%b==0) lis[t-1][1]++,e/=b; lis[t-1][1]*=m2; &#125; for(int i=0;i&lt;n;i++)&#123; tot=0; scanf("%lld",&amp;a); int j; for(j=0;j&lt;t;j++) if(a%lis[j][0]==0)&#123; p=0; while(a%lis[j][0]==0) p++,a/=lis[j][0]; k=lis[j][1]/p; if(lis[j][1]%p)k++;tot=max(tot,k); &#125;else break; if(j!=t)continue; ans=(ans&lt;0)?tot:(ans&gt;tot?tot:ans); &#125; printf("%lld\n",ans); return 0; &#125; 普及T4 道路游戏题目地址 方法一这是一道比较难的DP。状态的表示比较难想，我个人一开始给出的转移方程是：设$f(i,j,k)$表示当前在$i$工厂，$j$时间，$k$状态时的最大金币量，其中$k=0$表示当前机器人刚刚走出了第一步，$k=1$表示当前机器人走出了$2$到$p$步，并且已经被回收。这样状态转移方程就很好写，$f(i,j,0)$就从上一秒的$f(i-1,j-1,1)$里面找最大值，$f(i,j,1)$就枚举一下步数。这么做的时间复杂度是$O(nmp)$的。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005][1005][2]=&#123;0&#125;,m[1005][1005],n,t,p,cost[1005];int deque[4005][2],f=0,r=0,R;void in(int o,int at)&#123; while(r&gt;f&amp;&amp;o&gt;deque[r-1][0]) r--; deque[r][0]=o,deque[r++][1]=at;&#125;int out(int at)&#123; if(deque[f][1]==(at+R-p)%n) f++; return deque[f][0];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;t,&amp;p); int i,j,m2=0,m3=0,k,l,ans=0,sum; R=1000*n; for(i=0;i&lt;n;i++) for(j=0;j&lt;t;j++) scanf("%d",&amp;m[i][j]); for(i=0;i&lt;n;i++) scanf("%d",&amp;cost[i]); for(i=1;i&lt;=t;i++)&#123;//[f,r] for(j=0;j&lt;n;j++)&#123; dp[i][j][1]=m2; if(!j)dp[i][j][1]+=m[n-1][i-1]-cost[n-1]; else dp[i][j][1]+=m[j-1][i-1]-cost[j-1]; for(k=(j-1+n)%n,l=1,sum=0;l&lt;p;l++,k=(k-1+n)%n) if(i-l&gt;0) sum+=m[k][i-l], dp[i][j][0]=max(dp[i][j][0],dp[i-l][k][1]+sum); else break; m3=max(m3,max(dp[i][j][0],dp[i][j][1])); &#125; m2=m3,m3=0; &#125; for(i=0;i&lt;n;i++) ans=max(ans,max(dp[t][i][0],dp[t][i][1])); printf("%d\n",ans); return 0;&#125; 但是居然过了！我就没留意这道题了（其实我都写了单调队列但没用上）今天想了一下，发现没必要那么麻烦，很多地方可以优化。 方法二设$f(i,j)$为机器人走到$i$工厂，$j$时间所能收集的最大金币量。那么 f(i,j)=\max \limits_{i\le k \le p} \left\{ \max \limits_{1\le s\le n}\left\{f(s,j-k) \right\} +sum(i-1,j)-sum(i-k-1,j-k)-cost[i-k]\right\}其中 sum(i,j)=sum(i-1,j-1)+coin[i][j]那么提出$sum(i,j)$就可以发现括号里的量只与$k$有关，就用单调队列。而$sum$是可以前后递推出来的。所以，解决本题的时间复杂度就优化为了$O(nm)$。其实你如果读上面的题解读得仔细的话就会发现我没有讲到一个东西，那就是单调队列该怎么用。本题的优化方式十分特殊，由于$sum$是斜方格形进行求和的（$i-k,j-k \rightarrow i,j$），所以单调队列的下标也要随着$i$改变而改变。具体可以看代码。 完了么？没有。很多题解都会被洛谷上的Extra Test卡掉，虽然我也不知道这数据怎么出的但反正很厉害。（提示：其实读懂了题就不会被坑）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,p,coin[2005][1005],sum[1005][1005],cost[2005];int Deque[1005][1005][2],f[1005],r[1005],maxi[1005];int dp[1005][1005];void init()&#123; n=read(),m=read(),p=read(); for(int i=0;i&lt;n;i++) for(int j=1;j&lt;=m;j++) coin[i][j]=coin[i+n][j]=read(); for(int i=0;i&lt;n;i++)cost[i]=cost[i+n]=read();&#125;void inque(int x,int val,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;val&gt;Deque[x][r[x]-1][0])r[x]--; Deque[x][r[x]][0]=val,Deque[x][r[x]++][1]=k;&#125;int outque(int x,int k)&#123; while(r[x]&gt;f[x]&amp;&amp;k-Deque[x][f[x]][1]&gt;p)f[x]++; return Deque[x][f[x]][0];&#125;void solve()&#123; for(int i=0;i&lt;n;i++)inque(i,-cost[i],0); int R=1000*n; //R：当前单调队列的偏移量 for(int j=1;j&lt;=m;j++)&#123; R--; sum[n-1][j]=sum[n-2][j-1]+coin[n-1][j]; sum[0][j]=sum[n-1][j-1]+coin[0][j]; dp[0][j]=outque(R%n,j)+sum[n-1][j]; maxi[j]=dp[0][j]; for(int i=1;i&lt;n;i++)&#123; sum[i][j]=sum[i-1][j-1]+coin[i][j]; dp[i][j]=outque((i+R)%n,j)+sum[i-1][j]; maxi[j]=max(maxi[j],dp[i][j]); &#125; inque(R%n,maxi[j]-cost[0]-sum[n-1][j],j); for(int i=1;i&lt;n;i++) inque((i+R)%n,maxi[j]-cost[i]-sum[i-1][j],j); &#125; //以上把0单独处理了 printf("%d\n",maxi[m]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 潜伏者题目地址 稍微麻烦的模拟。只要注意及时停止即可。12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;char f[27],sec[105],ori[105],s[105];int flag=1,vis[27];int main()&#123; scanf("%s%s%s",sec,ori,s); int l1=strlen(sec),l2=strlen(s); if(l1&lt;26)&#123; flag=0;goto end; &#125;//不够26个字母 for(int i=0;i&lt;l1;i++)&#123; if(f[sec[i]-'A']&amp;&amp;ori[i]!=f[sec[i]-'A'])&#123; flag=0;goto end; &#125;//没对上 f[sec[i]-'A']=ori[i],vis[sec[i]-'A']=1; &#125; for(int i=0;i&lt;26;i++) if(!vis[i]||!f[i])&#123; flag=0;goto end; &#125;//禁止没有得对 for(int i=0;i&lt;26;i++)vis[f[i]-'A']++; for(int i=0;i&lt;26;i++) if(vis[i]&gt;2)&#123; flag=0;goto end; &#125;//禁止一对多 end: if(!flag)printf("Failed\n"); else &#123; for(int i=0;i&lt;l2;i++) printf("%c",f[s[i]-'A']); printf("\n"); &#125; return 0;&#125; 提高T2 Hankson的趣味题题目地址 一道奇怪的数学题。（理论上这题爆搜比正解快，数据好像不是很好）考虑唯一分解和$GCD$，$LCM$的关系。设对于一个质数$p$，其为b_1的一个因数。那么：设k_{a_0},k_{a_1},k_{b_0},k_{b_1},k_x为a_0,a_1,b_0,b_1,x中$p$的次数。则：因为k_{a_1}=\min\{k_{a_0},k_x\},k_{b_1}=\max\{k_{b_0},k_x\}，若k_{a_0}>k_{a_1}那么k_x=k_{a_1}；若k_{a_0}=k_{a_1}，那么k_x\ge k_{a_1}.若k_{b_0}]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>数论</tag>
        <tag>其他DP</tag>
        <tag>单调队列</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2010 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2010%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2010八道题目的题解。 普及T1 数字统计题目地址 某一道普及的弱化版。模拟即可。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int l,r,ans=0;int main()&#123; scanf("%d%d",&amp;l,&amp;r); for(int i=l;i&lt;=r;i++)&#123; int t=i; while(t)ans+=(t%10==2),t/=10; &#125; printf("%d\n",ans); return 0;&#125; 普及T2 接水问题题目地址 模拟即可。可以用堆加速，但我的代码里没用。不用堆的时间复杂度是$O(nm)$，用的话是$O(nlogm)$。12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int n,m,at[105],w[10005],f=0,ans=0; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d",&amp;at[i]); for(int i=m;i&lt;n;i++) scanf("%d",&amp;w[i-m]); for(;;)&#123; int mini=INF; for(int i=0;i&lt;m;i++) if(at[i]&gt;0&amp;&amp;at[i]&lt;mini)mini=at[i]; if(mini==INF)break; ans+=mini; for(int i=0;i&lt;m;i++) if(at[i]&gt;0)&#123; at[i]-=mini; if(!at[i])&#123; if(f!=n-m)at[i]=w[f++]; else at[i]=-1; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 普及T3 导弹拦截题目地址 此题致敬了11年前的那道经典题目。我们希望这个工作半径最小，直觉上就要让这两个系统都被充分利用。也就是让第一套拦截一部分，第二套拦截另一部分。我们先对所有导弹到第一套系统的距离从近到远排一个序，企图把这个序列切成$2$份，将前半部分给第一个系统，将后半部分（远的）给第二个系统。枚举切开的部位，找到第二套系统应该有的工作半径，也就是分配给第二套系统的最远导弹到他的距离。这里用各种方法实现，我用的是对所有导弹到第二套系统的距离从远到近排一个序，然后用一个指针扫的方法。综上，解决本题的时间复杂度为$O(nlogn)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int id,dis;&#125;Mis;Mis mis[200005];bool operator&lt;(Mis a,Mis b)&#123;return a.dis&lt;b.dis;&#125;int p1[2],p2[2],n,at;//p1 x p2 ybool vis[100005]=&#123;0&#125;;int ask()&#123;//找第二套应该有的工作半径 while(vis[mis[at].id]&amp;&amp;at&lt;2*n) at++; if(at==2*n)return 0; else return mis[at].dis;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;p1[0],&amp;p2[0],&amp;p1[1],&amp;p2[1],&amp;n); int i,j,l1,l2,ans=2000000000; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;l1,&amp;l2), mis[i].dis=(p1[0]-l1)*(p1[0]-l1)+ (p2[0]-l2)*(p2[0]-l2), mis[i+n].dis=-(p1[1]-l1)*(p1[1]-l1)- (p2[1]-l2)*(p2[1]-l2), mis[i].id=mis[i+n].id=i; sort(mis,mis+n), sort(mis+n,mis+n+n), at=n; ans=min(ans,-ask());//全部分配给第二套 for(i=0;i&lt;n;i++) vis[mis[i].id]=1, ans=min(ans,(mis[i].dis-ask())); printf("%d\n",ans); return 0;&#125; 普及T4 三国游戏题目地址 这个人肯定不会输给电脑。因为计算机的选将是完全根据这个人的选法来的，也就是说，这个人自己是一定有把握选中更好的策略的。然后具体选法，非常简单：最大的一定被拆，所以我们矮子里拔高个儿，选默契值排第二且是所有第二中最高的一对将。这样就做完了。时间复杂度：$O(n^2)$。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,mat[505][505]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) scanf("%d",&amp;mat[i][j]), mat[j][i]=mat[i][j];&#125;void solve()&#123; int max1=0,max2=0,ans=0; for(int i=0;i&lt;n;i++)&#123; max1=max2=0; for(int j=0;j&lt;n;j++)&#123; if(mat[i][j]&gt;max1)max2=max1,max1=mat[i][j]; else if(mat[i][j]&gt;max2)max2=mat[i][j]; &#125; ans=max(ans,max2); &#125; printf("1\n%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T1 机器翻译题目地址 用队列模拟即可。12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool vis[1005];int w,m,n,que[100005],f=0,r=0;void init()&#123; m=read(),n=read();&#125;void solve()&#123; int ans=0; while(n--)&#123; w=read(); if(!vis[w])&#123; vis[w]=1,que[r++]=w,ans++; if(r-f==m+1)vis[que[f++]]=0; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高T2 乌龟棋题目地址 按卡片数$DP$即可。只要知道每一种卡片的使用情况就可以推知当前所处位置，从而进行状态转移。设$f(i,j,k,l)$表示用了$i$张$1$，$j$张$2$，$k$张$3$，$l$张$4$的最大得分，则状态转移方程容易导出。1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define dis(a,b,c,d) score[1+a+(b&lt;&lt;1)+(d&lt;&lt;2)+(c&lt;&lt;2)-c]#define fep(a,b) for(a=0;a&lt;=cnt[b];a++)using namespace std;int dp[41][41][41][41]=&#123;0&#125;,n,m,cnt[4]=&#123;0&#125;,score[353];int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v,d; for(i=1;i&lt;=n;i++) scanf("%d",&amp;score[i]); for(i=0;i&lt;m;i++) scanf("%d",&amp;j),cnt[j-1]++; dp[0][0][0][0]=score[1]; fep(i,0)fep(j,1)fep(u,2)fep(v,3)&#123; d=dis(i,j,u,v); if(i)dp[i][j][u][v]=max(dp[i-1][j][u][v]+d,dp[i][j][u][v]); if(j)dp[i][j][u][v]=max(dp[i][j-1][u][v]+d,dp[i][j][u][v]); if(u)dp[i][j][u][v]=max(dp[i][j][u-1][v]+d,dp[i][j][u][v]); if(v)dp[i][j][u][v]=max(dp[i][j][u][v-1]+d,dp[i][j][u][v]); &#125; printf("%d\n",dp[cnt[0]][cnt[1]][cnt[2]][cnt[3]]); return 0;&#125; 提高T3 关押罪犯（待考察）题目地址 贪心。将仇恨值从大到小排序，从仇恨最大的一对人开始处理起。记录每一个人的“对手”，看作是这个人和“对手”必须处在不同监狱。如果两人所处监狱相同那就表示分配到此为止，输出答案。然后分类讨论，假设两人都还没有对手就互相记为对手，表示两人不会在一个监狱；只有一个人有对手，那就另一个人把这个人记为对手，并且把这个人的对手收为己方（用并查集实现）；两个人都有，那就收各自的对手为己方。讨论完之后，处理下一对罪犯，如此反复。这样就可以在$O(mlogm)$的时间复杂度内解决这个问题。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int parent[20005],riv[20005]=&#123;0&#125;,m,n,re[100005][3];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;&#125;void init(int k)&#123; for(int i=1;i&lt;=k;i++)parent[i]=i;&#125;int Find(int a)&#123; if(parent[a]==a)return a; return (parent[a]=Find(parent[a]));&#125;void joint(int x,int y)&#123; int a=Find(x),b=Find(y); if(a==b)return; parent[b]=a;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(n);int i,k1,k2,t1,t2; for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;re[i][1],&amp;re[i][2],&amp;re[i][0]); qsort(re,m,sizeof(re[0]),cmp); for(i=0;i&lt;m;i++)&#123; t1=re[i][1],t2=re[i][2]; if(Find(t1)==Find(t2))break; if(riv[t2]&amp;&amp;!riv[t1])swap(t1,t2); if(!riv[t2])&#123; if(!riv[t1])riv[t1]=t2,riv[t2]=t1; else riv[t2]=t1,joint(t2,riv[t1]); &#125;else joint(t2,riv[t1]),joint(t1,riv[t2]); &#125; if(i==m)printf("0\n"); else printf("%d\n",re[i][0]); return 0;&#125; 提高T4 引水入城题目地址 先搜索，搜出每一个出水站能最多支援几个国家。然后会发现每一个国家能支援到的国家一定是一段一段存在的。如果不是，那么会形成一些国家无法被到达的局面，就输出$0$，然后统计。否则对每段区间排序后贪心选择即可。可以用一些手段加速，如对在第一行的国家，只选取相对周围的国家更高一些的国家来搜索，因为这个国家肯定可以向两侧扩展。时间复杂度：$O(nm)$（近似）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;bool dp[505][505],able[505][505]=&#123;0&#125;;int n,m,h[505][505],par[505],res,ans,dx[]=&#123;-1,0,0,1&#125;,dy[]=&#123;0,-1,1,0&#125;;int stack[250005][2],top=0;void dfs(int x,int y)&#123; int nx,ny,i; stack[top][0]=x,stack[top++][1]=y; while(top)&#123; x=stack[--top][0],y=stack[top][1]; for(i=0;i&lt;4;i++)&#123; nx=x+dx[i],ny=y+dy[i]; if(nx&gt;=0&amp;&amp;ny&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&lt;m&amp;&amp; h[nx][ny]&lt;h[x][y]&amp;&amp;!dp[nx][ny]) dp[nx][ny]=1,stack[top][0]=nx,stack[top++][1]=ny; &#125; &#125;&#125;void _solve()&#123; int i,j,p,k,rec[505][2],tot=0,l,r; for(ans=1,i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; p=par[i-1],k=0; while(k&lt;m&amp;&amp;!able[p][k])k++; rec[tot][0]=k; if(tot&amp;&amp;rec[tot-1][0]==k)tot--; while(k&lt;m&amp;&amp;able[p][k])k++; rec[tot++][1]=k-1; if(k-1&lt;rec[tot-1][0])tot--; j=i-1; &#125; for(l=rec[0][0],r=rec[0][1],i=1;i&lt;tot;i++)&#123; while(i&lt;tot&amp;&amp;rec[i][0]&lt;=r+1)i++; if(r==m-1)break; i--,r=rec[i][1],ans++; &#125;&#125;void solve()&#123; int i,j,k; for(i=j=0;j&lt;m;j++)&#123; while(i&lt;m&amp;&amp;par[i]==par[j])i++; memset(dp,0,sizeof(dp)); dp[0][par[i-1]]=1,dfs(0,par[i-1]); memcpy(able[par[i-1]],dp[n-1],sizeof(bool)*m); j=i-1; &#125; bool cnt[505]=&#123;0&#125;; for(k=i=0;i&lt;m;i++) for(j=0;j&lt;m;j++) if(able[par[i]][j]&amp;&amp;!cnt[j])cnt[j]=1,k++; res=(k==m)?1:0; if(res)_solve(); else ans=m-k; printf("%d\n%d\n",res,ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,maxi,lst; for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++) scanf("%d",&amp;h[i][j]); for(i=0;i&lt;m;i++)&#123; while(i&lt;m-1&amp;&amp;h[0][i+1]&gt;h[0][i])i++; for(j=i-1;j&gt;=0&amp;&amp;h[0][j]&lt;h[0][j+1];j--) par[j]=i; par[i]=i; for(j=i+1;j&lt;m&amp;&amp;h[0][j]&lt;h[0][j-1];j++) par[j]=i; while(i&lt;m-1&amp;&amp;h[0][i+1]&lt;h[0][i])i++; &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>堆</tag>
        <tag>队列</tag>
        <tag>贪心</tag>
        <tag>其他DP</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2008%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2008八道题目的题解。 普及T1 ISBN号码题目地址 模拟即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;char isbn[20];int last,sum=0,cnt=1;int main()&#123; scanf("%s",isbn); for(int i=0;i&lt;13;i++)&#123; if(isdigit(isbn[i])&amp;&amp;i!=12) sum+=(isbn[i]-'0')*cnt,cnt++; else if(isdigit(isbn[i])&amp;&amp;i==12) sum%=11,last=isbn[i]-'0'; else sum%=11,last=10; &#125; if(last==sum)&#123; printf("Right"); &#125;else&#123; for(int i=0;i&lt;12;i++) putchar(isbn[i]); printf("%c\n",sum==10?'X':sum+'0'); &#125; return 0;&#125; 普及T2 排座椅题目地址 算一下选每一行或者每一列可以阻断的人数，然后排序贪心即可。注意行号和列号都要排序再输出。时间复杂度：$\mathcal O(nlogn+mlogm)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;struct Seat&#123; int id,tot;&#125;;Seat line[1005],row[1005];bool cmp(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.tot&gt;sb.tot;&#125;bool cmp2(const Seat &amp;sa,const Seat &amp;sb)&#123; return sa.id&lt;sb.id;&#125;int n,m,K,L,D;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;L,&amp;D); int x1,y1,x2,y2; for(int i=1;i&lt;=n;i++) line[i].tot=0,line[i].id=i;//该行上面 for(int i=1;i&lt;=m;i++) row[i].tot=0,row[i].id=i;//该列右边 for(int i=1;i&lt;=D;i++)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(x1==x2) row[min(y1,y2)].tot++; //同行记录列 else if(y1==y2) line[min(x1,x2)].tot++; &#125; sort(line+1,line+1+n,cmp),sort(line+1,line+K+1,cmp2); sort(row+1,row+1+m,cmp),sort(row+1,row+1+L,cmp2); for(int i=1;i&lt;K;i++) printf("%d ",line[i].id); printf("%d\n",line[K].id); for(int i=1;i&lt;L;i++) printf("%d ",row[i].id); printf("%d\n",row[L].id); return 0;&#125; 普及T3 传球游戏题目地址 方法一数据怎么小，怎么玩？打表！123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt;int q[28][28]=&#123;&#123;2,6,10,22,42,86,170,342,682,1366,2730,5462,10922,21846,43690,87382,174762,349526,699050,1398102,2796202,5592406,11184810,22369622,44739242,89478486,178956970,357913942&#125;,&#123;0,8,0,32,0,128,0,512,0,2048,0,8192,0,32768,0,131072,0,524288,0,2097152,0,8388608,0,33554432,0,134217728,0,536870912&#125;,&#123;0,6,2,20,14,70,72,254,330,948,1430,3614,6008,13990,24786,54740,101118,215766,409640,854702,1652090,3396916,6643782,13530350,26667864,53971350,106914242,215492564&#125;,&#123;0,6,0,22,0,86,0,342,0,1366,0,5462,0,21846,0,87382,0,349526,0,1398102,0,5592406,0,22369622,0,89478486,0,357913942&#125;,&#123;0,6,0,20,2,70,18,252,110,924,572,3434,2730,12902,12376,48926,54264,187036,232562,720062,980674,2789164,4086550,10861060,16878420,42484682,69242082,166823430&#125;,&#123;0,6,0,20,0,72,0,272,0,1056,0,4160,0,16512,0,65792,0,262656,0,1049600,0,4196352,0,16781312,0,67117056,0,268451840&#125;,&#123;0,6,0,20,0,70,2,252,22,924,156,3432,910,12870,4760,48622,23256,184796,108528,705894,490314,2708204,2163150,10430500,9373652,40313160,40060078,156305070&#125;,&#123;0,6,0,20,0,70,0,254,0,948,0,3614,0,13990,0,54740,0,215766,0,854702,0,3396916,0,13530350,0,53971350,0,215492564&#125;,&#123;0,6,0,20,0,70,0,252,2,924,26,3432,210,12870,1360,48620,7752,184756,40698,705434,201894,2704204,961400,10401250,4440150,40123152,20030010,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,926,0,3460,0,13110,0,50252,0,194446,0,758100,0,2973350,0,11716252,0,46333566,0,183739940&#125;,&#123;0,6,0,20,0,70,0,252,0,924,2,3432,30,12870,272,48620,1938,184756,11970,705432,67298,2704156,354200,10400602,1776060,40116656,8584290,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3434,0,12902,0,48926,0,187036,0,720062,0,2789164,0,10861060,0,42484682,0,166823430&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,2,12870,34,48620,342,184756,2660,705432,17710,2704156,106260,10400600,592020,40116600,3121560,155117522&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12872,0,48656,0,185136,0,708512,0,2725408,0,10532160,0,40870080,0,159189120&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,2,48620,38,184756,420,705432,3542,2704156,25300,10400600,161460,40116600,950040,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48622,0,184796,0,705894,0,2708204,0,10430500,0,40313160,0,156305070&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,2,184756,42,705432,506,2704156,4600,10400600,35100,40116600,237510,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184758,0,705476,0,2704708,0,10405800,0,40157550,0,155402532&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,2,705432,46,2704156,600,10400600,5850,40116600,47502,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705434,0,2704204,0,10401250,0,40123152,0,155172330&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,2,2704156,50,10400600,702,40116600,7308,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704158,0,10400652,0,40117356,0,155125640&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,2,10400600,54,40116600,812,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400602,0,40116656,0,155118390&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,2,40116600,58,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116602,0,155117580&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,2,155117520&#125;,&#123;0,6,0,20,0,70,0,252,0,924,0,3432,0,12870,0,48620,0,184756,0,705432,0,2704156,0,10400600,0,40116600,0,155117522&#125;&#125;;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m);printf("%d\n",q[n-3][m-3]); return 0; &#125; 方法二实际上这个递推是很水，设$\mathcal f\left(i,j\right)$为当前球到了第$i$个人的时候是第$j$次的情况下，传球的方法数，则可以递推得 \mathcal f\left(i,j\right)=f\left(i-1,j-1\right)+f\left(i+1,j-1\right)其中$i-1$指$i$左边的人，$i+1$指$i$右边的人。假设开始的人是￥0￥号即可。时间复杂度：$\mathcal O\left(nm\right)$123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,f[35][35];int main()&#123; scanf("%d%d",&amp;n,&amp;m); f[0][0]=1; for(int j=1;j&lt;=m;j++)&#123; f[0][j]=f[n-1][j-1]+f[1][j-1]; f[n-1][j]=f[0][j-1]+f[n-2][j-1]; for(int i=1;i&lt;n-1;i++) f[i][j]=f[i-1][j-1]+f[i+1][j-1]; &#125; printf("%d\n",f[0][m]); return 0;&#125; 普及T4 立体图题目地址 这题目是不是一看就很恶劣啊？是的！但是只要知道构图的顺序就完成了一部分。我的构图顺序是从最底层构起，每一层按列构成，从远到近，从左到右，从下到上，这样就解决了图形覆盖的问题。然后就是坐标的计算以及图形具体元素坐标的计算，这里可以参考我的代码。时间复杂度：画一个正方体的时间是常数，所以是$O($正方体数$)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;char mp[20001][350];int n,m,mp2[55][55],BOT=20000;void lie(int x,int y)&#123; mp[x][y]=mp[x][y+4]='+', mp[x][y+1]=mp[x][y+2]=mp[x][y+3]='-';&#125;void build(int x,int y,int z)&#123; int dx=BOT,dy=0; dx-=(z-1)*3+3+2*(m-x+1);//yuanlaiwei x dy+=(m-x+1)*2+(y-1)*4; lie(dx,dy),lie(dx+2,dy-2),lie(dx+5,dy-2); mp[dx+3][dy+4]='+', mp[dx+1][dy-1]=mp[dx+1][dy+3]=mp[dx+4][dy+3]='/'; mp[dx+3][dy-2]=mp[dx+3][dy+2]= mp[dx+4][dy-2]=mp[dx+4][dy+2]= mp[dx+1][dy+4]=mp[dx+2][dy+4]='|', mp[dx+1][dy]=mp[dx+1][dy+1]=mp[dx+1][dy+2]= mp[dx+2][dy+3]=mp[dx+3][dy+3]= mp[dx+3][dy]=mp[dx+3][dy-1]=mp[dx+3][dy+1]= mp[dx+4][dy]=mp[dx+4][dy-1]=mp[dx+4][dy+1]=' ';&#125;void output()&#123; int s1=0,s2=0,i,j,ok; for(i=BOT;i&gt;=0;i--)&#123; for(j=0,ok=0;j&lt;350;j++) if(mp[i][j]!='.')ok=1; if(!ok)break; &#125; s1=i+1; for(i=349;i&gt;=0;i--)&#123; for(j=s1,ok=0;j&lt;=BOT;j++) if(mp[j][i]!='.')ok=1; if(ok)break; &#125; s2=i; //printf("%d %d\n",s1,s2); for(i=s1;i&lt;=BOT;i++)&#123; for(j=0;j&lt;=s2;j++) printf("%c",mp[i][j]); printf("\n"); &#125;&#125;int main()&#123; memset(mp,'.',sizeof(mp)); scanf("%d%d",&amp;m,&amp;n); int i,j,k; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mp2[i][j]); for(i=1;i&lt;=100;i++) for(k=0;k&lt;n;k++) for(j=0;j&lt;m;j++) if(mp2[j][k]&gt;=i) build(j+1,k+1,i); output(); return 0;&#125; 提高T1 笨小猴题目地址 模拟即可。注意0和1都不是质数。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;bool judge(int x)&#123; if(!x||x==1)return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0)return 0; return 1;&#125;char s[1005];int cnt[27],len;int main()&#123; scanf("%s",s); len=strlen(s); for(int i=0;i&lt;len;i++) cnt[s[i]-'a']++; int maxi=0,mini=1000; for(int i=0;i&lt;26;i++)&#123; if(!cnt[i])continue; maxi=max(maxi,cnt[i]),mini=min(mini,cnt[i]); &#125; if(judge(maxi-mini)) printf("Lucky Word\n%d\n",maxi-mini); else printf("No Answer\n0\n"); return 0;&#125; 提高T2 火柴棒等式题目地址 方法一大概划定一下加数的范围，然后暴力枚举即可。1是最少的，所以以他为标准，大概左右两边的加数是在2000左右。（实际上试验后发现在1000左右）1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int cnt[]=&#123;6,2,5,5,4,5,6,3,7,6&#125;,n,ans=0;int table[2005];int get(int a)&#123; int res=0; while(a)res+=cnt[a%10],a/=10; return res;&#125;int main()&#123; scanf("%d",&amp;n),n-=4; table[0]=6; for(int i=1;i&lt;=2000;i++) table[i]=get(i); for(int i=0;i&lt;=1000;i++) for(int j=0;j&lt;=1000;j++) if(table[i]+table[j]+table[i+j]==n)ans++; printf("%d\n",ans); return 0;&#125; 方法二题目是死的，人是活的。打表也是好手段。1int ans[]=&#123;0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128&#125;; 提高T3 传纸条题目地址 设$\mathcal f\left( k,i,j\right) \left( i \le j \right)$为走了$\mathcal k$步，第一条路径当前在第$\mathcal i$列，第二条在第$\mathcal j$列时的最大的爱心值。则转移方程为 \mathcal f\left( k,i,j\right) = \max \left\{ f\left( k-1,i,j\right) , f\left( k-1,i-1,j\right) , f\left( k-1,i,j-1\right),f\left( k-1,i-1,j-1\right) \right\} + \begin{cases} data[k-i][i] \quad \left(i=j\right)\\ data[k-i][i]+data[k-j][j] \quad \left(i \neq j\right) \\ \end{cases}1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][51][51]=&#123;0&#125;,m,n,mat[51][51];int main()&#123; int i,j,k;scanf("%d%d",&amp;m,&amp;n); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(k=1;k&lt;m+n-1;k++) for(j=0;j&lt;n;j++) for(i=0;i&lt;=j;i++)&#123; if(k-i&lt;0||k-i&gt;=m||k-j&lt;0||k-j&gt;=m)continue; dp[k][i][j]=max(dp[k-1][i][j],dp[k][i][j]); if(i)dp[k][i][j]=max(dp[k-1][i-1][j],dp[k][i][j]); if(j)dp[k][i][j]=max(dp[k-1][i][j-1],dp[k][i][j]); if(i&amp;&amp;j)dp[k][i][j]=max(dp[k-1][i-1][j-1],dp[k][i][j]); dp[k][i][j]+=mat[k-i][i]; if(i!=j)dp[k][i][j]+=mat[k-j][j]; &#125; printf("%d\n",dp[m+n-2][n-1][n-1]); return 0;&#125; 提高T4 双栈排序题目地址 双栈排序=单栈排序*2。那我们探究一下单栈排序吧！显然，单栈排序中，如果有两个数$\mathcal a_i$和$\mathcal a_k$，其中$\mathcal a_k&lt;a_i$，那么显然$\mathcal a_k$先弹出，$\mathcal a_i$后弹出。什么时候一个序列无法被单栈排序呢？如果因为某个原因，上面的事情做不到，就说明无法单栈排序。换言之，我们假设$\mathcal i&lt;k$且$\mathcal a_k&lt;a_i$，那么如果两个数之间有一个碍事的：有元素$\mathcal i&lt;j&lt;k$，并且$\mathcal a_i&lt;a_j$，那么显然在弹出$\mathcal a_k$后必须要先弹掉$\mathcal a_j$才能弹出$\mathcal a_i$，这不符合条件。所以无法单栈排序。一个栈做不成，那就两个。考虑把这些碍事的元素放到另一个栈里，这样就不矛盾了。问题是如何分配呢？我们知道，根据上述条件，$\mathcal a_i$和$\mathcal a_j$必然无法在同一个栈中。根据这种”二分“的性质，我们想到了二分图。把下标看做结点，然后不能在一个栈里的点对间连一条边，判断这个图是否是二分图即可。这一步可以直接用DFS实现。之后就比较简单了，输出排序过程即可。 还有一个瓶颈：怎么求这样的点对？直接枚举会带来$\mathcal O\left(n^3\right)$的时间复杂度，我们承受不住。观察到$\mathcal a_k$具体是多少不重要，只要有一个$\mathcal k$满足\mathcal j]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>暴力</tag>
        <tag>递推</tag>
        <tag>二分图</tag>
        <tag>多线程DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2011 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2011%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2011十道题目的题解。 普及T1 数字反转题目地址 模拟123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;char num[15];int main()&#123; scanf("%s",num); int f=(num[0]=='-'),len=strlen(num),cur=0; reverse(num,num+len); while(num[cur]=='0')cur++; if(f)putchar('-'); if(!num[cur]||num[cur]=='-')printf("0\n"); else&#123; while(isdigit(num[cur]))putchar(num[cur]),cur++; &#125; return 0;&#125; 普及T2 统计单词数题目地址 本题不需要使用字符串匹配的高级算法，模拟即可。注意单词必须完全匹配，即匹配时两个单词长度要一样。123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;char w[20],s[1000005];int ans1=-1,ans2=0,l1,l2;bool judge(int t)&#123; for(int i=0;i&lt;l1;i++) if(w[i]!=s[t+i])return 0; if(t+l1==l2||s[t+l1]==' ')return 1; return 0;&#125;int main()&#123; scanf("%s",w); while(getchar()!='\n'); fgets(s,1000003,stdin); l1=strlen(w),l2=strlen(s); for(int i=0;i&lt;l1;i++)if(isupper(w[i]))w[i]+='a'-'A'; for(int i=0;i&lt;l2;i++)if(isupper(s[i]))s[i]+='a'-'A'; for(int i=0;i&lt;l2;i++) if(s[i]!=' '&amp;&amp;(!i||s[i-1]==' ')&amp;&amp;i+l1-1&lt;l2) if(judge(i))&#123; if(ans1&lt;0)ans1=i; ans2++; &#125; if(ans1&lt;0)printf("%d\n",ans1); else printf("%d %d\n",ans2,ans1); return 0;&#125; 普及T3 瑞士轮题目地址 模拟+归并。直接模拟的话是$O(nqlogn)$的时间复杂度，会超时。发现每次比完赛之后赢的人和输的人各自的相对排名不变，所以将胜者和败者归并起来，时间复杂度为$O(nq)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;P p[200005],pp[200005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,r,q,w[200005],q1[200005],q2[200005],r1,r2;//q1胜者 q2败者 void Merge()&#123; int tot=0,lb=1,rb=1; while(lb&lt;=r1&amp;&amp;rb&lt;=r2)&#123; int L=q1[lb],R=q2[rb]; if(p[L]&lt;p[R])pp[++tot]=p[L],lb++; else pp[++tot]=p[R],rb++; &#125; while(lb&lt;=r1)pp[++tot]=p[q1[lb]],lb++; while(rb&lt;=r2)pp[++tot]=p[q2[rb]],rb++; memcpy(p+1,pp+1,sizeof(P)*n);&#125;void init()&#123; n=read()&lt;&lt;1,r=read(),q=read(); for(int i=1;i&lt;=n;i++) p[i].first=-read(),p[i].second=i; for(int i=1;i&lt;=n;i++)w[i]=read(); sort(p+1,p+n+1); &#125;void solve()&#123; while(r--)&#123; r1=r2=0; for(int i=1;i&lt;=n;i+=2)&#123; q1[++r1]=i,q2[++r2]=i+1; if(w[p[i].second]&lt;w[p[i+1].second]) swap(q1[r1],q2[r2]),p[i+1].first--; else p[i].first--; &#125; Merge(); &#125; printf("%d\n",p[q].second);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 表达式的值题目地址 $DP$。实际上那两个运算就是与和或，所以直接用栈来模拟一下运算过程即可。按运算数来$DP$，记录一下当前编号为$id$的运算数取$0$和$1$时的方案数，这样做法就比较显然了，在模拟的时候计数即可。时间复杂度为$O(n)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;int s1[100005][2]=&#123;0&#125;,s2[100005]=&#123;0&#125;,t1=0,t2=0,pro[300],lim,M=10007;char _exp[100005];void opr()&#123; int a1,a2,b1,b2,o; a1=s1[--t1][0],a2=s1[t1][1], b1=s1[--t1][0],b2=s1[t1][1], o=s2[--t2]; if(o=='+') s1[t1][0]=(a1*b1)%M, s1[t1++][1]=(a1*b2+a2*b1+a2*b2)%M; if(o=='*')&#123; s1[t1][1]=(a2*b2)%M, s1[t1++][0]=(a1*b1+a1*b2+a2*b1)%M; &#125;&#125;void calc()&#123; int i,j; for(i=0;i&lt;lim;i++)&#123; if(_exp[i]=='(') s2[t2++]='('; else if(_exp[i]==')')&#123; while(s2[t2-1]!='(') opr(); t2--; &#125;else&#123; if(_exp[i-1]!=')') s1[t1][0]=1, s1[t1++][1]=1; while(t2&amp;&amp;s2[t2-1]!='('&amp;&amp; pro[s2[t2-1]]&gt;=pro[_exp[i]]) opr(); s2[t2++]=_exp[i]; if(_exp[i+1]==')') s1[t1][0]=1, s1[t1++][1]=1; &#125; &#125;&#125;void init()&#123; pro['+']=1,pro['*']=2; scanf("%d%s",&amp;lim,&amp;_exp[1]); lim++; _exp[0]='('; _exp[lim++]=')';&#125;void solve()&#123; calc(); printf("%d\n",s1[0][0]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 铺地毯题目地址 模拟即可。注意判断矩形和无解条件。1234567891011121314#include &lt;bits/stdc++.h&gt;int x[10002],y[10002],l[10002],w[10002],n,dx,dy;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d%d%d",&amp;x[i],&amp;y[i],&amp;l[i],&amp;w[i]); scanf("%d%d",&amp;dx,&amp;dy); int at=-1; for(int i=0;i&lt;n;i++) if((dx&lt;=x[i]+l[i]&amp;&amp;dx&gt;=x[i])&amp;&amp;(dy&lt;=y[i]+w[i]&amp;&amp;dy&gt;=y[i])) at=i+1; printf("%d\n",at); return 0;&#125; 提高D1T2 选择客栈（待考察）题目地址 直接枚举是$O(n^2)$的，不够优秀。考虑这么一种做法：我们分颜色考虑，对于一种颜色$col$，用某个数据结构按距离从大到小存一 下客栈的编号（其实从小到大还是从大到小不重要），然后按顺序枚举每一个客栈，统计一下它的贡献。（也就是有几种方案，他被住下了）贡献怎么算呢？我们画个图 $cur$表示我们找到的离当前枚举到的客栈最近的合法（指最低消费$\le p$）客栈的编号，那么由乘法原理，这个时候$cur$左边的颜色为$col$的客栈数乘上右边颜色为$col$的客栈数就是可行的贡献。诶，刚才不是说算每一个客栈的贡献么？对的。这里由于$cur$右边的$col$颜色客栈之间没有合法客栈，所以把右边的一起算。这里还有一个问题：如果$cur$的颜色是$col$怎么办？如果$cur$右边的客栈全被统计过了，就把他划分到右边，否则划分到左边，这样可以保证正确性。计算完后继续看下一个客栈，这里有一个优化：如果客栈编号大于$cur$就直接跳过，因为他的贡献算过了。综上，使用以上算法的时间复杂度为$O(nk)$。由于数据的原因，实际时间复杂度远小于该值。本题还存在一个时间复杂度仅为$O(n)$的算法，可根据以上算法优化而来，各位不妨自行思考。提示：如果我们边读入数据，边动态更新$cur$会怎么样呢？123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,k,p,col[200005],cost[200005];int at[55],id[200005],nex[200005],cnt=0,tot[55];void init()&#123; n=read(),k=read(),p=read(); for(int i=1;i&lt;=n;i++)&#123; col[i]=read(),cost[i]=read(); id[++cnt]=i,nex[cnt]=at[col[i]],at[col[i]]=cnt,tot[col[i]]++; &#125; //链式前向星 &#125;void solve()&#123; int ans=0; for(int i=0;i&lt;k;i++)&#123; if(!at[i])continue ; int lf=tot[i],cur=id[at[i]]+1; //lf 左端 rt 右端 for(int j=at[i];j;j=nex[j])&#123; if(id[j]&gt;cur)continue;//优化，该客栈被统计过就跳过 int rt=0;//一开始cur右边没被统计过的客栈数是0 for(cur=id[j];cur&amp;&amp;cost[cur]&gt;p;cur--)//更新cur if(col[cur]==i)rt++,lf--;//遇到一个客栈在cur右边 if(!cur)break;//找不到这样的合法客栈 if(col[cur]==i&amp;&amp;!rt)rt=1,lf--;//对应右边无客栈被统计的情况 ans+=rt*lf;//计算贡献 &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T3 Mayan游戏题目地址 本题模拟的成分远大于搜索。由于步数已经确定，所以只要采用最简单的$DFS$即可求出结果。当然，我们需要一些必要的剪枝和优化： 列表内容最优化剪枝：按照$x,y$的顺序遍历方块，保证第一个找到的可行方案一定是最优方案。 最优化剪枝：只有当左边是空的时候才左移，否则等价于左边的右移。 最优化剪枝：不移动同色方块。 可行性剪枝：有某种方块个数$\le 2$直接退出，因为不可能消除。 程序上的优化：用$2$个队列处理事件，一个处理掉落，一个处理消除。这样就可以跑的非常快了。理论上还可以加一个估价的优化，就是通过同色方块的连接情况判断至少还要走几步，但实际上以上的优化已经足够了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//交换2个方块后要处理影响//1.掉落 2.消除 //可行性剪枝：同颜色&lt;=2个退出//设置一个掉落队列和一个事件队列//事件队列检查是否有可以消除的方块，有的话就把最上面一层得上一个加入掉落队列 //在掉落队列里检查上方是否有方块，有的话将上方的方块下降后全部加入事件队列 //两者需要交替进行。int pz[10][5][7];int n,ans[10][3],movement[10][3],cnt[11],flag=0;int dque[10005][2],dr,df;//掉落队列 int eque[10005][2],er,ef;//事件队列 int visx[10],visy[10],vis[5][7];void solve_clear(int cur)&#123; int dx,dy,col,len; for(int i=0;i&lt;5;i++)visx[i]=0; for(int i=0;i&lt;7;i++)visy[i]=0; memset(vis,0,sizeof(vis)); while(er&gt;ef)&#123; dx=eque[ef][0],dy=eque[ef++][1]; if(!visx[dx])&#123;//同一个x visx[dx]=1; col=pz[cur][dx][0],len=1; for(int i=1;i&lt;7;i++)&#123; if(pz[cur][dx][i]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[dx][j]=1; &#125; col=pz[cur][dx][i],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=6;7-j&lt;=len;j--)vis[dx][j]=1; &#125; &#125; if(!visy[dy])&#123; visy[dy]=1; col=pz[cur][0][dy],len=1; for(int i=1;i&lt;5;i++)&#123; if(pz[cur][i][dy]==col) len++; else&#123; if(len&gt;=3&amp;&amp;col)&#123; for(int j=i-1;i-j&lt;=len;j--)vis[j][dy]=1; &#125; col=pz[cur][i][dy],len=1; &#125; &#125; if(len&gt;=3&amp;&amp;col)&#123; for(int j=4;5-j&lt;=len;j--)vis[j][dy]=1; &#125; &#125; &#125; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) if(vis[i][j])&#123; pz[cur][i][j]=0; if(j!=6) dque[dr][0]=i,dque[dr++][1]=j+1; &#125; &#125;void solve_drop(int cur)&#123; int dx,dy,des; while(dr&gt;df)&#123; dx=dque[df][0],dy=dque[df++][1]; for(des=dy-1;des&gt;=0&amp;&amp;!pz[cur][dx][des];des--); des++; for(int i=dy;i&lt;7;i++) if(pz[cur][dx][i]) pz[cur][dx][des++]=pz[cur][dx][i], eque[er][0]=dx,eque[er++][1]=des-1; for(int i=des;i&lt;7;i++) pz[cur][dx][i]=0; &#125;&#125;void dfs(int cur)&#123; if(flag)return ; if(cur==n)&#123; for(int i=0;i&lt;5;i++) if(pz[cur][i][0])return ; memcpy(ans,movement,sizeof(ans)); flag=1; return ; &#125; for(int i=1;i&lt;=10;i++)cnt[i]=0; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;7;j++) cnt[pz[cur][i][j]]++; for(int i=1;i&lt;=10;i++) if(cnt[i]&amp;&amp;cnt[i]&lt;3)return ; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;7;j++)&#123; if(!pz[cur][i][j])continue; if(i!=4&amp;&amp;pz[cur][i+1][j]!=pz[cur][i][j])&#123; //向右移动 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i+1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i+1,dque[dr++][1]=j; while(dr&gt;df) solve_drop(cur+1),solve_clear(cur+1); movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=1; dfs(cur+1); &#125; if(i&amp;&amp;!pz[cur][i-1][j]&amp;&amp;pz[cur][i-1][j]!=pz[cur][i][j])&#123;//向左边 memcpy(pz[cur+1],pz[cur],sizeof(pz[0])); swap(pz[cur+1][i-1][j],pz[cur+1][i][j]); dr=df=0,ef=er=0; dque[dr][0]=i,dque[dr++][1]=j, dque[dr][0]=i-1,dque[dr++][1]=j; while(dr&gt;df)&#123; solve_drop(cur+1),solve_clear(cur+1); &#125; movement[cur][0]=i,movement[cur][1]=j,movement[cur][2]=-1; dfs(cur+1); &#125; &#125; &#125;&#125;void init()&#123; n=read(); int t; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;8;j++)&#123; t=read(); if(!t)break; pz[0][i][j]=t; &#125;&#125;void solve()&#123; dfs(0); if(!flag)printf("-1\n"); else &#123; for(int i=0;i&lt;n;i++) printf("%d %d %d\n",ans[i][0],ans[i][1],ans[i][2]); &#125;&#125;int main()&#123; freopen("a.in","r",stdin); init(); solve(); return 0;&#125; 提高D2T1 计算系数题目地址 套用二项式定理和组合数取模即可。$x^ny^m$的系数是$C_n^k \times a^n\times b^m$。时间复杂度：$O(k^2)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define M 10007using namespace std; int dp[1005]=&#123;0&#125;,a,b,k,m,n,ans; int Pow(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1)res=(res*a)%M; a=(a*a)%M,b&gt;&gt;=1; &#125;return res;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;k,&amp;n,&amp;m); a%=M,b%=M,dp[0]=1; for(int i=1;i&lt;=k;i++) for(int j=i;j&gt;=1;j--) dp[j]+=dp[j-1],dp[j]%=M; //计算组合数 ans=(dp[n]*Pow(a,n))%M, ans=(ans*Pow(b,m))%M; printf("%d\n",ans); return 0; &#125; 提高D2T2 聪明的质监员题目地址 较为明显的二分。二分一个$x$，然后扫一遍表，看看哪些$w$大于等于$x$，然后用前缀和存一下符合条件的$w$前缀和与$w$的数量前缀和，最后$m$个区间算一遍加起来即可。时间复杂度：$O((n+m)logn)$123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;ll S,tot,v[200005],ans,sum[200005],cnt[200005];int w[200005],n,m,ev[200005][2];void solve(int r)&#123; int i; sum[0]=cnt[0]=0; for(i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1], cnt[i]=cnt[i-1]; if(w[i-1]&gt;=r)sum[i]+=v[i-1],cnt[i]++; &#125; for(i=0;i&lt;m;i++) tot+=(cnt[ev[i][1]]-cnt[ev[i][0]-1])* (sum[ev[i][1]]-sum[ev[i][0]-1]);&#125;int main()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;S); int i,j,lb=0,rb=1000000,md; ans=S; for(i=0;i&lt;n;i++) scanf("%d%lld",&amp;w[i],&amp;v[i]); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;ev[i][0],&amp;ev[i][1]); while(rb-lb)&#123; md=(rb+lb)/2,tot=0; solve(md); if(tot==S)&#123;ans=0;break;&#125; else if(tot&gt;S)ans=min(ans,tot-S),lb=md+1; else ans=min(ans,S-tot),rb=md; &#125; printf("%lld\n",ans); return 0;&#125; 提高D2T3 观光公交（待考察）题目地址 题解题目的意思就是选择若干条路，修改他们的长度，使得总的旅行时间最少。具体的做法就是贪心，找省时间最多的路段用。我们把道路分块，为什么要这么做呢？我们把本题第一个数据画成图。123456710 5 05 7 2 4 8 2 8 3 110 3 41 1 333 6 914 4 81 1 4 上面的竖线表示到站的人的到站时间，点表示时间点。虚线部分是指车子到站之后还要等待虚线的时间才能等到人全部上齐。虚线左端是到站时间点，右端是发车时间点。设一个站i中，来的最晚的人到达时间是$latest[i]$。然后，我们手算后可以发现一些性质：性质1.如果车子到达i站的时间是$curt$，并且$curt\le latest[i]$，那么$i$前面和$i$后面，两个路段相互独立。什么意思呢？我们可以感性地这么想：让一段路的长度减少，就相当于把这段路以及其后面的到站时间点往前拉。但是第i站的点永远不会动，因为他的到站时间点和发车时间点是用虚线连接着的，发车时间一定不变。所以对i前面的路修改，$i$后面的就不会受影响；同理对$i$后面的路修改，$i$前面的路也不会受影响。我们称呼到达这样的站的路为隔离路。上图中，$5\rightarrow 6$就是隔离路。根据这个性质，我们可以很方便的把路分块，分割成几个相互不影响的路块以及分隔他们的隔离路。分完了块就可以计算优化一条路能节省的时间了。下面我们对一个路块进行探究：设一个块中开头的站编号为$belong$，末尾的站是$tail$。显然，由上文，$tail\rightarrow tail+1$的路是隔离路。性质2.一个块中，如果优化$i\rightarrow i+1$站的路，使其长度$-1$，可以节省的时间是在$i+1,i+2,…tail,tail+1$这些站下车的人数的总和。这个性质很容易证明，由于这些人都已经上了车，所以优化这段路就相当于把后面站的到站时间点都$-1$，每一个人的到达时间就$-1$，所以省下的时间是人数的和，证毕。根据这个性质，我们可以用后缀和计算出省下的时间，找到在块中最优的那段路。不在块中的隔离路也能优化，优化一次节省的时间是在隔离路通向的下一站下车的人数。接下来的问题是一段路最多可以优化多少次。根据上图可以发现，一段路被优化一定次数，前面的某一段路就会变成隔离路。比如优化$1\rightarrow 2$的路后，$3\rightarrow 4$就变成了隔离路。所以在分块时还要对每一段路统计一个$mingap$，表示一段路最多优化几次就会导致后面的某段路变为隔离路。优化$mingap$次数之后，原来的块就失效了，需要对当前操作块进行重构。如果一段路的长度变成了$0$，或者$mingap$为$0$，就称这一段路是无效路，在寻找最大值时忽略。之后重复以上步骤即可。分析一下时间复杂度：每一轮我们找出一段可以修改的路，修改完成后，至少会使得一段路变为隔离路，或者使得一条隔离路变为无效路。所以每一条路最多被修改$2$次。一共有$O(n)$条路，所以最多做$O(n)$次，所有的路就被修改完了。每一轮我们需要$O(n)$的时间找到省时间最多的路段，并且至多用$O(n)$的时间更新块的情况，结合上面可知，最多做$O(n)$轮，所以该算法的理论时间复杂度为$O(n^2)$。贪心的正确性比较显然，在此不证明。存在$O(nk)$的编程复杂度更低，但是可能会超时的做法。很可惜，本题数据太水，根本卡不掉。事实上，本题存在时间运行上比本题解程序实现更优的程序实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,K,dis[1005],latest[1005],dec[1005],cost[1005],cnt[1005],cnt2[1005];int belong[1005],mingap[1005],tail[1005],ans=0;void build_block(int l,int r)&#123; int bid=l,curt=latest[l]; for(int i=l+1;i&lt;=r;i++)&#123; curt+=dis[i-1]; if(curt&gt;latest[i])belong[i-1]=bid; else&#123; belong[i-1]=-1,mingap[i-1]=INF; int tmp=curt-dis[i-1]; for(int j=i-2;j&gt;=bid;j--) mingap[j]=min(min(tmp-latest[j+1],dis[j]),mingap[j+1]), tmp-=dis[j]; curt=latest[i],tail[bid]=i-1,bid=i; &#125; &#125; if(bid!=r)&#123; int bef=INF; for(int j=r-1;j&gt;=bid;j--) mingap[j]=min(bef,min(dis[j],curt-latest[j+1])), bef=min(bef,mingap[j]),curt-=dis[j]; tail[bid]=r; &#125;&#125;void init()&#123; n=read(),m=read(),K=read(); for(int i=1;i&lt;n;i++)dis[i]=read(); for(int i=1;i&lt;=m;i++)&#123; int Ti=read(),Ai=read(),Bi=read(); latest[Ai]=max(latest[Ai],Ti); cost[Ai]+=Ti; dec[Ai]++,dec[Bi]--,cnt[Ai]++,cnt2[Bi]++; &#125; for(int i=2;i&lt;=n+1;i++)dec[i]+=dec[i-1]; int curt=latest[1]; ans+=cnt[1]*latest[1]-cost[1]; for(int i=1;i&lt;n;i++)&#123; if(latest[i+1]&gt;curt+dis[i])&#123; ans+=cnt2[i+1]*dis[i]+(dec[i]-cnt2[i+1])*(latest[i+1]-curt); ans+=cnt[i+1]*latest[i+1]-cost[i+1]; curt=latest[i+1]; &#125;else&#123; ans+=dec[i]*dis[i],curt+=dis[i]; ans+=cnt[i+1]*curt-cost[i+1]; &#125; &#125; //每一段路上坐车人数 &#125;void solve()&#123; build_block(1,n); for(;K;)&#123; int maxi=0,maxid=-1,curb=0,bid,sum; for(int i=1;i&lt;n;i++)&#123; bid=belong[i]; if(bid&lt;0)&#123; if(dis[i]&amp;&amp;cnt2[i+1]&gt;maxi)maxi=cnt2[i+1],maxid=i; &#125;else&#123; if(curb!=bid)&#123; curb=bid,sum=0; for(int j=tail[bid]+1;j&gt;=i+1;j--)sum+=cnt2[j]; &#125; if(mingap[i]&amp;&amp;sum&gt;maxi)maxi=sum,maxid=i; sum-=cnt2[i+1]; &#125; &#125; if(maxid&lt;0)break; bid=belong[maxid]; if(bid&lt;0)&#123; if(K&gt;dis[maxid]) ans-=maxi*dis[maxid],K-=dis[maxid],dis[maxid]=0; else &#123; ans-=maxi*K; break; &#125; &#125;else&#123; if(K&gt;mingap[maxid])&#123; ans-=maxi*mingap[maxid],K-=mingap[maxid],dis[maxid]-=mingap[maxid]; &#125;else &#123; ans-=maxi*K; break; &#125; build_block(bid,tail[bid]); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>二分</tag>
        <tag>栈</tag>
        <tag>贪心</tag>
        <tag>字符串DP</tag>
        <tag>二路归并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2012%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2012十道题目的题解。 普及T1 质因数分解题目地址 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); for(int i=2;i*i&lt;=n;i++) if(n%i==0)&#123; printf("%d\n",n/i); return 0; &#125; return 0;&#125; 普及T2 寻宝题目地址 模拟，时间复杂度$O(nm)$。每一层记录一下有楼梯的房间数，找房间用一个循环实现。1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,sum=0,p=20123,at[10005][105][2],access[10005]=&#123;0&#125;,st;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int tmp=0,lf; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; scanf("%d%d",&amp;at[i][j][0],&amp;at[i][j][1]); if(at[i][j][0])access[i]++; &#125; scanf("%d",&amp;st); for(int i=0;i&lt;n;i++)&#123; lf=at[i][st][1]; sum+=lf,lf%=access[i],tmp=st; if(!lf)lf=access[i]; for(;;)&#123; if(at[i][tmp][0])lf--; if(!lf)break; tmp=(tmp+1)%m; &#125; st=tmp,sum%=p; &#125; printf("%d\n",sum); return 0;&#125; 普及T3 摆花题目地址 很容易看出来这是一个$DP$。设$f(i,j)$为摆到第i种花，共有$j$盆的方案数。那么 f(i,j)=\sum_{k=0}^{\min(j,a[i])}f(i-1,j-k)时间复杂度：$O(nm^2)$。12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;using namespace std;int n,m,a[105],dp[105][105]=&#123;0&#125;,p=1000007;int main()&#123; int i,j,k; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(i=0;i&lt;=a[0];i++) dp[1][i]=1; for(i=2;i&lt;=n;i++) for(j=0;j&lt;=m;j++) for(k=0;k&lt;=a[i-1];k++) if(j-k&gt;=0)dp[i][j]+=dp[i-1][j-k],dp[i][j]%=p; else break; printf("%d\n",dp[n][m]); return 0;&#125; 普及T4 文化之旅题目地址 错误方法不正确，但却能快速通过本题的方法是$SPFA$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 1000000000using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[20005];int cnt=0,at[105],n,k,m,s,t;int que[10005][105],f,r,c[105],mat[105][105],d[105],in[105]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125;void spfa_bfs()&#123; fill(d+1,d+n+1,INF); d[s]=0; que[r][0]=s,que[r++][c[s]]=1,in[s]=1; int i,_u,_v,_co,j,ok,cul; while(r-f)&#123; _u=que[f++][0],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost,cul=c[_v]; for(ok=1,j=1;j&lt;=k;j++) if(mat[cul][que[f-1][j]])&#123; ok=0;break; &#125; if(!ok)continue; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r][0]=_v; for(j=1;j&lt;=k;j++) que[r][j]=que[f-1][j]; r++; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;k,&amp;m,&amp;s,&amp;t); int i,j,u,v,_c; for(i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(i=1;i&lt;=k;i++) for(j=1;j&lt;=k;j++) scanf("%d",&amp;mat[i][j]); memset(at,-1,sizeof(at)); for(i=0;i&lt;m;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;_c), addedge(u,v,_c), addedge(v,u,_c); spfa_bfs(); printf("%d\n",d[t]&gt;=INF-100?-1:d[t]); return 0;&#125; 正解正解是搜索。考虑使用高效算法进行优化，那么先以$T$为起点跑$SPFA$，然后从起点搜索的时候，如果不考虑文化的容斥关系都有“当前点到$T$最短路长$+$当前已走距离$\ge ans$”的话就停止搜索。用$DFS$，跑的还比较快。upd:上述的做法是正确的，但是这题数据很恶，所以要调整搜索顺序，倒着搜。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define INF 1000000000using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int to[20005],at[105],nex[20005],cnt=0;int V,E,K,S,T,mat[105][105],c[105],dis[105][105];int que[10005],f,r,dist[105],in[105];int vis[105],ans=1000000000;void spfa()&#123; fill(dist+1,dist+V+1,INF); f=r=0,que[r++]=S,in[S]=1,dist[S]=0; int h,v; while(r&gt;f)&#123; h=que[f++],in[h]=0; for(int i=at[h];i;i=nex[i])&#123; v=to[i]; if(dist[v]&gt;dist[h]+dis[h][v])&#123; dist[v]=dist[h]+dis[h][v]; if(!in[v]) in[v]=1,que[r++]=v; &#125; &#125; &#125;&#125;void dfs(int cur,int d)&#123; if(cur==S)&#123; ans=min(ans,d); return ; &#125; if(d+dist[cur]&gt;=ans)return ; vis[c[cur]]=1; for(int i=at[cur];i;i=nex[i])&#123; int v=to[i],flag=0; if(vis[c[v]])continue; for(int j=1;j&lt;=K;j++) if(vis[j]&amp;&amp;mat[c[v]][j])&#123; flag=1; break; &#125; if(flag)continue; dfs(v,d+dis[cur][v]); &#125; vis[c[cur]]=0;&#125; void init()&#123; V=read(),K=read(),E=read(),S=read(),T=read(); for(int i=1;i&lt;=V;i++)c[i]=read(); for(int i=1;i&lt;=K;i++) for(int j=1;j&lt;=K;j++) mat[i][j]=read(); for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) dis[i][j]=INF; for(int i=1;i&lt;=E;i++)&#123; int u=read(),v=read(),co=read(); if(dis[u][v]&lt;co)continue; dis[u][v]=dis[v][u]=co; to[++cnt]=v,nex[cnt]=at[u],at[u]=cnt; to[++cnt]=u,nex[cnt]=at[v],at[v]=cnt; &#125; spfa();&#125;void solve()&#123; dfs(T,0); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 Vigenère密码题目地址 这个加密运算其实就是循环移位。密文是循环进位，我们倒着做就行了。12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char key[1005],tex[1005];int get(char a,char b)&#123; return (b-'a'-(a-'a')+26)%26;&#125;int main()&#123; scanf("%s%s",key,tex); int l1=strlen(key),l2=strlen(tex); for(int i=0;i&lt;l1;i++) key[i]=tolower(key[i]); for(int i=0;i&lt;l2;i++)&#123; if(isupper(tex[i])) putchar('A'+get(key[i%l1],tolower(tex[i]))); else putchar('a'+get(key[i%l1],tex[i])); &#125; return 0; &#125; 提高D1T2 国王游戏题目地址 考虑第$i$和第$i+1$个人，他们手上的数字分别为a_i,b_i,a_{i+1},b_{i+1}，第$i+1$个人站在第$i$个人身后。设第$i$个人前面所有人左手数字的积为$T$，那么这两个人拿到的金币数分别为\lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor如果两人交换顺序，那么两人拿到的金币数分别为\lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor为了让获得最多金币的人得到的金币尽量少，我们就需要根据\max \left \{ \lfloor \frac{T}{b_i}\rfloor,\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor\right\}和\max \left \{ \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor\right\}判断是否该让两个人交换顺序。如果交换了顺序使得取得的$max$更小，那么就需要交换。而根据归纳法，对每一对人按这种方法排一个序，就可以求出正确的答案。此时排序的时间复杂度为$O(n^2)$。但仔细观察可以发现，\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor > \lfloor \frac{T}{b_{i+1}}\rfloor,\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor>\lfloor \frac{T}{b_i}\rfloor。因此只需要确定了\lfloor \frac{T\cdot a_i }{b_{i+1}}\rfloor和\lfloor \frac{T\cdot a_{i+1} }{b_i}\rfloor的大小关系，就可以根据不等号的传递性判断哪一种顺序产生的最大值更小。而对上面两个式子变形，消去$T$并且移项便可以发现：只要比较a_ib_i和a_{i+1}b_{i+1}的大小就可判断。于是可以以a_ib_i为关键字排序，来确定整个队伍的顺序。此时，时间复杂度为$O(nlogn+$高精度运算需要的时间$)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; using namespace std;typedef long long ll;struct P&#123; int a,b,t;&#125;;bool operator&lt;(const P &amp;u,const P &amp;v)&#123; return (u.t&lt;v.t);&#125;P p[1005];int d1[3]=&#123;0&#125;,d2[5000]=&#123;0&#125;,d3[5000],ans[5000]=&#123;0&#125;,n;void mul(int s1[],int s2[],int to[])&#123; to[0]=s1[0]+s2[0]; for(int i=1;i&lt;=s1[0];i++)&#123; int x=0; for(int j=1;j&lt;=s2[0];j++) x=s1[i]*s2[j]+x+to[i+j-1],to[i+j-1]=x%10000,x/=10000; to[i+s2[0]]=x; &#125; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;void div(int s1[],int s2,int to[])&#123; to[0]=s1[0]; int x=0; for(int i=s1[0];i&gt;=1;i--) to[i]=(x*10000+s1[i])/s2,x=x*10000+s1[i]-to[i]*s2; for(;to[0]&gt;1&amp;&amp;to[to[0]]==0;)to[0]--;&#125;int smaller(int n1[],int n2[])&#123;//&lt;0 ：小于 if(n1[0]!=n2[0])return n1[0]-n2[0]; else&#123; for(int i=n1[0];i&gt;=1;i--) if(n1[i]!=n2[i])return n1[i]-n2[i]; return 0; &#125;&#125;void output(int s[])&#123; printf("%d",s[s[0]]); for(int i=s[0]-1;i&gt;=1;i--) printf("%04d",s[i]); printf("\n");&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;=n;i++) scanf("%d%d",&amp;p[i].a,&amp;p[i].b),p[i].t=p[i].a*p[i].b; sort(p+1,p+1+n); d1[0]=d2[0]=d2[1]=1; for(int i=0;i&lt;n;i++)&#123; memset(d3,0,sizeof(d3)); d1[1]=p[i].a,mul(d1,d2,d3),memcpy(d2,d3,sizeof(d3)); div(d2,p[i+1].b,d3); if(smaller(ans,d3)&lt;0) memcpy(ans,d3,sizeof(d3)); &#125; output(ans); return 0;&#125; 提高D1T3 开车旅行题目地址 倍增。倍增出小A小B经过$2^k$个回合的情况，然后找最近的最小值用排序+双向链表或者$BST$即可。时间复杂度：$O((n+m)logn)$。边界的一些处理比较烦，需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2100000000using namespace std;typedef long long ll;int high[100005][2],_h[100005][2],lf[100005],rt[100005],n,lg,X,S;ll dis[100005][4],_dis[100005][18][4];//dis [0] 小A开距离 [1]小A开到 [2]小B开距离 [3]小B开到//_dis[i][j]过2^j个回合 [0]小a开距离 [1]小b开距离 [2]开到 [3]总路程 int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;void init()&#123; int i,j,lis[4],m1[2],m2[2],d; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;high[i][0]), high[i][1]=i; memcpy(_h,high,sizeof(high)); qsort(_h,n,sizeof(_h[0]),cmp); lf[_h[0][1]]=-1; for(i=1;i&lt;n;i++) lf[_h[i][1]]=_h[i-1][1]; rt[_h[n-1][1]]=-1; for(i=0;i&lt;n-1;i++) rt[_h[i][1]]=_h[i+1][1]; for(i=0;i&lt;n;i++)&#123; lis[0]=lf[i],lis[1]=rt[i]; lis[2]=(lf[i]&lt;0)?-1:lf[lis[0]]; lis[3]=(rt[i]&lt;0)?-1:rt[lis[1]]; m1[0]=m2[0]=INF; m1[1]=m2[1]=-1; //m1：最小 m2：第二小 [0]距离 [1]位置 for(j=0;j&lt;4;j++) if(lis[j]&gt;=0)&#123; d=abs(high[lis[j]][0]-high[i][0]); if(d&lt;m1[0]||(d==m1[0]&amp;&amp;high[lis[j]][0]&lt;high[m1[1]][0]))//lis[j]的海拔低 m2[0]=m1[0],m2[1]=m1[1], m1[0]=d,m1[1]=lis[j]; else if(d&lt;m2[0]||(d==m2[0]&amp;&amp;high[lis[j]][0]&lt;high[m2[1]][0])) m2[0]=d,m2[1]=lis[j]; &#125; if(m2[0]&gt;=INF)m2[0]=0; if(m1[0]&gt;=INF)m1[0]=0; dis[i][0]=m2[0], dis[i][1]=m2[1], dis[i][2]=m1[0], dis[i][3]=m1[1]; if(rt[i]&gt;=0)lf[rt[i]]=lf[i]; if(lf[i]&gt;=0)rt[lf[i]]=rt[i];//自我删除 &#125; for(i=1,d=0;i&lt;n;i&lt;&lt;=1,d++); lg=d; for(i=0;i&lt;n;i++)&#123; _dis[i][0][0]=dis[i][0]; if(dis[i][1]&gt;=0) _dis[i][0][1]=dis[dis[i][1]][2], _dis[i][0][2]=dis[dis[i][1]][3]; else _dis[i][0][1]=0,_dis[i][0][2]=-1; _dis[i][0][3]=_dis[i][0][0]+_dis[i][0][1]; &#125; for(j=1;j&lt;=lg;j++) for(i=0;i&lt;n;i++)&#123; _dis[i][j][0]=_dis[i][j-1][0], _dis[i][j][1]=_dis[i][j-1][1]; if(_dis[i][j-1][2]&gt;=0)//目的地存在 _dis[i][j][0]+=_dis[_dis[i][j-1][2]][j-1][0], _dis[i][j][1]+=_dis[_dis[i][j-1][2]][j-1][1], _dis[i][j][2]=_dis[_dis[i][j-1][2]][j-1][2]; else _dis[i][j][2]=-1; _dis[i][j][3]=_dis[i][j][0]+_dis[i][j][1]; &#125;&#125;void ask(int id,int &amp;a,int &amp;b)&#123; int i; for(i=lg;i&gt;=0;i-- ) if(_dis[id][i][3]+a+b&lt;=X&amp;&amp;_dis[id][i][2]&gt;=0)&#123; a+=_dis[id][i][0], b+=_dis[id][i][1], ask(_dis[id][i][2],a,b); break; &#125; if(i&lt;0) for(i=0;i&lt;=lg;i++) if(_dis[id][i][0]+a+b&lt;=X)&#123; a+=_dis[id][i][0]; break; &#125;&#125;void solve1()&#123; int i,_d[2],d_[2],ans; double bi=1e12,t1,t2; scanf("%d",&amp;X); for(i=0;i&lt;n;i++)&#123; d_[0]=d_[1]=0; ask(i,d_[0],d_[1]); t1=d_[0],t2=d_[1]; if(!t2)t1=1e11; else t1/=t2; if(bi&gt;t1||(abs(bi-t1)&lt;0.0000001&amp;&amp;high[i][0]&gt;high[ans][0])) bi=t1,_d[0]=d_[0],_d[1]=d_[1],ans=i; &#125; printf("%d\n",ans+1); &#125;void solve2()&#123; int m,i,u,v; scanf("%d",&amp;m); for(i=0;i&lt;m;i++) scanf("%d%d",&amp;S,&amp;X), u=0,v=0, ask(S-1,u,v), printf("%d %d\n",u,v);&#125;int main()&#123; init(); solve1(); solve2(); return 0;&#125; 提高D2T1 同余方程题目地址 就是让你求一个逆元。用快速幂+欧拉函数或者扩欧都行。我只写了扩欧，但是前者应该好写一点。时间复杂度：$O(logn)$12345678910111213141516171819#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; ll d=a; if(b)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125;else x=1,y=0; return d; &#125;int main()&#123; ll a,m,x,y; scanf("%lld%lld",&amp;a,&amp;m); extgcd(a,m,x,y); x=(x%m+m)%m; printf("%lld\n",x); return 0; &#125; 提高D2T2 借教室题目地址 方法一维护一种数据结构，它支持:1.区间减法2.检查最小值的正负性线段树即可。这种方法常数很大。时间复杂度：$O((n+m)logn)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define INF 2000000000using namespace std;typedef long long ll;int seg[2200000],tag[2200000]=&#123;0&#125;;int n,size,_a,_b,m,rec[3][1000005],_v;int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar(); return x;&#125;void pushdown(int id)&#123; if(tag[id]&amp;&amp;id&lt;size) tag[id&lt;&lt;1]+=tag[id],tag[id&lt;&lt;1|1]+=tag[id], seg[id&lt;&lt;1]+=tag[id],seg[id&lt;&lt;1|1]+=tag[id], tag[id]=0; &#125;void init()&#123; int i; for(size=1;size&lt;n;size&lt;&lt;=1); for(i=size;i-size&lt;n;i++)seg[i]=read(); for(;i&lt;(size&lt;&lt;1);i++)seg[i]=INF; for(i=size-1;i&gt;=1;i--) seg[i]=min(seg[i&lt;&lt;1],seg[i&lt;&lt;1|1]);&#125;void minus(int id,int l,int r)&#123; if(l&gt;_b||r&lt;_a)return ; if(_a&lt;=l&amp;&amp;r&lt;=_b)&#123; tag[id]+=_v,seg[id]+=_v; return ; &#125; pushdown(id); minus(id&lt;&lt;1,l,(l+r)&gt;&gt;1); minus(id&lt;&lt;1|1,(l+r+1)&gt;&gt;1,r); seg[id]=min(seg[id&lt;&lt;1],seg[id&lt;&lt;1|1]);&#125;int solve()&#123; for(int i=0;i&lt;m;i++)&#123; _v=-rec[0][i],_a=rec[1][i],_b=rec[2][i], minus(1,1,size); if(seg[1]&lt;0)return i+1; &#125; return -1;&#125;int main()&#123; n=read(),m=read(); init(); for(int i=0;i&lt;m;i++) rec[0][i]=read(),rec[1][i]=read(),rec[2][i]=read(); int ans=solve(); if(ans&lt;0)printf("0\n"); else printf("-1\n%d\n",ans); return 0;&#125; 方法二我们发现随着订单的增多，可用教室的数量是只减不增的，所以我们尝试二分。二分一个最大订单量，然后区间减法用差分实现，最后扫一遍，看看是否存在负值即可。（差分：假设我们有一个数列:a_1,a_2,a_3,...,a_n 定义它的差分数列是a_1,a_2-a_1,a_3-a_2,...a_n-a_{n-1} 这样可以发现差分数列中前$n$个元素的和就是原来数列当前位置元素的值。然后为什么说他可以用来做区间减法呢？比方有$5$个数，$a_1,a_2,a_3,a_4,a_5$，差分数列就是$a_1,a_2-a_1,a_3-a_2,a_4-a_3,a_5-a_4$，然后第$2$到$4$个每一个减掉$p$，那么原数列就是 a_1,a_2-p,a_3-p,a_4-p,a_5新的差分数列就是 a_1,a_2-a_1-p,a_3-a_2,a_4-a_3,a_5-a_4+p可以发现，本来要修改多个元素，在差分数列里就只要修改$2$个元素。由于我们只要在处理完所有区间操作后再扫一遍查询负数，所以这么做能满足我们的需求。时间复杂度：$O((n+m)logn)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,d[N],q[N],s[N],e[N];int oold,nnew;void update()&#123; if(nnew&gt;oold)&#123; for(int i=oold+1;i&lt;=nnew;i++) d[s[i]]-=q[i],d[e[i]+1]+=q[i]; &#125;else&#123; for(int i=oold;i&gt;nnew;i--) d[s[i]]+=q[i],d[e[i]+1]-=q[i]; &#125;&#125;bool C()&#123; int flag=0,sum=0; update(); for(int i=1;i&lt;=n;i++)&#123; sum+=d[i]; if(sum&lt;0)&#123; flag=1; break; &#125; &#125; return flag;&#125;void init()&#123; n=read(),m=read(); int lst=read(); d[1]=lst; for(int i=2;i&lt;=n;i++) d[i]=read(),d[i]-=lst,lst+=d[i]; d[n+1]=-lst; for(int i=1;i&lt;=m;i++) q[i]=read(),s[i]=read(),e[i]=read();&#125;void solve()&#123; int L=1,R=m; oold=0; while(R&gt;L)&#123; nnew=(L+R)&gt;&gt;1; if(C())R=nnew; else L=nnew+1; oold=nnew; &#125; if(L==m)printf("0\n"); else printf("-1\n%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T3 疫情控制题目地址 容易发现时间越多，控制疫情的任务越有可能完成。所以先二分一个答案$x$，然后判断它可不可行。显然，一个军队走的越高，他能控制的就越多，所以让军队尽量向上走，直到走到根或者时间不够为止。如果可以走到根就记录一下走到根的时候剩余的时间，走不到就给最后到的点打一个标记，这个向上走可以用倍增实现。还可以发现的是，与根直接相连的点很重要，我们称呼他们为关键点，只要全部控制了他们就完成了任务。而判断一个关键点是否被控制可以用一遍$DFS$实现。对于没被控制的关键点，我们把他们到根的路径长记录下来。我们要让可以到根的军队发配到相应的关键点，并且使得这个分配尽可能合理。怎么做呢？考虑贪心，让剩余时间少的军队去占领最近的关键点，时间多的去占领远的。所以给军队剩余时间和关键点的距离分别排序，做一个贪心即可。注意，如果当前扫到的军队无法前往最近的关键点，那就让他回到他之前到根的路上经过的关键点。这样可以最大程度的利用军队。综上，我们在$O(nlogn+mlognlogw)$的时间复杂度内完成了本题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 10000000000000ll#define LOG 17using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P left[50005],city[50005];int to[100005],nex[100005],at[50005],cnt=0;int n,m,p[100005],par[50005][20],secfa[50005];int cost[100005],depth[50005],maxd=0,dis[50005][20];int tot=0,totc=0;bool vis[50005];int query(int u,int t)&#123; if(depth[u]&lt;=t)return 1; for(int i=LOG;i&gt;=0;i--) if(par[u][i]&amp;&amp;dis[u][i]&lt;=t) t-=dis[u][i],u=par[u][i]; return u;&#125;void dfs2(int cur,int fa)&#123; if(vis[cur])return ; bool flag=1,isleaf=1; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; dfs2(to[i],cur),flag&amp;=vis[to[i]]; isleaf=0; &#125; if(!isleaf)vis[cur]=flag;&#125;bool C(int x)&#123; tot=totc=0; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=m;i++)&#123; int goal=query(p[i],x); if(goal==1)left[++tot].first=x-depth[p[i]],left[tot].second=p[i]; else vis[goal]=1; //打标记 &#125; dfs2(1,0); if(vis[1])return 1;//根节点的子树全部被覆盖了 for(int i=at[1];i;i=nex[i]) if(!vis[to[i]])city[++totc].second=to[i],city[totc].first=cost[i]; sort(left+1,left+tot+1); sort(city+1,city+totc+1); int r=1,fr; for(int i=1;r&lt;=totc&amp;&amp;i&lt;=tot;i++)&#123; fr=left[i].second; if(left[i].first&lt;city[r].first)&#123; vis[secfa[fr]]=1; &#125;else&#123; vis[city[r].second]=1,r++; &#125; while(vis[city[r].second]&amp;&amp;r&lt;=totc)r++; &#125; if(r==totc+1)return 1; return 0;&#125;void addedge(int _u,int _v,int _c)&#123; to[++cnt]=_v,cost[cnt]=_c,nex[cnt]=at[_u],at[_u]=cnt;&#125;void dfs(int cur,int fa)&#123; par[cur][0]=fa,maxd=max(maxd,depth[cur]); for(int j=1;j&lt;=LOG;j++) if(par[cur][j-1]) par[cur][j]=par[par[cur][j-1]][j-1], dis[cur][j]=dis[cur][j-1]+dis[par[cur][j-1]][j-1]; for(int i=at[cur];i;i=nex[i])&#123; if(to[i]==fa)continue ; int _v=to[i],_c=cost[i]; depth[_v]=depth[cur]+_c, dis[_v][0]=_c; if(cur==1)secfa[_v]=_v; else secfa[_v]=secfa[cur]; dfs(_v,cur); &#125;&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); m=read(); for(int i=1;i&lt;=m;i++)p[i]=read(); dfs(1,0);&#125;void solve()&#123; int son=0; for(int i=at[1];i;i=nex[i])son++; if(son&gt;m)&#123; printf("-1\n"); return ; &#125; int L=0,R=2*maxd,M; while(R&gt;L)&#123; M=(L+R)&gt;&gt;1; if(C(M))R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>数论</tag>
        <tag>贪心</tag>
        <tag>其他DP</tag>
        <tag>SPFA</tag>
        <tag>倍增</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2013%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2013十道题目的题解。 普及T1 计数问题题目地址 某一道著名数位DP的弱化版。模拟即可，时间复杂度为$O(n)$。1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans=0,x;int main()&#123; scanf("%d%d",&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) for(int j=i;j;j/=10) ans+=(j%10==x); printf("%d\n",ans); return 0;&#125; 普及T2 表达式求值题目地址 简单而又基础的表达式计算的题目。连括号都没有，只要注意取模即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;char k[1200005]=&#123;0&#125;;int len,st[2][100005]=&#123;0&#125;,top[2]=&#123;0&#125;,pro[255];void push(int a,int to)&#123; st[to][top[to]++]=a;&#125;int pop(int to)&#123; top[to]--; return st[to][top[to]];&#125;void opr()&#123; int a1,a2,p; a2=pop(1),a1=pop(1),p=pop(0); if(p=='+')push((a1+a2)%10000,1); if(p=='*')push((a1%10000)*(a2%10000)%10000,1);&#125;int main()&#123; fgets(&amp;k[1],1200000,stdin); k[0]='(',len=strlen(k); while(isspace(k[len-1])) k[--len]='\0'; k[len++]=')'; pro['+']=pro['-']=1; pro['*']=pro['/']=2; int sum=-1; for(int i=0;i&lt;len;i++)&#123; if(isdigit(k[i]))&#123; if(sum==-1)sum=k[i]-'0'; else sum=sum*10+k[i]-'0'; &#125;else&#123; if(sum&gt;-1) push(sum,1),sum=-1; if(k[i]=='(') push('(',0); else if(k[i]==')')&#123; while(st[0][top[0]-1]!='(') opr(); pop(0); &#125;else&#123; while(st[0][top[0]-1]!='('&amp;&amp;pro[st[0][top[0]-1]]&gt;=pro[k[i]]) opr(); push(k[i],0); &#125; &#125; &#125; printf("%d\n",pop(1)%10000); return 0; &#125; 普及T3 小朋友的数字题目地址 容易看出这是一个最大子段和的问题。我们知道小朋友的分数是不递减的，所以边算便取模即可。 完了吗？没有。相信很多人都挂在了第一个点。这个点很有意思，因为通过它，我们发现上文的一个重要结论是错的。小朋友的分数在第2-n个是不递减的。但第一个不是。所以要加上对第一个的特判，方法就是：如果当前记录的（分数+特征值）的最大值还是负数，答案就取第一个分数和当前分数的较大值，否则直接取当前分数。因为如果（分数+特征值）的最大值还是负数，那么他一定还有可能小于第一个的分数。时间复杂度：$O(n)$。本题代码可能有疏漏，如果能hack掉请告诉我一声，谢谢！12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 2100000000000000llusing namespace std;typedef long long ll;ll d,maxspc=-INF,sum=0,ans,maxi=-INF,mini=INF,p,sc,beg; int n;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;p,&amp;d); mini=0,sum=d,maxi=d,maxspc=2*d,sc=maxi%p,ans=maxi%p; beg=d; for(int i=2;i&lt;=n;i++)&#123; mini=min(mini,sum), scanf("%lld",&amp;d),sum+=d, maxi=max(maxi,sum-mini);//sp[i] sc=maxspc%p; if(maxi&gt;0)&#123; maxspc=(maxi+sc)%p; if(maxspc&lt;0)ans=max(sc,beg); else ans=sc; &#125; &#125; printf("%lld\n",ans); return 0;&#125; 普及T4 车站分级题目地址 一眼看出来是差分约束，后来发现这个图是一个$DAG$（题目保证存在这么一个方案，就不会有环的存在），求最长路可以直接跑拓扑排序，所以就做完了。时间复杂度为$O(n^2m)$，理论上如此，但实际操作中还行。（主要花在建图上）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,cnt[1005]=&#123;0&#125;,to[1005][1005],lis[1005];int vis[1005],d[1005]=&#123;0&#125;,que[1005],f,r,du[1005]=&#123;0&#125;;bool mat[1005][1005]=&#123;0&#125;;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; memset(vis,0,sizeof(vis)); int u,v,k,fi,en; scanf("%d",&amp;k); for(int j=0;j&lt;k;j++) scanf("%d",&amp;lis[j]),vis[lis[j]]=1; fi=lis[0],en=lis[k-1]; //有无人向我连边？ for(int j=fi+1;j&lt;en;j++)&#123; if(vis[j])continue; for(u=0;u&lt;k;u++) if(!mat[j][lis[u]]) mat[j][lis[u]]=1, to[j][cnt[j]++]=lis[u], du[lis[u]]++; &#125; &#125;&#125;void solve()&#123; int i,j,lst,at,ans=0; memset(vis,0,sizeof(vis)); fill(d+1,d+n+1,-1); f=r=0; for(i=1;i&lt;=n;i++) if(!du[i]) d[i]=0,que[r++]=i; while(r-f)&#123; int h=que[f++],v; for(int i=0;i&lt;cnt[h];i++)&#123; v=to[h][i]; d[v]=max(d[v],d[h]+1); du[v]--; if(!du[v])que[r++]=v; &#125; ans=max(ans,d[h]); &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 转圈游戏题目地址 相当于每一次对编号加一个$m$，然后对$n$取模，如此做$10^k$次。所以答案就是$(m+m+m+…+m+x)\mod n=(m\times 10^k+x)\mod n$。使用快速幂即可，时间复杂度$O(logk)$。1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll n,m,k,x;int main()&#123; scanf("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;x); printf("%lld\n",((Pow(10%n,k,n))*m+x)%n); return 0;&#125; 提高D1T2 火柴排队题目地址 如果你知道什么叫排序不等式，这题就是道裸题。如果你不知道，额，你也可以自己证明：当a_1]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>拓扑排序</tag>
        <tag>贪心</tag>
        <tag>MST</tag>
        <tag>线性DP</tag>
        <tag>LCA</tag>
        <tag>树状数组</tag>
        <tag>差分约束</tag>
        <tag>快速幂</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2015%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2015十道题目的题解。 普及T1 金币题目地址 模拟123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int k,ans=0; scanf("%d",&amp;k); for(int i=1,j=1;i&lt;=k;i++)&#123; ans+=j; if(j*(j+1)/2==i)j++; &#125; printf("%d\n",ans); return 0;&#125; 普及T2 扫雷游戏题目地址 模拟1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,mat[105][105],dx[]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;-1,0,1,-1,1,-1,0,1&#125;;char s[105];void get(int x,int y)&#123; int res=0; for(int i=0;i&lt;8;i++) res+=(mat[x+dx[i]][y+dy[i]]==-1); mat[x][y]=res; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) mat[i][j]-=(s[j]=='*'); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) if(!mat[i][j])get(i,j),printf("%d",mat[i][j]); else putchar('*'); putchar('\n'); &#125; return 0;&#125; 普及T3 求和题目地址 我们挖掘条件的性质可以发现：$y$无关紧要，当$x$和$z$的奇偶性相同时，他们之间旧就会产生分数。所以每一种颜色分奇偶计数，然后一种颜色一个奇偶性产生的分数为 score=(s_4-2)\times s_1+s_2\times s_3其中$s_4$为该种颜色该种奇偶性的格子数，$s_1$为这些格子$x\times num_x$的和，$s_2$和$s_3$分别为这些格子$x$和$num_x$的和。其中$x$指编号，$num_x$指编号为$x$的格子上的数。证明过程略，可以自己手动推导。综上，这个算法的时间复杂度是$O(n+m)$。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define INF 2000000000#define M 10007using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,num[100005],col[100005],ans=0;int s1[100005][2],s2[100005][2],s3[100005][2],s4[100005][2];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)num[i]=read()%M; for(int i=1;i&lt;=n;i++)col[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; int c=col[i],B=i&amp;1; s1[c][B]+=i*num[i],s1[c][B]%=M; s2[c][B]+=i,s2[c][B]%=M; s3[c][B]+=num[i],s3[c][B]%=M; s4[c][B]++; &#125; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;2;j++) ans+=(s4[i][j]-2)*s1[i][j]%M, ans+=s2[i][j]*s3[i][j]%M, ans%=M; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 普及T4 推销员题目地址 一道贪心。我们可以先算出总的疲劳值，然后每一次选择哪一户人家再也不去。这个时候，我们要保证减少的疲劳值最少。我们可以发现一次只有$2$种删去住户的决策：如图，$head$表示当前疲劳值消耗最小的住户编号，$last$表示最低端的住户编号，$front$是$last$前一个住户的编号。每一次可以去掉$head$，也可以去掉$last$。而去掉$last$就没必要走$front$到$last$的路了，所以第二种决策会减少$(dis[last]-dis[front])\times 2+last$需要的疲劳值。对住户的(疲劳值,编号)二元组按疲劳值排个序，然后维护以上3个量即可：$last$,$front$和$head$。注意，还需要维护每一个住户是否已经被清除，是的话要打标记，否则$head$指向的住户可能会是$last$，这样就不合法。时间复杂度：$O(nlogn)$1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define M 100005using namespace std;int dis[M],cost[M][2],ans[M],tmp[M],front,t,n,last,head;bool vis[M]=&#123;0&#125;;int cmp(const void *a,const void *b)&#123; return *(int*)a-*(int*)b;&#125;int main()&#123; scanf("%d",&amp;n); int i; for(i=0;i&lt;n;i++) scanf("%d",&amp;dis[i]); ans[n-1]=dis[n-1]*2; for(i=0;i&lt;n;i++) scanf("%d",&amp;tmp[i]), cost[i][1]=i, cost[i][0]=tmp[i], ans[n-1]+=cost[i][0]; qsort(cost,n,sizeof(cost[0]),cmp); last=n-1,front=n-2,head=0; vis[last]=true; for(i=n-2;i&gt;=0;i--)&#123; ans[i]=ans[i+1]; while(head&lt;n&amp;&amp;(vis[cost[head][1]]))head++; t=(dis[last]-dis[front])*2+tmp[last]; if(t&lt;cost[head][0]) vis[last]=vis[front]=1, ans[i]-=t, last=front--; else vis[cost[head][1]]=1, ans[i]-=cost[head][0], head++; while(vis[front])front--; &#125; for(i=0;i&lt;n;i++) printf("%d\n",ans[i]); return 0;&#125; 提高D1T1 神奇的幻方题目地址 模拟12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int n,ans[50][50]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); int i,j,x,y; for(i=2,x=0,y=n/2,ans[x][y]=1;i&lt;=n*n;i++)&#123; if(!x)&#123; if(y==n-1)x++; else x=n-1,y++; &#125;else&#123; if(y==n-1)y=0,x--; else &#123; if(!ans[x-1][y+1]) x--,y++; else x++; &#125; &#125; ans[x][y]=i; &#125; for(i=0;i&lt;n;i++,printf("\n")) for(j=0;j&lt;n;j++,(j&lt;n)?printf(" "):0) printf("%d",ans[i][j]); return 0;&#125; 提高D1T2 信息传递题目地址 乱搞。题目：求最小环。解：爆搜/tarjan。能用tarjan是因为这里面的强连通分量只能是简单环。 DFS解法123456789101112131415161718192021222324#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int n,to[200005],vis[200005]=&#123;0&#125;,ans=INF;void dfs(int cur,int st)&#123; if(vis[cur]==-1)return ; if(vis[cur])&#123; ans=min(ans,st-vis[cur]); vis[cur]=-1; return ; &#125; vis[cur]=st; dfs(to[cur],st+1),vis[cur]=-1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;to[i]); for(int i=1;i&lt;=n;i++) dfs(to[i],1); printf("%d\n",ans); return 0; &#125; Tarjan解法12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define addedge(_u,_v) edge[cnt].v=_v,edge[cnt].next=at[_u],at[_u]=cnt,cnt++using namespace std;typedef struct &#123; int v,next;&#125;Edge;Edge edge[200105];int at[200005],VNum,mini,D=0;int dfn[200005]=&#123;0&#125;,low[200005],stack[200005],top=0;bool in[200005];void init()&#123; int i,cnt=0,a,b,t; memset(at,-1,sizeof(at)); for(i=0;i&lt;VNum;i++) scanf("%d",&amp;a),addedge(i,a-1);&#125;void tarjan_scc(int id)&#123; dfn[id]=low[id]=++D; in[id]=true;stack[top++]=id; int i=at[id],vv;while(i!=-1)&#123;vv=edge[i].v; if(!dfn[vv])tarjan_scc(vv),low[id]=min(low[id],low[vv]); else if(in[vv])low[id]=min(low[id],dfn[vv]); i=edge[i].next; &#125; if(dfn[id]==low[id])&#123; i=0; do in[stack[--top]]=false,i++; while(stack[top]!=id); if(i!=1)mini=min(mini,i); &#125;&#125;int main()&#123; scanf("%d",&amp;VNum); init(); mini=VNum; for(int i=0;i&lt;VNum;i++)if(!dfn[i])tarjan_scc(i); printf("%d\n",mini); return 0;&#125; 提高D1T3 斗地主题目地址 部分搜索。先搞掉所有顺子，然后问题转化为一个简单的最优化问题，dp可解。设$f(i,j,k,l)$为一副牌，有$i$份4张，$j$份3张，$k$份2张，$l$份1张，最少打几次。这个最开始就可以做。然后搜索即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//剪枝:出牌数递减，（牌大小递增） //贪心：5个直接搞 int n,cnt[20],ans;int f[7][9][13][24],pat[5];void dp()&#123;//与顺子无关的dp memset(f,0x3f,sizeof(f)); f[0][0][0][0]=0; int xa=n/4,xb=n/3,xc=n/2; for(int i=0;i&lt;=xa;i++) for(int j=0;j&lt;=xb;j++) for(int k=0;k&lt;=xc;k++) for(int l=0;l&lt;=n;l++)&#123; int &amp;t=f[i][j][k][l]; if(i)&#123; t=min(t,f[i-1][j][k][l]+1); if(l&gt;=2)t=min(t,f[i-1][j][k][l-2]+1); if(k&gt;=2)t=min(t,f[i-1][j][k-2][l]+1); &#125; if(j)&#123; t=min(t,f[i][j-1][k][l]+1); if(l)t=min(t,f[i][j-1][k][l-1]+1); if(k)t=min(t,f[i][j-1][k-1][l]+1); &#125; if(k)t=min(t,f[i][j][k-1][l]+1); if(l)t=min(t,f[i][j][k][l-1]+1); &#125;&#125;int small_solve()&#123; for(int i=0;i&lt;=4;i++)pat[i]=0; for(int i=0;i&lt;=13;i++)pat[cnt[i]]++; return f[pat[4]][pat[3]][pat[2]][pat[1]];&#125;void dfs(int cd,int st)&#123; if(st+1&gt;=ans&amp;&amp;cd!=0)return ; if(cd==0)&#123; ans=min(ans,st); return ; &#125; int flag=0; //只搜索顺子 for(int k=1;k&lt;=12;k++)&#123; if(cnt[k]&gt;=3)&#123; if(k&lt;=11)&#123; for(int i=k+1;i&lt;=12&amp;&amp;cnt[i]&gt;=3;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=3; dfs(cd-(i-k+1)*3,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=3; &#125; &#125; &#125; if(cnt[k]&gt;=2)&#123; if(k&lt;=10&amp;&amp;cnt[k+1]&gt;=2)&#123; for(int i=k+2;i&lt;=12&amp;&amp;cnt[i]&gt;=2;i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]-=2; dfs(cd-(i-k+1)*2,st+1); for(int j=k;j&lt;=i;j++)cnt[j]+=2; &#125; &#125; &#125; if(cnt[k])&#123; if(k&lt;=8&amp;&amp;cnt[k+1]&amp;&amp;cnt[k+2]&amp;&amp;cnt[k+3])&#123; for(int i=k+4;i&lt;=12&amp;&amp;cnt[i];i++)&#123; flag=1; for(int j=k;j&lt;=i;j++)cnt[j]--; dfs(cd-(i-k+1),st+1); for(int j=k;j&lt;=i;j++)cnt[j]++; &#125; &#125; &#125; &#125; ans=min(ans,st+small_solve());&#125;void init()&#123; ans=n; memset(cnt,0,sizeof(cnt)); int u; for(int i=1;i&lt;=n;i++)&#123; u=read(); if(!u)cnt[u]++; else if(u&lt;=2)cnt[u+11]++; else cnt[u-2]++; read(); &#125;&#125;void solve()&#123; dfs(n,0); printf("%d\n",ans);&#125;int main()&#123; int T=read(); n=read(); dp(); while(T--)&#123; init(); solve(); &#125; return 0;&#125; 提高D2T1 跳石头题目地址 看到描述就看的出是二分答案。二分答案，设为$x$，把石头排序之后扫一遍，看看是否有石头与前一个石头的间隔小于$x$，有的话拆掉该石头，否则把这个石头作为“前一个石头”，再看下一个。如果拆的次数大于$M$就判定失败，否则判定成功。时间复杂度$O(NlogL)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,m,at[50005];bool C(int x)&#123; int left=m,lst=0; for(int i=2;i&lt;=n+2;i++)&#123; if(at[i]-lst&lt;x)left--; else lst=at[i]; if(left&lt;0)return 0; &#125; return 1;&#125;void init()&#123; L=read(),n=read(),m=read(); at[1]=0,at[n+2]=L; for(int i=2;i&lt;=n+1;i++) at[i]=read(); sort(at+2,at+n+2);&#125;void solve()&#123; int l=0,r=L,mid; while(r&gt;l)&#123; mid=(l+r+1)&gt;&gt;1; if(C(mid))l=mid; else r=mid-1; &#125; printf("%d\n",l);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T2 子串题目地址 看数据范围猜算法系列时间复杂度相信各位都看的出来：$O(nmk)$怎么刻画状态呢？首先有$2$维必不可缺：$i$表示$A$前$i$个字符，$j$表示$B$前$j$个字符。这里指的是用前$i$个$A$的字符来匹配$B$的前$j$个字符，串$A$的前$i$个不一定要严格匹配，但串$B$的前$j$个必须严格匹配上。之后，段也要表示：$t$表示现在做了$t$段。看到这些段不是连续的，所以使用情况也要表示出来，设一个布尔变量$l$表示串$A$的这个字符是不是被使用了，是为$1$，不是为$0$。够了，用$f(i,j,t,l)$来表示。不使用这个字符，就继承串$A$上一位的状态。使用的话，必须匹配成功，然后有$2$个决策：开启新的一段（前一个字符没用的话就默认开启新的一段了），或者接上前一段。得到状态转移方程： f(i,j,t,0)=f(i-1,j,t,0)+f(i-1,j,t,1) \\ f(i,j,t,1)= \begin{cases} f(i-1,j-1,t,1)+f(i-1,j-1,t-1,0)+f(i-1,j-1,t-1,1) \quad (a[i]=b[j]) \\0\quad (a[i] \neq b[j]) \end{cases}初始是$f(i,0,0,0)=1$。要用滚动数组，不然MLE。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,k,dp[2][205][205][2]=&#123;0&#125;,ans=0,M=1000000007;char a[1005]=&#123;0&#125;,b[205]=&#123;0&#125;;int main()&#123; scanf("%d%d%d%s%s",&amp;n,&amp;m,&amp;k,&amp;a[1],&amp;b[1]); int i,j,o,p,t; dp[0][0][0][0]=dp[1][0][0][0]=1; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; for(o=1;o&lt;=k;o++)&#123; if(a[i]==b[j]) dp[i&amp;1][j][o][1]=(( dp[1^(i&amp;1)][j-1][o-1][0]+ dp[1^(i&amp;1)][j-1][o][1])%M+ dp[1^(i&amp;1)][j-1][o-1][1])%M; else dp[i&amp;1][j][o][1]=0; dp[i&amp;1][j][o][0]=( dp[1^(i&amp;1)][j][o][0]+// dp[1^(i&amp;1)][j][o][1])%M; &#125; &#125; &#125; printf("%d\n",(dp[n&amp;1][m][k][0]+dp[n&amp;1][m][k][1])%M); return 0;&#125; 提高D2T3 运输计划题目地址 直接求解显然很困难，考虑转化为判定性问题，二分一个答案$x$，判定他是否可行。完成一次运输的时间取决于最长路的大小，也就是保证所有路径的长度都小于$x$。考虑大于$x$的路径，在他们的公共路上删掉一段路才可以使他们一起变小。理所当然的，这段路必须是他们的公共路径中最长的一段。怎么找这条最长的公共路呢？我们可以玩一玩区间加法，给每一个在$(u,v)$两点上的路径打一个标记，这样就说明这些点在$(u,v)$路径上。如果两点的标记数都等于长度大于$x$的路径总数，呢么两点间的这段路就是他们的公共路径。区间加法有$2$种实现方式：一种是树剖/$LCT$，一种是树上差分（和序列上的没区别）。由于只需要查询一遍，没必要用什么奇奇怪怪的数据结构，所以用差分，在$x$和$y$上打一个$+1$标记，在$LCA$处打一个$-2$标记。由于是对点操作，所以要把边和点捆绑起来。具体不难实现。时间复杂度取决于求解$LCA$时所用算法的时间复杂度。用倍增的时间复杂度是$O((n+m)logn)$。注意卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXN 300005using namespace std;typedef struct&#123; int v,cost,_next; &#125;Edge; Edge edge[MAXN*2];int n,m,par[MAXN][20]=&#123;0&#125;,dis[MAXN]=&#123;0&#125;,cnt=0,at[MAXN];int son[MAXN]=&#123;0&#125;,bro[MAXN]=&#123;0&#125;,depth[MAXN];int bus[MAXN][4],_dis[MAXN];// 0 路径长 1 _dis 到父亲的路径长 int dec[MAXN]=&#123;0&#125;,que[MAXN],f,r,sum[MAXN];int cmp(const void *a,const void *b)&#123; return *(int*)b-*(int*)a;//从大到小 &#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;int bs(int lth)&#123; int s=0,len=m,md,pos; while(len)&#123; md=s+(len&gt;&gt;1); if(lth&lt;bus[md][0]) s=md+1,len=len-(len&gt;&gt;1)-1; else len&gt;&gt;=1; &#125; return s;&#125;void _init()&#123; int i,j,h,u,v,c; f=r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; h=que[f++]; for(i=at[h];i!=-1;i=edge[i]._next)&#123; v=edge[i].v; if(v==par[h][0])continue; que[r++]=v, depth[v]=depth[h]+1, par[v][0]=h, bro[v]=son[h],son[h]=v, _dis[v]=edge[i].cost, dis[v]=dis[h]+_dis[v]; &#125; for(i=1;i&lt;=19;i++) if(par[h][i-1]) par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j; if(depth[u]&lt;depth[v]) swap(u,v); for(i=0;(1&lt;&lt;i)&lt;=depth[u]-depth[v];i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=19;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;int C(int tot)&#123; int i,j,h,maxi=0,_max=0; for(i=r-1;i&gt;=0;i--)&#123; h=que[i]; for(sum[h]=dec[h],j=son[h];j;j=bro[j]) sum[h]+=sum[j]; if(sum[h]&gt;maxi) maxi=sum[h],_max=_dis[h]; else if(sum[h]==maxi) _max=max(_max,_dis[h]); &#125; return maxi==tot?_max:0; &#125;void prepare()&#123; n=read(),m=read(); int i,j,u,v,c; memset(at,-1,sizeof(at)); for(i=0;i&lt;n-1;i++) u=read(),v=read(),c=read(), addedge(u,v,c), addedge(v,u,c); _init(); for(i=0;i&lt;m;i++) u=read(),v=read(), bus[i][1]=u,bus[i][2]=v, bus[i][3]=query(u,v), bus[i][0]=dis[u]+dis[v]-2*dis[bus[i][3]];&#125;void solve()&#123; qsort(bus,m,sizeof(bus[0]),cmp); int s=max(0,bus[m-1][0]-1001),t=bus[0][0],md,i,w; while(t-s)&#123; md=(t+s)/2; memset(dec,0,sizeof(dec)); for(i=0;i&lt;m&amp;&amp;bus[i][0]&gt;md;i++) dec[bus[i][1]]++, dec[bus[i][2]]++, dec[bus[i][3]]-=2; w=C(i); if(bus[0][0]-w&lt;=md)t=md; else s=md+1; &#125; printf("%d\n",s);&#125;int main()&#123; prepare(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>DFS</tag>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>其他DP</tag>
        <tag>字符串DP</tag>
        <tag>LCA</tag>
        <tag>差分</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2014%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2014十道题目的题解。 普及T1 珠心算测验题目地址 没读懂题目就会被坑。模拟即可，但是要注意先去重，不然会多次统计。另外还要注意整数对的无序性。也就是说，两个数$a+b=c$和$b+a=c$不能算$2$遍。在找到这个数$c$后，还要及时把他删除，以免多次统计。所以，$O(n^2)$扫一遍即可。12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int a[104],n,ans=0;char vis[20004]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); sort(a,a+n); n=unique(a,a+n)-a; for(int i=0;i&lt;n;i++)vis[a[i]]=1; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) if(vis[a[i]+a[j]])ans++,vis[a[i]+a[j]]=0; printf("%d\n",ans); return 0;&#125; 普及T2 比例简化题目地址 方法一模拟即可，注意简化后分数和原分数的比较，涉及浮点数的运算。时间复杂度$O(L^2)$。123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int a,b,lim,fz,fm;double bi,mini=1e9,cur;int gcd(int a,int b)&#123; return (!b)?a:gcd(b,a%b);&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;lim); bi=(double)a/b,cur=1e9; for(int i=1;i&lt;=lim;i++) for(int j=1;j&lt;=lim;j++)&#123; double t=(double)i/j; if(t-bi&gt;0&amp;&amp;t-bi&lt;cur) cur=t-bi,fz=i,fm=j; else if(fabs(t-bi)&lt;1e-8)&#123; fz=i,fm=j;break; &#125; &#125; int g=gcd(fz,fm); fz/=g,fm/=g; printf("%d %d\n",fz,fm); return 0;&#125; 方法二对每一个不大于$L$的数进行一次二分，找出以此数为分母时最接近$\frac {A}{B}$的分数的分子。时间复杂度：$O(LlogL)$。 普及T3 螺旋矩阵题目地址 观察发现这个结构很有规律，因为螺旋矩阵是一层一层螺旋的，所以考虑一层一层递进求解。我们每一次去掉矩阵最外面的一层，如12341 2 3 4 12 13 14 5 ---&gt; 13 1411 16 15 6 ---&gt; 16 1510 9 8 7 这样里面还是一个螺旋矩阵，但由$n\times n$变为了$(n-2)\times (n-2)$。最后到了要求的数的那一层的时候采用模拟算法，算出那个数即可。时间复杂度：$O(n)$。1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n,x,y,tot=0;int main()&#123; scanf("%d%d%d",&amp;n,&amp;x,&amp;y); for(;x!=1&amp;&amp;y!=1&amp;&amp;x!=n&amp;&amp;y!=n;) tot+=4*n-4,n-=2,x--,y--; if(x==1)tot+=y; else&#123; tot+=n-1; if(y==n)tot+=x; else&#123; tot+=n-1; if(x==n)tot+=(n-y+1); else&#123; tot+=n-1; if(y==1)tot+=(n-x+1); &#125; &#125; &#125; printf("%d\n",tot); return 0;&#125; 普及T4 子矩阵题目地址 这题一脸不可做。是吗？我们先尝试搜索，按照计算，我们最多搜索$(C_{16}^8)^2$次。这样会$TLE$。别急，先搜出我们当前选取的行。然后问题就转化为了求这些行中某些列产生的最小的分数。这个问题我们就很熟悉了，这不是一个$O(m^2)$的$DP$么？设$f(i,j)$为选了$i$列，当前在第$j$列时最小的分数，则状态转移方程易导出。综上，我们使用搜索和$DP$相结合的方法解决了本题。实际上，这样的搜索和高效算法结合的思想早在许多年前就已经用到（即$NOI2003$智破连环阵），在这里出现着实很妙。而在$NOIP2015$中也有这样的思想。时间复杂度：$O(C_n^mm^2)$（近似）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,r,c,mat[20][20],ans=1000000000;int cur_r[20],cur_c[20],v_c[20]=&#123;0&#125;,w[20][20],dp[20][20]=&#123;0&#125;;void dfs_c(int at,int cur)&#123; int fm=cur_c[at-1],val,pos; cur+=v_c[fm]; if(cur&gt;=ans)return; if(at==c)&#123; ans=min(ans,cur);return ; &#125; for(int i=fm+1;i&lt;=m-c+at;i++)&#123; cur_c[at]=i; if(cur&gt;=ans)return ; else dfs_c(at+1,cur); for(int j=0;j&lt;r;j++)&#123; pos=cur_r[j]; val=mat[pos][i]-mat[pos][fm]; if(val&lt;0)val=-val; cur-=val; &#125; &#125;&#125;void solve_()&#123; int pos; memset(v_c,0,sizeof(v_c)); memset(w,0,sizeof(w)); memset(dp,0,sizeof(dp)); for(int i=0;i&lt;m;i++) for(int j=1;j&lt;r;j++) v_c[i]+=abs(mat[cur_r[j]][i]-mat[cur_r[j-1]][i]); for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=0;k&lt;r;k++) pos=cur_r[k], w[i][j]+=abs(mat[pos][i]-mat[pos][j]); for(int i=0;i&lt;m;i++) dp[1][i]=v_c[i]; for(int i=2;i&lt;=c;i++)&#123; for(int j=0;j&lt;m;j++)&#123; pos=1000000000; for(int k=0;k&lt;j;k++) if(dp[i-1][k]+w[k][j]&lt;pos) pos=dp[i-1][k]+w[k][j]; dp[i][j]=pos+v_c[j]; &#125; &#125; for(int i=c-1;i&lt;m;i++) ans=min(ans,dp[c][i]);&#125;void dfs_r(int at)&#123; int fm=cur_r[at-1],val; for(int i=fm+1;i&lt;=n-r+at;i++)&#123; cur_r[at]=i; for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]+=val; &#125; if(at==r-1)solve_(); else dfs_r(at+1); for(int j=0;j&lt;m;j++)&#123; val=mat[i][j]-mat[fm][j]; if(val&lt;0)val=-val; v_c[j]-=val; &#125; &#125;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;r,&amp;c); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;mat[i][j]);&#125;void solve()&#123; for(int i=0;i&lt;=n-r;i++)&#123; cur_r[0]=i; dfs_r(1); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 生活大爆炸版石头剪刀布题目地址 判断胜负你可以用一堆if else 或者 switch case，但最简便的还是打表计算。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int tab[5][5]=&#123;//A打B &#123;0,0,1,1,0&#125;, &#123;1,0,0,1,0&#125;, &#123;0,1,0,0,1&#125;, &#123;0,0,1,0,1&#125;, &#123;1,1,0,0,0&#125;&#125;;int n,na,nb,a[205],b[205],ans1=0,ans2=0;void init()&#123; n=read(),na=read(),nb=read(); for(int i=0;i&lt;na;i++)a[i]=read(); for(int i=0;i&lt;nb;i++)b[i]=read();&#125;void solve()&#123; int ra,rb; for(int i=0;i&lt;n;i++) ra=i%na,rb=i%nb, ans1+=tab[a[ra]][b[rb]],ans2+=tab[b[rb]][a[ra]]; printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T2 联合权值题目地址 这是一棵树，同时点对距离为$2$这个条件也很微妙，所以先把他转化为一棵有根树，再利用父子关系求解。距离为$2$，我们可以枚举中心点。对于树上的一个点来说，这意味着以他为中心点的点对是由它的父亲与儿子，儿子与儿子构成的。这样最大的权值好做了，记录儿子中的最大权值和次大权值，比较父亲的权值和儿子中最大权值的积以及儿子中最大、次大权值的积，以此更新答案即可。但是权值的和就比较麻烦，儿子和父亲形成的点对的权值和好算，但儿子之间相互的乘积是相互乘的，一次要花费$O(儿子数^2)$的时间计算。最坏情况下是$O(n^2)$的。如何优化？这需要一些数学知识。设儿子的权值为a_1,a_2,a_3,...,a_m,那么儿子们的联合权值之和就是a_1a_2+a_1a_3+...+a_1a_m+a_2a_3+...+a_2a_m+...+a_{m-1}a_m。这里不加证明的给出$2$种在$O(n)$时间计算该值的方法：1.设f(i)=a_1+a_2+...+a_i，g(i)=a_1a_2+a_1a_3+...+a_1a_i+a_2a_3+...+a_2a_i+...+a_{i-1}a_i。更新$g(i)$需要$f(i)$。步骤如下：初始$f(0)=g(0)=0$，$i=1$。（1：g(i)=g(i-1)+a_i\times f(i-1)（2：f(i)=f(i-1)+a_i（3：$i=i+1$2.展开(a_1+a_2+a_3+...+a_m)^2可知维护儿子的权值和和权值平方和就可以算出联合权值之和。代码用的是方法2.综上所述，在使用$DFS/BFS$对树进行遍历的情况下，以上算法的时间复杂度是$O(n)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt; using namespace std;typedef struct&#123; int w,par,son,bro;&#125;Tree;Tree tr[200005];int n,q[200005],f=0,r=0,M=10007,ans=0,ans2=0;void prepare()&#123; int i,h,sum,sum2,mx,mx2,e; for(i=0;i&lt;n;i++) if(tr[i].par&lt;0)&#123;q[r++]=i;break;&#125; while(r-f)&#123; h=q[f++],sum=sum2=mx=mx2=0; for(i=tr[h].son;i!=-1;i=tr[i].bro)&#123; e=tr[i].w, sum=(sum+e)%M, sum2=(sum2+(e*e)%M)%M; if(e&gt;mx)mx2=mx,mx=e; else if(e&gt;mx2)mx2=e; q[r++]=i; &#125; ans2=max(ans2,max(mx*mx2,mx*tr[tr[h].par].w)), ans=(ans+(tr[tr[h].par].w*sum*2)%M)%M, ans=(ans+(sum*sum-sum2)%M+M)%M; &#125;&#125;int main()&#123; scanf("%d",&amp;n); int i,u,v; for(i=0;i&lt;n;i++) tr[i].par=tr[i].son=tr[i].bro=-1; for(i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v), u--,v--; if(tr[v].par&gt;=0)swap(u,v); tr[v].par=u,tr[v].bro=tr[u].son,tr[u].son=v; &#125; for(i=0;i&lt;n;i++) scanf("%d",&amp;tr[i].w); prepare(); printf("%d %d\n",ans2,ans); return 0;&#125; 提高D1T3 飞扬的小鸟题目地址 一个背包DP的模型。按$x$坐标划分阶段，状态是坐标，决策有：1.点若干次屏幕；2.不点屏幕。发现决策$1$对应无限背包，决策$2$对应$01$背包。所以做一次DP。设$f(i,j,l)$表示到了点$(i,j)$最少需要点击屏幕的次数，其中$l=0$表示本次不点击屏幕，$l=1$表示本次点击。则状态转移方程容易导出，在此就不列出了。在转移的时候注意之前转移而来的状态和当前转移的合法性，以及一个细节：在最高处，小鸟可以平移飞行。时间复杂度：$O(nm)$（近似，因为在最高点有一次枚举）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define INF 2000000000using namespace std;int dp[2][1005][2],n,m,k,up[10005],down[10005],rec[10005][2];void input()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int i,j; for(i=0;i&lt;n;i++) scanf("%d%d",&amp;up[i],&amp;down[i]), rec[i][0]=-1,rec[i][1]=m+3; rec[n][0]=-1,rec[n][1]=m+3; for(i=0;i&lt;k;i++) scanf("%d",&amp;j), scanf("%d%d",&amp;rec[j][0],&amp;rec[j][1]);&#125;void solve()&#123; int res,ans,i,j,t,u,v,o,l,p,q; for(i=0;i&lt;=m;i++) dp[0][i][0]=dp[0][i][1]=0; for(i=1;i&lt;=n;i++)&#123; for(o=0,j=1;j&lt;=m;j++)&#123; dp[i&amp;1][j][0]=dp[i&amp;1][j][1]=INF; if(j+down[i-1]&lt;=m) p=(j+down[i-1]&lt;rec[i-1][1])&amp;&amp;(j+down[i-1]&gt;rec[i-1][0]), q=(j&lt;rec[i][1])&amp;&amp;(j&gt;rec[i][0]), u=(p)?dp[1^(i&amp;1)][j+down[i-1]][0]:INF, v=(p)?dp[1^(i&amp;1)][j+down[i-1]][1]:INF, dp[i&amp;1][j][0]=(q)?min(u,v):INF; if(j-up[i-1]&gt;0) for(l=(j==m)?0:up[i-1];l&lt;=up[i-1];l++) p=(j-l&lt;rec[i-1][1])&amp;&amp;(j-l&gt;rec[i-1][0]), t=dp[i&amp;1][j-l][1], u=(p)?dp[1^(i&amp;1)][j-l][0]:INF, v=(p)?dp[1^(i&amp;1)][j-l][1]:INF, t=min(min(u,v),t), dp[i&amp;1][j][1]=min(dp[i&amp;1][j][1],t+1); if(j&lt;rec[i][1]&amp;&amp;j&gt;rec[i][0]&amp;&amp;(dp[i&amp;1][j][0]&lt;INF|| dp[i&amp;1][j][1]&lt;INF))o=1; &#125; if(!o)&#123;res=0;break;&#125; &#125; if(i==n+1)res=1; printf("%d\n",res); if(res) for(ans=INF,j=n,i=1;i&lt;=m;i++) ans=min(ans,min(dp[j&amp;1][i][0],dp[j&amp;1][i][1])); else for(ans=0,j=0;j&lt;i;j++) if(rec[j][0]!=-1)ans++; printf("%d\n",ans);&#125;int main()&#123; input(); solve(); return 0;&#125; 提高D2T1 无线网络发射器选址题目地址 枚举一下路口即可。或者玩矩阵前缀和。时间复杂度：$O(128^2 n)$或者$O(d^2)$（理论上）12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int d,R,n,sum[1000][1000],cnt=0,ans=0;void init()&#123; d=read(),n=read(),R=(d&lt;&lt;1|1); for(int i=1;i&lt;=n;i++) sum[read()+R][read()+R]=read(); for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i][j-1]; for(int i=R;i&lt;=128+R+d;i++) for(int j=R;j&lt;=128+R+d;j++) sum[i][j]+=sum[i-1][j];&#125;void solve()&#123; for(int i=R+d;i&lt;=128+R+d;i++) for(int j=R+d;j&lt;=128+R+d;j++)&#123; int val=sum[i][j]-sum[i-R][j]-sum[i][j-R]+sum[i-R][j-R]; if(val&gt;ans)ans=val,cnt=1; else if(val==ans)cnt++; &#125; printf("%d %d\n",cnt,ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T2 寻找道路题目地址 考虑先删不合法的点，再跑一遍BFS找到最短路。首先把边反向，从终点跑一下，看看哪些点是合法的。遍历到的点都是和终点直接或者间接连通着的。对于没有被遍历到的点，就要取消它和它连着的点的合法性。这一步可以直接在下一步跑最短路的时候做。时间复杂度：$O(n)$。注意判断起点的合法性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;typedef long long ll;typedef struct&#123; int v,_nex;&#125;Edge;Edge edge[400005];char vis[10005]=&#123;0&#125;;int n,m,que[20005],f,r,at[10005],cnt=0,S,T,d[10005];int at_[10005];void bfs1()&#123; f=r=0; que[r++]=T,vis[T]=1; int h,i,j,v; while(r-f)&#123; h=que[f++]; for(i=at[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!vis[v]) vis[v]=1,que[r++]=v; &#125; &#125;&#125;bool judge(int u)&#123; for(int i=at_[u];i;i=edge[i]._nex) if(!vis[edge[i].v])return 0; return 1;&#125;void bfs2()&#123; if(!judge(S))return ; d[S]=0,f=r=0; que[r++]=S; int i,j,h,v,st; while(r-f)&#123; h=que[f++]; for(i=at_[h];i;i=edge[i]._nex)&#123; v=edge[i].v; if(!judge(v))continue; if(d[v]&gt;d[h]+1) d[v]=d[h]+1,que[r++]=v; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i,j,u,v; for(i=0;i&lt;m;i++) scanf("%d%d",&amp;u,&amp;v), edge[++cnt].v=u,edge[cnt]._nex=at[v],at[v]=cnt; scanf("%d%d",&amp;S,&amp;T); fill(d+1,d+n+1,INF); bfs1(); for(i=1;i&lt;=n;i++) for(j=at[i];j;j=edge[j]._nex) edge[++cnt].v=i,edge[cnt]._nex=at_[edge[j].v],at_[edge[j].v]=cnt; bfs2(); if(d[T]==INF)printf("-1\n"); else printf("%d\n",d[T]); return 0;&#125; 提高D2T3 解方程题目地址 高精大概可以做到$50$分。想一想，带进去一个$x$，怎么判断左边是否是$0$呢？可不可以避免计算这个准确值呢？学过哈希，我们知道可以把字符串映射到一个值上，值相等那么认为两个字符串相等。但是这个数一般而言很大，所以要对素数取模，来缩小这个值。（虽然哈希跟这题没什么关系）我们也可以用这种类似的做法。对于一个$x$，只要把左边的值模一下一个质数$p$，如果答案是$0$，那么左边的值就很有可能是$0$。为了提高准确程度，我们多模几个质数，如果得到的结果都是$0$，就认为$x$是一个根。这么做可以拿$70$分，因为判断一个解的时间复杂度是$O(n\times $质数个数$)$的，总时间复杂度是$O(m\times n\times $质数个数$)$。然后发现其实没必要全部枚举$m$，因为只要几个$x$模$p$的余数相同，左边的值都是相同的。所以只要保存$x=0,1,…p-1$的取模结果即可，时间复杂度是$O(n\times p_{max}\times $质数个数$+m)$。质数选几个不大不小的即可，推荐选$5$~$6$个。当然如果你幸运EX的话模一两个也是能A掉的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt; #include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int p[]=&#123;9973,10723,10937,11161,13337&#125;;int n,m,a[5][105]=&#123;0&#125;,fx[5][20000];char s[100005];bool ans[1000005];int read_(int M)&#123;; int f=1,x=0; if(s[0]=='-')f=-f; for(char *t=(s[0]=='-'?s+1:s);*t;t++)x=(x*10+*t-'0')%M; return f*x;&#125;void init()&#123; n=read(),m=read(); for(int i=0;i&lt;=n;i++)&#123; scanf("%s",s); for(int j=0;j&lt;5;j++)a[j][i]=read_(p[j]); &#125; for(int i=0;i&lt;5;i++) for(int j=1;j&lt;=p[i];j++)&#123; int res=0; for(int k=n;k&gt;=0;k--) res=(res*j+a[i][k])%p[i]; fx[i][j]=res; &#125;&#125;void solve()&#123; int cnt=0,flag; for(int i=1;i&lt;=m;i++)&#123; flag=0; for(int j=0;j&lt;5;j++) if(fx[j][i%p[j]])&#123; flag=1; break; &#125; if(!flag)cnt++,ans[i]=1; &#125; printf("%d\n",cnt); for(int i=1;i&lt;=m;i++) if(ans[i])printf("%d\n",i);&#125;int main()&#123; init(); solve(); return 0; &#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>模拟</tag>
        <tag>二分</tag>
        <tag>树形结构</tag>
        <tag>背包DP</tag>
        <tag>最短路</tag>
        <tag>非完美算法</tag>
        <tag>部分搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 题解]]></title>
    <url>%2F2018%2F08%2F20%2Fnoip2016%2F</url>
    <content type="text"><![CDATA[本文包含了NOIP2016十道题目的题解。 普及T1 买铅笔题目地址 对于每一种都判断一下，我要达到这个量最少要买几包铅笔。这是一个简单的除法和模运算。1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n,c,v,ans=2000000000;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;3;i++)&#123; scanf("%d%d",&amp;v,&amp;c); j=(n%v==0)?n/v:(n/v+1); j*=c,ans=min(ans,j); &#125; printf("%d\n",ans); return 0;&#125; 普及T2 回文日期题目地址 你可以估计一下年份的范围，然后直接暴力统计。使用字符串函数是基本功呢。（笑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;char a[10],b[10];int rs[]=&#123;1,3,5,7,8,10,12&#125;,ans=0,x1,x2,y1,y2,m1,m2,d1,d2;bool cmp(int ye,int mo,int da)&#123; if(ye&lt;y1||ye&gt;y2)return false; if(ye==y1)&#123; if(mo&lt;m1)return false; else if(mo==m1)&#123; if(da&lt;d1)return false; &#125; &#125;else if(ye==y2)&#123; if(mo&gt;m2)return false; else if(mo==m2)&#123; if(da&gt;d2)return false; &#125; &#125; return true;&#125;int main()&#123; scanf("%s%s",a,b); x1=atoi(a),x2=atoi(b); y1=x1/10000,y2=x2/10000; m1=(x1%10000)/100,m2=(x2%10000)/100; d1=x1%100,d2=x2%100; int i,j,k,l,t,ye,mo,da,ok; for(i=0;i&lt;=1;i++) for(j=0;j&lt;=9;j++)&#123; mo=i*10+j; if(mo&gt;12)break; if(!mo)continue; for(k=0;k&lt;=3;k++)&#123; if(k==3&amp;&amp;mo==2)break; for(l=0;l&lt;=9;l++)&#123; ye=l*1000+k*100+j*10+i, da=k*10+l; if(da&gt;31)break; if(!da)continue; if(da==31)&#123; for(ok=t=0;t&lt;7;t++) if(mo==rs[t])ok=1; if(!ok)break; &#125; if(ye%400==0||(ye%4==0&amp;&amp;ye%100!=0))&#123; if(mo==2&amp;&amp;da&gt;29)break; &#125;else if(mo==2&amp;&amp;da&gt;28)break; if(!cmp(ye,mo,da))continue; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 普及T3 海港题目地址 统计？12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;typedef struct&#123; int t,k,st;&#125;D;D _q[100005];int n,cnt[100005]=&#123;0&#125;,_cnt=0,q[300005],f,r,cur=0;int main()&#123; scanf("%d",&amp;n); int t,m,i,j,l; f=r=0; for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;t,&amp;m); _q[r].t=t,_q[r++].k=m; while(r&gt;f&amp;&amp;_q[f].t&lt;=t-86400)&#123; for(j=_q[f].st,l=0;l&lt;_q[f].k;l++,j++)&#123; cnt[q[j]]--; if(!cnt[q[j]])_cnt--; &#125; f++; &#125; _q[r-1].st=cur; for(l=0;l&lt;m;l++,cur++)&#123; scanf("%d",&amp;q[cur]); cnt[q[cur]]++; if(cnt[q[cur]]==1)_cnt++; &#125; printf("%d\n",_cnt); &#125; return 0;&#125; 普及T4 魔法阵题目地址 好方法不妨设x_a-x_b=len，那么对于每一个$i$，设i=x_b，枚举一次$len$。接下来的事情就很玄学了：$len$的限制是$len\le i-1$且$len\le 2\times\lfloor \frac{n-i-1}7 \rfloor$，算一下发现$len_{max}=\lfloor \frac{2n-4}9 \rfloor$，又由于$len$是偶数，所以每一次枚举的次数至多为$\lfloor \frac n 9 \rfloor$。这个常数很小，考虑暴力。总体上是枚举长度$len$，每一次枚举x_a，x_b，算出可行的x_c，x_d贡献，再对x_c，x_d做一遍。（当然也可以只做一遍，那样会很麻烦，见下面的下面的失败代码）这里可以发现随着x_c，x_d的递增x_a，x_b是递增的，所以可以用前缀和优化；对于x_c，x_d同理。时间复杂度$O(n^2)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],cnt[15005]=&#123;0&#125;;int ca[15005],cb[15005],cc[15005],cd[15005];void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) a[i]=read(),cnt[a[i]]++;&#125;void solve()&#123; int hf_max=n/9,len,rp,xa,xb,xc,xd,sum; for(int hf=1;hf&lt;=hf_max;hf++)&#123;//长度的一半 len=hf&lt;&lt;1,sum=0; for(xc=4*len+2;xc&lt;=n-hf;xc++)&#123;//枚举xc xd=xc+hf,xa=xc-4*len-1,xb=xa+len; sum+=cnt[xa]*cnt[xb]; cc[xc]+=cnt[xd]*sum,cd[xd]+=cnt[xc]*sum; &#125; sum=0; for(xb=n-7*hf-1;xb&gt;=len+1;xb--)&#123;//枚举xb xa=xb-len,xd=7*hf+xb+1,xc=xd-hf; sum+=cnt[xc]*cnt[xd]; ca[xa]+=cnt[xb]*sum,cb[xb]+=cnt[xa]*sum; &#125; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]],cb[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125; 劣方法之前写了一个不够好，但是空间够大的情况下可以拿95分（大概）的程序。。。有兴趣的同学可以看看。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40005],ws[15005];int pre[2005][15005],dc[2005][15005],dd[2005][15005]; int ca[15005],cb[15005],cc[15005],cd[15005];bool calced[15005];void calc(int at,int len)&#123; int *cur=pre[len]; for(int i=at;i+len&lt;=n;i++) cur[i]=cur[i-1]+ws[i]*ws[i+len]; calced[len]=1;&#125;void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++)a[i]=read(),ws[a[i]]++;&#125;void solve()&#123; int xb,len,cnt,cnt_c,xs,hf; int lenmax=n/9,*tc,*td; for(int i=2;i&lt;=n;i++)&#123; if(!ws[i])continue; cnt=0; for(int len=2;len&lt;xb;len+=2)&#123; int rp=7*(len&gt;&gt;1)+i+1; if(rp&gt;n)break; if(!ws[i-len])continue; xs=ws[i-len]*ws[i],hf=(len&gt;&gt;1); dc[hf][rp-hf]+=xs,dc[hf][n-hf+1]-=xs; dd[hf][rp]+=xs,dd[hf][n+1]-=xs; if(!calced[hf])calc(rp-hf,hf); cnt_c=pre[hf][n-hf]-pre[hf][rp-hf-1]; cnt_c*=xs,cnt+=cnt_c,ca[i-len]+=cnt_c; &#125; cb[i]+=cnt; &#125; for(int i=1;i&lt;=lenmax;i++)&#123; tc=dc[i],td=dd[i]; for(int j=8*i+2;j&lt;=n-i;j++) tc[j]+=tc[j-1],td[j+i]+=td[j+i-1], cc[j]+=tc[j]*ws[j+i],cd[j+i]+=td[j+i]*ws[j]; &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",ca[a[i]]/ws[a[i]],cb[a[i]]/ws[a[i]],cc[a[i]],cd[a[i]]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T1 玩具谜题题目地址 按照题意模拟即可。确定左右方向就用异或的方法。当然，多写几行判断也是可行的。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int in_or_out[100005],n,m;//in 0,out 1char job[100005][20];void init()&#123; n=read(),m=read(); for(int i=0;i&lt;n;i++) scanf("%d%s",&amp;in_or_out[i],job[i]);&#125;void solve()&#123; int opr,s,lst=0; while(m--)&#123; opr=read(),s=read(); int res=opr^in_or_out[lst]; if(!res)lst=(lst-s+n)%n; else lst=(lst+s)%n; &#125; printf("%s\n",job[lst]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T2 天天爱跑步题目地址 当初比赛的时候连暴力都没写对orz暴力的话，直接上$LCA$，大力模拟即可，大概可以拿25分。。。满分做法是从链状做法中过渡而来的。我们发现，从$S$到$T$总是经过他们的$LCA$的（废话），也就是说，可以从$LCA$的角度入手。然后考虑把树问题变成链问题，只要把$LCA$两边的链扯出来即可。对于一条链，一个点$S$可以给另一个点$i$贡献的情况只有从$S$到$i$走的步数=$W_i$。反映在链上，就是$|S-i|=W_i$。反映在树上，就是$depth[S]-depth[i]=W_i$，即$depth[S]=W_i+depth[i]$。这里假定$S$不是LCA，那么从$S$出发时不会往下面走的。我们显然希望对于$i$统计合法的对应$S$。那么就造一个数组，统计当前合法的$S$的个数，走到一个$i$上查一下即可。同理，另一边，有从LCA向下走到$T$，也是一样的道理，多开一个数组就行。（条件是$depth[i]-W_i=depth[T]-len(x,y)$）计算答案的顺序需要注意： 进入的时候先减掉答案，出去的时候再加上，才可以得到自身的贡献。（对于自己统计到的$S$和$T$） 由于$S$到$LCA$是向上，并且我们只希望在$S$到$LCA$的路径上查到我们想要的贡献，所以在向下DFS时添加自己作为$S$的信息，并在回到$LCA$时再减掉$S$的贡献；对$LCA$到$T$，我们只要它向上走的贡献，所以在回溯的时候在$T$处加上，再在$LCA$处减去。 负数下标。 总结一下，这道题有一个类似于差分的思想。。。在2015年应该有所领略。时间复杂度取决于你求$LCA$时算法的时间复杂度。为$O((n+m)logn)$或者$O(n+m)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000#define MAXN 300005#define MAXL 21using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,to[MAXN*2],_next[MAXN*2],at[MAXN]=&#123;0&#125;,Cnt=0;//树部分 int que[MAXN],depth[MAXN],par[MAXN][MAXL]=&#123;0&#125;,LOG;//LCA部分 int at2[MAXN]=&#123;0&#125;,to2[MAXN],_next2[MAXN],Cnt2=0;//存T的信息 int ats[MAXN]=&#123;0&#125;,tos[MAXN],_nexts[MAXN],Cnts=0;//自己是LCA时存S的深度 int att[MAXN]=&#123;0&#125;,tot[MAXN],_nextt[MAXN],Cntt=0;//自己是LCA时存T的深度 int m,ans[MAXN],w[MAXN],c[MAXN]=&#123;0&#125;;//ans答案 w出现时间 cS人数 int down[MAXN],up[MAXN*2]=&#123;0&#125;;//up S-&gt;LCA down LCA-&gt;T（可能有负数） void addedge(int _u,int _v)&#123; to[++Cnt]=_v,_next[Cnt]=at[_u],at[_u]=Cnt;&#125;void bfs()&#123; int f=0,r=0; que[r++]=1,depth[1]=1; while(r-f)&#123; int h=que[f++]; for(int i=at[h];i;i=_next[i])&#123; int _v=to[i]; if(_v==par[h][0])continue; que[r++]=_v,depth[_v]=depth[h]+1,par[_v][0]=h; &#125; for(int i=1;i&lt;=LOG;i++) if(par[h][i-1])par[h][i]=par[par[h][i-1]][i-1]; else break; &#125;&#125;int query(int u,int v)&#123; int i,j,d; if(depth[u]&lt;depth[v]) swap(u,v); for(d=depth[u]-depth[v],i=0;(1&lt;&lt;i)&lt;=d;i++); for(i--;i&gt;=0&amp;&amp;depth[u]!=depth[v];i--) if(depth[u]-(1&lt;&lt;i)&gt;=depth[v]) u=par[u][i]; if(u==v)return u; for(i=LOG;i&gt;=0;i--) if(par[u][i]&gt;0&amp;&amp;par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i]; return par[u][0];&#125;//倍增求解LCAvoid dfs(int cur)&#123; //主要求解过程 int up_ans=up[depth[cur]+w[cur]], down_ans=down[depth[cur]-w[cur]+MAXN]; //旧的答案 up[depth[cur]]+=c[cur]; //作为S，添加自己 for(int i=at[cur];i;i=_next[i]) if(to[i]!=par[cur][0])dfs(to[i]); //搜索子树 for(int i=at2[cur];i;i=_next2[i]) down[to2[i]+MAXN]++; //作为T，添加自己的信息 ans[cur]=up[depth[cur]+w[cur]]+down[depth[cur]-w[cur]+MAXN]-up_ans-down_ans; //利用DFS性质计算自己的答案 for(int i=ats[cur];i;i=_nexts[i])&#123; up[tos[i]]--;//回溯时删去S if(tos[i]==depth[cur]+w[cur])ans[cur]--;//如果S就是LCA，那么答案重复，减掉1个 &#125; for(int i=att[cur];i;i=_nextt[i]) down[tot[i]+MAXN]--;//作为LCA，回溯时删去T&#125;void init()&#123; n=read(),m=read(); for(LOG=1;(1&lt;&lt;LOG)&lt;n;LOG++); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; bfs(); for(int i=1;i&lt;=n;i++)w[i]=read(); for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(); int lca=query(u,v),len=depth[u]+depth[v]-2*depth[lca]; c[u]++; tos[++Cnts]=depth[u],_nexts[Cnts]=ats[lca],ats[lca]=Cnts; tot[++Cntt]=depth[v]-len,_nextt[Cntt]=att[lca],att[lca]=Cntt; to2[++Cnt2]=depth[v]-len,_next2[Cnt2]=at2[v],at2[v]=Cnt2; &#125;&#125;void solve()&#123; dfs(1); for(int i=1;i&lt;n;i++) printf("%d ",ans[i]); printf("%d\n",ans[n]);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D1T3 换教室题目地址 很水的期望DP，但是对于第一次写的人有点难度。（比方说我） 题目说要求最小的体力消耗期望值，并给出了地图，说明肯定先要求一次多源最短路。然后在现实意义上理解一下这里期望的意义。在这里，期望是概率和权值的乘积之和。并且每一次是否选课和其他几次都是没有关系的。会对权值造成影响的是这一次和前一次的申请情况。比如第$i$次申请了，第$i-1$次没申请，那么有两种情况：一是申请通过，本次体力消耗是c_{i-1}到d_i的最短路长；二是没有通过，本次体力消耗是c_{i-1}到c_i的最短路长。那么期望体力就是 E=k_i*d[c_{i-1},d_i]+(1-k_i)\times d[c_{i-1},c_i]以此类推，都申请有4种情况，一个申请一个不申请有2种情况，都不申请有1种情况，每种情况对应的期望体力是不变的。这样就转化为了一个类似背包的问题。设$f(i,j,k)$表示对于前$i$节课，使用了$j$次机会时需要的最小期望体力，$k=0$表示此次不申请，$k=1$表示此次不申请，分类讨论即可写出状态转移方程。具体见代码。时间复杂度：$O(nm+V^3)$注意，由于涉及了浮点数运算，该题的代码如果写的常数太大的话就会在最后一个点TLE。所以要适度卡常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,V,E,INF=1000000000;int d[305][305];int p1[2005],p2[2005];double f[2005][2005][2],p[2005],inf=1e9;void floyd()&#123; for(int k=0;k&lt;V;k++) for(int i=0;i&lt;V;i++) for(int j=0;j&lt;V;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;V,&amp;E); int i,j,u,v,c; for(i=0;i&lt;n;i++) scanf("%d",&amp;p1[i]),p1[i]--; for(i=0;i&lt;n;i++) scanf("%d",&amp;p2[i]),p2[i]--; for(i=0;i&lt;n;i++) scanf("%lf",&amp;p[i]); for(i=0;i&lt;V;i++) for(j=0;j&lt;V;j++) d[i][j]=(i==j)?0:INF; for(i=0;i&lt;E;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); if(d[u-1][v-1]&gt;c) d[u-1][v-1]=d[v-1][u-1]=c; &#125; floyd();&#125;void solve()&#123; int i,j,A,B,C,D; double choice,ans=inf; for(i=0;i&lt;n;i++) for(j=0;j&lt;=m;j++) f[i][j][0]=f[i][j][1]=inf; f[0][0][0]=f[0][1][1]=0; for(i=1;i&lt;n;i++)&#123; A=d[p1[i-1]][p1[i]], B=d[p1[i-1]][p2[i]], C=d[p2[i-1]][p1[i]], D=d[p2[i-1]][p2[i]]; f[i][0][0]=f[i-1][0][0]+A; for(j=1;j&lt;=m;j++)&#123; choice=min(f[i-1][j][0]+A, f[i-1][j][1]+p[i-1]*C+(1-p[i-1])*A); f[i][j][0]=min(f[i][j][0],choice); choice=min(f[i-1][j-1][0]+p[i]*B+ (1-p[i])*A, f[i-1][j-1][1]+p[i-1]*p[i]*D+ (1-p[i-1])*p[i]*B+ p[i-1]*(1-p[i])*C+ (1-p[i-1])*(1-p[i])*A); f[i][j][1]=min(f[i][j][1],choice); &#125; &#125; for(i=0;i&lt;=m;i++) ans=min(ans,min(f[n-1][i][0],f[n-1][i][1])); printf("%.2lf\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125; 提高D2T1 组合数问题题目地址 这题给你公式就是给你坑。（如果你不会求逆元的话）实际上没有必要求逆元，直接拿组合数经典公式就可以做了。我们知道：C_n^m=C_{n-1}^{m-1}+C_{n-1}^m。同时，如果一个组合数是$k$的倍数，那么C_n^m \mod k =0。所以就$O(nm)$递推一下，在递推的过程中让C_n^m对$k$取模，如果结果为$0$就在当前位置记录一下。这样可以解决一次回答，但时间复杂度不够优，每次都这么做是O(n_{max}\times m_{max}\times t)的，可能只能过70%左右的数据。发现$k$不变，所以考虑预处理再回答。这里使用前缀和思想。设$ans(n,m)$表示所有$0\le i\le n,0\le j \le m$中，有多少C_i^j是$k$的倍数，即C_i^j \mod k =0。先求出每一行的前缀和，再求一次每一列的前缀和就可得到所有的$ans(n,m)$。（详见代码）这样回答一个询问的时间是$O(1)$，总时间复杂度是O(n_{max}\times m_{max} +t)。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int T,k,C[2005][2005],sum[2005][2005]=&#123;0&#125;,maxn=0,maxm=0,n[10005],m[10005];void init()&#123; int i,j,v; for(i=0;i&lt;=maxn;i++) C[i][0]=1; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%k; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++)&#123; if(j&lt;=i&amp;&amp;C[i][j]==0)v=1;else v=0; sum[i][j]=sum[i-1][j]+v; &#125; for(i=1;i&lt;=maxn;i++) for(j=1;j&lt;=maxm;j++) sum[i][j]+=sum[i][j-1];&#125;int main()&#123; scanf("%d%d",&amp;T,&amp;k); for(int i=1;i&lt;=T;i++) scanf("%d%d",&amp;n[i],&amp;m[i]),maxn=max(maxn,n[i]),maxm=max(maxm,m[i]); init(); for(int i=1;i&lt;=T;i++) printf("%d\n",sum[n[i]][m[i]]); return 0;&#125; 提高D2T2 蚯蚓题目地址 考场上我想到了这个方法，但因为没证明所以不敢用。。。结果一看题解就吓傻了。可以证明同一种切法下，先切割的比后切割的长度会更长，所以维护$3$个递减队列，然后先把所有初始蚯蚓放在队列$1$，然后不断取出，把$\lfloor px\rfloor$的放在队列$2$中，$x-\lfloor px\rfloor $放在队列$3$中，每一次取$1,2,3$中最大值出来切。注意：1.维护下标（切的时间）很麻烦，不妨直接先减去当前时间和$q$的乘积，然后到了它在加上。为什么可以这么做？因为一条蚯蚓的实际长度是len+(t_{当前}-t_{被切})*q，展开得(len-t_{被切}\times q)+q\times t_{当前}，所以队列里只需要维护前面括号里的元素即可。相应的，在求最大值时，初始最大值要取很小，因为要维护的值可能是个很小的负数。2.要卡常，STL慢的飞起。时间复杂度$O(n+m)$。 补充证明上面那个性质。假设有$2$条蚯蚓长度分别是$a,b(a&gt;b)$，那么$a$会比$b$先被切。设两个蚯蚓被切得时间点分别是t_a,t_b(t_a \lfloor p\times b\rfloor和a-\lfloor p\times a\rfloor +(t_b-t_a)\times q>b-\lfloor p\times b\rfloor。所以上面的命题成立，证毕。大家都看的出来好嘛1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int q1[100005]=&#123;0&#125;,q2[7000005],q3[7000005],n,m,q,u,v,t;int f1=0,f2=0,f3=0,r1=0,r2=0,r3=0;double xs,tmp;int main()&#123; scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t); xs=u,xs/=(double)v; int i,j,k,maxi,_max,fi,se,ok=0; for(i=0;i&lt;n;i++) scanf("%d",&amp;q1[i]); sort(q1,q1+n); r1=n,reverse(q1,q1+n); for(i=0;i&lt;m;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=i*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; tmp=_max,tmp*=xs; fi=(int)floor(tmp),se=_max-fi; q2[r2++]=fi-(i+1)*q, q3[r3++]=se-(i+1)*q; &#125; printf("\n"); for(ok=i=0;i&lt;m+n;i++)&#123; maxi=_max=0x80000001; if(r1&gt;f1)maxi=1,_max=q1[f1]; if(r2&gt;f2&amp;&amp;_max&lt;q2[f2])maxi=2,_max=q2[f2]; if(r3&gt;f3&amp;&amp;_max&lt;q3[f3])maxi=3,_max=q3[f3]; if(maxi==1)f1++; if(maxi==2)f2++; if(maxi==3)f3++; _max+=m*q; if((i+1)%t==0)&#123; if(ok)printf(" "); ok=1,printf("%d",_max); &#125; &#125; printf("\n"); return 0;&#125; 提高D2T3 愤怒的小鸟题目地址 状压搜索/DP枚举抛物线，看一次抛物线能砸死哪些猪，然后跑DP搜索过不去？那就卡时呗。DP？设$f(i,S)$表示解决了前i头猪，正在解决第$i+1$头，猪被打死的情况为$S$的最小方案数。那么先算出以包含第$i$头猪在内的所有抛物线能砸死的猪的情况（压位表示），然后跑记忆化搜索即可。时间复杂度：搜索：$O($你卡时就能过$)$DP：$O($你不卡时也能过$)$实际检验发现，搜索效率很高，对于小数据非常轻松。但DP的发挥更加稳定，不会被奇奇怪怪的东西卡死。在洛谷上，搜索不卡时95分，花费254ms；DP花费2154ms。 DP做法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,tag,tab[20][500];int in[20][1&lt;&lt;19];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1;//x坐标相同 a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1;//a必须&lt;0 b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;//解方程void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=((1&lt;&lt;i)|(1&lt;&lt;j)); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]-_a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;int dfs(int at,int S)&#123; if(in[at][S]&lt;0x3f3f3f3f)return in[at][S]; int st=0x3f3f3f3f,i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; st=min(st,1+dfs(j,_S)); &#125; return (in[at][S]=st);&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); memset(in,0x3f,sizeof(in)); tag=(1&lt;&lt;n); for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); in[n][tag-1]=0; printf("%d\n",dfs(0,0)); &#125; return 0;&#125; 搜索做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int T,n,m,ans,tag,tab[20][500];double pos[20][2],eps=1e-8;int jfc(double &amp;a,double &amp;b,int i,int j)&#123; if(pos[i][0]&lt;pos[j][0])swap(i,j); if(fabs(pos[i][0]-pos[j][0])&lt;eps)return -1; a=(pos[i][1]-(pos[j][1]*pos[i][0]/pos[j][0]))/ (pos[i][0]*pos[i][0]-pos[i][0]*pos[j][0]); if(a&gt;0||fabs(a)&lt;eps)return -1; b=(pos[i][1]-a*pos[i][0]*pos[i][0])/pos[i][0]; return 0;&#125;void init()&#123; int i,j,S,p; double _a,_b; char vis[50]; for(i=0;i&lt;n;i++)&#123; memset(vis,0,sizeof(vis)); for(j=i+1;j&lt;n;j++)&#123; if(vis[j])continue; if(jfc(_a,_b,i,j)&lt;0)continue; S=0;S|=(1&lt;&lt;i);S|=(1&lt;&lt;j); for(p=j+1;p&lt;n;p++) if(fabs(pos[p][1]-_b*pos[p][0]- _a*pos[p][0]*pos[p][0])&lt;eps) S|=(1&lt;&lt;p),vis[p]=1; tab[i][++tab[i][0]]=S; &#125; tab[i][++tab[i][0]]=(1&lt;&lt;i); &#125;&#125;void dfs(int at,int st,int S)&#123; if(S!=tag-1&amp;&amp;st&gt;=ans-1)return ; if(S==tag-1)&#123;ans=min(ans,st);return ;&#125; int i,j,_S; for(i=1;i&lt;=tab[at][0];i++)&#123; _S=S,_S|=tab[at][i]; for(j=at+1;j&lt;n;j++) if((_S&amp;(1&lt;&lt;j))==0)break; dfs(j,st+1,_S); &#125;&#125;int main()&#123; scanf("%d",&amp;T); int i,j,u,v; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); memset(tab,0,sizeof(tab)); tag=(1&lt;&lt;n),ans=n; for(i=0;i&lt;n;i++) scanf("%lf%lf",&amp;pos[i][0],&amp;pos[i][1]); init(); dfs(0,0,0); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>模拟</tag>
        <tag>数论</tag>
        <tag>最短路</tag>
        <tag>单调队列</tag>
        <tag>状压DP</tag>
        <tag>LCA</tag>
        <tag>期望DP</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shortest-path-problems]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2Fshortest-path-problems%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[对循环不变式的理解]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2Floop-invariants%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SPFA 学习笔记]]></title>
    <url>%2F2018%2F08%2F19%2Fwriting%2FSPFA%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa106 Fermat vs. Pythagoras]]></title>
    <url>%2F2018%2F08%2F18%2Fuva106%2F</url>
    <content type="text"><![CDATA[题目链接 题解考察了素毕达哥拉斯三元组的生成。貌似没必要加很多的优化？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int ans1[1000005] = &#123;0&#125;, ans2[1000005] = &#123;0&#125;;bool vis[1000005] = &#123;0&#125;;int n;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void init()&#123; for(int v = 2; v &lt;= 1000; ++v)&#123; if(v * v &gt; n)break; for(int u = (v % 2 == 0) ? 1 : 2; u &lt; v; u += 2)&#123; if(u * u + v * v &gt; n) break; if(gcd(v, u) != 1) continue; int aa = v * v - u * u, bb = 2 * u * v, cc = v * v + u * u; ans1[cc]++; for(int i = 1; i * cc &lt;= n; ++i) vis[i * aa] = 1, vis[i * bb] = 1, vis[i * cc] = 1; &#125; &#125; for(int i = 1; i &lt;= n; ++i) ans1[i] += ans1[i - 1], ans1[i - 1] = 0, ans2[i] = ans2[i - 1] + 1 - vis[i], ans2[i - 1] = 0, vis[i] = 0;&#125;void solve()&#123; printf("%d %d\n", ans1[n], ans2[n]); ans1[n] = ans2[n] = 0;&#125;int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[勾股数探究]]></title>
    <url>%2F2018%2F08%2F18%2FPythagorean-triple%2F</url>
    <content type="text"><![CDATA[勾股数，又叫毕达哥拉斯三元数， 是由正整数构成的三元组。其三个数对应一个直角三角形的三条边。这里对勾股数的性质做一些探究。 基本性质一般用一个三元组表示一组勾股数：$(a, b, c)$其中有 a ^ 2 + b ^ 2 = c ^2容易看出，一组勾股数中每一个数乘上一个正整数$n$，得到的三元组$(na, nb, nc)$仍为一组勾股数。正因如此，我们希望找到这样的勾股数，使它不为除自己外某一个勾股数的倍数。换句话说，我们希望有一种方法可以枚举出所有的素勾股数，即使$(a, b, c)=1$。 构造方式先直接给出这样的构造方式：设$u &lt; v(u ,v\in \mathbb{N}^*)$，并且$u,v$奇偶性不同，且$(u, v) = 1$，那么令 \begin{cases} a = v ^ 2 - u ^ 2\\ b = 2 u v \\ c = v ^ 2 + u ^ 2\end{cases}即可构造出全部的素勾股数。证明：假设这样产生的勾股数存在$(a, b, c)= d$，那么由于$u, v$奇偶性不同， 故$a, c$必为奇数。故$d$为奇数。则对于$c$则必须有$u|d, v|d$，导出$(u, v)\ge d$，与前提中的$(u, v)=1$矛盾。故原命题得证，证毕。 由此可见，使用这样的方式构造出素勾股数之后再进行倍增，即可构造出所有可能的勾股数。 问题扩展问题：已知$a, b, c\in \mathbb{N}^*$和$b$，求满足$a ^ 2 + b ^ 2 = c ^ 2$的所有解。解题：把式子化为$b ^ 2 = (c - a)(c + a)$，设$x = c + a, y= c - a$，那么就有$b ^2 = x y$。对$b$枚举一次因数，然后对因数进行组合，同时考虑一下奇偶性带来的问题，计算出$x,y$，解出$a,c$即可。因为因数的个数为$O(\sqrt b)$，组合因数的时候会产生$O(b)$的因数个数，所以该方法的时间复杂度应为$O(b)$。 相关运用UVa106（同Poj1305） 参考资料 《什么是数学》 百度百科]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 最短路]]></title>
    <url>%2F2018%2F08%2F18%2Ftemplate-shortest-path%2F</url>
    <content type="text"><![CDATA[各种最短路的模板！首先可以利用反证法证明一个定理：最短路径的子路径也是最短路径。这个定理构成了之后算法的基石。 同时还有一个重要的不等式： d(v)\le d(u)+w(u, v)这个不等式叫三角不等式，它是松弛操作的理论基础。 Bellman-Ford算法容易知道，当一个图$G=(V, E)$中不存在负环时，该图中的最短路最多经过$|V|-1$条边。最短路上是不可能存在一个路径的权重和为正的环的。因此进行松弛操作时，最多进行$|V|-1$次就可以算出最短路。若在第$|V|$次仍可以进行松弛，那么就说明存在一个负环。Bellman-Ford算法基于上述思路，对每一条边都进行$|V|-1$次的松弛，从而就可求出最短路。同时，也可以用于判断负环是否存在。从上述说明也可以看出，Bellman-Ford算法允许图中有负权边。1234567891011121314bool Bellman_Ford()&#123; for(int i = 1; i &lt; V; ++i) for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost) d[v] = d[u] + edge[j].cost; &#125; for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost) return false;//还能松弛说明这个图存在负环 &#125; return true;&#125; 除了上述写法，还有一种经过了一定优化的写法：12345678910111213141516bool Bellman_Ford()&#123; for(int i = 1; i &lt;= V; ++i)&#123; int flag = 0; for(int j = 0; j &lt; E; ++j)&#123; int u = edge[j].from, v = edge[j].to; if(d[v] &gt; d[u] + edge[j].cost)&#123; d[v] = d[u] + edge[j].cost, flag = 1; if(i == V) return false; &#125; &#125; if(!flag) break;//松弛的次数已经足够了，没有必要再进行下去 &#125; return true;&#125; 容易看出，Bellman-Ford算法的时间复杂度为$O(|V|\times |E|)$。因此，大部分情况下Bellman-Ford算法在解决问题的时候时间复杂度都不够好。但是，它的一个优化版本——SPFA的应用场合就相当多了。 Dijkstra算法DIjkstra算法在求单源最短路方面表现相当稳定。朴素实现时它的时间复杂度为$O(|V|^2+|E|)$，而在使用一定的数据结构时可以将时间复杂度降到$O(|E|log|V|)$。Dijkstra算法的使用条件是图中没有负权边。当图中的边权全为正时，可以从起点出发，采用贪心的方法，一步一步得到最短路径。具体方法是：找出所有没有使用过的顶点中离起点最近的点，然后松弛所有与其相邻的边，重复这一步骤。 SPFASPFA一般被视为Bellman-Ford算法的改良版本。虽然其名字由某一篇论文提出，但似乎这个方法在很早以前就已经出现了。SPFA更详细的介绍在另一篇博客里，在此就不详细说明。 朴素搜索当边权相同或者图很特殊（如$DAG$）时，可以直接采用搜索或者递推的方式计算最短路。由于这不是一个统一的模型，故在此不给出代码。 以上算法一般用于解决单源最短路问题。 矩阵乘法将图上的边距离对应成矩阵中相应行列的一个点，即可构造出一个矩阵 Floyd算法Floyd最短路算法可以在$O(|V|^3)$的时间复杂度下解决多源最短路问题。Floyd算法用到了动态规划的思想。考虑原始情况下，令$d[i][j]$表示点$i$和点$j$之间的最短距离。但这并不够用来表示一个状态，因此我们加上一维$k$，令$d[k][i][j]$表示利用编号为$0$到$k - 1$的点作为中转站时，$i$和$j$之间的最短距离。初始化时令$d[0][i][j] = cost[i][j]$（此时认为不使用中转站），其他值设为$INF$。在$0$到$k-1$的答案被算出来后，考虑$k$的情况。当不以$k$为中转站时，有$d[k+1][i][j]=d[k][i][j]$；当以$k$为中转站时，有$d[k+1][i][j]=d[k][i][k]+d[k][k][j]$。结合一下就是 d[k+1][i][j]=\min\left\{d[k][i][j],d[k][i][k]+d[k][k][j]\right\}可以发现，此时第一维已经没有什么必要。故最后我们可以得到以下代码。1234567void Floyd()&#123; //此时d数组里面已经存了相关信息 for(int k = 0; k &lt; V; ++k) for(int i = 0; i &lt; V; ++i) for(int j = 0; j &lt; V; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; Floyd算法允许负权边的存在，同时也可以用来判断负环是否存在。当负环存在时，存在$i$使得$d[i][i]&lt;0$。Floyd算法在一些和动态规划有所联系的图论题目里也有不错的表现，比如题目最小密度路径里面，可以增加一维记录当前走过的路径的条数，然后求出恰好经过一定数目路径的最短路的长度。同时Floyd算法的实现性也很强，很容易实现。不过似乎Floyd算法无法求出最短路径树。 参考资料 《算法导论》 《挑战程序设计竞赛（第2版）》 相关博客]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学英语]]></title>
    <url>%2F2018%2F08%2F16%2Fmath-english%2F</url>
    <content type="text"><![CDATA[列出一些常见的数学英语 Aadjacentadj. 毗邻的 Ccuboidn. 立方体 Eequilateraladj. 等边的，等面的 Iintegraladj. 整的，整数的，完整的，积分的n. 积分，整体 Mmaximumadj. 最大值的，最大量的n. 最大的量、体积、强度等 minimumn. 最低限度; 最小量; 最低消费; 极小值adj. 最小的; 最低的; 最少的 Pperimetern. 周长，周围 primen. 质数adj. 质的 TtotientEuler’s totient function: 欧拉函数 Rrelatively prime互质e.g. 15 is relatively prime to 2.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连分数和佩尔方程 学习笔记]]></title>
    <url>%2F2018%2F08%2F15%2Fwriting%2Fcontinued-fraction-and-pell-equation%2F</url>
    <content type="text"></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectEuler 61-100题解]]></title>
    <url>%2F2018%2F08%2F15%2Fpe61-100%2F</url>
    <content type="text"><![CDATA[继续探索 PE61先枚举排列，然后按照排列顺序进行搜索即可。或者按照图论，构图搜索也可以。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int p[6][10005], cnt[6] = &#123;0&#125;;int per[] = &#123;0, 1, 2, 3, 4, 5&#125;;int ans[6], t_ans[6];void init()&#123; int i; for(i = 1; (i * (i + 1) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i + 1) &gt;&gt; 1) &lt; 10000; ++i) p[0][cnt[0]++] = (i * (i + 1) &gt;&gt; 1); for(i = 1; i * i &lt; 1000; ++i); for(; i * i &lt; 10000; ++i) p[1][cnt[1]++] = i * i; for(i = 1; (i * (i * 3 - 1) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i * 3 - 1) &gt;&gt; 1) &lt; 10000; ++i) p[2][cnt[2]++] = (i * (i * 3 - 1) &gt;&gt; 1); for(i = 1; i * (2 * i - 1) &lt; 1000; ++i); for(; i * (2 * i - 1) &lt; 10000; ++i) p[3][cnt[3]++] = i * (2 * i - 1); for(i = 1; (i * (i * 5 - 3) &gt;&gt; 1) &lt; 1000; ++i); for(; (i * (i * 5 - 3) &gt;&gt; 1) &lt; 10000; ++i) p[4][cnt[4]++] = (i * (i * 5 - 3) &gt;&gt; 1); for(i = 1; i * (i * 3 - 2) &lt; 1000; ++i); for(; i * (i * 3 - 2) &lt; 10000; ++i) p[5][cnt[5]++] = i * (i * 3 - 2);&#125;void getN(int index, int tail)&#123; if(index == 6)&#123; if(ans[5] % 100 == ans[0] / 100) memcpy(t_ans, ans, sizeof(ans)); return ; &#125; int id = per[index], hd = tail * 100; int _index = lower_bound(p[id], p[id] + cnt[id], hd) - p[id]; if(p[id][_index] / 100 != tail) return ; for(int i = _index; i &lt; cnt[id]; ++i)&#123; if(p[id][i] / 100 != tail) break ; ans[index] = p[id][i]; getN(index + 1, p[id][i] % 100); &#125;&#125;void solve()&#123; do&#123; int st = per[0]; for(int i = 0; i &lt; cnt[st]; ++i) ans[0] = p[st][i], getN(1, p[st][i] % 100); &#125;while(next_permutation(per, per + 6)); int sum = 0; for(int i = 0; i &lt; 6; ++i) sum += t_ans[i]; printf("%d\n", sum);&#125; 答案：28684 PE62一个一个长度去试12345678910111213141516171819map&lt;string, int&gt; mp;map&lt;string, ll&gt; mp2;ll ans = INF;void solve()&#123; char s[20]; for(ll i = 4642ll; i * i * i &lt; 1000000000000ll; ++i)&#123; sprintf(s, "%lld", i * i * i); sort(s, s + 12); string ss(s); if(!mp.count(ss)) mp[ss] = 1, mp2[ss] = i; else&#123; mp[ss]++; if(mp[ss] == 5) ans = min(ans, mp2[ss]); &#125; &#125; printf("%lld\n", ans * ans * ans);&#125; 答案：127035954683 PE63拿python水过12345678ans = 0for n in range(1, 22, 1): for i in range(1, 10, 1): x = i ** n if len(str(x)) == n: ans += 1print(ans) 答案：49 PE64这个连分数的构造方法一开始还不太容易看出来。。。答案写在另一篇博文里了。12 答案： PE65用python水过12345678910111213141516171819202122232425262728p = 1q = 1def gcd(a, b): if b == 0: return a else: return gcd(b, a % b)for i in range(1, 99, 1): a = 0 if (99 - i) % 3 == 2: a = ((98 - i) / 3 + 1) * 2 else: a = 1 pp = q qq = p + q * a p = pp q = qqp = p + q + qp /= gcd(p, q)ans = 0while p &gt; 0: ans += p % 10 p /= 10print(ans) 答案：272 PE66这个方程有名字，叫做佩尔方程。它的解和连分数有着很大的关系，将其写在了另一篇博文里12 PE67水DP答案：7273 PE68PE69筛出欧拉函数然后直接枚举。。。123456789void solve()&#123; getPhi(); int maxi; double d = 0; for(int i = 2; i &lt;= 1000000; ++i) if(d &lt; 1.0 * i / phi[i]) d = 1.0 * i / phi[i], maxi = i; printf("%d\n", maxi);&#125; 答案：510510 PE70枚举即可123456789101112131415161718192021void solve()&#123; getPhi(); int maxi; double d = 10000000; char s1[10], s2[10]; for(int i = 2; i &lt; 10000000; ++i)&#123; sprintf(s1, "%d", i); sprintf(s2, "%d", phi[i]); int len1 = strlen(s1), len2 = strlen(s2); if(len1 == len2)&#123; sort(s1, s1 + len1); sort(s2, s2 + len2); if(!strcmp(s1, s2))&#123; double dd = 1.0 * i / phi[i]; if(dd &lt; d) d = dd, maxi = i; &#125; &#125; &#125; printf("%d\n", maxi);&#125; 答案：8319823 PE71对于每一个$d$二分即可123456789101112131415161718void solve()&#123; double rd = 1.0 * 3 / 7, eps = 1e6; int fz, fm; for(int d = 9; d &lt;= 1000000; ++d)&#123; if(d % 7 == 0)continue; int l = 1, r = d - 1; while(r - l)&#123; int mid = (r + l + 1) &gt;&gt; 1; double rr = 1.0 * mid / d; if(rr &gt; rd)r = mid - 1; else l = mid; &#125; double rr = 1.0 * r / d; if(rd - rr &lt; eps) eps = rd - rr, fz = r, fm = d; &#125; printf("%d %d\n", fz, fm);&#125; 答案：428570 PE72就是对1~1000000的欧拉函数求和。。。1234567891011121314151617181920212223242526bool vis[1000005] = &#123;0&#125;;int prime[500005], tot = 0;int phi[1000005];ll sum = 0;void getPhi()&#123; phi[1] = 1; for(int i = 2; i &lt;= 1000000; ++i)&#123; if(!vis[i]) phi[i] = i - 1, prime[++tot] = i; for(int j = 1; j &lt;= tot; ++j)&#123; if(1ll * prime[j] * i &gt; 1000000) break; vis[prime[j] * i] = 1; if(i % prime[j] == 0)&#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125;else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; sum += 1ll * phi[i]; &#125;&#125;void solve()&#123; getPhi(); printf("%lld\n", sum);&#125; 答案：303963552391 PE73注意分数为不可约。12345678910111213141516171819int ans = 0;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void solve()&#123; double l = 1.0 / 3, r = 1.0 / 2; for(int i = 4; i &lt;= 12000; ++i)&#123; for(int j = 1; j &lt; i; ++j)&#123; if(gcd(i, j) &gt; 1) continue; double cur = 1.0 * j / i; if(abs(cur - l) &lt; 1e-7 || abs(cur - r) &lt; 1e-7) continue ; if(cur &gt; l &amp;&amp; cur &lt; r) ans++; &#125; &#125; printf("%d\n", ans);&#125; 答案：7295372 PE74虽然这道题我给出了一个正确的答案但我还是觉得我写错了。。。怎么回事？做法就是顺着一个数DFS下去，然后记录步数。12345678910111213141516171819202122232425262728293031323334int fac[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int d[10000005], ans = 0, st[10000005] = &#123;0&#125;;bool vis[10000005] = &#123;0&#125;;void getD()&#123; for(int i = 0; i &lt; 10; ++i) d[i] = fac[i]; for(int i = 10; i &lt;= 10000000; ++i) d[i] = d[i / 10] + fac[i % 10];&#125;void dfs(int x)&#123; vis[x] = 1; int nx = d[x]; if(!vis[nx]) dfs(nx); else&#123; if(!st[nx])&#123; st[x] = 1; return ; &#125; &#125; st[x] = st[nx] + 1;&#125;void solve()&#123; getD(); vis[1] = vis[2] = true; st[1] = st[2] = 1; for(int i = 3; i &lt; 1000000; ++i) if(!vis[i]) dfs(i); for(int i = 3; i &lt; 1000000; ++i) if(st[i] == 60) ans++; printf("%d\n", ans);&#125; 答案：402 PE75一开始我写了一个暴力枚举，然后很干脆的挂掉了。。。后来我想到可以枚举所有的素毕达哥拉斯三元数， 然后用类似筛法的方法让其倍数的方法数$+1$， 最后统计方法数仅为$1$的对数。这样做就快多了。123456789101112131415161718192021222324int ans = 0;int cnt[1500005] = &#123;0&#125;;int gcd(int a, int b)&#123; return (!b) ? a : gcd(b, a % b);&#125;void pre()&#123; for(int v = 2; v &lt;= 1000; ++v) for(int u = 1; u &lt; v; ++u)&#123; if((u &amp; 1) &amp;&amp; (v &amp; 1))continue; if(gcd(u, v) != 1)continue; int dis = 2 * v * v + 2 * u * v; if(dis &gt; 1500000) break; for(int i = dis; i &lt;= 1500000; i += dis) cnt[i]++; &#125;&#125;void solve()&#123; pre(); for(int i = 12; i &lt;= 1500000; i += 2) if(cnt[i] == 1) ans++; printf("%d\n", ans);&#125; 答案：161667 PE76划分问题。令$p(n, m)$表示$n$划分为若干个小于等于$m$的数的方法数。那么有 p(n, m)=\begin{cases} 1\quad(n = 0) \\ p(n, m - 1)\quad (m >n)\\p(n, m - 1) +p (n - m, m)\quad (else)\end{cases}1234567891011121314ll p[105][105] = &#123;0&#125;;void solve()&#123; for(int i = 1; i &lt;= 100; ++i) p[1][i] = 1ll; for(int i = 2; i &lt;= 100; ++i)&#123; p[i][1] = 1ll; for(int j = 2; j &lt; i; ++j) p[i][j] = p[i][j - 1] + p[i - j][j]; p[i][i] = p[i][i - 1] + 1; for(int j = i + 1; j &lt;= 100; ++j) p[i][j] = p[i][j - 1]; &#125; printf("%lld\n", p[100][99]);&#125; 答案：190569291 PE77对pe76进行一定程度的加工即可。12345678910111213141516171819202122232425262728293031ll p[10005][10005] = &#123;0&#125;;bool vis[10005] = &#123;0&#125;;int prime[5005], tot = 0;void init()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; prime[tot++] = i; &#125;&#125;void solve()&#123; int ans; for(int i = 0; i &lt; tot; ++i) p[0][prime[i]] = 1ll; for(int i = 2; i &lt;= 10000; ++i)&#123; int id = upper_bound(prime, prime + tot, i) - prime - 1; //int pp = prime[id]; if(i &amp; 1) p[i][2] = 0; else p[i][2] = 1; for(int j = 1; j &lt;= id; ++j) p[i][prime[j]] = p[i][prime[j - 1]] + p[i - prime[j]][prime[j]]; for(int j = id + 1; j &lt; tot; ++j) p[i][prime[j]] = p[i][prime[j - 1]]; if(p[i][prime[id]] &gt; 5000)&#123; ans = i; break; &#125; &#125; printf("%d\n", ans);&#125; 答案：71（蜜汁小） PE78一开始拿pe76写了很久，结果什么都没有。。。后来发现了一个很神奇的东西。12 PE79…手算…?对所有询问排个序，去个重，就差不多可以发现一些问题了。答案：73162890 PE80考虑到精度问题，我们考虑对一个大整数开根号。比如计算$\sqrt 2$的前一百位，可以改为计算$10^{100}\times \sqrt 2$的前一百位。即先把根号的值放大，然后二分出具体的值即可。12345678910111213141516171819x = 10 ** 300ans = 0for i in range(2, 100, 1): y = math.floor(math.sqrt(i) + 0.5) if y * y != i: z = i * x l = 1 r = z while r - l &gt; 0: mid = (r + l) &gt;&gt; 1 if mid * mid &lt; z: l = mid + 1 else: r = mid s = str(l) for j in range(0, 100, 1): ans += eval(s[j: j + 1])print(ans) 答案：40886 PE81水DP答案：427337 PE82根据矩阵和走路的方式建图，跑最短路即可。12 答案： PE83同上。 PE84我不会这样的神奇概率题。。。我就模拟这个游戏足够多次，然后根据访问次数判断哪三个地方访问概率最大。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int vis[49] = &#123;0&#125;, cur = 0;int curc = 0, curh = 0;int cc[20] = &#123;0&#125;, ch[20] = &#123;0&#125;;pair&lt;int, int&gt; pp[45];pair&lt;int, int&gt; getS()&#123; int i = 1 + rand() % 4, j = 1 + rand() % 4; return make_pair(i, j);&#125;int getR(int x)&#123; if(x == 7)return 15; if(x == 22)return 25; if(x == 36)return 5;&#125;int getU(int x)&#123; if(x == 7)return 12; if(x == 22)return 28; if(x == 36)return 12;&#125;void init()&#123; srand(time(NULL)); cc[rand() % 16] = 1; int i = rand() % 16; while(cc[i]) i = rand() % 16; cc[i] = 2; for(int j = 1; j &lt;= 10; ++j)&#123; i = rand() % 16; while(ch[i]) i = rand() % 16; ch[i] = j; &#125;&#125;void solve()&#123; int lst = 0; for(int i = 1; i &lt;= 100000000; ++i)&#123; pair&lt;int, int&gt; p = getS(); int d = p.first + p.second; if(p.first == p.second) lst++; else lst = 0; if(lst == 3)&#123; cur = 10, lst = 0; &#125;else&#123; int to = (cur + d) % 40; if(to == 2 || to == 17 || to == 33)&#123; int id = cc[curc]; curc = (curc + 1) % 16; if(id == 1)&#123; cur = 0; &#125;else if(id == 2)&#123; cur = 10; &#125;else&#123; cur = to; &#125; &#125;else if(to == 7 || to == 22 || to == 36)&#123; int id = ch[curh]; curh = (curh + 1) % 16; if(id == 1)&#123; cur = 0; &#125;else if(id == 2)&#123; cur = 10; &#125;else if(id == 3)&#123; cur = 11; &#125;else if(id == 4)&#123; cur = 24; &#125;else if(id == 5)&#123; cur = 39; &#125;else if(id == 6)&#123; cur = 5; &#125;else if(id == 7 || id == 8)&#123; cur = getR(to); &#125;else if(id == 9)&#123; cur = getU(to); &#125;else if(id == 10)&#123; cur = to - 3; &#125;else&#123; cur = to; &#125; &#125;else if(to == 30)&#123; cur = 10; &#125;else&#123; cur = to; &#125; &#125; vis[cur]++; &#125; for(int i = 0; i &lt; 40; ++i) pp[i] = make_pair(vis[i], i); sort(pp, pp + 40); for(int i = 39; i &gt; 36; --i) printf("%d", pp[i].second);&#125; 答案：101524 PE85小学奥数题。边长为$n,m$的矩形内部有C_{n+1}^2 C_{m+1}^2个小矩形。123456789101112ll ans = INF, maxi;void solve()&#123; for(int i = 1; i &lt;= 2000; ++i)&#123; for(int j = 1; j &lt;= 2000; ++j)&#123; ll pp = 1ll * i * j * (i + 1) * (j + 1); pp &gt;&gt;= 2; if(abs(pp - 2000000) &lt; ans) ans = abs(pp - 2000000), maxi = 1ll * i * j; &#125; &#125; printf("%lld\n", maxi);&#125; 答案：2772 PE87直接3重循环，算出所有可能即可。1234567891011121314151617181920212223242526272829303132bool vis[10005] = &#123;0&#125;;int prime[4][10005], tot[4] = &#123;0&#125;;bool dd[50000005] = &#123;0&#125;;void getP()&#123; for(int i = 2; i &lt;= 8000; ++i) if(!vis[i])&#123; for(int j = i + i; j &lt;= 8000; j += i) vis[j] = 1; prime[0][++tot[0]] = i; &#125;&#125;void solve()&#123; getP(); for(int i = 1; i &lt; 4; ++i)&#123; for(int j = 1; j &lt;= tot[i - 1]; ++j)&#123; if(1ll * prime[0][j] * prime[i - 1][j] &gt;= 50000000ll)&#123; tot[i] = j - 1; break; &#125; prime[i][j] = prime[0][j] * prime[i - 1][j]; &#125; &#125; for(int k = 1; k &lt;= tot[1]; ++k) for(int i = 1; i &lt;= tot[2]; ++i) for(int j = 1; j &lt;= tot[3]; ++j) if(prime[1][k] + prime[2][i] + prime[3][j] &lt; 50000000) dd[prime[1][k] + prime[2][i] + prime[3][j]] = 1; int ans = 0; for(int i = 1; i &lt; 50000000; ++i) ans += dd[i]; printf("%d\n", ans);&#125; 答案：1097343 PE90生成组合，然后测试即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int cb[2][10], ans = 0;void judge()&#123; int l[2]; l[0] = l[1] = 0; for(int o = 0; o &lt; 2; ++o)&#123; int flag = 0; for(int i = 0; i &lt; 6; ++i)&#123; l[o] |= (1 &lt;&lt; cb[o][i]); if(cb[o][i] == 6 || cb[o][i] == 9) flag += cb[o][i]; &#125; if(flag == 6) l[o] |= (1 &lt;&lt; 9); if(flag == 9) l[o] |= (1 &lt;&lt; 6); &#125; int flag = 1; for(int i = 1; i &lt; 10; ++i)&#123; int g = (i * i) % 10, s = (i * i) / 10; g = 1 &lt;&lt; g, s = 1 &lt;&lt; s; if(((s &amp; l[0]) &amp;&amp; (g &amp; l[1])) || (s &amp; l[1]) &amp;&amp; (g &amp; l[0]))&#123; continue; &#125;else&#123; flag = 0; break; &#125; &#125; ans += flag;&#125;void getC(int o, int index, int left)&#123; cb[o][5 - left] = index; if(!left)&#123; if(!o) for(int i = 0; i &lt;= 4; ++i) getC(1, i, 5); else&#123; judge(); &#125; return ; &#125; for(int i = index + 1; i &lt;= 10 - left; ++i) getC(o, i, left - 1);&#125;void solve()&#123; for(int i = 0; i &lt;= 4; ++i) getC(0, i, 5); printf("%d\n", ans &gt;&gt; 1);&#125; 答案：1217 PE91四重循环。。。12345678910111213141516int ans = 0;void solve()&#123; for(int i = 0; i &lt;= 50; ++i) for(int j = 0; j &lt;= 50; ++j) for(int k = 0; k &lt;= 50; ++k) for(int l = 0; l &lt;= 50; ++l)&#123; if(!i &amp;&amp; !j)continue; if(!k &amp;&amp; !l)continue; if(i == k &amp;&amp; j == l)continue; int a = i * i + j * j, b = k * k + l * l, c = (i - k) *(i - k) + (j - l) * (j - l); if(a + b == c || a + c == b || b + c == a) ans++; &#125; printf("%d\n", ans &gt;&gt; 1);&#125; 答案：14234 PE92直接模拟即可。。89的比例还是挺高的。1234567891011121314151617int ans = 0;int sqr(int x)&#123; return x * x;&#125;void solve()&#123; for(int i = 2; i &lt; 10000000; ++i)&#123; int j = i; for(; j != 1 &amp;&amp; j != 89; )&#123; int sum = 0; while(j) sum += sqr(j % 10), j /= 10; j = sum; &#125; if(j == 89)ans++; &#125; printf("%d\n", ans);&#125; 答案：8581146 PE94做一些数学上的分析根据海伦公式有：$S=\sqrt{p(p-a)(p-b)(p-c)}$其中$a,b,c$均为边长在这道题中上式可以化为$S=(p-i)\sqrt{p(p-i-1)}$或$S=(p-i)\sqrt{p(p-i+1)}$然后由于面积要求为正整数，所以需要$p(p-i+1)$为完全平方数按照这个枚举即可。123456789101112131415161718bool sqr(ll x)&#123; ll r = (ll)floor(sqrt(x) + 0.5); return r * r == x;&#125;void solve()&#123; int ans = 0; for(int i = 3; i &lt;= 333333333; i += 2)&#123; ll p = (3 * i - 1) &gt;&gt; 1; p *= (i + 1) &gt;&gt; 1; if(sqr(p)) ans += 3 * i - 1; p = (3 * i + 1) &gt;&gt; 1; p *= (i - 1) &gt;&gt; 1; if(sqr(p)) ans += 3 * i + 1; &#125; printf("%d\n", ans);&#125; 答案：518408346 PE95对每一个数DFS一遍即可。1234567891011121314151617181920212223242526272829303132int d[1000005] = &#123;0&#125;;int ans = 0, mini;int vis[1000005] = &#123;0&#125;, tot = 0;void getD()&#123; for(int i = 2; i &lt;= 1000000; ++i)&#123; int j; for(j = 1; j * j &lt; i; ++j) if(i % j == 0) d[i] += j + i / j; if(j * j == i)d[i] += j; d[i] -= i; &#125;&#125;void dfs(int x, int st)&#123; vis[x] = tot; if(d[x] &gt; 1000000 || !d[x]) return ; if(vis[d[x]] == tot)&#123; if(st &gt; ans) ans = st, mini = d[x]; return ; &#125;else if(!vis[d[x]])&#123; dfs(d[x], st + 1); &#125;&#125;void solve()&#123; getD(); for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i]) tot++, dfs(i, 1); printf("%d %d\n", mini, ans);&#125; 答案：14316 PE96把现成的数独模板丢上去即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0;int tans[10][10]=&#123;0&#125;;void get(int at)&#123; int mini=99,p,x,y,o; for(int i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(int j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini)mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1]; lis[at+1][0]=lis[p][0],lis[at+1][1]=lis[p][1]; lis[p][0]=x,lis[p][1]=y;&#125;void dfs(int at)&#123; int x=lis[at][0],y=lis[at][1]; for(int i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1,sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125;else &#123; memcpy(tans, sd, sizeof(sd)); &#125; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0,sd[x][y]=0; &#125;&#125;//0 行 1 列 2 宫 int main()&#123; int ans = 0; char s1[10], s2[10]; for(int i = 0; i &lt; 50; ++i)&#123; int tmp; tot = 0; memset(sd, 0, sizeof(sd)); memset(lis, 0, sizeof(lis)); memset(vis, 0, sizeof(vis)); scanf("%s%s", s1, s2); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp)&#123; sd[i][j]=tmp; vis[0][i][tmp]=vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; &#125;else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); ans += tans[0][0] * 100 + tans[0][1] * 10 + tans[0][2]; &#125; printf("%d\n", ans); return 0; &#125; 答案：24702 PE97python，这个我还能说什么。。。答案：8739992577 PE99化成对数比即可。1234567891011double maxm = 0;int ans;void solve()&#123; for(int i = 1; i &lt;= 1000; ++i)&#123; int b = read(), e = read(); double tt = 1.0 * e * log(b); if(tt &gt; maxm) maxm = tt, ans = i; &#125; printf("%d\n", ans);&#125; 答案：709]]></content>
      <categories>
        <category>ProjectEuler</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectEuler 1-60题解]]></title>
    <url>%2F2018%2F08%2F11%2Fpe1-60%2F</url>
    <content type="text"><![CDATA[探索新领域PE前面的题还是很比较简单的。除了某些题（如51，60）需要一定的枚举策略之外，其他题大部分靠暴力即可。 PE1直接枚举即可。1234567void solve()&#123; int sum = 0; for(int i = 3; i &lt; 1000; ++i) if(i % 3 == 0 || i % 5 == 0) sum += i; printf("%d\n", sum);&#125; 答案：233168 PE2直接枚举即可。1234567891011int fib[1005];void solve()&#123; int i, sum = 0; fib[0] = 1, fib[1] = 2; for(i = 2; fib[i - 1] &lt; 4000000; ++i) fib[i] = fib[i - 1] + fib[i - 2]; for(; i &gt;= 0; --i) if(fib[i] &lt;= 4000000 &amp;&amp; fib[i] % 2 == 0) sum += fib[i]; printf("%d\n", sum);&#125; 答案：4613732 PE3本来可以直接上Pollard-Rho，后来想了一下其实不用。因为这个数还是比较小的。1234567891011ll c = 600851475143;void solve()&#123; ll tmp = c; for(ll i = 2; i * i &lt;= c; ++i) if(tmp % i == 0)&#123; while(tmp % i == 0 &amp;&amp; tmp / i != 1) tmp /= i; if(tmp / i == 1)break ; &#125; printf("%d\n", tmp);&#125; 答案：6857 PE4枚举即可。1234567891011121314151617bool isP(int t)&#123; char s[8]; sprintf(s, "%d", t); int len = strlen(s); for(int i = 0; i &lt; (len &gt;&gt; 1); ++i) if(s[i] != s[len - i -1]) return false; return true;&#125;void solve()&#123; int ans = 0; for(int i = 100; i &lt; 1000; ++i) for(int j = 100; j &lt; 1000; ++j) if(isP(i * j)) ans = max(ans, i * j); printf("%d\n", ans);&#125; 答案：906609 PE5可以手算出答案。答案：232792560 PE6直接手算即可。答案：25164150 PE7直接用筛法计算即可。12345678910111213bool vis[1000005] = &#123;0&#125;;int sum = 0;void solve()&#123; int N = 1000000; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; sum++; if(sum == 10001)printf("%d\n", i); for(int j = i + i; j &lt;= N; j += i) vis[j] = 1; &#125; &#125;&#125; 答案：104743 PE8直接遍历即可。123456789101112131415char num[1005];ll ans = 0;void init()&#123; for(int i = 0; i &lt; 20; ++i) scanf("%s", num + i * 50);&#125;void solve()&#123; for(int i = 0; i &lt;= 987; ++i)&#123; ll pro = 1; for(int j = 0; j &lt; 13; ++j) pro *= (ll)(num[i + j] - '0'); ans = max(ans, pro); &#125; printf("%lld\n", ans);&#125; 答案：23514624000 PE9直接循环遍历，枚举即可。1234567891011ll ans;void solve()&#123; for(int i = 3; i &lt;= 1000; ++i) for(int j = 3; j &lt;= 1000; ++j) if(i * i + j * j == (1000 - i - j) * (1000 - i - j) &amp;&amp; 1000 &gt; i + j)&#123; ans = 1ll * i * j * (1000 - i - j); goto printans; &#125; printans: printf("%lld\n", ans);&#125; 答案：31875000 PE10使用筛法即可。12345678910111213bool vis[2000005] = &#123;0&#125;;ll sum = 0;void solve()&#123; int N = 2000000; for(int i = 2; i &lt;= N; ++i)&#123; if(!vis[i])&#123; sum += (ll)i; for(int j = i + i; j &lt;= N; j += i) vis[j] = 1; &#125; &#125; printf("%lld\n", sum);&#125; 答案：142913828922 PE11枚举即可。一个数只需要枚举4个方向。12345678910111213141516171819202122232425262728293031323334353637int dat[25][25];void init()&#123; for(int i = 0; i &lt; 20; ++i) for(int j = 0; j &lt; 20; ++j) dat[i][j] = read();&#125;void solve()&#123; int ans = 0; for(int i = 0; i &lt; 20; ++i) for(int j = 0; j &lt; 20; ++j)&#123; if(i &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j]; ans = max(ans, t); &#125; if(j &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i][j - k]; ans = max(ans, t); &#125; if(i &gt;= 3 &amp;&amp; j &gt;= 3)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j - k]; ans = max(ans, t); &#125; if(i &gt;= 3 &amp;&amp; j &lt;= 16)&#123; int t = 1; for(int k = 0; k &lt; 4; ++k) t *= dat[i - k][j + k]; ans = max(ans, t); &#125; &#125; printf("%d\n", ans);&#125; 答案：70600674 PE12直接枚举每一个三角形数的因子即可。123456789101112131415161718int getD(ll t)&#123; int cnt = 0; ll i; for(i = 1; i * i &lt; t; ++i) if(t % i == 0) cnt += 2; if(i * i == t)cnt++; return cnt;&#125;void solve()&#123; ll t, n; for(n = 11; ; ++n)&#123; t = n * (n + 1) &gt;&gt; 1; if(getD(t) &gt; 500) break; &#125; printf("%lld\n", t);&#125; 答案：76576500 PE13用python水过去123456y = 0for i in range(1, 101, 1): x = input() y = y + xprint(y) 答案：5537376230 PE14直接跑递归即可。看清题目，问的是什么数产生最长链而不是最长链有多长！12345678910111213141516171819202122int step[1000005] = &#123;0&#125;, ans = 0, maxi;int go(ll cur)&#123; if(cur &lt;= 1000000 &amp;&amp; step[cur]) return step[cur]; int res; if(cur &amp; 1) res = go(cur * 3 + 1) + 1; else res = go(cur &gt;&gt; 1) + 1; if(cur &lt;= 1000000) step[cur] = res; return res;&#125;void solve()&#123; step[1] = 1; for(int i = 2; i &lt;= 1000000; ++i)&#123; go(i); if(step[i] &gt; ans) ans = step[i], maxi = i; &#125; printf("%d\n", maxi);&#125; 答案：837799 PE15即为C_{40}^{20}答案：137846528820 PE16用python水过1234567x = 2 ** 1000sum = 0while x &gt; 0: sum += x % 10 x /= 10print(sum) 答案：1366 PE17神奇模拟题。了解一下英式的读数字方式即可。12345678910111213141516171819202122int ge[] = &#123;0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8&#125;;int ten[] = &#123;0, 0, 6, 6, 5, 5, 5, 7, 6, 6&#125;;void solve()&#123; int sum = 0; for(int i = 1; i &lt; 1000; ++i)&#123; if(i &lt; 20) sum += ge[i]; else if(i &lt; 100) sum += ge[i % 10] + ten[i / 10]; else &#123; sum += ge[i / 100] + 7; if(i % 100 != 0)&#123; sum += 3;//and if(i % 100 &lt; 20) sum += ge[i % 100]; else sum += ge[i % 10] + ten[(i % 100) / 10]; &#125; &#125; &#125; printf("%d\n", sum + 11);//one thousand&#125; 答案：21124 PE18一个简单的DP。12345678910111213141516int dat[17][17] = &#123;0&#125;;int dp[17][17] = &#123;0&#125;;void init()&#123; for(int i = 1; i &lt;= 15; ++i) for(int j = 1; j &lt;= i; ++j) dat[i][j] = read();&#125;void solve()&#123; for(int i = 1; i &lt;= 15; ++i) for(int j = 1; j &lt;= i; ++j) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + dat[i][j]; int ans = 0; for(int i = 1; i &lt;= 15; ++i) ans = max(ans, dp[15][i]); printf("%d\n", ans);&#125; 答案：1074 PE19模拟。1234567891011121314151617181920212223int month[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;void solve()&#123; int cury = 1901, curm = 1, curd = 1, curx = 2, ans = 0; for(; ; )&#123; curd++, curx++; if(curd &gt; month[curm])&#123; if(curm != 2)&#123; curm++, curd = 1; &#125;else&#123; if(cury % 4 != 0) curm++, curd = 1; else if(curd == 30) curm++, curd = 1; &#125; &#125; if(curm == 13) cury++, curm = 1; if(cury &gt; 2000)break; if(curx == 8)curx = 1; if(curx == 7 &amp;&amp; curd == 1)ans++; &#125; printf("%d\n", ans);&#125; 答案：171 PE20用python水过12345678910x = 1for i in range(2, 101, 1): x *= ians = 0while x &gt; 0: ans += x % 10 x /= 10print(ans) 答案：648 PE21遍历即可。1234567891011121314151617int ans = 0;int d(int x)&#123; int res = 0, i = 1; for(i = 1; i * i &lt; x; ++i) if(x % i == 0) res += i + x / i; if(i * i == x)res += i; return res - x;&#125;void solve()&#123; for(int i = 2; i &lt; 10000; ++i)&#123; int dd = d(i); if(dd != i &amp;&amp; d(dd) == i) ans += i + dd; &#125; printf("%d\n", ans &gt;&gt; 1);&#125; 答案：31626 PE22用string排序后水过。12345678910111213141516171819202122232425char s[105];string ss[10005];int n = 0;void solve()&#123; for(; ; )&#123; char c = getchar(); if(c == EOF)break; int i = 0; while((c = getchar()) != '"') s[i++] = c; s[i] = '\0'; getchar(); n++; ss[n] = s; &#125; sort(ss + 1, ss + n + 1); ll ans = 0; for(int i = 1; i &lt;= n; ++i)&#123; int len = ss[i].length(), sum = 0; for(int j = 0; j &lt; len; ++j) sum += ss[i][j] - 'A' + 1; ans += 1ll * sum * i; &#125; printf("%lld\n", ans);&#125; 答案：871198282 PE23暴力水过12345678910111213141516171819202122232425int d[30005] = &#123;0&#125;, lis[30005], tot = 0;bool vis[30005] = &#123;0&#125;;void init()&#123; for(int i = 1; i &lt;= 28123; ++i)&#123; int j; for(j = 1; j * j &lt; i; ++j) if(i % j == 0) d[i] += j + i / j; if(j * j == i)d[i] += j; d[i] -= i; if(d[i] &gt; i) lis[++tot] = i; &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= tot; ++i) for(int j = i; j &lt;= tot; ++j) if(lis[i] + lis[j] &lt;= 28123) vis[lis[i] + lis[j]] = 1; int ans = 0; for(int i = 1; i &lt;= 28123; ++i) if(!vis[i]) ans += i; printf("%d\n", ans);&#125; 答案：4179871 PE24大力next_permutation答案：2783915460 PE25用python水过。123456789101112x = 1y = 1ind = 2while True: z = x + y x = y y = z ind += 1 if len(str(z)) == 1000: breakprint(ind) 答案：4782 PE26当余数出现循环时终止即可。12345678910111213141516171819202122int lis[1005], tot, cur[1005];int ans = 0, maxi;void solve()&#123; for(int i = 11; i &lt; 1000; ++i)&#123; int t = 10; memset(cur, 0, sizeof(cur)); for(tot = 1; ; ++tot)&#123; lis[tot] = t / i; if(!cur[t % i]) cur[t % i] = tot; else&#123; if(ans &lt; tot - cur[t % i]) ans = tot - cur[t % i], maxi = i; break ; &#125; t %= i; t *= 10; &#125; &#125; printf("%d %d\n", ans, maxi);&#125; 答案：983 PE27枚举即可。注意负数不能算质数。123456789101112131415161718192021int ans = 0, maxi;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;void solve()&#123; for(int a = -999; a &lt; 1000; ++a)&#123; for(int b = 2; b &lt;= 1000; ++b)&#123; int n; for(n = 0; ; ++n) if(!isP(n * n + a * n + b)) break; if(n &gt; ans) ans = n, maxi = a * b; &#125; &#125; printf("%d\n", maxi);&#125; 答案：-59231 PE28模拟出蛇形数阵即可。12345678910111213141516171819int d[1005][1005] = &#123;0&#125;;int dx[] = &#123;1, 0, -1, 0, 0&#125;, dy[] = &#123;0, -1, 0, 1, 1&#125;;void solve()&#123; int x = 501, y = 502, c = 2; d[501][501] = 1; for(int i = 2; i &lt;= 1000; i += 2)&#123; for(int j = 0; j &lt; 4; ++j)&#123; for(int k = 0; k &lt; i; ++k) d[x][y] = c, c++, x += dx[j], y += dy[j]; x -= dx[j], y -= dy[j]; x += dx[j + 1], y += dy[j + 1]; &#125; &#125; int sum = 0; for(int i = 1; i &lt;= 1001; ++i) sum += d[i][i] + d[i][1002 - i]; printf("%d\n", sum - 1);&#125; 答案：669171001 PE29用对数表示幂，排序去重即可。会有奇怪的精度问题。12345678910111213141516double d[10005];int tot = 0, ans = 0;bool cmp(const double&amp; d1, const double&amp; d2)&#123; return abs(d1 - d2) &lt; 1e-5;&#125;void solve()&#123; for(int i = 2; i &lt;= 100; ++i) for(int j = 2; j &lt;= 100; ++j) d[tot++] = 100.0 * j * log(i); sort(d, d + tot); double cur = -1; for(int i = 0; i &lt; tot; ++i) if(!cmp(cur, d[i])) cur = d[i], ans++; printf("%d\n", ans);&#125; 答案：9183 PE30枚举即可。上界小于100000012345678910111213int sum = 0;int qq(int x)&#123; return x * x * x * x * x;&#125;void solve()&#123; for(int i = 2; i &lt;= 1000000; ++i)&#123; int t = i, s = 0; while(t) s += qq(t % 10), t /= 10; if(s == i)sum += i; &#125; printf("%d\n", sum);&#125; 答案：443839 PE31多重背包。1234567891011121314int w[] = &#123;1, 2, 5, 10, 20, 50, 100, 200&#125;;int f[205] = &#123;0&#125;;void solve()&#123; f[0] = 1; for(int i = 0; i &lt; 8; ++i)&#123; for(int j = 1; ; j &lt;&lt;= 1)&#123; int d = j * w[i]; if(d &gt; 200)break ; for(int k = 200; k &gt;= d; --k) f[k] += f[k - d]; &#125; &#125; printf("%d\n", f[200]);&#125; 答案：73682 PE32从1234开始枚举即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int cnt[11];bool f(int x)&#123; bool flag = 1; while(x)&#123; if(cnt[x % 10] || x % 10 == 0) flag = 0; cnt[x % 10]++, x /= 10; &#125; return flag;&#125;void t(int x)&#123; while(x) cnt[x % 10]--, x /= 10;&#125;void solve()&#123; int ans = 0; for(int i = 1234; i &lt; 1000000; ++i)&#123; for(int j = 1; j &lt; 10; ++j) cnt[j] = 0; if(!f(i))continue ; for(int j = 2; j * j &lt; i; ++j)&#123; if(i % j == 0)&#123; if(!f(j))&#123; t(j); continue ; &#125;else&#123; if(!f(i / j))&#123; t(i / j), t(j); continue; &#125;else&#123; int flag = 1; for(int i = 1; i &lt; 10; ++i) if(cnt[i] != 1)&#123; flag = 0; break; &#125; if(flag)&#123; printf("%d %d %d\n", i, j, i / j); ans += i; break ; &#125;else &#123; t(j), t(i / j); continue; &#125; &#125; &#125; &#125; &#125; &#125; printf("%d\n", ans);&#125; 答案：45228 PE33枚举分子分母即可。题意有点不太好懂。1234567891011121314151617181920212223void solve()&#123; int fz = 1, fm = 1, cnt = 0; for(int i = 10; i &lt;= 99; ++i) for(int j = i + 1; j &lt;= 99; ++j)&#123; if(i % 10 == 0 &amp;&amp; j % 10 == 0) continue ; int a = i / 10, b = i % 10, c = j / 10, d = j % 10; if(a == c)&#123; if(i * d == j * b) fz *= i, fm *= j, cnt++; &#125;else if(a == d)&#123; if(i * c == j * b) fz *= i, fm *= j, cnt++; &#125;else if(b == c)&#123; if(i * d == j * a) fz *= i, fm *= j, cnt++; &#125;else if(b == d)&#123; if(i * c == j * a) fz *= i, fm *= j, cnt++; &#125; &#125; printf("%d %d\n", fm / gcd(fm, fz), cnt);&#125; 答案：100 PE34枚举即可只有2个数符合。。1234567891011121314int f[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;void solve()&#123; ll ans = 0; for(int i = 10; i &lt;= 100000000; ++i)&#123; int t = i, sum = 0; while(t) sum += f[t % 10], t /= 10; if(sum == i) ans += 1ll * i, printf("%d\n", i); &#125; printf("%lld\n", ans);&#125; 答案：40730 PE35循环枚举即可。1234567891011121314151617181920212223242526bool vis[1000005] = &#123;0&#125;;char s[16];void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; &#125;&#125;void solve()&#123; getP(); int ans = 13; for(int i = 111; i &lt; 1000000; i += 2)&#123; if(vis[i])continue; sprintf(s, "%d", i); int len = strlen(s), j; sprintf(s + len, "%d", i); for(j = len; j &gt; 0; --j)&#123; s[j + len] = '\0'; if(vis[atoi(s + j)]) break ; &#125; if(!j)ans++; &#125; printf("%d\n", ans);&#125; 答案：55 PE36直接枚举回文数即可。1234567891011121314151617181920212223ll sum = 0;int d[30];bool isP(int x)&#123; int t = x, cnt = 0; while(t) d[cnt++] = t % 10, t /= 10; for(int i = 0; i &lt; (cnt &gt;&gt; 1); ++i) if(d[i] != d[cnt - i - 1]) return false; t = x, cnt = 0; while(t) d[cnt++] = t % 2, t &gt;&gt;= 1; for(int i = 0; i &lt; (cnt &gt;&gt; 1); ++i) if(d[i] != d[cnt - i - 1]) return false; return true;&#125;void solve()&#123; for(int i = 1; i &lt; 1000000; i += 2) if(isP(i)) sum += 1ll * i; printf("%lld\n", sum);&#125; 答案：872187 PE37枚举即可1234567891011121314151617181920212223242526272829303132333435int sum = 0, ten[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000&#125;;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool is(int x)&#123; int t = x; if(!isP(x))return false; for(; ; )&#123; t /= 10; if(!t)break; if(!isP(t))return false; &#125; int m; for(m = 1; ten[m] &lt; x; m++) ; for(m--; m &gt; 0; --m)&#123; x %= ten[m]; if(!isP(x))return false; &#125; return true;&#125;void solve()&#123; int cnt = 0; for(int i = 11; cnt &lt; 11 &amp;&amp; i &lt; 1000000; i += 2)&#123; if(i % 10 != 3 &amp;&amp; i % 10 != 7) continue ; if(is(i)) cnt++, sum += i, printf("%d\n", i); &#125; printf("%d\n", sum);&#125; 答案：748317 PE38枚举这样的数即可12345678910111213141516171819202122232425262728int ans = 0;bool vis[11];void solve()&#123; char s[15]; for(int i = 2; i &lt; 10000; ++i)&#123; memset(vis, 0, sizeof(vis)); int cnt = 0, flag = 1, j; for(j = 1; flag &amp;&amp; cnt &lt; 9 &amp;&amp; j &lt; 10; ++j)&#123; int t = i * j; while(t)&#123; if(t % 10 == 0 || vis[t % 10])&#123; flag = 0; break; &#125;else vis[t % 10] = 1, cnt++, t /= 10; &#125; &#125; if(cnt == 9 &amp;&amp; flag)&#123; s[0] = '\0'; for(int k = 1, st = 0; k &lt; j; ++k) sprintf(s + st, "%d", k * i), st = strlen(s); ans = max(ans, atoi(s)); &#125; &#125; printf("%d\n", ans);&#125; 答案：932718654 PE39循环枚举即可1234567891011121314int ans = 0, maxi;void solve()&#123; for(int i = 12; i &lt;= 1000; ++i)&#123; int cnt = 0; for(int j = 3; j &lt;= i / 3; ++j)&#123; for(int k = j + 1; k &lt; i - j - j &amp;&amp; k &lt; (i - j) &gt;&gt; 1; ++k) if(j * j + k * k == (i - j - k) * (i - j - k)) cnt++; if(cnt &gt; ans) ans = cnt, maxi = i; &#125; &#125; printf("%d\n", maxi);&#125; 答案：840 PE40貌似只能枚举。。。数据还特别大。跑了几分钟才跑出来。123456789101112131415161718int len = 0;char s[1000105];int c(int x)&#123; return s[x - 1] - '0';&#125;void solve()&#123; s[0] = '\0'; for(int i = 1; len &lt; 1000000; ++i)&#123; sprintf(s + len, "%d", i); if(i &lt; 10)len++; else if(i &lt; 100)len += 2; else if(i &lt; 1000)len += 3; else if(i &lt; 10000)len += 4; else if(i &lt; 100000)len += 5; else if(i &lt; 1000000)len += 6; &#125; printf("%d\n", c(1) * c(10) * c(100) * c(1000) * c(10000) * c(100000) * c(1000000));&#125; 答案：210 PE41从长度为9的排列开始，一直向下尝试。123456789101112131415161718int p[] = &#123;7, 6, 5, 4, 3, 2, 1&#125;;bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;void solve()&#123; while(prev_permutation(p, p + 7))&#123; printf("x"); int x = 0; for(int i = 0; i &lt; 7; ++i) x = x * 10 + p[i]; if(isP(x))break ; &#125; for(int i = 0; i &lt; 7; ++i) printf("%d", p[i]);&#125; 答案：7652413 PE42字符串题。。。123456789101112131415161718int seq[10005], ans = 0;char s[16];void solve()&#123; for(int i = 1; i &lt;= 10000; ++i) seq[i - 1] = i * (i + 1) &gt;&gt; 1; for(; ; )&#123; char c = getchar(); if(c == EOF)break; int i = 0, sum = 0; while((c = getchar()) != '"') s[i++] = c, sum += c - 'A' + 1; s[i] = '\0'; getchar(); if(*lower_bound(seq, seq + 10000, sum) == sum) ans++; &#125; printf("%d\n", ans);&#125; 答案：162 PE43枚举排列即可。12345678910111213141516171819202122int p[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int pr[] = &#123;2, 3, 5, 7, 11, 13, 17&#125;;ll ans = 0;void solve()&#123; do&#123; int flag = 1; for(int i = 1; i &lt; 8; ++i)&#123; int j = p[i] * 100 + p[i + 1] * 10 + p[i + 2]; if(j % pr[i - 1] != 0)&#123; flag = 0; break; &#125; &#125; if(flag)&#123; ll x = 0; for(int i = 0; i &lt; 10; ++i) x = x * 10 + p[i]; ans += 1ll * x; &#125; &#125;while(next_permutation(p, p + 10)); printf("%lld\n", ans);&#125; 答案：16695334890 PE44枚举。但是数据有一点吓人。123456789101112131415161718192021222324ll seq[40005];void solve()&#123; for(ll i = 1; i &lt;= 40000; ++i) seq[i - 1] = i * (3 * i - 1) &gt;&gt; 1; int i; for(i = 0; i &lt; 40000; ++i)&#123; int flag = 0; for(int j = 0; j &lt; 40000; ++j)&#123; ll sum = seq[i] + seq[j]; int index = lower_bound(seq, seq + 40000, sum) - seq; if(index == 40000) break; if(seq[index] == sum)&#123; index = lower_bound(seq, seq + 40000, sum + seq[j]) - seq; if(index &lt; 40000 &amp;&amp; seq[index] == sum + seq[j])&#123; flag = 1; break; &#125; &#125; &#125; if(flag)break ; &#125; printf("%lld\n", seq[i]);&#125; 答案：5482660 PE45枚举即可。三角形数有点大。12345678910111213141516ll sqr(ll x)&#123; ll r = (ll)floor(sqrt(x) + 0.5); if(r * r != x) return -1; return r;&#125;void solve()&#123; ll n; for(n = 286; n &lt; 1000000; ++n)&#123; ll t = n * (n + 1) &gt;&gt; 1; ll a = sqr(1 + 8 * t), b = sqr(1 + 24 * t); if(a &gt; 0 &amp;&amp; (1 + a) % 4 == 0 &amp;&amp; b &gt; 0 &amp;&amp; (1 + b) % 6 == 0) break; &#125; printf("%lld\n", n);&#125; 答案：1533776805 PE46枚举即可。123456789101112131415161718192021222324252627282930313233343536373839int prime[100005], tot = 0;bool vis[1000005] = &#123;0&#125;;bool isP(int x)&#123; if(x &lt;= 1)return false; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool isQ(int x)&#123; int d = (int)floor(sqrt(x) + 0.5); return d * d == x;&#125;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; prime[tot++] = i; &#125;&#125;void solve()&#123; int ans; getP(); for(int i = 35; ; i += 2)&#123; if(isP(i))continue ; int flag = 0; for(int j = 1; j &lt; tot &amp;&amp; i - prime[j] &gt; 0; ++j) if(isQ((i - prime[j]) &gt;&gt; 1))&#123; flag = 1; break ; &#125; if(!flag)&#123; ans = i; break; &#125; &#125; printf("%d\n", ans);&#125; 答案：5777 PE47找质因数即可12345678910111213141516171819202122232425int get(int x)&#123; int cnt = 0, t = x; for(int i = 2; i * i &lt;= x; ++i)&#123; if(t % i == 0)&#123; while(t % i == 0) t /= i; cnt++; &#125; if(t == 1)break; &#125; if(t != 1)cnt++; return cnt;&#125;void solve()&#123; bool b1 = 0, b2 = 0, b3 = 0, b4 = 0; int i; for(i = 6; ; ++i)&#123; if(get(i) == 4) b4 = 1; if(b1 &amp;&amp; b2 &amp;&amp; b3 &amp;&amp; b4) break; b1 = b2, b2 = b3, b3 = b4, b4 = 0; &#125; printf("%d\n", i - 3);&#125; 答案：134043 PE48大力python答案：9110846700 PE49枚举即可1234567891011121314151617181920212223242526272829303132bool vis[10005] = &#123;0&#125;;char s1[10], s2[10];void getP()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; &#125;&#125;bool cmp(int x, int y)&#123; sprintf(s1, "%d", x); sprintf(s2, "%d", y); sort(s1, s1 + 4); sort(s2, s2 + 4); return strcmp(s1, s2) == 0;&#125;void solve()&#123; getP(); int ans1 = 0, ans2 = 0; for(int i = 1489; i &lt; 10000; i += 2)&#123; if(vis[i])continue; for(int j = 2; i + j + j &lt; 10000; ++j)&#123; if(vis[i + j] || vis[i + j + j]) continue; if(!cmp(i, i + j) || !cmp(i, i + j + j)) continue; ans1 = i, ans2 = j; &#125; if(ans1)break; &#125; printf("%d%d%d\n", ans1, ans1 + ans2, ans1 + 2 * ans2);&#125; 答案：296962999629 PE50用前缀和枚举即可12345678910111213141516171819202122232425int prime[100005], tot = 0, sum[100005] = &#123;0&#125;;bool vis[1000005] = &#123;0&#125;;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; prime[++tot] = i; &#125;&#125;void solve()&#123; getP(); for(int i = 1; i &lt;= 9592; ++i) sum[i] = sum[i - 1] + prime[i]; int ans = 0; for(int i = 547; i &gt;= 0; --i)&#123; for(int j = i; sum[j] - sum[j - i] &lt; 1000000; ++j) if(!vis[sum[j] - sum[j - i]])&#123; ans = sum[j] - sum[j - i]; break ; &#125; if(ans)break ; &#125; printf("%d\n", ans);&#125; 答案：997651 PE51千万看清楚题目！替换的数字一开始就需要相同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748char s[10];bool vis[1000005] = &#123;0&#125;;int yq[6], i;void getP()&#123; for(int i = 2; i &lt;= 1000000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 1000000; j += i) vis[j] = 1; &#125;&#125;bool change()&#123; sprintf(s, "%d", i); int cnt = 0, lst = -1; for(int i = 0; i &lt; 5; ++i) if(yq[i])&#123; if(lst &lt; 0)lst = s[i] - '0'; else if(lst &gt; 2 || lst != s[i] - '0')return false; &#125; for(int i = lst; i &lt; 10; ++i)&#123; for(int j = 0; j &lt; 5; ++j) if(yq[j]) s[j] = i + '0'; if(!vis[atoi(s)]) cnt++; &#125; return cnt == 8;&#125;bool get(int d)&#123; if(d == 5)&#123; if(change()) return true; return false; &#125; yq[d] = 0; if(get(d + 1))return true; yq[d] = 1; if(get(d + 1))return true; return false;&#125;void solve()&#123; getP(); for(i = 100001; i &lt; 1000000; i += 2)&#123; if(i % 5 == 0 || vis[i])continue; if(get(0)) break ; &#125; printf("%d\n", i);&#125; 答案：121313 PE52居然真的是142857。。。12345678910111213141516171819int pp[8];void solve()&#123; int i; for(i = 1; i &lt;= 1000000; ++i)&#123; for(int j = 1; j &lt;= 6; ++j)&#123; pp[j] = 0; for(int t = i * j; t; t /= 10) pp[j] |= (1 &lt;&lt; (t % 10)); &#125; int flag = 1; for(int j = 2; j &lt;= 6; ++j) if(pp[j - 1] != pp[j])&#123; flag = 0; break; &#125; if(flag)break ; &#125; printf("%d\n", i);&#125; 答案：142857 PE53递推即可。123456789101112131415int dat[105][105] = &#123;0&#125;;void solve()&#123; dat[1][0] = dat[1][1] = 1; int ans = 0; for(int i = 2; i &lt;= 100; ++i)&#123; dat[i][0] = 1; for(int j = 1; j &lt;= 100; ++j)&#123; if(dat[i - 1][j] + dat[i - 1][j - 1] &gt; 1000000) dat[i][j] = 1000001, ans++; else dat[i][j] = dat[i - 1][j] + dat[i - 1][j - 1]; &#125; &#125; printf("%d\n", ans);&#125; 答案：4075 PE54这就是个模拟题和数学有毛关系123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224int p[2][6][2], ans = 0;int tab[128];int cnt[2][5], vcnt[2][19];void init()&#123; char cd[4]; for(int o = 0; o &lt; 2; ++o)&#123; for(int i = 0; i &lt; 5; ++i)&#123; scanf("%s", cd); p[o][i][1] = tab[cd[1]]; if(cd[0] == 'T') p[o][i][0] = 9; if(cd[0] == 'J') p[o][i][0] = 10; if(cd[0] == 'Q') p[o][i][0] = 11; if(cd[0] == 'K') p[o][i][0] = 12; if(cd[0] == 'A') p[o][i][0] = 13; if(isdigit(cd[0])) p[o][i][0] = cd[0] - '0' - 1; &#125; &#125; memset(cnt, 0, sizeof(cnt)); memset(vcnt, 0, sizeof(vcnt));&#125;int getRank(int o)&#123; for(int i = 0; i &lt; 5; ++i) cnt[o][p[o][i][1]]++, vcnt[o][p[o][i][0]]++; int flag1 = 0, flag2 = 0, flag3 = 0; for(int i = 0; i &lt; 4; ++i) if(cnt[o][i] == 5)&#123; flag1 = 1; if(vcnt[o][9] &amp;&amp; vcnt[o][10] &amp;&amp; vcnt[o][11] &amp;&amp; vcnt[o][12] &amp;&amp; vcnt[o][13]) return 10; else&#123; for(int j = 1; j &lt; 9; ++j) if(vcnt[o][j] &amp;&amp; vcnt[o][j + 1] &amp;&amp; vcnt[o][j + 2] &amp;&amp; vcnt[o][j + 3] &amp;&amp; vcnt[o][j + 4]) return 9; &#125; &#125; for(int i = 1; i &lt;= 13; ++i) if(vcnt[o][i] == 4) return 8; else if(vcnt[o][i] == 3)&#123; flag2 = 1; for(int j = 1; j &lt;= 13; ++j)&#123; if(j == i)continue; if(vcnt[o][j] == 2) return 7; &#125; &#125;else if(vcnt[o][i] == 2) flag3++; if(flag1)return 6; for(int j = 1; j &lt;= 9; ++j) if(vcnt[o][j] &amp;&amp; vcnt[o][j + 1] &amp;&amp; vcnt[o][j + 2] &amp;&amp; vcnt[o][j + 3] &amp;&amp; vcnt[o][j + 4]) return 5; if(flag2)return 4; if(flag3 == 2)return 3; else if(flag3 == 1)return 2; return 1;&#125;bool judge1(int lim)&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == lim)&#123; maxi[i] = j; break; &#125; &#125; return maxi[0] &gt; maxi[1]; &#125;bool judge1(int lim, int lf)&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == lim)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1]) return judge1(lf); else return maxi[0] &gt; maxi[1];&#125;bool judge2()&#123; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] &gt; vcnt[1][j]) return true; else if(vcnt[0][j] &lt; vcnt[1][j]) return false; &#125;&#125;bool judge3()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 3)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; maxi[0] = maxi[1] = 0; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(maxi[0])maxi[1] = j; else maxi[0] = j; &#125; &#125; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[1][j] == 1)&#123; if(maxi[0] &gt; j) return true; else if(maxi[0] &lt; j) return false; else&#123; for(--j; j &gt;= 1; --j) if(vcnt[1][j] == 1) return maxi[1] &gt; j; &#125; &#125; &#125; &#125;else return maxi[0] &gt; maxi[1];&#125;bool judge4()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 2)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; int maxii = maxi[0]; for(int i = maxii - 1; i &gt;= 1; ++i) if(vcnt[0][i] == 2)&#123; if(vcnt[1][i] == 2)&#123; for(int j = 13; j &gt;= 1; --j) if(vcnt[0][j] == 1 || vcnt[1][j] == 1) return vcnt[0][j] &gt; vcnt[1][j]; &#125;else return true; &#125;else if(vcnt[1][i] == 2) return false; &#125;else return maxi[0] &gt; maxi[1];&#125;bool judge5()&#123; int maxi[2]; for(int i = 0; i &lt; 2; ++i) for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[i][j] == 2)&#123; maxi[i] = j; break; &#125; &#125; if(maxi[0] == maxi[1])&#123; for(int j = 13; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(vcnt[1][j] == 1)&#123; for(--j; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)&#123; if(vcnt[1][j] == 1)&#123; for(--j; j &gt;= 1; --j)&#123; if(vcnt[0][j] == 1)return true; else if(vcnt[1][j] == 1)return false; &#125; &#125;else return true; &#125;else if(vcnt[1][j] == 1) return false; &#125; &#125;else return true; &#125;else if(vcnt[1][j] == 1) return false; &#125; &#125;else return maxi[0] &gt; maxi[1];&#125;void solve()&#123; int r1 = getRank(0), r2 = getRank(1); if(r1 &gt; r2)ans++; else if(r1 == r2)&#123; int flag = 0; if(r1 == 9 || r1 == 5) flag = judge1(1); if(r1 == 8) flag = judge1(4, 1); if(r1 == 7) flag = judge1(3); if(r1 == 6 || r1 == 1) flag = judge2(); if(r1 == 4) flag = judge3(); if(r1 == 3) flag = judge4(); if(r1 == 2) flag = judge5(); if(flag) ans++; &#125; printf("%d\n", ans);&#125;int main()&#123; freopen("a.in", "r", stdin); tab['C'] = 0, tab['D'] = 1, tab['H'] = 2, tab['S'] = 3; for(int i = 0; i &lt; 1000; ++i)&#123; init(); solve(); &#125; return 0;&#125; 答案：376 PE55还是用python水过1234567891011121314151617181920212223242526ans = 0def rev(x): s = str(x) return s[::-1]def judge(x): s = str(x) l = len(s) for i in range(0, l &gt;&gt; 1, 1): if s[i] != s[l - i - 1]: return 0 return 1for i in range(5, 10000, 1): x = i flag = 0 for j in range(1, 50, 1): x += string.atoi(rev(x)) if judge(x): flag = 1 break if flag == 0: ans += 1print(ans) 答案：249 PE56用python水过12345678910111213ans = 0for i in range(1, 100, 1): for j in range(1, 100, 1): x = i ** j sum = 0 while x &gt; 0: sum += x % 10 x /= 10 if sum &gt; ans: ans = sumprint(ans) 答案：972 PE57用python水过答案：153 PE58相当于PE28的加强版。数据很大！很大！不能模拟！123456789101112131415161718192021bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i)&#123; if(x % i == 0) return false; &#125; return true;&#125;void solve()&#123; int d, cnt = 0, cur = 1; for(d = 1; ; ++d)&#123; for(int i = 0; i &lt; 4; ++i)&#123; cur += d &lt;&lt; 1; if(isP(cur)) cnt++; &#125; double p = 1.0 * cnt / (4 * d + 1); if(p &lt; 0.1) break; &#125; printf("%d\n", d &lt;&lt; 1 | 1);&#125; 答案：26241 PE59用了一个剪枝就ok了。123456789101112131415161718192021222324252627282930313233int s[100005], n = 0, ss[100005];void init()&#123; while(scanf("%d,", &amp;s[n]) == 1) n++;&#125;/*void solve()&#123; int cc[4]; for(int i = 0; i &lt; 26; ++i) for(int j = 0; j &lt; 26; ++j) for(int k = 0; k &lt; 26; ++k)&#123; cc[0] = i + 'a', cc[1] = j + 'a', cc[2] = k + 'a'; int flag = 0; for(int t = 0; t &lt; n; ++t)&#123; ss[t] = (s[t] ^ cc[t % 3]); if(ss[t] == '`' || ss[t] == '|')&#123; flag = 1; break; &#125; &#125; if(!flag)&#123; for(int t = 0; t &lt; n; ++t) printf("%c", ss[t]); printf("\n%c%c%c\n", cc[0], cc[1], cc[2]); &#125; &#125;&#125;*/void solve()&#123; int cc[] = &#123;'g', 'o', 'd'&#125;, ans = 0; for(int i = 0; i &lt; n; ++i) ans += (s[i] ^ cc[i % 3]); printf("%d\n", ans);&#125; 答案：107359（密钥：god） PE60采用一定的枚举策略即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool vis[10005] = &#123;0&#125;;int prime[10005], tot = 2;int ans = INF, c[10];set&lt;int&gt; st[10005];int getL(int x)&#123; if(x &lt; 10)return 10; if(x &lt; 100)return 100; if(x &lt; 1000)return 1000; if(x &lt; 10000)return 10000;&#125;bool isP(int x)&#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;bool judge(int x1, int x2)&#123; if(st[x1].count(x2)) return false; int l1 = getL(x1), l2 = getL(x2); if(!isP(x1 + l1 * x2) || !isP(x2 + l2 * x1))&#123; st[x1].insert(x2); return false; &#125; return true;&#125;void getP()&#123; for(int i = 2; i &lt;= 10000; ++i) if(!vis[i])&#123; for(int j = i &lt;&lt; 1; j &lt;= 10000; j += i) vis[j] = 1; &#125; prime[0] = 3, prime[1] = 7; for(int i = 11; i &lt; 10000; i += 2) if(!vis[i]) prime[tot++] = i;&#125;void getC(int index, int left, int sum)&#123; c[left] = prime[index]; for(int i = left + 1; i &lt; 5; ++i) if(!judge(c[i], prime[index])) return ; if(sum &gt;= ans)return ; if(left == 0)&#123; ans = sum; return ; &#125; for(int i = index + 1; i &lt;= tot - left; ++i) getC(i, left - 1, sum + prime[i]);&#125;void solve()&#123; getP(); for(int i = 0; i &lt;= tot - 5; ++i) getC(i, 4, prime[i]); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ProjectEuler</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待更 斐波那契系列问题]]></title>
    <url>%2F2018%2F08%2F10%2Fproblem-fibonacci%2F</url>
    <content type="text"><![CDATA[我不会数学orz 题解首先看一个喜闻乐见的题目 $\forall x\in \mathbb{N}^*,(x,1)$可行。$x=1$时此数列即为斐波那契数列（以下用$F(n)$代替）。先证：$gcd(F(n),F(n-1)) = 1\quad (1)$证明：由辗转相除：$gcd(F(n), F(n-1))=gcd(F(n-1),F(n-2))=…=gcd(F(2),F(1))=1$ 再证：$F(m+n)=F(n+1)F(m)+F(m-1)F(n)\quad (2)$证明：$F(m+n)=F(m+n-1)+F(m+n-2)$$=2F(m+n-2)+F(m+n-3)$$=3F(m+n-3)+2F(m+n-4)$$=…=F(i+1)F(m+n-i)+F(i)F(m+n-i-1)$$=F(n+1)F(m)+F(m-1)F(n)$ 因此：$gcd(F(m),F(n))$$=gcd(F(n+1)F(m-n)+F(n)F(m-n-1),F(n))$（由$(2)$）$=gcd(F(n+1)F(m-n),F(n))$而由$(1)$，$F(n+1)$和$F(n)$互质故$gcd(F(m),F(n))=gcd(F(m-n),F(n))$相当于对$F$的下标做辗转相除所以最后的答案即为$F(gcd(m,n))$ $x\ge 2$时，$(1)(2)$也均满足$Q.E.D.$ 斐波那契的模问题]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEOI2014 南园满地堆轻絮]]></title>
    <url>%2F2018%2F08%2F10%2Fluogu4105%2F</url>
    <content type="text"><![CDATA[题目链接 题解容易看出$Ans$越大，数列调整的余地越大，数列就越有可能变成一个不下降序列。所以考虑二分答案，然后从头到尾遍历，尽量保持数列的不下降性。无法保持则判断为当前答案过小。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, s[5000005];ll a, b, c, d, mod;int f(ll x)&#123; ll res = (b + a * x) % mod; res = (res * x + c) % mod; res = (res * x + d) % mod; return (int)res;&#125;bool C(int g)&#123; int bef = max(1, s[1] - g); for(int i = 2; i &lt;= n; ++i)&#123; if(s[i] - g &gt;= bef) bef = s[i] - g; else if(s[i] + g &lt; bef) return false; &#125; return true;&#125;void init()&#123; n = read(); a = read(), b = read(), c = read(), d = read(); s[1] = read(), mod = read(); s[0] = 0; for(int i = 2; i &lt;= n; i++) s[i] = (f(s[i - 2]) + f(s[i - 1])) % mod;&#125;void solve()&#123; int l = 0, r = mod; while(r - l)&#123; int mid = (r + l) &gt;&gt; 1; if(C((r + l) &gt;&gt; 1)) r = mid; else l = mid + 1; &#125; printf("%d\n", r);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1382 楼房]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1382%2F</url>
    <content type="text"><![CDATA[题目链接 题解利用线段树进行区间取$max$和单点查询即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int n, len, x[200005], xx[200005], h[100005];int size, seg[800005] = &#123;0&#125;, tag[800005] = &#123;0&#125;, _a, _b, val;int node[400005][2], tot = 0;void init()&#123; n = read(); for(int i = 0; i &lt; n; ++i) h[i] = read(), x[i &lt;&lt; 1] = read(), x[i &lt;&lt; 1 | 1] = read(); memcpy(xx, x, sizeof(xx)); sort(xx, xx + n + n); len = unique(xx, xx + n + n) - xx; for(size = 1; size &lt; len; size &lt;&lt;= 1);&#125;void pushdown(int id)&#123; if(tag[id])&#123; seg[id &lt;&lt; 1] = max(seg[id &lt;&lt; 1], tag[id]); tag[id &lt;&lt; 1] = max(tag[id &lt;&lt; 1], tag[id]); seg[id &lt;&lt; 1 | 1] = max(seg[id &lt;&lt; 1 | 1], tag[id]); tag[id &lt;&lt; 1 | 1] = max(tag[id &lt;&lt; 1 | 1], tag[id]); tag[id] = 0; &#125;&#125;void update(int id, int l, int r)&#123; if(l &gt; _b || r &lt; _a)return ; if(l &gt;= _a &amp;&amp; r &lt;= _b)&#123; seg[id] = max(seg[id], val); tag[id] = max(tag[id], val); return ; &#125; pushdown(id); update(id &lt;&lt; 1, l, (l + r) &gt;&gt; 1); update(id &lt;&lt; 1 | 1, (l + r + 1) &gt;&gt; 1, r); seg[id] = max(seg[id &lt;&lt; 1], seg[id &lt;&lt; 1 | 1]);&#125;int query(int id, int l, int r)&#123; if(l &gt; _b || r &lt; _a)return 0; if(l &gt;= _a &amp;&amp; r &lt;= _b)return seg[id]; pushdown(id); return max(query(id &lt;&lt; 1, l, (l + r) &gt;&gt; 1), query(id &lt;&lt; 1 | 1, (l + r + 1) &gt;&gt; 1, r));&#125;void solve()&#123; for(int i = 0; i &lt; n; ++i)&#123; _a = lower_bound(xx, xx + len, x[i &lt;&lt; 1]) - xx + 1; _b = lower_bound(xx, xx + len, x[i &lt;&lt; 1 | 1]) - xx; val = h[i]; update(1, 1, size); &#125; node[tot][0] = xx[0], node[tot++][1] = 0; _a = _b = 1; int h_last = query(1, 1, size); if(h_last) node[tot][0] = xx[0], node[tot++][1] = h_last; for(int i = 1; i &lt; len; ++i)&#123; _a = _b = i + 1; int h_cur = query(1, 1, size); if(h_cur != h_last) node[tot][0] = xx[i], node[tot++][1] = h_last, node[tot][0] = xx[i], node[tot++][1] = h_cur, h_last = h_cur; &#125; printf("%d\n", tot); for(int i = 0; i &lt; tot; ++i) printf("%d %d\n", node[i][0], node[i][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Balanced Lineup]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2880%2F</url>
    <content type="text"><![CDATA[题目链接 题解ST表模板题…线段树估计会挂，因为询问太多了。12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int f1[16][50005],dat[50005],f2[16][50005],N,Q; int max(int a,int b)&#123;return (a&gt;b)?a:b;&#125;int min(int a,int b)&#123;return (a&lt;b)?a:b;&#125;void sttable(int n)&#123; int i,j,p; memcpy(f1[0],dat,sizeof(dat)); memcpy(f2[0],dat,sizeof(dat)); for(i=1;(1&lt;&lt;i)&lt;=n;i++) for(j=0,p=(1&lt;&lt;(i-1));j&lt;n-p;j++) f1[i][j]=max(f1[i-1][j],f1[i-1][j+p]), f2[i][j]=min(f2[i-1][j],f2[i-1][j+p]);//同时对最大最小两个st表初始化，递推&#125;int rmq(int l,int r)&#123; int k=0;while((1&lt;&lt;(k+1))&lt;(r-l+1))k++; return max(f1[k][l],f1[k][r-(1&lt;&lt;k)+1])-min(f2[k][l],f2[k][r-(1&lt;&lt;k)+1]);//询问部分&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;Q); int i,l,r; for(i=0;i&lt;N;i++) scanf("%d",&amp;dat[i]); sttable(N); for(i=0;i&lt;Q;i++) scanf("%d%d",&amp;l,&amp;r), printf("%d\n",rmq(l-1,r-1)); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 遥远的行星]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3198%2F</url>
    <content type="text"><![CDATA[题目链接 题解看到数据规模就吓傻了这题暴力是根本过不动的。所以我们可以用一些玄学方法在这题中，有一个很关键的提示： 误差不超过$5\%$即可 可以发现在这种条件下正确答案的范围非常宽所以可以采用近似的方法，不必每一个$j-i$都计算，可以用一个值来代替某一个范围内的$j-i$。具体的程序实现是：对于一个$j$，有编号为i\in [1,a_j]的行星给他力将此区间分成$k$段，每段的分母$j-i$近似用该区间中点的分母表示$k$可以自行选一个定值，这里用的是100。可以往小里取，不TLE即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;int n;double a,m[100005],sum[100005],f[100005];void init()&#123; scanf("%d%lf",&amp;n,&amp;a); sum[0]=m[0]=0; for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;m[i]), sum[i]=sum[i-1]+m[i];&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; double s=a*i,mid; int lim=floor(s);//[1,ai] if(lim&lt;=100)&#123;//区间长不足100直接算 for(int j=1;j&lt;=lim;j++) f[i]+=m[i]*m[j]/(i-j); &#125;else&#123; int l2=lim/100; for(int j=l2;j&lt;=l2*100;j+=l2) mid=(i-j+i-j+l2-1)*0.5,//算中点的分母 f[i]+=(sum[j]-sum[j-l2])*m[i]/mid; for(int j=l2*100+1;j&lt;=lim;j++)//不足100直接算 f[i]+=m[i]*m[j]/(i-j); &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%.6lf\n",f[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>非完美算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2009 学校食堂Dining]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2157%2F</url>
    <content type="text"><![CDATA[题目链接 题解“写过小笼包你就会发现这是一道模板题”一开始我是这么想的，结果发现这样可能会出现没有头的情况。并且要找到头是一件非常困难的事。所以就用普通状压，设$f(i,j,k)$表示前$i-1$个人吃完，$i~i+7$个人吃饭的状态是$j$，上一个吃的人是$i+k$。就可以愉快的转移了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000#define offset 8using namespace std;typedef long long ll;int n,d[1005],t[1005],f[1005][257][17];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int val(int x,int y)&#123; return (x&lt;=0)?0:(t[x]^t[y]);&#125;void solve()&#123; for(int i=1;i&lt;=n+1;i++) for(int j=0;j&lt;(1&lt;&lt;8);j++) for(int k=-8;k&lt;=7;k++) f[i][j][k+offset]=INF; f[1][0][-1+offset]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;(1&lt;&lt;8);j++)&#123; for(int k=-8;k&lt;=7;k++)&#123; if(f[i][j][k+offset]&gt;=INF)continue; if(j&amp;1)//自己吃过了 f[i+1][j&gt;&gt;1][k-1+offset]=min(f[i+1][j&gt;&gt;1][k-1+offset],f[i][j][k+offset]); else&#123; int r=n+2; for(int u=1,v=0;v&lt;8;v++,u&lt;&lt;=1)&#123; if((j&amp;u)==0)&#123; if(i+v&gt;r)break; r=min(r,i+v+d[i+v]);//不能在这之后选人 f[i][j|u][v+offset]=min(f[i][j|u][v+offset],f[i][j][k+offset]+val(i+k,i+v)); &#125; &#125; &#125; &#125; &#125; &#125;&#125;void init()&#123; int T=read(); while(T--)&#123; n=read(),d[0]=n+2; for(int i=1;i&lt;=n;i++)t[i]=read(),d[i]=read(); solve(); int ans=INF; for(int i=-8;i&lt;=-1;i++) ans=min(ans,f[n+1][0][i+offset]); printf("%d\n",ans); &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1999 高维正方体]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1999%2F</url>
    <content type="text"><![CDATA[题目链接 题解给出一种这个题的思考方法吧…设$f(i,j)$表示$i$维超立方体中$j$维元素的个数。先思考：点的个数如何变化？很显然，每升一维，点的个数就多一倍，故$f(i,0)=2^i$。而根据规律可以看出，某一维在升维之后，他自己这一维复制了一份，同时原来比他小一维德元素也升为了他这一维。故得到递推关系：$f(i,j)=2f(i-1,j)+f(i-1,j-1)$。结合以上两个方程，很容易想到这是一个$O(n^2)$的dp。但显然不行。这么做复杂度大的太可怕。可以发现，这个递推模型和杨辉三角很像。所以我们写一下：观察发现，每一斜列都构成一个高阶等差数列。换言之，第$q$个斜列上的数都可以表示成一个$q-1$次多项式。计算后可以发现，对于同样的$q$，右边的第$k$个位置的数总是比左边的同样位置的数大$2^{q-1}$倍。根据这个就可以发现，下面每一个数的通项为C_i^j\times 2^{i-j}所以答案就是C_a^b\times 2^{a-b}。之后组合数取模什么的拿线性逆元做即可。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define P 1000000007llusing namespace std;typedef long long ll;ll a,b,inv[100005];ll q_pow(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%P; a=(a*a)%P,b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; scanf("%lld%lld",&amp;a,&amp;b);&#125;void solve()&#123; if(a&lt;b)&#123; printf("0\n"); return ; &#125;//特判 inv[1]=1; for(ll i=2;i&lt;=100000;i++) inv[i]=(P-(P/i))*inv[P%i]%P;//逆元 ll ans=q_pow(2,a-b); for(int i=1;i&lt;=b;i++) ans=ans*(a-i+1)%P, ans=ans*inv[i]%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI2014预选 小笼包]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2808%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题很厉害。我也是看了题解才知道怎么做的。（官网日文真心看不懂）（如果日语学的很6的话可以看这里：链接）我们看到这道题，首先想到的是什么？对！就是爆搜。…先留着这个看似不切实际的想法。我们暴力算排列，然后$O(n^2)$算结果，复杂度不用想，肯定上天。然后观察：$D$最大不过$7$，然后我们又有上面那个算法，所以现在考虑用这个条件来优化转移。设$dp(i,Perm)$，其中$Perm$表示从$i-maxd+1$吃到第$i$个小笼包的顺序，$i$表示当前正在处理第$i$个。则这样就可以状态转移了，每一次向前推进一位，然后对于前面的排列，我们试图插入新的小笼包，并且计算新的小笼包在其中造成的贡献。（被泼到，泼别的）时间复杂度O(D_{max}!P)（官方说是$P$一个多项式，算了也别管了）这种新的状压方式学到了。不过可能看的时候会有疑问：$k$为什么会到$7$呢？还是要考虑到原来整个排列全被枚举的情况。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int f[2][7000000]=&#123;0&#125;,permu[10],permu2[10];//在第i次吃第j个小笼包int n,d[105],a[105]; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init_permu()&#123; for(int j=0;j&lt;7;j++) permu[j]=j;&#125; int ptoi(int *L)&#123; int res=0; for(int i=0;i&lt;7;i++) res=res*10+L[i]; return res;&#125;void init()&#123; n=read(); for(int i=0;i&lt;n;i++)d[i]=read(); for(int i=0;i&lt;n;i++)a[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;n;i++)&#123; init_permu(); int B=(i&amp;1),B_=(B^1),cnt,code1,code2; do&#123; code1=ptoi(permu); for(int k=0;k&lt;=7;k++)&#123; //枚举新加入的位置 cnt=0; int contribution=0; //在第i个被吃掉之前他被泼到的 for(int kk=0;kk&lt;k;kk++)&#123; int loc=i-1-permu[kk]; if(loc&gt;=0&amp;&amp;permu[kk]+1&lt;=d[loc]) contribution+=a[loc]; if(permu[kk]&lt;6) permu2[cnt++]=permu[kk]+1; &#125; permu2[cnt++]=0; //在第i个被吃掉之后他被泼到的 for(int kk=k;kk&lt;7;kk++)&#123; int loc=i-1-permu[kk]; if(loc&gt;=0&amp;&amp;permu[kk]+1&lt;=d[i]) contribution+=a[i]; if(permu[kk]&lt;6) permu2[cnt++]=permu[kk]+1; &#125; code2=ptoi(permu2); f[B_][code2]=max(f[B_][code2],f[B][code1]+contribution); &#125; f[B][code1]=0; &#125;while(next_permutation(permu,permu+7)); &#125; int ans=0; init_permu(); do&#123; ans=max(ans,f[n&amp;1][ptoi(permu)]); &#125;while(next_permutation(permu,permu+7)); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>JOI</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2013 数列]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3228%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题我用了一种不够数学的方法来解。30分做法：DP，设$f(i,j)$表示第$i$天以$j$为当天股价的方案数，则 f(i,j)=\begin{cases} 1\quad (i=1)\\ \sum_{k=1}^M f(i-1,j-k) \quad(i>1)\end{cases}答案为$\sum_{j=1}^N f(K,j)$数据太大，只能拿30分。100分做法：在30分做法上做文章。可以发现，对于所有$i\le N-(K-1)M$的$f(0,i)$而言，他们对最终答案的贡献是一样的。（因为他们可以给出的贡献的上界都是$i+(K-1)M$，下界都是$i+K-1$）但对于更大的$i$，由于要求的答案范围的上界为$N$，所以他们对更高股价的贡献是要去掉的。问题转化为求$N-(K-1)M$个相同的贡献值的和以及$(K-1)M$个不同贡献值的和。对于前一个子问题，我们考虑一个等价的问题：从第一个格子出发，每一个格子有$M$条路通向下一个格子，问走$K-1$步的走法数，一种走法和另外一种走法相同当且仅当两条路径完全相同。由乘法原理知答案为$M^{K-1}$。所以前一个子问题的答案为$[N-(K-1)M]M^{K-1}$。后一个子问题不好办。怎么弄？假设，画图，观察。（这是我的方法，当然有其他方法发现这个规律。）设$M=3,K=4$，则作图：（$i$表示天数，这张表表示开始的某个$f(1,j)$对后面第$i$天答案的贡献）然后依次写出$j=N-(K-1)M+1,N-(K-1)M+2,…,N-(K-1)$时对答案的贡献。（$j&gt;N-(K-1)$时，$j$对答案贡献为$0$。）这是个很对称的图形，沿对角线翻折后发现每一列都变为了完整的一列。一列的和我们之前已经求了出来，就是$M^{K-1}$。设其内部所有数的和为$sum$，则 sum= \frac{(K-1)(M-1)}{2} M^{K-1}总答案即为 \left( N-\frac{(K-1)(M+1)}{2}\right)M^{K-1}使用快速幂和逆元计算即可。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;ll N,M,K,P;ll Pow(ll a,ll b,ll c)&#123; ll res=1; a%=c; while(b)&#123; if(b&amp;1)res=(res*a)%c; a=(a*a)%c,b&gt;&gt;=1; &#125; return res;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%lld%lld%lld%lld",&amp;N,&amp;K,&amp;M,&amp;P);&#125;void solve()&#123; ll ans1=Pow(M,K-1,P); ll inv2,ans; N%=P,ans=(N*ans1)%P; if(M&amp;1)inv2=(M+1)/2,inv2=inv2*M%P; else inv2=M/2,inv2=inv2*(M+1)%P; inv2=inv2*(K-1)%P; inv2=inv2*Pow(M,K-2,P)%P; ans+=P,ans=(ans-inv2)%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 彩票]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2236%2F</url>
    <content type="text"><![CDATA[题目链接 题解暴搜加个上下界的判断就A了顺带一题，这题卡精度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,x,y,ans=0;double sum[55]=&#123;0&#125;,lim,EPS=1e-11;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void dfs(int at,int lst,double t)&#123; //再取n-at个数 if(at==n)&#123; if(t-lim&lt;EPS&amp;&amp;t-lim&gt;-EPS)ans++; return ; &#125; if(t+sum[m]-sum[m-n+at]-EPS&gt;lim)return ; //加了最小的还是超过了 for(int i=lst+1;i&lt;=m-n+at+1;i++)&#123; if(t+sum[i+n-at-1]-sum[i-1]+EPS&lt;lim)return ; //加了最大的还是达不到 dfs(at+1,i,t+1.0/(double)i); &#125; &#125;void init()&#123; n=read(),m=read(),x=read(),y=read(); for(int i=1;i&lt;=m;i++) sum[i]=sum[i-1]+1.0/(double)i; lim=x,lim/=(double)y;&#125;void solve()&#123; for(int i=1;i&lt;=m-n+1;i++) dfs(1,i,1.0/(double)i); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2001 求正整数]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu1128%2F</url>
    <content type="text"><![CDATA[题目链接 题解一看就是DP按质因数DP，转移的时候保存一下指数即可。对了，还要加上对数的优化。直接保存一个巨大的整数不是什么容易的事。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;double f[20][50005],P_[20];int F[20][50005]=&#123;0&#125;,n,P[17]=&#123;1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;int real_ans[50005]=&#123;0&#125;;int multiply_to_int(int s1[],int s2)&#123; int i,j,x=0; for(i=1;i&lt;=s1[0];i++) x+=s1[i]*s2, s1[i]=x%10000,x/=10000; while(x) s1[++s1[0]]=x%10000,x/=10000;&#125;int main()&#123; scanf("%d",&amp;n); int i,j,k,mini,cnt; double m,ans; for(i=0;i&lt;20;i++) for(j=0;j&lt;=n;j++) f[i][j]=1e9; for(i=0;i&lt;=16;i++) P_[i]=log(P[i]); for(i=1;i&lt;=n;i++) f[1][i]=(i-1)*P_[1],F[1][i]=1; for(i=1;i&lt;=15;i++) for(j=1;j&lt;=n;j++) for(k=1;j*k&lt;=n;k++)&#123; m=f[i][j]+(k-1)*P_[i+1]; if(m&lt;f[i+1][j*k]) f[i+1][j*k]=m,F[i+1][j*k]=j; &#125; for(ans=1e9,i=1;i&lt;=16;i++) if(ans&gt;f[i][n]) ans=f[i][n],mini=i; real_ans[0]=real_ans[1]=1; for(j=mini,k=n;j&gt;0;j--)&#123; cnt=k/F[j][k]; for(i=1;i&lt;cnt;i++) multiply_to_int(real_ans,P[j]); k=F[j][k]; &#125; printf("%d",real_ans[real_ans[0]]); for(i=real_ans[0]-1;i&gt;=1;i--) printf("%04d",real_ans[i]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2004 宠物收养场]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2286%2F</url>
    <content type="text"><![CDATA[题目链接 题解直接用平衡树模拟即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,cnt; int cmp(int x) const &#123; if(x==v)return -1; return x&gt;v; &#125; void maintain()&#123; siz=cnt; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[400005];int n,S=0,ans,ANS=0;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;cnt=1,tr-&gt;v=x; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); return ; &#125; tr-&gt;siz++; if(tr-&gt;v==x)&#123; tr-&gt;cnt++; &#125;else&#123; int d=tr-&gt;cmp(x); insert_tr(tr-&gt;ch[d],x); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1); &#125;&#125;void del(Tr* &amp;tr,int x)&#123; int d=tr-&gt;cmp(x); if(d==-1)&#123; if(tr-&gt;cnt&gt;1)tr-&gt;siz--,tr-&gt;cnt--; else&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),tr-&gt;siz--,del(tr-&gt;ch[d_],x); &#125; &#125; &#125;else tr-&gt;siz--,del(tr-&gt;ch[d],x);&#125; void previous(Tr *tr,int x)&#123; if(tr==NULL)return ; if(x&gt;tr-&gt;v) ans=tr-&gt;v,previous(tr-&gt;ch[1],x); else previous(tr-&gt;ch[0],x);&#125;void success(Tr *tr,int x)&#123; if(tr==NULL)return ; if(x&lt;tr-&gt;v) ans=tr-&gt;v,success(tr-&gt;ch[0],x); else success(tr-&gt;ch[1],x);&#125;void solve()&#123; n=read(); Tr *root=NULL; int cnt1=0,cnt2=0,a,b; for(int i=1;i&lt;=n;i++)&#123; a=read(),b=read(); if(!a)&#123; if(!cnt2)insert_tr(root,b),cnt1++; else&#123; int ans1,ans2,res; ans=-1,previous(root,b),ans1=ans; ans=-1,success(root,b),ans2=ans; if(ans1==-1)res=ans2; else if(ans2==-1)res=ans1; else if(ans2-b&lt;b-ans1)res=ans2; else res=ans1; del(root,res),ANS+=abs(res-b),ANS%=1000000; cnt2--; &#125; &#125;else&#123; if(!cnt1)insert_tr(root,b),cnt2++; else&#123;//有宠物 int ans1,ans2,res; ans=-1,previous(root,b),ans1=ans; ans=-1,success(root,b),ans2=ans; if(ans1==-1)res=ans2; else if(ans2==-1)res=ans1; else if(ans2-b&lt;b-ans1)res=ans2; else res=ans1; del(root,res),ANS+=abs(res-b),ANS%=1000000; cnt1--; &#125; &#125; &#125; printf("%d\n",ANS);&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2009 梦幻布丁]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3201%2F</url>
    <content type="text"><![CDATA[题目链接 题解膜一发启发式合并启发式合并从前我都只在并查集上用到过，但今天是在这种上面…这道题的做法非常暴力：直接对每一个颜色节点构建链式前向星，然后合并的时候短链合并到长链上。为什么这么做是对的呢？因为短链合并之后最少比原来要长一倍，所以合并起来最多合并$logn$次，这样均摊总时间复杂度就是$O(nlogn)$。感觉这种思想跟线段数的区间开方的分析有着异曲同工之妙…有一个细节：要记录合并时操作的真正颜色，因为短合长或者长合短在程序操作上是等价的，但颜色是不等价的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,id[1000005],ans,a[100005]=&#123;0&#125;;int cnt[1000005]=&#123;0&#125;,at[1000005]=&#123;0&#125;,_nex[100005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void _merge(int x,int y)&#123; if(x==y)return ; if(cnt[id[x]]&gt;cnt[id[y]])swap(id[x],id[y]); x=id[x],y=id[y]; if(!cnt[x])return ; //x,y号元素代表的真正颜色（程序操作上） cnt[y]+=cnt[x],cnt[x]=0; //x合并到y上 for(int i=at[x];i;i=_nex[i])&#123; if(a[i-1]==y)ans--; if(a[i+1]==y)ans--; &#125; for(int i=at[x];i;i=_nex[i])&#123; a[i]=y; if(!_nex[i])&#123; _nex[i]=at[y]; break; &#125; &#125; at[y]=at[x],at[x]=0;&#125; void init()&#123; n=read(),m=read(); int col; for(int i=1;i&lt;=n;i++)&#123; a[i]=read(),col=a[i]; if(a[i]!=a[i-1])ans++; cnt[col]++,_nex[i]=at[col],at[col]=i; &#125; for(int i=1;i&lt;=1000000;i++)id[i]=i;&#125;void solve()&#123; int opr,x,y; for(int i=1;i&lt;=m;i++)&#123; opr=read(); if(opr==2)printf("%d\n",ans); else x=read(),y=read(),_merge(x,y); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 营业额统计]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2234%2F</url>
    <content type="text"><![CDATA[题目链接 题解双向链表裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;pair&lt;ll,int&gt; P[100005];int n,nex[100005],pre[100005],id[100005];ll a[100005],ans=0;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); int i=1; while(~scanf("%lld",&amp;a[i]))P[i].first=a[i],P[i].second=i,i++; while(i&lt;=n)P[i].first=0,P[i].second=i,a[i++]=0; sort(P+1,P+n+1); //for(i=1;i&lt;=n;i++)printf("%lld %d\n",P[i].first,P[i].second); for(i=1;i&lt;=n;i++)id[i]=P[i].second; pre[id[1]]=nex[id[n]]=0; for(i=1;i&lt;n;i++) nex[id[i]]=id[i+1],pre[id[i+1]]=id[i];&#125;void solve()&#123; for(int i=n;i&gt;=2;i--)&#123; int tp=pre[i],tn=nex[i]; ll res=INF; if(tp)res=min(res,a[i]-a[tp]); if(tn)res=min(res,a[tn]-a[i]); ans+=res; if(tn)pre[tn]=tp; if(tp)nex[tp]=tn; &#125; printf("%lld\n",ans+a[1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 玩具装箱TOY]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3195%2F</url>
    <content type="text"><![CDATA[题目链接 题解一道很简单的斜率优化DP。设$f(i)$表示装到第$i$个玩具为止的时候，最小的花费。那么 f(i)=\min \limits_{1 \le j]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 越狱]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3197%2F</url>
    <content type="text"><![CDATA[题目链接 题解总共情况有$M^N$种不会越狱的情况有$M\times (M-1)^{N-1}$种。前者减去后者即为答案。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll n,m,P=100003;ll qpow(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=(res*a)%P; a=(a*a)%P,b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; scanf("%lld%lld",&amp;m,&amp;n); m%=P;&#125;void solve()&#123; ll ans=qpow(m,n),ans2=qpow(m-1,n-1); ans2=(ans2*m)%P; ans=(ans+P-ans2)%P; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2006 公路修建问题]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2323%2F</url>
    <content type="text"><![CDATA[题目链接 题解二分最大限制，kruskal判断。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int u,v,c1,c2;&#125;;Edge edge[20005];int n,k,m,par[10005],q1[20005],q2[20005],vis[20005];bool cmp1(int a,int b)&#123; return edge[a].c1&lt;edge[b].c1;&#125;bool cmp2(int a,int b)&#123; return edge[a].c2&lt;edge[b].c2;&#125;int Find(int t)&#123; if(par[t]==t)return t; return (par[t]=Find(par[t]));&#125;void unite(int a,int b)&#123; if(Find(a)==Find(b))return ; par[Find(a)]=Find(b);&#125;int judge(int M)&#123; int cnt=0,tot=n,at,ans=0,u,v,c; for(int i=1;i&lt;=n;i++)par[i]=i; memset(vis,0,sizeof(vis)); for(at=0;tot&gt;n-k&amp;&amp;at&lt;m;at++)&#123; if(edge[q1[at]].c1&gt;M)continue; u=edge[q1[at]].u,v=edge[q1[at]].v, c=edge[q1[at]].c1; if(Find(u)!=Find(v)) unite(u,v),ans+=c,vis[q1[at]]=1,tot--; &#125; if(at==m&amp;&amp;tot!=n-k)return -1; for(at=0;tot&gt;1&amp;&amp;at&lt;m;at++)&#123; if(edge[q2[at]].c2&gt;M||vis[q2[at]])continue; u=edge[q2[at]].u,v=edge[q2[at]].v, c=edge[q2[at]].c2; if(Find(u)!=Find(v)) unite(u,v),ans+=c,vis[q2[at]]=2,tot--; &#125; if(at==m&amp;&amp;tot!=1)return -1; return ans;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].c1,&amp;edge[i].c2); for(int i=0;i&lt;m;i++) q1[i]=q2[i]=i; sort(q1,q1+m,cmp1); sort(q2,q2+m,cmp2);&#125;void solve()&#123; int L=0,R=INF,M,ans; while(R-L)&#123; M=(L+R)/2; ans=judge(M); if(ans&gt;=0) R=M; else L=M+1; &#125; printf("%d\n",L); judge(L); for(int i=0;i&lt;m;i++) if(vis[i])printf("%d %d\n",i+1,vis[i]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2008 GT考试]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3193%2F</url>
    <content type="text"><![CDATA[题目链接 题解构造状态转移图，用矩阵优化DP。状态转移图是现成的，就是KMP的匹配图。按照这个对每一个点处理：把模式串每一位看作一个点，最开始也加一个点（0号点，表示匹配不到模式串的任何一个点）每一个点都有0-9共9条边，每个点（除了最后一个点）都向下一个点连一条相应数字边，然后最初的0号点就只有9个自环边。之后每一个点（除了最后一个）能往前转移就往前转，转不了就转到0号点上去。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,Mod,fail[55],ans=0;char danger[55];struct Mat&#123; int dat[22][22]; int r,c; Mat()&#123; memset(dat,0,sizeof(dat)); &#125;&#125;;Mat mul(Mat &amp;a,Mat &amp;b)&#123; Mat newed; newed.r=a.r,newed.c=b.c; int i,j,k,t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p)&#123; Mat E;E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)E=mul(E,a); a=mul(a,a),p&gt;&gt;=1; &#125; return E;&#125;int mat[21][21];void build_fail(char *pat,int l,int *fail)&#123; fail[0]=-1; for(int i=1,j=-1;i&lt;l;i++)&#123; for(;j&gt;-1&amp;&amp;pat[i]!=pat[j+1];j=fail[j]); if(pat[i]==pat[j+1]&amp;&amp;i&gt;j+1) fail[i]=++j; else fail[i]=-1; &#125;&#125;void init()&#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;Mod,danger); build_fail(danger,m,fail);&#125;void solve()&#123; Mat Ori,Plu,res; Ori.r=Plu.r=Plu.c=m+1; Ori.c=1; Plu.dat[0][0]=9,Plu.dat[1][0]=1; bool used[10]; int CNT=10; for(int i=1;i&lt;m;i++)&#123; int f=i-1,flag=0; memset(used,0,sizeof(used)); CNT=10; do&#123; f=fail[f]; if(danger[f+1]!=danger[i])&#123; if(!used[danger[f+1]-'0']) used[danger[f+1]-'0']=1, Plu.dat[f+2][i]=1, CNT--; &#125; &#125;while(f!=-1); Plu.dat[i+1][i]=1; CNT--; Plu.dat[0][i]=CNT; &#125; for(int i=0;i&lt;=m;i++) Plu.dat[m][i]=0; Ori.dat[0][0]=1; Plu=Pow(Plu,n); res=mul(Plu,Ori); for(int i=0;i&lt;m;i++) ans=(ans+res.dat[i][0])%Mod; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2002 公交车路线]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2233%2F</url>
    <content type="text"><![CDATA[题目链接 题解构造递推关系，设$f(p,n)$表示换了$n$次车到了$p$点的方案数，发现F点与D点均只能由上一个点转移而来，E点由F与D点转移而来，其余点由两侧的点转移而来。由此得到递推方程，但是$n$太大，故使用矩阵乘法加速。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Mat&#123; int dat[10][10],r,c; Mat(int a,int b)&#123; this-&gt;r=a,this-&gt;c=b, memset(this-&gt;dat,0,sizeof(this-&gt;dat)); &#125;&#125;;int Mod=1000,n,dx[]=&#123;0,0,1,1,2,2,3,3,4,4,5,6,7,7&#125;,dy[]=&#123;1,2,0,3,0,4,1,5,2,6,3,4,5,6&#125;;void mul(Mat &amp;a,Mat &amp;b,Mat &amp;newed)&#123; newed.r=a.r,newed.c=b.c; int i,j,k,t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125;&#125;Mat pow(Mat a,int p)&#123; Mat E(a.c,a.c),F(a.c,a.c); int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)mul(E,a,F),E=F; mul(a,a,F),a=F,p&gt;&gt;=1; &#125; return E;&#125;int main()&#123; n=read(); Mat q(8,8),s(8,1),e(8,1); for(int i=0;i&lt;14;i++) q.dat[dx[i]][dy[i]]=1; s.dat[0][0]=1; q=pow(q,n),mul(q,s,e); printf("%d\n",e.dat[7][0]); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 操作系统]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2278%2F</url>
    <content type="text"><![CDATA[题目链接 题解中心思想就是模拟，堆按优先级大小排序，每次看堆顶元素是否完成，如果完成则就退出，否则等待下一个任务并减去这段等待时间，最后插入下一个任务，循环往复。本题具有一定的实际意义。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef struct&#123; int id,st,ls,pr;&#125;Pro;Pro q[400005];bool operator &lt;(Pro a,Pro b)&#123; if(a.pr==b.pr)return a.st&gt;b.st; else return a.pr&lt;b.pr;&#125;priority_queue&lt;Pro&gt; pq;int at=0,r=0;int s(Pro &amp;x)&#123; if(scanf("%d",&amp;x.id)==1) scanf("%d%d%d",&amp;x.st,&amp;x.ls,&amp;x.pr); else return 0; return 1;&#125;int main()&#123; Pro pre,n,a; while(s(q[r]))r++; pq.push(q[0]); at=q[0].st; for(int i=1;i&lt;r;i++)&#123; while(!pq.empty()&amp;&amp;at+pq.top().ls&lt;=q[i].st) a=pq.top(), printf("%d %d\n",a.id,at+a.ls), at+=a.ls, pq.pop();//若此项目已经完成，则退出 if(!pq.empty()) a=pq.top(), pq.pop(), a.ls-=q[i].st-at, pq.push(a);//结束部分等待时间 at=q[i].st, pq.push(q[i]);//放入优先队列 &#125; while(!pq.empty()) a=pq.top(), printf("%d %d\n",a.id,at+a.ls), at+=a.ls, pq.pop(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2011 数学作业]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3216%2F</url>
    <content type="text"><![CDATA[题目链接 题解\begin{bmatrix} n&ans&1 \end{bmatrix} \begin{bmatrix} 1 & 1 & 0 \\0 & 10^q & 0 \\ 1 & 0 & 1 \end{bmatrix} = \begin{bmatrix} n+1 & ans\times10^q+n &1\end{bmatrix}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef unsigned long long ll;ll n,Mod;struct Mat&#123; ll dat[3][3]; int r,c; Mat(int _r,int _c)&#123; r=_r,c=_c; memset(this-&gt;dat,0,sizeof(this-&gt;dat)); &#125;&#125;;Mat mul(Mat &amp;a,Mat &amp;b)&#123; Mat newed(a.r,b.c); int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p)&#123; Mat E(a.c,a.c); int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)E=mul(E,a); a=mul(a,a),p&gt;&gt;=1; &#125; return E;&#125;void print(Mat q)&#123; for(int i=0;i&lt;q.r;i++)&#123; for(int j=0;j&lt;q.c;j++) printf("%llu ",q.dat[i][j]); printf("\n"); &#125;&#125;void init()&#123; scanf("%llu%llu",&amp;n,&amp;Mod); n++;&#125;void solve()&#123; ll cur=1,nex=10; Mat Ori(1,3),Plu(3,3),Copy(3,3),res(3,3); Ori.dat[0][0]=Ori.dat[0][2]=1; Plu.dat[0][0]=Plu.dat[0][1]= Plu.dat[2][0]=Plu.dat[2][2]=1; Plu.dat[1][1]=10; for(;;)&#123; Copy=Pow(Plu,min(nex,n)-cur); res=mul(Ori,Copy); if(nex&gt;=n)break; Plu.dat[1][1]*=10,Plu.dat[1][1]%=Mod; cur*=10,nex*=10; Ori=res; &#125; printf("%llu\n",res.dat[0][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2006 超级英雄]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2319%2F</url>
    <content type="text"><![CDATA[题目链接 题解裸的二分图匹配洛谷上是强化的版本左边的点代表题目，右边的点代表锦囊用匈牙利算法从上至下匹配即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;bool mat[1005][1005]=&#123;0&#125;;int n,m,op[1005]=&#123;0&#125;,vis[1005];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); mat[i][u]=mat[i][v]=1; &#125;&#125;int dfs(int cur)&#123; for(int j=0;j&lt;n;j++)&#123; if(mat[cur][j]&amp;&amp;!vis[j])&#123; vis[j]=1; if(!op[j]||dfs(op[j]))&#123; op[j]=cur; return 1; &#125; &#125; &#125; return 0;&#125;int Edmonds()&#123; int ret=0; for(int i=1;i&lt;=m;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))ret++; else break; &#125; return ret;&#125;void solve()&#123; int ans=Edmonds(); printf("%d\n",ans); for(int i=1;i&lt;=ans;i++)&#123; int j; for(j=0;j&lt;n;j++) if(op[j]==i)&#123; printf("%d\n",j); break; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最大匹配</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2012 永无乡]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3224%2F</url>
    <content type="text"><![CDATA[题目链接 题解并查集，然后利用启发式合并最多带来一个$log$的代价，暴力拆treap，然后合并。时间复杂度$O(nlog^2 n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,cnt,id; int cmp(int x) const &#123; if(x==v)return -1; return x&gt;v; &#125; void maintain()&#123; siz=cnt; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[1700005],*pos[400005],*root;int S=0,n,m;int par[100005],rk[100005]; void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x,int i_)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;cnt=1,tr-&gt;v=x; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); tr-&gt;id=i_; return ; &#125; tr-&gt;siz++; if(tr-&gt;v==x)&#123; tr-&gt;cnt++; &#125;else&#123; int d=tr-&gt;cmp(x); insert_tr(tr-&gt;ch[d],x,i_); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1); &#125;&#125;int Kth(Tr *tr,int x)&#123; if(tr==NULL||x&lt;=0||x&gt;tr-&gt;siz)return -1; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(x&lt;=evid)return Kth(tr-&gt;ch[0],x); else if(x&gt;evid+tr-&gt;cnt)return Kth(tr-&gt;ch[1],x-evid-tr-&gt;cnt); else return tr-&gt;id;&#125;int Find(int t)&#123; if(par[t]==t)return t; else return (par[t]=Find(par[t]));&#125;int unite(int a,int b)&#123; int x=Find(a),y=Find(b); if(x==y)return -1; if(rk[x]&gt;rk[y])&#123; par[y]=x; return x; &#125;else &#123; par[x]=y; if(rk[x]==rk[y])rk[y]++; return y; &#125;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void dfs(Tr *t)&#123; if(t==NULL)return ; insert_tr(root,t-&gt;v,t-&gt;id); dfs(t-&gt;ch[0]),dfs(t-&gt;ch[1]);&#125;void MMerge(int x,int y)&#123; if(Find(x)==Find(y))return ; int ss=Find(x),tt=Find(y); int res=unite(x,y);//大的 if(res==tt)root=pos[tt],dfs(pos[ss]),pos[tt]=root; else root=pos[ss],dfs(pos[tt]),pos[ss]=root;&#125; void init()&#123; n=read(),m=read(); int pri,u,v; for(int i=1;i&lt;=n;i++) par[i]=i,rk[i]=0,pri=read(), insert_tr(pos[i],pri,i); for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(); MMerge(u,v); &#125;&#125;void solve()&#123; int q=read(),x,y; char ord[3]; while(q--)&#123; scanf("%s%d%d",ord,&amp;x,&amp;y); if(ord[0]=='B')MMerge(x,y); else printf("%d\n",Kth(pos[Find(x)],y)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>BST</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 消防局的设立]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2279%2F</url>
    <content type="text"><![CDATA[题目链接 题解这道题是一个贪心，蓝书上面讲过。就是每次从最大深度的开始向上面走，走2步，然后如果上面的点还没有被覆盖就覆盖上面的点。这么做可以被证明是正确的。实际上从直觉上来看也是正确的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;vector&lt;int&gt; depth[1005];int n,par[1005]=&#123;0&#125;,bro[1005],son[1005],dep[1005]=&#123;0&#125;,maxd=0;bool vis[1005]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); dep[1]=0,depth[0].push_back(1); for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;par[i]); bro[i]=son[par[i]],son[par[i]]=i; dep[i]=dep[par[i]]+1; depth[dep[i]].push_back(i); maxd=max(maxd,dep[i]); &#125;&#125;void dfs(int cur,int k)&#123; if(k==2)return; if(par[cur]&amp;&amp;k&lt;2) vis[par[cur]]=1,dfs(par[cur],k+1); for(int i=son[cur];i;i=bro[i]) if(k&lt;2) vis[i]=1,dfs(i,k+1);&#125; void solve()&#123; int ans=0; for(int i=maxd;i&gt;=0;i--)&#123; int S=depth[i].size(); for(int j=0;j&lt;S;j++)&#123; int u=depth[i][j]; if(vis[u])continue; if(par[par[u]])u=par[par[u]]; else if(par[u])u=par[u]; vis[u]=1,dfs(u,0),ans++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2001 矩阵乘积]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2222%2F</url>
    <content type="text"><![CDATA[题目链接 题解三元组矩阵乘法…数据结构书上一般都会讲到。因为指定了要求的值的位置，所以可以在矩阵$A\times B$的过程中，只保留$A$的$x$一行上的值，然后用$B$中的值去乘。对$B\times C$也如此。这样矩阵乘法的复杂度就会远低于$O(n^3)$，就做完了。复杂度大概是$O(n^2)$?实际上这题更麻烦的是读入…123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int x,y,m,n,o,p;int Am[6005]=&#123;0&#125;,Bm[6005]=&#123;0&#125;;char input[10005];int main()&#123; int i,j,u,v,val; scanf("%d%d%d%d%d%d",&amp;x,&amp;y,&amp;m,&amp;n,&amp;o,&amp;p); fgets(input,10000,stdin); for(;;)&#123; fgets(input,10000,stdin); if(!isdigit(input[0]))break; sscanf(input,"%d%d%d",&amp;u,&amp;v,&amp;val); if(u==x)Am[v]=val; &#125; for(;;)&#123; fgets(input,10000,stdin); if(!isdigit(input[0]))break; sscanf(input,"%d%d%d",&amp;u,&amp;v,&amp;val); Bm[v]+=Am[u]*val; &#125; memcpy(Am,Bm,sizeof(Bm)); memset(Bm,0,sizeof(Bm)); while(~scanf("%d%d%d",&amp;u,&amp;v,&amp;val)) Bm[v]+=Am[u]*val; printf("%d\n",Bm[y]); return 0;&#125; ​]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2003 激光炸弹]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2280%2F</url>
    <content type="text"><![CDATA[题目链接 题解一开始看错题目，以为有很多个炸弹…暴力即可123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,r,mat[5005][5005]=&#123;0&#125;,x=0,y=0;void init()&#123; n=read(),r=read(); int dx,dy,c; for(int i=1;i&lt;=n;i++) dx=read(),dy=read(),c=read(), dx++,dy++,mat[dx][dy]+=c, x=max(x,dx),y=max(y,dy); x=max(x,r),y=max(y,r); for(int i=1;i&lt;=x;i++) for(int j=1;j&lt;=y;j++) mat[i][j]+=mat[i][j-1]; for(int j=1;j&lt;=y;j++) for(int i=1;i&lt;=x;i++) mat[i][j]+=mat[i-1][j];&#125;void solve()&#123; int ans=0; for(int i=r;i&lt;=x;i++) for(int j=r;j&lt;=y;j++) ans=max(ans,mat[i][j]-mat[i-r][j]-mat[i][j-r]+mat[i-r][j-r]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2004 L语言]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2292%2F</url>
    <content type="text"><![CDATA[题目链接 题解Hash和DP。实际上也可以拿trie做。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef unsigned int ui;char t[1000005];bool able[1000005]=&#123;0&#125;; int n,m,lth[25];ui hsh[25],h[1000005],P=1005257,Pow[1000005];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%s",t); hsh[i]=0,lth[i]=strlen(t); for(int j=0;j&lt;lth[i];j++) hsh[i]=P*hsh[i]+t[j]; &#125; Pow[0]=1; for(int i=1;i&lt;=1000000;i++) Pow[i]=Pow[i-1]*P; for(int i=0;i&lt;m;i++)&#123; scanf("%s",t); int len=strlen(t),ans=0,j,k; h[0]=0,able[0]=1; for(j=1;j&lt;=len;j++)&#123; h[j]=h[j-1]*P+t[j-1]; for(k=0;k&lt;n;k++)&#123; if(lth[k]&lt;=j&amp;&amp;h[j]-Pow[lth[k]]*h[j-lth[k]]==hsh[k]) able[j]|=able[j-lth[k]]; if(able[j])break; &#125; if(able[j])ans=j; &#125; printf("%d\n",ans); memset(able,0,sizeof(able)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>字符串DP</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2010 弹飞绵羊]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu3203%2F</url>
    <content type="text"><![CDATA[题目链接 题解LCT模板题。把跳到的点当作是父亲，支持删边和连边即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,fa[200005]=&#123;0&#125;,ch[200005][2],siz[200005]=&#123;0&#125;,rev[200005]=&#123;0&#125;;int val[200005],to[200005];int cmp(int k)&#123; return ch[fa[k]][1]==k;&#125;int isroot(int k)&#123; return ch[fa[k]][0]!=k&amp;&amp;ch[fa[k]][1]!=k;&#125;void Rev(int k)&#123; swap(ch[k][0],ch[k][1]); rev[k]^=1;&#125;void maintain(int k)&#123; siz[k]=siz[ch[k][0]]+siz[ch[k][1]]+1;&#125;void pushdown(int k)&#123; if(k&amp;&amp;rev[k])&#123; rev[k]=0; if(ch[k][0])Rev(ch[k][0]); if(ch[k][1])Rev(ch[k][1]); &#125;&#125;void pushup(int k)&#123; if(!k)return ; if(!isroot(k))pushup(fa[k]); pushdown(k);&#125; void Rotate(int k)&#123; int Fa=fa[k],Gfa=fa[Fa],d=cmp(k); ch[Fa][d]=ch[k][d^1],fa[ch[k][d^1]]=Fa; ch[k][d^1]=Fa,fa[Fa]=k; fa[k]=Gfa; if(!isroot(Fa))&#123; if(Fa==ch[Gfa][0])ch[Gfa][0]=k; else if(Fa==ch[Gfa][1])ch[Gfa][1]=k; &#125; maintain(Fa); &#125;void splay(int k)&#123; pushup(k); for(int Fa=fa[k];!isroot(k);Rotate(k),Fa=fa[k]) if(fa[Fa]&amp;&amp;!isroot(Fa))Rotate(cmp(k)==cmp(Fa)?Fa:k); maintain(k);&#125; void access(int k)&#123; for(int t=0;k;t=k,k=fa[k])splay(k),ch[k][1]=t,maintain(k);&#125; void makeroot(int k)&#123; access(k),splay(k),Rev(k);&#125;int findroot(int k)&#123; while(fa[k])k=fa[k];return k;&#125;void Split(int u,int v)&#123; makeroot(u),access(v),splay(v);&#125;void cut(int u,int v)&#123; Split(u,v); ch[v][0]=fa[u]=0; maintain(v);&#125;void link(int u,int v)&#123; makeroot(u),fa[u]=v;&#125;void init()&#123; n=read(),siz[n+1]=1; for(int i=1;i&lt;=n;i++)val[i]=read(),to[i]=min(n+1,i+val[i]),siz[i]=1; for(int i=1;i&lt;=n;i++)link(i,to[i]); &#125;void solve()&#123; m=read(); int opr,x,y; while(m--)&#123; opr=read(),x=read()+1; if(opr==1) Split(x,n+1),printf("%d\n",siz[n+1]-1); if(opr==2)&#123; y=read(); if(to[x]==n+1&amp;&amp;x+y&gt;n)continue; cut(x,to[x]),val[x]=y,to[x]=min(x+y,n+1),link(x,to[x]); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 GameZ游戏排名系统]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2584%2F</url>
    <content type="text"><![CDATA[题目链接 题解双关键字平衡树。其实也没什么，跟排序的时候写两个关键字一样操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt; #define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; Tr *ch[2]; int r,v,siz,tim; char name[12]; int cmp(int x,int tt) const &#123; if(x==v&amp;&amp;tt==tim)return -1; return x==v?tt&gt;tim:x&gt;v; &#125; void maintain()&#123; siz=1; if(ch[0]!=NULL)siz+=ch[0]-&gt;siz; if(ch[1]!=NULL)siz+=ch[1]-&gt;siz; &#125;&#125;;Tr tree[400005],*ans;int S=0,n,T;char ord[12];map&lt;unsigned int,int&gt; mp1;//最近一次得分 map&lt;unsigned int,int&gt; mp2;//最近一次插入 void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr; tr-&gt;maintain(),k-&gt;maintain(),tr=k;&#125;void insert_tr(Tr* &amp;tr,int x,int tt)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;siz=1,tr-&gt;v=x,tr-&gt;tim=tt; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); memcpy(tr-&gt;name,ord,sizeof(ord)); return ; &#125; tr-&gt;siz++; int d=tr-&gt;cmp(x,tt); insert_tr(tr-&gt;ch[d],x,tt); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1);&#125;void del(Tr* &amp;tr,int x,int tt)&#123; int d=tr-&gt;cmp(x,tt); if(d==-1)&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),tr-&gt;siz--,del(tr-&gt;ch[d_],x,tt); &#125; &#125;else tr-&gt;siz--,del(tr-&gt;ch[d],x,tt);&#125; Tr* Kth(Tr *tr,int x)&#123; if(tr==NULL||x&lt;=0||x&gt;tr-&gt;siz)return NULL; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(x&lt;=evid)return Kth(tr-&gt;ch[0],x); else if(x&gt;evid+1)return Kth(tr-&gt;ch[1],x-evid-1); else return tr;&#125;int Rank(Tr *tr,int x,int tt)&#123; if(tr==NULL)return 0; int evid=(tr-&gt;ch[0]==NULL)?0:tr-&gt;ch[0]-&gt;siz; if(tr-&gt;cmp(x,tt)&lt;0)return evid+1; if(!tr-&gt;cmp(x,tt))return Rank(tr-&gt;ch[0],x,tt); else return evid+1+Rank(tr-&gt;ch[1],x,tt);&#125; bool Find(Tr *tr,int x)&#123; while(tr!=NULL)&#123; if(tr-&gt;v==x)return true; else tr=tr-&gt;ch[(tr-&gt;v&lt;x)]; &#125; return false;&#125;unsigned int Hash(char *s)&#123; unsigned int res=0; for(;*s;s++)res=res*133u+*s; return res;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;void solve()&#123; n=read(),T=0; Tr *root=NULL; while(n--)&#123; scanf("%s",ord); if(ord[0]=='+')&#123; int u=-read(),pre,close; unsigned int code=Hash(ord+1); pre=mp1[code],close=mp2[code]; //上一次的得分和插入时间 if(pre&amp;&amp;Find(root,pre)) del(root,pre,close); mp1[code]=u,mp2[code]=T,insert_tr(root,u,T); &#125;else if(isdigit(ord[1]))&#123; int rk=atoi(ord+1); for(int i=0;i&lt;10;i++)&#123; ans=Kth(root,rk+i); if(ans==NULL)break; if(i)printf(" "); printf("%s",ans-&gt;name+1); &#125; printf("\n"); &#125;else &#123; unsigned int code=Hash(ord+1); int pre=mp1[code],close=mp2[code]; printf("%d\n",Rank(root,pre,close)); &#125; T++; &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 书架]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2596%2F</url>
    <content type="text"><![CDATA[题目链接 题解平衡树裸题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Tr&#123; int siz,v,pr,l,r,fa;&#125;;Tr tr[400005];int S=0,root=0,n,m,a[200005];int pos[200005];void maintain(int k)&#123; tr[k].siz=1; if(tr[k].l)tr[k].siz+=tr[tr[k].l].siz,tr[tr[k].l].fa=k; if(tr[k].r)tr[k].siz+=tr[tr[k].r].siz,tr[tr[k].r].fa=k;&#125;int newnode(int k)&#123; S++,tr[S].v=k,tr[S].pr=rand(),tr[S].siz=1; tr[S].l=tr[S].r=tr[S].fa=0; return S;&#125;void Split_K(int now,int k,int &amp;x,int &amp;y)&#123; if(!now)x=y=0; else&#123; if(k&gt;tr[tr[now].l].siz) x=now,Split_K(tr[now].r,k-tr[tr[now].l].siz-1,tr[now].r,y); else y=now,Split_K(tr[now].l,k,x,tr[now].l); maintain(now); &#125;&#125;int Merge(int x,int y)&#123; if(!x||!y)return x+y; if(tr[x].pr&lt;tr[y].pr)&#123; tr[x].r=Merge(tr[x].r,y); maintain(x); return x; &#125;else&#123; tr[y].l=Merge(x,tr[y].l); maintain(y); return y; &#125;&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int get_pos(int x)&#123; int res=1+tr[tr[x].l].siz; while(tr[x].fa)&#123; if(x==tr[tr[x].fa].r) res+=tr[tr[tr[x].fa].l].siz+1; x=tr[x].fa; &#125; return res;&#125;void init()&#123; srand(12414841); tr[0].siz=tr[0].v=tr[0].fa=0; n=read(),m=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++) pos[a[i]]=newnode(a[i]), root=Merge(root,pos[a[i]]);//rank数组&#125;void solve()&#123; char ord[10]; int x,u,v,w,y,z,t,i1,i2; for(int i=1;i&lt;=m;i++)&#123; scanf("%s",ord); u=v=w=y=z=t=0; if(ord[0]=='A') x=read(), printf("%d\n",get_pos(pos[x])-1); if(ord[0]=='T')&#123; x=read(),u=get_pos(pos[x]); Split_K(root,u-1,w,z); Split_K(z,1,y,v); root=Merge(Merge(y,w),v); &#125; if(ord[0]=='B')&#123; x=read(),u=get_pos(pos[x]); Split_K(root,u-1,w,z); Split_K(z,1,y,v); root=Merge(Merge(w,v),y); &#125; if(ord[0]=='Q')&#123; x=read(); Split_K(root,x-1,w,z); Split_K(z,1,y,v); printf("%d\n",tr[y].v); root=Merge(Merge(w,y),v); &#125; if(ord[0]=='I')&#123; x=read(),y=read(); if(y)&#123; u=get_pos(pos[x]); Split_K(root,u-1,w,v); Split_K(v,1,t,z); if(y==-1)&#123; Split_K(w,u-2,i1,i2); root=Merge(Merge(Merge(i1,t),i2),z); &#125;else&#123; Split_K(z,1,i1,i2); root=Merge(Merge(Merge(w,i1),t),i2); &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 三色二叉树]]></title>
    <url>%2F2018%2F08%2F09%2Fluogu2585%2F</url>
    <content type="text"><![CDATA[题目链接 题解水DP。分别给每个点设3个状态即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char s[10005];int n,l[10005]=&#123;0&#125;,r[10005]=&#123;0&#125;,ans,f[10005][3],o;int dfs(int cur)&#123; if(s[cur]=='0')return cur; if(s[cur]=='1')&#123; l[cur]=cur+1; return dfs(cur+1); &#125; if(s[cur]=='2')&#123; l[cur]=cur+1; int t=dfs(cur+1); r[cur]=t+1; return dfs(t+1); &#125; &#125;int dfs2(int cur)&#123; if(l[cur])dfs2(l[cur]); if(r[cur])dfs2(r[cur]); if(l[cur]&amp;&amp;r[cur])&#123; if(!o)&#123; f[cur][0]=max(f[l[cur]][1]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][1]), f[cur][2]=max(f[l[cur]][1]+f[r[cur]][0],f[l[cur]][0]+f[r[cur]][1]), f[cur][1]=max(f[l[cur]][0]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][0])+1; &#125;else&#123; f[cur][0]=min(f[l[cur]][1]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][1]), f[cur][2]=min(f[l[cur]][1]+f[r[cur]][0],f[l[cur]][0]+f[r[cur]][1]), f[cur][1]=min(f[l[cur]][0]+f[r[cur]][2],f[l[cur]][2]+f[r[cur]][0])+1; &#125; &#125;else if(l[cur])&#123; if(!o)&#123; f[cur][0]=max(f[l[cur]][1],f[l[cur]][2]), f[cur][2]=max(f[l[cur]][1],f[l[cur]][0]), f[cur][1]=max(f[l[cur]][0],f[l[cur]][2])+1; &#125;else&#123; f[cur][0]=min(f[l[cur]][1],f[l[cur]][2]), f[cur][2]=min(f[l[cur]][1],f[l[cur]][0]), f[cur][1]=min(f[l[cur]][0],f[l[cur]][2])+1; &#125; &#125;else&#123; f[cur][0]=f[cur][2]=0,f[cur][1]=1; &#125;&#125;void init()&#123; scanf("%s",s+1); n=strlen(s+1),dfs(1);&#125;void solve()&#123; ans=0,o=0,dfs2(1); ans=max(ans,max(f[1][0],max(f[1][1],f[1][2]))); printf("%d ",ans); memset(f,0,sizeof(f)); ans=INF,o=1,dfs2(1); ans=min(ans,min(f[1][0],min(f[1][1],f[1][2]))); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI2014 HOT-Hotels]]></title>
    <url>%2F2018%2F08%2F09%2Fpoi2014-hot%2F</url>
    <content type="text"><![CDATA[题目链接 题解一个比较容易证明的结论是：这三个点必然会经过某一个点，并且该点到他们的距离相等。这样，我们枚举每一个点，然后算一下每层深度有多少个这样的点，计数即可。这样会有重复，不妨这么考虑：一个点是“中心点”的前提是他是另外$3$个点的$LCA$。所以为了避免某$2$个深度相同的点的$LCA$不是当前枚举的点，我们就把每一颗当前枚举点的子树看作是一个集合，集合中深度相同的$2$个点不可同时选取，就转化为了一个组合问题。假设有$n$个集合，大小分别为a_1,a_2,a_3,...,a_n要从其中$3$个集合中各选一个元素组成$3$元组个方案数显然是a_ia_ja_k。这些方案数的和就是当前点的答案。然后考虑加入一个集合，要快速得到这个集合的贡献，就要维护其他集合两两乘积的和，把新集合大小乘上去就是新集合的贡献。维护两两乘积的和又需要维护所有集合大小之和，这就是代码里开了$f,g$2个数组的原因。$f$就是集合大小和，$g$就是两两乘积和。这么做是$O(n^2)$的。容易被卡。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,to[10005],nex[10005],at[10005]=&#123;0&#125;,cnt=0;ll ans=0,f[5005],g[5005],d[5005]=&#123;0&#125;;//次数1 2 3 void dfs(int cur,int fa,int de)&#123; d[de]++; for(int i=at[cur];i;i=nex[i]) if(to[i]!=fa) dfs(to[i],cur,de+1); &#125;void init()&#123; n=read(); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); to[++cnt]=v,nex[cnt]=at[u],at[u]=cnt; to[++cnt]=u,nex[cnt]=at[v],at[v]=cnt; &#125; &#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); for(int j=at[i];j;j=nex[j])&#123; dfs(to[j],i,1); for(int k=1;k&lt;=n;k++)//合并集合 ans+=d[k]*g[k],g[k]+=d[k]*f[k],f[k]+=d[k],d[k]=0; &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POI</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI2014 PTA-Little Bird]]></title>
    <url>%2F2018%2F08%2F09%2Fpoi2014-pta%2F</url>
    <content type="text"><![CDATA[题目链接 题解要用单调队列这一点比较明显，DP也可以看得出来。所以就是单调队列+DP。保证单调队列里的元素相同体力消耗下靠近队首的高度尽量高即可，相当于在维护队列体力消耗值从队首到队尾递增的基础上对高度进行递减的维护。时间复杂度是$O(Nq)$。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[1000005],m,d,que[1000005],f,r,dp[1000005];void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();&#125;void solve()&#123; m=read(); while(m--)&#123; d=read(); f=r=0; dp[1]=0,que[r++]=1; for(int i=2;i&lt;=n;i++)&#123; while(r-f&amp;&amp;i-que[f]&gt;d)f++; dp[i]=dp[que[f]]+(a[que[f]]&lt;=a[i]); while(r-f&amp;&amp;(dp[que[r-1]]&gt;dp[i]||(dp[que[r-1]]==dp[i]&amp;&amp;a[que[r-1]]&lt;a[i]))) r--; que[r++]=i; &#125; printf("%d\n",dp[n]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POI</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2011 兔农]]></title>
    <url>%2F2018%2F08%2F09%2Fnoi2011t1%2F</url>
    <content type="text"><![CDATA[题目链接 题解模拟能拿75分。题目肯定是和斐波那契数列有关，但有关在哪里呢？由于有取模，所以我们看看有没有什么和循环有关的性质。我们设$fib[i]$为斐波那契数列的第$i$项，而设$F[i]$为该数列的第i项。把$k=7$作为例子，观察$F[i]$对$k$取模的序列：$1,1,2,3,5,0, $$5,5,3,0, $$3,3,6,2,0,$$2,2,4,6,3,2,5,0,5,5,3,0,$（之所以这一段前面的$0$不算是一段的结尾，是因为这个$0$不是由于减了一个$1$而产生的）$3,3,6,2,0,…$设$fib[0]=0$，则可以发现： 每一段的开头两个数都是相同的两个数，并且正好就是前面那一个段的最后一个非$0$数。同时只有除$k$和$0$以外的$k-1$种数，所以最多在不超过$k$段的情况下就会出现循环。（假设这个循环是存在的话。） 对于某一段而言，这一段都相当于一段小的斐波那契数列。比如说某一段的开头是$x$，那么这一段就是$x,x,2x,3x,5x,8x,…$换言之，这一段的第$i$个数就是$fib[i]\cdot x$。如果这一段有长度，那么设长度是$Len$，则$fib[Len]\cdot x \mod k=1$.这个时候就是我们要减掉$1$的时候。 有了以上的推导，我们不难得出具体算法： 根据$fib[Len]\cdot x \mod k=1$求出$fib[Len]$ 反推出$Len$ 求出下一段的开头，也就是$fib[Len-1]\cdot x$，转回第1步 第1步里头，不难发现$fib[Len]$就是$x^{-1}(mod\quad k)$，所以如果逆元都不存在的话这就成了裸题。否则，算出逆元。第2步，预处理出对于每个$i$，$fib[Len]=i$的最小$Len$。如果是不存在，那么也变成了矩阵乘法裸题。但是可能这个$Len$很大啊？有2个方法： 估计一下$fib \mod k$的循环节长度，直接算 数学证明。vfk大佬的博客上有证明，我不会证，只知道了结论：$fib \mod k$的循环节是以$0,1,1$为开头的，且长度不超过$6000$。就直接算了。 第3步，由于直接模拟可能超时，所以要用矩阵快速幂。一个数减掉$1$是一个很好写的矩阵，这里就不列了，有兴趣的看代码吧。 剩下的细节还挺好处理的。边算边记录答案即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;ll n,k,p,ans;ll minlen[1000005],block[1000005][3],vis[1000005]=&#123;0&#125;,top=0;ll sum[1000005]=&#123;0&#125;;ll FIB[3][3]=&#123; &#123;0,1,0&#125;, &#123;1,1,0&#125;, &#123;0,0,1&#125;&#125;,MINUS[3][3]=&#123; &#123;1,0,0&#125;, &#123;0,1,0&#125;, &#123;0,-1,1&#125;&#125;;//vis 总长度为什么时开头变成了i // block保存段长信息 struct Mat&#123; ll dat[3][3]; int r,c; Mat()&#123; memset(dat,0,sizeof(dat)); &#125;&#125;;Mat Minus,Fib;Mat mul(Mat &amp;a,Mat &amp;b,ll Mod)&#123; Mat newed; newed.r=a.r,newed.c=b.c; int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; for(t=0,k=0;k&lt;a.c;k++)t+=(a.dat[i][k])*(b.dat[k][j]),t%=Mod; newed.dat[i][j]=t%Mod; &#125; return newed;&#125;Mat Pow(Mat a,ll p,ll Mod)&#123; Mat E;E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) E.dat[i][i]=1; while(p)&#123; if(p&amp;1)E=mul(E,a,Mod); a=mul(a,a,Mod),p&gt;&gt;=1; &#125; return E;&#125;ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll d=extgcd(b,a%b,y,x); y-=(a/b)*x; return d;&#125;void setfib(Mat &amp;mat)&#123; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) mat.dat[i][j]=FIB[i][j]; mat.r=mat.c=3;&#125;void setminus(Mat &amp;mat)&#123; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) mat.dat[i][j]=MINUS[i][j]; mat.r=mat.c=3;&#125;void init()&#123; scanf("%lld%lld%lld",&amp;n,&amp;k,&amp;p); memset(minlen,-1,sizeof(minlen)); memset(vis,-1,sizeof(vis)); ll fib1=1,fib2=1,fib3,t; for(ll i=3;i&lt;=6*k;i++)&#123; fib3=(fib1+fib2),t=fib3%k; //printf("\t %lld %lld %lld\n",fib1,fib2,t); if(t==1&amp;&amp;fib2==1&amp;&amp;fib1==0)break; if(minlen[t]&lt;0)minlen[t]=i; fib1=fib2,fib2=t; &#125; MINUS[2][1]=p-1; //计算对应的Len setfib(Fib),setminus(Minus);&#125;void solve()&#123; ll x=1,dx,dy,d,len; ll cyc=-1; Mat Ori,Plu,res; Ori.r=1,Ori.c=3; Ori.dat[0][0]=Ori.dat[0][2]=1, Ori.dat[0][1]=0; for(;;)&#123; d=extgcd(x,k,dx,dy); //ax+bk=1 if(d!=1) break; else&#123; //逆元存在 dx=(dx+k)%k,len=minlen[dx]; if(len==-1)//不存在对应的 break; block[top][0]=x,block[top][1]=len; Plu=Pow(Fib,len-1,k); res=mul(Ori,Plu,k); //求出fib[len-1] block[top++][2]=(x*res.dat[0][1])%k; x=block[top-1][2]; sum[top]=sum[top-1]+len; if(vis[x]&gt;=0)&#123; //说明top-1的后面和cyc是一样的 cyc=vis[x]+1; break; &#125; vis[x]=top-1; &#125; &#125; if(cyc==-1)&#123; //没有最终的循环节，就变成矩阵乘法裸题 for(ll i=0;i&lt;top&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; if(n) Plu=Pow(Fib,n,p), Ori=mul(Ori,Plu,p); ans=Ori.dat[0][1]; &#125;else&#123; for(ll i=0;i&lt;cyc&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; if(!n)&#123; ans=Ori.dat[0][1];goto build_ans; &#125; d=n/(sum[top]-sum[cyc]),n%=(sum[top]-sum[cyc]); if(d)&#123; //至少存在一个循环节 for(ll i=0;i&lt;3;i++) for(ll j=0;j&lt;3;j++) Plu.dat[i][j]=(i==j)?1:0; Plu.r=Plu.c=3; for(ll i=cyc;i&lt;top;i++) res=Pow(Fib,block[i][1],p),res=mul(res,Minus,p),Plu=mul(Plu,res,p); Plu=Pow(Plu,d,p),Ori=mul(Ori,Plu,p); &#125; for(ll i=cyc;i&lt;top&amp;&amp;n;i++)&#123; len=block[i][1]; Plu=Pow(Fib,min(n,len),p); Ori=mul(Ori,Plu,p); if(n&lt;len)&#123; n=0;break; &#125; n-=len; Ori=mul(Ori,Minus,p); &#125; ans=Ori.dat[0][1]; &#125; build_ans: printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI2011</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa100 The 3n + 1 problem]]></title>
    <url>%2F2018%2F08%2F07%2Fuva100%2F</url>
    <content type="text"><![CDATA[题目链接 题解模拟即可不需要RMQ也不需要记忆化…因为数据好像超出了1000012345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int rec(int cur)&#123; if(cur == 1)return 1; if(cur &amp; 1) return rec(3 * cur + 1) + 1; else return rec(cur &gt;&gt; 1) + 1;&#125;void init()&#123;&#125;void solve()&#123; int l, r; while(scanf("%d%d", &amp;l, &amp;r) == 2)&#123; int aans = 0; if(l &lt; r)&#123; for(int i = l; i &lt;= r; ++i) aans = max(aans, rec(i)); &#125;else &#123; for(int i = r; i &lt;= l; ++i) aans = max(aans, rec(i)); &#125; printf("%d %d %d\n", l, r, aans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 堆]]></title>
    <url>%2F2018%2F08%2F06%2Ftemplate-heap%2F</url>
    <content type="text"><![CDATA[堆包括二叉堆，二项堆，可并堆，斐波那契堆，等。 普通二叉堆最经典的堆结构。其本身为一颗完全二叉树，并且每一个节点都遵循着自身的值大于（或者小于）父节点的值的规律。至于出现重复的值该怎么办，这就要具体情况具体分析。一般而言不需要手写二叉堆，使用C++自带的即可。 以下操作默认为小根堆： 上浮操作让当前位置为$id$的节点不断与其父节点比较，若其比父节点大则符合小根堆的标准，停止上浮；若其小于父节点则与父节点相交换，实现上浮。12345678910void pushup(int *h, int id)&#123; int tmp = h[id]; while(id &gt;= 1)&#123; int par = id &gt;&gt; 1; if(h[par] &lt; tmp) break; h[id] = h[par], id &gt;&gt;= 1; &#125; h[id] = tmp;&#125; 下沉操作让当前位置为$id$的节点不断与其子节点比较，边界是其自身为叶子。若其只有一个子节点，且其小于子节点则符合堆的要求，停止下沉；否则其与子节点交换，下沉。若其有两个子节点且小于两个子节点，则停止下沉；否则让更小的那个子节点与自身交换，下沉。12345678910111213141516171819202122void pushdown(int *h, int id)&#123;//下称操作 int tmp = h[id]; while(id &lt;= (n &gt;&gt; 1))&#123; int lson = id &lt;&lt; 1, rson = id &lt;&lt; 1 | 1; if(rson &gt; n)&#123; if(tmp &lt; h[lson]) break; else h[id] = h[lson], id = lson; &#125;else&#123; if(tmp &lt; h[lson] &amp;&amp; tmp &lt; h[rson]) break; else &#123; if(h[lson] &lt; h[rson]) h[id] = h[lson], id = lson; else h[id] = h[rson], id = rson; &#125; &#125; &#125; h[id] = tmp;&#125; 插入操作将新数$val$插入堆的最底层中，从左到右第一个空出的位置（即堆的最后一个位置的后面）。然后执行上浮操作。12345void pushin(int *h, int val)&#123;//增加数操作 int id = ++n; h[id] = val; pushup(h, id);&#125; 弹出操作将堆最后一个位置的节点与根节点交换，删去最后一个位置的节点，然后让根下沉。123456int popout(int *h)&#123; int top = heap[1]; heap[1] = heap[n--]; pushdown(h, 1); return top;&#125; 建堆操作从底到顶，一层一层对非叶子节点进行下沉操作。1234void build_heap(int *h, int n)&#123;//建堆 for(int i = n &gt;&gt; 1; i &gt;= 1; --i) pushdown(heap, i);&#125; 斐波那契堆斐波那契堆是一种可并堆，虽然其的写法比较复杂，但是其的摊还时间复杂度比较优秀。许多操作可以做到平摊$O(1)$的时间复杂度。确切地说，一个斐波那契堆是一个具有最小堆序的有根树森林。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷1338 末日的传说]]></title>
    <url>%2F2018%2F08%2F06%2Fluogu1338%2F</url>
    <content type="text"><![CDATA[题目链接 题解这题其实可以这么考虑。我们考虑把这个问题缩小范围。比如$n=5$，在决定了最小的数”$1$”的位置之后，剩下的几个数是$2,3,4,5$，但是他们具体是多少没必要关心，我们只要关心他们的相对大小关系。所以考虑完当前最小的数，算出这个数对答案的贡献，然后减掉这个贡献，就可以转而解决一个更小的子问题。（即$n\rightarrow n-1$）回到题目上，要求是求一个有$m$个逆序对的字典序最小的排列。我们知道一个长度为$n$的排列最多有$\frac {n(n-1)}2$个逆序对，也知道一个排列的逆序对数越多，排列字典序越大。所以如果当前$m$不比当前的$\frac {(n-2)(n-1)}2$（也就是减少一个数之后的最多的逆序对数）大，就可以直接把当前的最小数放在最前面，这肯定是最优的。反之，则考虑最小数的放置位置。假设当前排列长为$n$，最小数为$a$，则$a$有$n$种放法，放在从左到右第$i$个位置时会生成$i-1$个逆序对（因为它左边有$i-1$个比他大）。因为$m$大于$n-1$长度排列最多所能产生的逆序数，所以$a$不可能放在最前面，否则不满足条件。怎么办呢？想到之前说的逆序对越多字典序越大，我们就必须让剩下的数能构成的逆序对数尽量小，所以$a$要放到最后，这样$m$减少的最多。放完了$a$，问题就变成了$n-1$和$m-(a$的贡献$)$的子问题，递归求解即可。时间复杂度$O(n)$。123456789101112131415#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll n,m,a[50005];int main()&#123; scanf("%lld%lld\n",&amp;n,&amp;m); ll lst=n,fst=1; for(int i=1;i&lt;=n;i++)&#123; ll t=(ll)(n-i)*(n-i-1)/2; if(t&gt;=m)a[fst++]=i; else a[lst--]=i,m-=(lst-fst+1); &#125; for(int i=1;i&lt;=n;i++)printf("%d ",a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板 排序算法]]></title>
    <url>%2F2018%2F08%2F05%2Ftemplate-sort%2F</url>
    <content type="text"><![CDATA[不能忘的基本排序！ 插入排序重点在于：在排第$k$个元素的时候，前$k-1$个已经有序。因此只要把第$k$个元素放到它应该在的地方即可。123456789101112void sort1(int* a, int n)&#123; for(int i = 1; i &lt; n; ++i)&#123; int tmp = a[i], j; for(j = i; j &gt; 0; --j)&#123; if(tmp &lt; a[j - 1]) a[j] = a[j - 1];//向后面移动 else break; &#125;//寻找位置 a[j] = tmp;//插入 &#125;&#125; 选择排序简单直观的排序方法。始终寻找当前的最小值，放在它应当在的地方。12345void sort2(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = i + 1; j &lt; n; ++j) if(a[i] &gt; a[j])swap(a[i], a[j]);&#125; 冒泡排序比较相邻元素，调整顺序以达到排序的目的。123456void sort3(int *a, int n)&#123; for(int i = 0; i &lt; n - 1; ++i) for(int j = 0; j &lt; n - i; ++j) if(a[j] &gt; a[j + 1]) swap(a[j], a[j + 1]);//交换过程&#125; 希尔排序希尔排序使用了一个序列（称之为增量序列） h_1,h_2,h_3,...,h_n其中h_1=1。排序时将序列划为h_k组，元素之间间隔为h_k，然后每组内部进行一个插入排序。随着增量减小数据间的有序程度也就越高，最终在增量达到$1$时达到有序。增量序列的选择直接与算法的效率挂钩。此处用的为$Hibbard$增量，即$1,3,7,…,2^k-1$。123456789101112131415void sort4(int *a, int n)&#123; int h[] = &#123;1, 3, 7, 15, 31&#125;; for(int i = lower_bound(h, h + 5, n) - h - 1; i &gt;= 0; --i)&#123;//寻找最大增量 for(int j = h[i]; j &lt; n; ++j)&#123; int tmp = a[j], k; for(k = j; k &gt;= h[i]; k -= h[i])&#123; if(tmp &lt; a[k - h[i]]) a[k] = a[k - h[i]]; else break; &#125; a[k] = tmp; &#125; &#125;&#125; 以上为常见的$O(n^2)$排序算法。 归并排序分治算法的典型应用，将数据层层分割，直到最简单的两个一组的情况，然后不断进行二路归并。1234567891011121314151617181920void Merge(int *a, int *tmp, int lhead, int rhead, int rend)&#123; int lpos = lhead, rpos = rhead, tpos = lhead; while(lpos &lt; rhead &amp;&amp; rpos &lt; rend)&#123; if(a[lpos] &lt; a[rpos]) tmp[tpos++] = a[lpos++]; else tmp[tpos++] = a[rpos++]; &#125; while(lpos &lt; rhead)tmp[tpos++] = a[lpos++]; while(rpos &lt; rend)tmp[tpos++] = a[rpos++]; for(int i = lhead; i &lt; rend; ++i) a[i] = tmp[i];&#125;void MergeSort(int *a, int left, int right)&#123;//左闭右开 int n = right - left, mid = (right + left) &gt;&gt; 1; if(n == 1)return ; MergeSort(a, left, mid); MergeSort(a, mid, right); Merge(a, b, left, mid, right);&#125; 快速排序快速排序的关键在于选择基准以及分割策略，其余的工作交给递归即可。一种比较优秀的选择基准的方法是对最左端，最右端，和最中间的三个数排序，选择第二大（即中间大小）的数作为基准。这种选择比纯粹的随机选择和固定的选择更加高明。之后，将基准和当前序列的倒数第二个值交换。分割时，利用两个指针，其中一个（设为$i$）从最左边向右扫，另一个（设为$j$）从倒数第二个位置向左扫。$i$只会在大于或等于基准的位置停下，$j$只会在小于或等于基准的位置停下。此时若$i&lt;j$，那么交换$i$和$j$对应的数；若$i \ge j$，那么指针停止行动，本次分割结束。之后由于$i$指针左右分别为小于等于和大于等于基准的数，故把基准换到$i$所在位置，再对$i$两侧递归执行排序。 以上的做法避免了几个隐患： 基准换到倒数第二个位置，为$i$提供了一个界限；同时选择基准时进行的排序也为$j$提供了一个界限。 $i$和$j$在遇到等于基准的值时都会停下，这是因为当多个相同元素存在时，若$i$和$j$都不停下，那么$i$会一直进行到接近末尾的地方，导致分割出来的左右两边序列长度不均衡，进而导致算法实际运行效率变差。 123456789101112131415161718192021222324252627282930void Median3(int *a, int left, int right)&#123; int mid = (left + right) &gt;&gt; 1; if(a[left] &gt; a[mid])swap(a[left], a[mid]); if(a[mid] &gt; a[right])swap(a[mid], a[right]); if(a[left] &gt; a[mid])swap(a[left], a[mid]); swap(a[mid], a[right - 1]);&#125;void Qsort(int *a, int left, int right)&#123;// 闭区间 int len = right - left + 1, pivot; if(len &lt;= 1)return ; if(len == 2)&#123; if(a[right] &lt; a[left])swap(a[left], a[right]); return ; &#125; Median3(a, left, right); pivot = a[right - 1]; int i = left, j = right - 1; for(;;)&#123; while(a[++i] &lt; pivot) ; while(a[--j] &gt; pivot) ; if(i &gt;= j)break; swap(a[i], a[j]); &#125; swap(a[i], a[right - 1]); Qsort(a, left, i - 1); Qsort(a, i + 1, right);&#125;void QuickSort(int *a, int n)&#123; Qsort(a, 0, n - 1);&#125; 堆排序建立一个堆，直接操作即可。此处不再赘述。 以上为常见的$O(nlogn)$排序算法。 记数排序计数排序的中心思想是：对于每一个输入的元素$x$，确定小于或等于$x$的元素的个数。利用这一信息，即可把该元素放在他应在的位置。12345678910void CountingSort(int *a, int *cnt, int *ans, int n)&#123; for(int i = 0; i &lt;= 10; ++i) cnt[i] = 0; for(int i = 0; i &lt; n; ++i) cnt[a[i]]++; for(int i = 1; i &lt;= 10; ++i) cnt[i] += cnt[i - 1]; for(int i = n - 1; i &gt;= 0; --i) ans[--cnt[a[i]]] = a[i];&#125; 基数排序基数排序执行这样一个过程：对$n$个$d$位数，从最低位开始，一直到最高位，以数的当前位上的数字作为关键字进行排序。 桶排序桶排序将$n$个分布在$[0,1)$上的实数放入$m$个“桶”里，每个桶对应着一个区间，并且对每一个桶里的数据进行排序，以达到总体的有序。 以上为常见的线性时间复杂度排序算法。]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷1396 营救]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1396%2F</url>
    <content type="text"><![CDATA[题目地址 题解为什么专门拿出这道题来写一个题解呢？因为这道题考察到了一个我们平时（可能）没有注意到的地方。并查集不仅可以用来做连通性状态的维护，还可以用来解决一些图论上的最值问题。像是这道题，就把二分和并查集结合在一起。二分答案，只把拥挤度小于答案的加入并查集，维护$S$和$T$的联通状态。这个思路真的很妙。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;struct Edge&#123; int u,v,cost; &#125;; Edge edge[20005];bool cmp(int a,int b)&#123; return edge[a].cost&lt;edge[b].cost;&#125;int id[20005],n,m,S,T;int par[10005];int Find(int x)&#123; if(par[x]==x)return x; return par[x]=(Find(par[x]));&#125;void Unite(int u,int v)&#123; par[Find(u)]=Find(v);&#125;bool judge(int M)&#123; for(int i=1;i&lt;=n;i++) par[i]=i; for(int i=0;i&lt;m;i++)&#123; if(edge[id[i]].cost&gt;M)break; Unite(edge[id[i]].u,edge[id[i]].v); if(Find(S)==Find(T))return 1; &#125; return 0;&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost), id[i]=i; sort(id,id+m,cmp);&#125;void solve()&#123; int L=0,R=20000,M; while(R-L)&#123; M=(R+L)/2; if(judge(M))//&lt;=M R=M; else L=M+1; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2420]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2420%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出每一个点到根的$xor$路径，然后直接$O(1)$回答询问。答案就是$val[u]\quad xor\quad val[v]$，因为$val[lca]$被消去了。这真的是经典问题？我怀疑你就是在水1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[200006];int cnt=0,at[100005]=&#123;0&#125;,n,val[100005]=&#123;0&#125;;void addedge(int _u,int _v,int _cost)&#123; edge[++cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int x,int fa)&#123; for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa) val[edge[i].v]=val[x]^edge[i].cost, dfs(edge[i].v,x);&#125;void init()&#123; n=read(); int u,v,c; for(int i=1;i&lt;n;i++) u=read(),v=read(),c=read(), addedge(u,v,c),addedge(v,u,c); dfs(1,0);&#125;void solve()&#123; int m=read(),u,v; while(m--) u=read(),v=read(), printf("%d\n",val[u]^val[v]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1730 最小密度路径]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1730%2F</url>
    <content type="text"><![CDATA[题目地址 题解这是floyd的一个拓展应用。可以求出恰好经过一定数目条路的最短路径长度。也是运用到了动态规划的思想，不过DP数组则变成了3维。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 0x14141414using namespace std;typedef long long ll;int d[1005][105][105],V,E,Q;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; V=read(),E=read(); int u,v,c; memset(d,0x14,sizeof(d)); for(int i=1;i&lt;=E;i++)&#123; u=read(),v=read(),c=read(); if(d[1][u][v]&gt;c)d[1][u][v]=c; &#125; for(int l=2;l&lt;=E;l++) for(int k=1;k&lt;=V;k++) for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) d[l][i][j]=min(d[l][i][j],d[l-1][i][k]+d[1][k][j]); Q=read();&#125;void solve()&#123; int u,v; double ans; for(int i=1;i&lt;=Q;i++)&#123; u=read(),v=read(); ans=INF; for(int l=1;l&lt;=E;l++) if(d[l][u][v]&lt;INF) ans=min(ans,d[l][u][v]/(double)l); if(ans&gt;INF-1)printf("OMG!\n"); else printf("%.3lf\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2758 编辑距离]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu2758%2F</url>
    <content type="text"><![CDATA[题目地址 题解非常经典的$DP$题目。转移方程和$LCS$问题非常相似，设$f(i,j)$表示$a$串的第$i$位匹配到$b$串的第$j$位所需要的最少操作数，那么有: f(i,j)=\begin {cases} f(i-1,j-1)\quad (a[i]=b[j])\\ \min \left\{f(i-1,j),f(i-1,j-1),f(i,j-1)\right\}+1 \quad (a[i]\neq b[j]) \end{cases}以上三个数分别对应删除，修改和插入时间复杂度O(l_1l_2)123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;char a[2005],b[2005];int f[2005][2005],l1,l2,l3;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b);&#125;void solve()&#123; f[0][0]=0; for(int i=1;i&lt;=l1;i++) f[i][0]=i; for(int i=1;i&lt;=l2;i++) f[0][i]=i; for(int i=1;i&lt;=l1;i++)&#123; for(int j=1;j&lt;=l2;j++)&#123; if(a[i-1]==b[j-1])&#123; f[i][j]=f[i-1][j-1]; &#125;else f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+1; //printf("%d %d:%d\n",i,j,f[i][j]); &#125; &#125; printf("%d\n",f[l1][l2]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>字符串DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1122 最大子树和]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1122%2F</url>
    <content type="text"><![CDATA[题目地址 题解树形DP。主要是体会一下树形DP于树形这种递归结构的关系。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,at[100005],to[100005],_next[100005],cnt=0;bool vis[100005];ll val[100005],dp[100005];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void dfs(int cur)&#123; //包含自己在内 dp[cur]=val[cur]; for(int i=at[cur];i!=-1;i=_next[i])&#123; if(!vis[to[i]])&#123; vis[to[i]]=1,dfs(to[i]); if(dp[to[i]]&gt;0)dp[cur]+=dp[to[i]]; &#125; &#125;&#125;void init()&#123; n=read(); memset(at,-1,sizeof(at)); int u,v; for(int i=1;i&lt;=n;i++) val[i]=read(); for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); to[cnt]=v,_next[cnt]=at[u],at[u]=cnt++; to[cnt]=u,_next[cnt]=at[v],at[v]=cnt++; &#125;&#125;void solve()&#123; ll ans=-INF; ans*=2ll; vis[1]=1,dfs(1); for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i]); printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待改进 COCI2007 Patrik 音乐会的等待]]></title>
    <url>%2F2018%2F08%2F05%2Fluogu1823%2F</url>
    <content type="text"><![CDATA[题目地址 题解这题就是在教你怎么玩单调栈…经典做法就是，维护一个不递增的栈，然后有人比栈顶的人还高的话，就把他加进来，然后因为这个人肯定能看见他与他前面第一个比他高的人之间的人，所以在出栈的时候累加答案。同时还要注意人身高相等的情况。下面我的程序给出的实现方式并不是一个很好的方式，所以有待改进具体的改进方式应该就是令栈单调递减并且维护一段数据的大小…12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll stack[500005],ans=0,tmp,len,lst;int main()&#123; int i,top=1,n,j; scanf("%d%lld",&amp;n,&amp;stack[0]); for(i=1;i&lt;n;i++)&#123; scanf("%lld",&amp;tmp); while(top&amp;&amp;stack[top-1]&lt;tmp) top--,ans++; stack[top++]=tmp; if(top&gt;1)ans++; for(j=top-2;j&amp;&amp;stack[j]==tmp;j--,ans++); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>COCI</category>
      </categories>
      <tags>
        <tag>经典问题</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4203 Pythagoras]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu6211%2F</url>
    <content type="text"><![CDATA[题目地址 题解枚举素勾股数。这道题由于数据很大，所以肯定要一开始就枚举好。枚举的时候要注意，使用gcd会超时，所以改为使用枚举素因子判断互质。由于$\sqrt{1000000000} \approx 31622$，而$2\times 3\times 5\times 7\times 11\times 13\times 17 &gt; 31622$，所以素因子最多不会超过6个。这样的话效率就比较好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f = 1, x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123;if(c == '-') f = -f; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')x = x * 10 + c - '0', c = getchar(); return f * x; &#125;int cnt[200005] = &#123;0&#125;, tot = 0;int p[10], a[200005];void init()&#123; for(int v = 2; v &lt;= 31622; ++v)&#123; int pcnt = 0, t = v; for(int i = 2; i * i &lt;= v; ++i)&#123; if(t % i == 0)&#123; t /= i; while(t % i == 0) t /= i; p[++pcnt] = i; if(t == 1) break ; &#125; &#125; if(t != 1) p[++pcnt] = t; for(int u = (v % 2 == 0) ? 1 : 2; u &lt; v; u += 2)&#123; int cc = u * u + v * v, flag = 1; if(cc &gt; 1000000000) break; for(int i = 1; i &lt;= pcnt; ++i) if(u % p[i] == 0)&#123; flag = 0; break ; &#125; if(!flag) continue ; int aa = v * v - u * u, bb = 2 * u * v; if(aa &gt; bb) cnt[(aa &amp; 131071)]++; else cnt[(bb &amp; 131071)]++; &#125; &#125;&#125;void solve()&#123; int k = read(), t; k = (1 &lt;&lt; k), t = k - 1; for(int i = 0; i &lt; k; ++i) a[i] = read(); ll ans = 0; for(int i = 0; i &lt; 131072; ++i) ans += 1ll * cnt[i] * a[(i &amp; t)]; printf("%lld\n", ans);&#125;int main()&#123; int T = read(); init(); while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4203 Doubloon Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu4203%2F</url>
    <content type="text"><![CDATA[题目地址 题解先大力打表，看SG函数有没有什么规律发现打表结果非常神奇：当$K$是奇数的时候，SG函数是$010101$变化的。$K$是偶数的时候，每逢$K$的倍数，$SG（x\cdot K）$就为$2$。否则仍然按照$010101$变化。比如$K=2:0,1,2,0,1,2 …$$K=4:0,1,0,1,2,0,1,0,1,2…$之后就简单了。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int S,k,T;int SG(int x)&#123; if(k%2)return x%2; else &#123; int mod=x%(k+1); if(mod&lt;k)return mod%2; else return 2; &#125; &#125;void solve()&#123; T=read(); while(T--)&#123; S=read(),k=read(); int ans=SG(S); if(ans!=2)printf("%d\n",ans); else &#123; for(int j=1;S-j&gt;=0;j*=k) if(!SG(S-j))&#123; printf("%d\n",j); break; &#125; &#125; &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1704 Georgia and Bob]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1704%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个模型，没记错是叫做阶梯博弈。他这个模型可以转化成Nim游戏。把每一对移动的棋子之间的间距看作是石头的数目，就可以依靠Nim游戏的结论进行解答。但是为什么这样的转化是正确的呢？首先两个棋子逼近，就相当于取走若干个石头；如果两个石头远离，那么不要紧，下一步可以把这个多出来的部分减掉去，所以还是相当于没有增加。如果石头个数是奇数就虚拟一个边界上的石头和他配对。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int T,n,a[1005];void solve()&#123; T=read(); while(T--)&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); if(n&amp;1)a[n+1]=0,n++; sort(a+1,a+n+1); int res=0; for(int i=1;i&lt;=n;i+=2) res^=(a[i+1]-a[i]-1); printf("%s\n",res?"Georgia will win":"Bob will win"); &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1079 Calendar Game]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu1079%2F</url>
    <content type="text"><![CDATA[题目地址 题解写成递推的形式即可。边界条件挺烦的，还好1A了。反正大力码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;char dp[200][13][40]=&#123;0&#125;;//1900--&gt;0int days[]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int run(int x,int y)&#123; return (y==2&amp;&amp;x&amp;&amp;x%4==0);&#125;void init()&#123; dp[101][11][3]=1; int r1=0,r2=0; for(int i=101;i&gt;=0;i--) for(int j=12;j&gt;=1;j--) for(int d=31;d&gt;=1;d--)&#123; if(i==101&amp;&amp;(j==12||(j==11&amp;&amp;d&gt;=3)))continue; if(d&gt;days[j]+run(i,j))continue; if(i==101&amp;&amp;(j&gt;=11||(j==10&amp;&amp;d&gt;4)))r1=-1; else&#123; if(j==12)r1=dp[i+1][1][d]; else if(d&lt;=days[j+1]+run(i,j+1))r1=dp[i][j+1][d]; else r1=-1; &#125; if(d==days[j]+run(i,j))&#123; if(j==12)r2=dp[i+1][1][1]; else r2=dp[i][j+1][1]; &#125;else r2=dp[i][j][d+1]; if(!r1||!r2)dp[i][j][d]=1; else dp[i][j][d]=0; &#125;&#125;void solve()&#123; int T=read(),yy,mm,dd; while(T--)&#123; yy=read(),mm=read(),dd=read(); printf("%s\n",dp[yy-1900][mm][dd]==1?"YES":"NO"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1740 A New Stone Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1740%2F</url>
    <content type="text"><![CDATA[题目地址 题解一般而言，这种题目都需要一定的找规律的技巧。首先$n=1$，先手必胜，这是显然的。$n=2$,如果两堆石头一样多，那么先手必败，因为后手可以不断模仿先手的操作来使石头数始终相同，达到自己不败的目的。如果石头数不相等，那么先手可以转移到石头相同的状态。$n=3$，可以构造出$2$堆相同的情况，只要去掉最多的那一堆就行。$n=4$，只要可以拆成$2$个完全一样的子局面，先手就是必败态，其余是必胜态。归纳一下，$n$是奇数，先手必胜；$n$是偶数，除非局面对称，否则先手必胜。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int n,a[1005];void init()&#123; &#125;void solve()&#123; for(;;)&#123; n=read(); if(!n)break; for(int i=1;i&lt;=n;i++)a[i]=read(); if(n%2)&#123; printf("1\n"); continue; &#125; sort(a+1,a+1+n); int flag=0; for(int i=1;i+i&lt;=n;i+=2) if(a[i]!=a[i+1])&#123; flag=1;break; &#125; printf("%d\n",flag); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3863 No Gambling]]></title>
    <url>%2F2018%2F08%2F04%2Fhdu3863%2F</url>
    <content type="text"><![CDATA[题目地址 题解由于后手只能不断采取行动去堵先手的路，而先手一定可以采取方式突破，所以先手必胜。1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; for(int n;;)&#123; n=read(); if(n&lt;0)break; printf("I bet on Oregon Maple~\n"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2234 Matches Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2234%2F</url>
    <content type="text"><![CDATA[题目地址 题解简单的Nim游戏。推荐看国家集训队2002年张一飞的论文，他的论文深入浅出地用集合的观点解释了nim游戏和的原理。之后的很多博弈论的题目都建立在这么一个基本模型的基础上。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; &#125;void solve()&#123; int M,a[25],res; while(~scanf("%d",&amp;M))&#123; res=0; for(int i=1;i&lt;=M;i++)a[i]=read(),res^=a[i]; printf("%s\n",res?"Yes":"No"); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1442 Black Box]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1442%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一无脑平衡树。 方法二堆的神奇操作。发现这个求第$k$小$k$是递增的，所以可以维护一个大根堆和一个小根堆，然后在其中一个堆上维护前$k$个数，另一个堆上维护剩下的数，这样只要关注第$k$个数是什么即可，而不需要管在他前面的或者在他后面的是不是有序的。所以操作就很简单了，$k$加$1$的时候从某个堆弹一个走就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define l(x) (x&lt;&lt;1)+1#define r(x) (x&lt;&lt;1)+2using namespace std;int h[200005]=&#123;0&#125;,size=0,n,m,k[200005];priority_queue&lt;int&gt; pq;//pq下&lt;pq顶&lt;h顶&lt;h底 void up(int s)&#123; int at,tmp=h[s]; while(s&gt;0)&#123; at=(s-1)/2; if(h[at]&lt;=tmp)break; h[s]=h[at],s=at; &#125; h[s]=tmp;&#125;void down(int s,int e)&#123; int lch,rch,tmp=h[s]; while(l(s)&lt;e)&#123; lch=l(s),rch=r(s); if(rch&lt;e&amp;&amp;h[rch]&lt;h[lch]) lch=rch; if(tmp&lt;=h[lch])break; h[s]=h[lch],s=lch; &#125; h[s]=tmp;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int i,j,at; for(i=0;i&lt;m;i++) scanf("%d",&amp;k[i]); pq.push(k[0]); for(i=0,j=1;i&lt;n;i++)&#123; scanf("%d",&amp;at); while(j&lt;at)&#123; if(pq.top()&gt;k[j])&#123; h[size++]=pq.top(),pq.pop(); pq.push(k[j]),up(size-1); &#125;else h[size++]=k[j],up(size-1); j++; &#125; printf("%d\n",pq.top()); if(!size)h[size++]=k[j++]; pq.push(h[0]),h[0]=h[--size],down(0,size); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2823 Sliding Window]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2823%2F</url>
    <content type="text"><![CDATA[题目地址 题解经典的单调队列入门题。思路很简单，就是先判断队头是否“过期”，然后再在队尾进行比较。这里的代码是可以进行空间上的优化的。注意一个点：$k=1$时最好特判。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; int n,k,a[1000005],d1[1000005][2],d2[1000005][2],f1=0,f2=0,r1=1,r2=1,ans[1000005][2];void in(int at,int p)&#123; while(r1&gt;f1&amp;&amp;d1[f1][1]&lt;=at-k) f1++; while(r2&gt;f2&amp;&amp;d2[f2][1]&lt;=at-k) f2++; while(r1&gt;f1&amp;&amp;d1[r1-1][0]&gt;p) d1[r1-1][0]=d1[r1-1][1]=0,r1--; while(r2&gt;f2&amp;&amp;d2[r2-1][0]&lt;p) d2[r2-1][0]=d2[r2-1][1]=0,r2--; d1[r1][0]=p,d1[r1++][1]=at; d2[r2][0]=p,d2[r2++][1]=at;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); i=(k==1)?0:1; d1[0][0]=d2[0][0]=a[0]; d1[0][1]=d2[0][1]=0; for(;i&lt;n;i++)&#123; in(i,a[i]); ans[i][0]=d1[f1][0]; ans[i][1]=d2[f2][0]; &#125; for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][0]); printf("%d\n",ans[n-1][0]); for(i=k-1;i&lt;n-1;i++) printf("%d ",ans[i][1]); printf("%d\n",ans[n-1][1]); return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3017 Cut the Sequence]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3017%2F</url>
    <content type="text"><![CDATA[题目地址 题解第一次做这样的利用决策单调性来优化DP的题目。设$f(i)$表示分割到第$i$个元素时，最大和的最小值。很容易得到方程： f(i)=\min \limits_{sum[j+1...i]]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2918 Tudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2918%2F</url>
    <content type="text"><![CDATA[题目地址 题解基本同26761234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); for(int TT=1;TT&lt;=T;TT++)&#123; printf("Scenario #%d:\n",TT); tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); if(!tot&amp;&amp;!flag)print(); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2676 Sudoku]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2676%2F</url>
    <content type="text"><![CDATA[题目地址 题解一道很经典的题。用的是NOIP2009的程序，没加修改就过了。总体上来说有2个大优化 记录了每一个空的位置 每次找可能的数字最少的空搜 0ms过，还行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int vis[3][11][11]=&#123;0&#125;,sd[10][10]=&#123;0&#125;;int lis[81][2],tot=0,flag=0;void get(int at)&#123; int i,mini=99,p,j,x,y,o; for(i=at+1;i&lt;tot;i++)&#123; x=lis[i][0],y=lis[i][1],o=0; for(j=1;j&lt;=9;j++)&#123; if(vis[0][x][j]||vis[1][y][j]||vis[2][(x/3)*3+y/3][j])continue; else o++; &#125; if(o&lt;mini) mini=o,p=i; &#125; x=lis[at+1][0],y=lis[at+1][1],lis[at+1][0]=lis[p][0]; lis[at+1][1]=lis[p][1],lis[p][0]=x,lis[p][1]=y;&#125;//0 行 1 列 2 宫void print()&#123; if(flag)return ; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++) printf("%d",sd[i][j]); printf("\n"); &#125; flag=1;&#125;void dfs(int at)&#123; int i,x=lis[at][0],y=lis[at][1]; for(i=1;i&lt;=9;i++)&#123; if(vis[0][x][i]||vis[1][y][i]||vis[2][(x/3)*3+y/3][i])continue; vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=1; sd[x][y]=i; if(at&lt;tot-1)&#123; if(at!=tot-2)get(at); dfs(at+1); &#125; else print(); vis[0][x][i]=vis[1][y][i]=vis[2][(x/3)*3+y/3][i]=0; sd[x][y]=0; if(flag)break; &#125;&#125;int main()&#123; int T,tmp; scanf("%d",&amp;T); while(T--)&#123; tot=0,flag=0; memset(vis,0,sizeof(vis)); memset(sd,0,sizeof(sd)); memset(lis,0,sizeof(lis)); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; scanf("%1d",&amp;tmp); if(tmp) sd[i][j]=tmp,vis[0][i][tmp]= vis[1][j][tmp]=vis[2][(i/3)*3+j/3][tmp]=1; else lis[tot][0]=i,lis[tot++][1]=j; &#125; dfs(0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3764 The xor-longest Path]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj3764%2F</url>
    <content type="text"><![CDATA[题目地址 题解求出从根出发到每一个点的异或距离，然后问题转化为在这些距离中找两个异或值最大的。这是个经典问题，只需要在用trie树查询时进行反向行走即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt;using namespace std;typedef unsigned int ll;struct Tree&#123; int l,r; Tree()&#123;l=r=-1;&#125;&#125;;typedef struct&#123; int v,_next; ll cost;&#125;Edge;Edge edge[200005];int cnt=0,at[100005]; void addedge(int _u,int _v,ll _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int n,siz=1;Tree tr[3000005];ll vx[100005];bool vis[100005];void Trie_insert(ll num)&#123; //printf("%u\n",num); for(ll j=(1&lt;&lt;31),cur=0;j;j&gt;&gt;=1) if((j&amp;num)==0)&#123;//l:0 r:1 if(tr[cur].l&lt;0) tr[cur].l=siz++; cur=tr[cur].l; &#125;else&#123; if(tr[cur].r&lt;0) tr[cur].r=siz++; cur=tr[cur].r; &#125;&#125;ll Trie_search(ll x)&#123; ll res=0; for(ll j=1&lt;&lt;31,cur=0;j;j&gt;&gt;=1)&#123; if(x&amp;j)&#123; if(tr[cur].l&gt;0)res+=j,cur=tr[cur].l; else cur=tr[cur].r; &#125;else&#123; if(tr[cur].r&gt;0)res+=j,cur=tr[cur].r; else cur=tr[cur].l; &#125; &#125; return res;&#125;void dfs(int cur,ll val)&#123; for(int i=at[cur];i!=-1;i=edge[i]._next)&#123; int _v=edge[i].v; if(!vis[_v]) vis[_v]=1, vx[_v]=val^edge[i].cost, Trie_insert(vx[_v]), dfs(_v,vx[_v]); &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=0;i&lt;siz;i++) tr[i].l=tr[i].r=-1; siz=1,cnt=0; memset(at,-1,sizeof(at)); memset(vis,0,sizeof(vis)); int u,v;ll c; for(int i=0;i&lt;n-1;i++) scanf("%d%d%u",&amp;u,&amp;v,&amp;c), addedge(u,v,c), addedge(v,u,c); dfs(0,0); vx[0]=0; //Trie_insert(0u); ll ans=0; for(int i=0;i&lt;n;i++) ans=max(ans,Trie_search(vx[i])); printf("%u\n",ans); &#125; return 0; &#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2142 The Balance]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2142%2F</url>
    <content type="text"><![CDATA[题目地址 题解注意$a$,$b$可以交换位置。之后就是简单的解方程了。要使$|x|+|y|$最小，需要保证$x$最小，之后保证$y$最小即可。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,d,x1,x2,y1,y2;ll gcd(ll aa,ll bb)&#123; return bb?gcd(bb,aa%bb):aa;&#125;ll extgcd(ll aa,ll bb,ll &amp;xx,ll &amp;yy)&#123; if(!bb)&#123; xx=1,yy=0; return aa; &#125; ll dd=extgcd(bb,aa%bb,yy,xx); yy-=(aa/bb)*xx; return dd;&#125;ll Abs(ll x)&#123; return (x&lt;0)?(-x):x;&#125;void work(ll a_,ll b_,ll &amp;x,ll &amp;y)&#123; ll g=extgcd(a_,b_,x,y),t=b_/g; x*=d/g,x=(x%t+t)%t; y=Abs((a_*x-d)/b_);&#125;int main()&#123; for(;;)&#123; scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;d); if(!a&amp;&amp;!b&amp;&amp;!d)break; work(a,b,x1,y1); work(b,a,x2,y2); if(x1+y1&lt;x2+y2)printf("%lld %lld\n",x1,y1); else printf("%lld %lld\n",y2,x2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1811 Prime Test]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1811%2F</url>
    <content type="text"><![CDATA[题目地址 题解算导上面有讲解。用MillerRabin和PollardRho合力解决。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int T;ll prime[]=&#123;2,3,5,7,11,13,17,19,23,61&#125;;ll gcd(ll a,ll b)&#123; return (!b)?a:gcd(b,a%b);&#125;ll mul(ll a,ll b,ll c)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%c; a=(a+a)%c,b&gt;&gt;=1; &#125; return res;&#125;ll Pow(ll a,ll b,ll c)&#123; ll res=1; a%=c; while(b)&#123; if(b&amp;1)res=mul(res,a,c); a=mul(a,a,c),b&gt;&gt;=1; &#125; return res;&#125;bool witness(ll a,ll n,ll d,ll r)&#123; ll t=Pow(a,d,n),_t=t; for(ll i=1;i&lt;=r;i++)&#123; t=mul(t,t,n); if(t==1&amp;&amp;_t!=1&amp;&amp;_t!=n-1) return 1; _t=t;//基于二次探测定理的操作 &#125; if(t!=1)return 1;//基于费马小定理的操作 return 0;&#125;bool Miller_Rabin(ll n)&#123;//1:质数 if(n==2)return 1; if(n&lt;=1||n%2==0)return 0; for(int i=0;i&lt;10;i++) if(n==prime[i])return 1; ll R=n-1,S=0; for(;R%2==0;R&gt;&gt;=1,S++);//n-1=d*2^r for(int i=0;i&lt;10;i++)//10:测试次数 if(witness(prime[i],n,R,S)) return 0; return 1;&#125;//根据算导，c最好不要是0或者2...//为什么呢？ ll Pollard_Rho(ll n,ll c)&#123; ll x=Pow(rand(),rand(),n),y=x,k=2,d=1,t; for(ll i=1;d==1;i++)&#123; x=(mul(x,x,n)+c)%n; if(x-y&lt;0)t=y-x; else t=x-y; d=gcd(t,n); if(i==k)y=x,k&lt;&lt;=1; &#125; return d;&#125;ll dfs(ll n)&#123; if(n==1)return 1; if(Miller_Rabin(n))return n; ll fac=n,Lans,Rans; while(fac==n) fac=Pollard_Rho(n,rand()%(n-1)+1); Lans=dfs(fac),Rans=dfs(n/fac); return min(Lans,Rans);&#125;void init()&#123; scanf("%d",&amp;T); srand('z'+'q'+'y'+'1'+'0'+'1'+'8'+1);&#125;void solve()&#123; while(T--)&#123; ll N; scanf("%lld",&amp;N); ll ans=dfs(N); if(ans==N)printf("Prime\n"); else printf("%lld\n",ans); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2774 Long Long Message]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2774%2F</url>
    <content type="text"><![CDATA[题目地址 题解就是求最长公共子串哈希+排序+二分=暴力卡过哈希要用unsigned long long，用unsigned int极其容易撞车12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef unsigned long long ui;char a[200005],b[200005];ui P=1000000007,list[200005],h1[200005],h2[200005],pow1[200005];int l1,l2;bool check(int c)&#123; int i,j;ui t; for(i=1;i&lt;=l1-c+1;i++) list[i-1]=h1[i+c-1]-h1[i-1]*pow1[c]; sort(list,list+l1-c); for(i=1;i&lt;=l2-c+1;i++)&#123; t=h2[i+c-1]-h2[i-1]*pow1[c]; if((*lower_bound(list,list+l1-c,t))==t) return true; &#125; return false;&#125;int main()&#123; scanf("%s%s",a,b); l1=strlen(a),l2=strlen(b); int i,j,l,r,md; for(pow1[0]=1,i=1;i&lt;=200000;i++) pow1[i]=pow1[i-1]*P; for(i=1;i&lt;=l1;i++) h1[i]=h1[i-1]*P+a[i-1]; for(i=1;i&lt;=l2;i++) h2[i]=h2[i-1]*P+b[i-1]; l=0,r=min(l1,l2); //用b匹配a while(l&lt;r)&#123; md=l+(r-l+1)/2; if(check(md)) l=md; else r=md-1; &#125; printf("%d\n",r); return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2348 Euclid's Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2348%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设$a&gt;b$。显然当$a\mod b=0$时，先手必胜。当$a\mod b\neq 0$时，若$a&gt;2b$，则可以证明在接下来先手所有可以采取的$k$种策略中必有必胜策略，故这个也是必胜态。我讲的比较浅显，各位不妨看下《挑战程序设计竞赛》的P310。123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll a,b,f;int main()&#123; for(;;)&#123; scanf("%lld%lld",&amp;a,&amp;b); if(!a&amp;&amp;!b)break; f=1; for(;;)&#123; if(a&lt;b)swap(a,b); if(a%b==0)break; if(a&gt;2*b)break; a-=b,f^=1; &#125; if(f)printf("Stan wins\n"); else printf("Ollie wins\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2484 A Funny Game]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj2484%2F</url>
    <content type="text"><![CDATA[题目地址 题解 当$n=1$或者$n=2$时，明显先手必胜。当$n=3$时，明显先手必败。由于每次只可取$1$或$2$个，而取$2$个时，$2$个必须相邻，推断有：当$n&gt;3$时，若$n$为偶数，先手无论如何取，后手可在先手对称的位置上取同等数量，于是先手必败。若$n$为奇数，先手取$1$个时，后手可在先手对称的位置上取$2$个，之后无论先手如何取，后手都可在先手对称的位置上取同等数量，先手必败。如果先手一开始取$2$个时，后手可在先手对称的位置上取$1$个,之后还剩下偶数个,可如上推出先手必败。故当$n&gt;3$时,先手必败(来自链接) 这种模仿对手以判断是否是必胜的思想方式很有效，学到了。12345678910111213141516#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int main()&#123; int n; for(;;)&#123; scanf("%d",&amp;n); if(!n)break; printf("%s\n",(n&lt;=2)?"Alice":"Bob"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1306 Combinations]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1306%2F</url>
    <content type="text"><![CDATA[题目地址 题解计算组合数即可12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef unsigned long long ll;ll C[105][105];ll read()&#123; ll x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void build()&#123; for(ll i=0;i&lt;=100;i++) C[i][0]=1; for(ll i=1;i&lt;=100;i++) for(ll j=1;j&lt;=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];&#125; int main()&#123; build(); ll u,v; for(;;)&#123; u=read(),v=read(); if(!u&amp;&amp;!v)return 0; printf("%llu things taken %llu at a time is %llu exactly.\n",u,v,C[u][v]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1285 Combinations, Once Again]]></title>
    <url>%2F2018%2F08%2F04%2Fpoj1285%2F</url>
    <content type="text"><![CDATA[题目地址 题解用基本的背包处理即可。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n[56],N,q,r;ll f[56];void packX(int d)&#123; int p=1,_n,j; for(j=N;j&gt;=0;j--) for(_n=1;_n&lt;=min(n[d],j);_n++) f[j]+=f[j-_n];&#125; int main()&#123; int i,j,T=1; for(;;T++)&#123; memset(n,0,sizeof(n)); memset(f,0,sizeof(f)); scanf("%d%d",&amp;N,&amp;q); if(!N&amp;&amp;!q)break; for(i=0;i&lt;N;i++) scanf("%d",&amp;j), n[j-1]++; for(f[0]=1ll,i=0;i&lt;N;i++) packX(i); printf("Case %d:\n",T); for(i=0;i&lt;q;i++) scanf("%d",&amp;r), printf("%lld\n",f[r]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Paired Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3669%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。按照产奶时间从大到小排序，然后小的和大的配对，更新最长时间即可。这不是普及组原题么123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P p[100005];int n,ans=0;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)p[i].second=read(),p[i].first=read(); sort(p+1,p+1+n);&#125;void solve()&#123; int po=n; for(int i=1;i&lt;=n;i++)&#123; while(po&gt;i&amp;&amp;p[i].second&gt;=p[po].second)&#123; if(p[po].second) p[i].second-=p[po].second,ans=max(ans,p[i].first+p[po].first); po--; &#125; if(po==i)break; p[po].second-=p[i].second; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO17OPEN Bovine Genomics S]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3670%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟吧。没想到更加优秀的做法。时间复杂度：$O(nm^3)$123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,ans=0,vis[100],key[256];char dna[1005][55];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n+n;i++)scanf("%s",dna[i]); key['A']=0,key['C']=1,key['G']=2,key['T']=3;&#125;void solve()&#123; int code,tot=0,flag=0; for(int i=0;i&lt;m;i++) for(int j=i+1;j&lt;m;j++) for(int k=j+1;k&lt;m;k++)&#123; tot++,flag=0; for(int t=1;t&lt;=n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; vis[code]=tot; &#125; for(int t=n+1;t&lt;=n+n;t++)&#123; code=(key[dna[t][i]]&lt;&lt;4)+(key[dna[t][j]]&lt;&lt;2)+key[dna[t][k]]; if(vis[code]==tot)&#123; flag=1;break; &#125; &#125; if(!flag)ans++; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16JAN Radio Contact]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3133%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP。按照时间变化递推即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,pos1[1005][2],pos2[1005][2],f[1005][1005];char s1[1005],s2[1005];void movement(char c,int &amp;x,int &amp;y)&#123; if(c=='N')y++;if(c=='S')y--; if(c=='E')x++;if(c=='W')x--;&#125;int sqr(int a,int b)&#123; return (pos1[a][0]-pos2[b][0])*(pos1[a][0]-pos2[b][0])+ (pos1[a][1]-pos2[b][1])*(pos1[a][1]-pos2[b][1]);&#125;void init()&#123; n=read(),m=read(); pos1[0][0]=read(),pos1[0][1]=read(); pos2[0][0]=read(),pos2[0][1]=read(); scanf("%s%s",s1+1,s2+1); for(int i=1,x=pos1[0][0],y=pos1[0][1];i&lt;=n;i++) movement(s1[i],x,y), pos1[i][0]=x,pos1[i][1]=y; for(int i=1,x=pos2[0][0],y=pos2[0][1];i&lt;=m;i++) movement(s2[i],x,y), pos2[i][0]=x,pos2[i][1]=y;&#125;void solve()&#123; memset(f,0x14,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++) f[i][0]=f[i-1][0]+sqr(i,0); for(int i=1;i&lt;=m;i++) f[0][i]=f[0][i-1]+sqr(0,i); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[i][j]=min(f[i-1][j],f[i][j-1]), f[i][j]=min(f[i][j],f[i-1][j-1]), f[i][j]+=sqr(i,j); printf("%d\n",f[n][m]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16FEB Load Balancing]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3138%2F</url>
    <content type="text"><![CDATA[题目地址 题解模拟即可。拿线扫描，然后直接模拟。可以二分，套上线段树可以做到$O(nlogn)$的复杂度。实际上应该不需要离散化。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; P;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;P pp[1005],p1[1005],p2[1005];int n;int cmp(P a,P b)&#123; return a.second&lt;b.second||(a.second==b.second&amp;&amp;a.first&lt;b.first);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)pp[i].first=read(),pp[i].second=read(); sort(pp+1,pp+n+1); int cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].first==pp[i].first) pp[i-1].first=cnt; else pp[i-1].first=cnt,cnt+=2; &#125; pp[n].first=cnt; memcpy(p1+1,pp+1,sizeof(P)*n); sort(pp+1,pp+n+1,cmp); cnt=1; for(int i=2;i&lt;=n;i++)&#123; if(pp[i-1].second==pp[i].second) pp[i-1].second=cnt; else pp[i-1].second=cnt,cnt+=2; &#125; pp[n].second=cnt; memcpy(p2+1,pp+1,sizeof(P)*n); //离散化之后分别按照x,y坐标排序，进行扫描。。。 &#125;void solve()&#123; //a | c //------- //b | d //一开始放在最左点左边，最下点下面 int a=0,b=0,c=0,d=0,A=0,B=n,sep,ans=n,maxi; p1[0].first=0,p2[0].second=0; for(int i=1;i&lt;=n;i++,A++,B--)&#123; if(p1[i].first==p1[i-1].first)continue; a=A,c=B,b=d=0; sep=p1[i].first-1; for(int j=1;j&lt;=n;j++)&#123; if(p2[j].second!=p2[j-1].second)&#123; maxi=0; if(maxi&lt;a)maxi=a;if(maxi&lt;b)maxi=b; if(maxi&lt;c)maxi=c;if(maxi&lt;d)maxi=d; if(maxi&lt;ans)ans=maxi; &#125; if(p2[j].first&lt;sep) a--,b++; else c--,d++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN Diamond Collector]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3143%2F</url>
    <content type="text"><![CDATA[题目地址 题解贪心。先排序，对于每一个钻石枚举他能到的最长区间，然后看他之前的和他这个区间不相交的最长区间。统计答案即可，时间复杂度$O(nlogn)$12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int a[100005],n,k,b[100005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1);&#125;void solve()&#123; int lst=0,ans=0,maxi=0; for(int i=1;i&lt;=n;i++)&#123; int loc=lower_bound(a+1,a+n+1,a[i]+k+1)-a-i; b[i]=loc; while(lst+b[lst+1]&lt;i) lst++,maxi=max(maxi,b[lst]); ans=max(ans,maxi+loc); &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO16OPEN 262144]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3147%2F</url>
    <content type="text"><![CDATA[题目地址 题解奇妙的做法。考虑倍增，由于合并必然是一整段连续的序列，所以设$f(i,j)$表示从$j$开始一直合并，直到出现$i$时的下标（开）。然后就可以倍增了。12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int f[65][270000]=&#123;0&#125;,n,ans=0;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int u; scanf("%d",&amp;u),f[u][i]=i+1;//左闭右开 ans=max(ans,u); &#125;&#125;void solve()&#123; for(int i=2;i&lt;=60;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(!f[i][j]&amp;&amp;f[i-1][j]&amp;&amp;f[i-1][f[i-1][j]]) f[i][j]=f[i-1][f[i-1][j]], ans=max(ans,i); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO15OPEN Bessie Goes Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3123%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力枚举…单纯从经验上来说，这道题有背包的解法，但是讨论极其复杂，还不如套一堆循环。注意负数的处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;//1B2E2S1I GOES 1M2Oll ans=0,cnt[7][7]=&#123;0&#125;;int n,mp[256];void init()&#123; n=read(); mp['B']=0,mp['E']=1,mp['S']=2, mp['I']=3,mp['G']=4,mp['O']=5, mp['M']=6; char ord[3]; ll u; for(int i=1;i&lt;=n;i++)&#123; scanf("%s%lld",ord,&amp;u); cnt[mp[ord[0]]][(u%7+7)%7]++; &#125;&#125;void solve()&#123; ll t1,t2,t3; for(int A=0;A&lt;7;A++) for(int B=0;B&lt;7;B++) for(int C=0;C&lt;7;C++) for(int D=0;D&lt;7;D++) for(int E=0;E&lt;7;E++) for(int F=0;F&lt;7;F++) for(int G=0;G&lt;7;G++)&#123; t1=A+B+B+C+C+D,t2=B+C+E+F,t3=G+F+F; if(t1%7==0||t2%7==0||t3%7==0) ans+=cnt[0][A]*cnt[1][B]*cnt[2][C]*cnt[3][D] *cnt[4][E]*cnt[5][F]*cnt[6][G]; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14FEB Roadblock]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2176%2F</url>
    <content type="text"><![CDATA[题目地址 题解先跑一次最短路，然后对最短路上的边进行操作即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;int mp[105][105],E,V,vis[105],d[105],pre[105];void dijkstra(int o)&#123; int lst,at,i,j; fill(d,d+V,INF); memset(vis,0,sizeof(vis)); if(o)memset(pre,-1,sizeof(pre)); d[0]=0; for(i=0;i&lt;V;i++)&#123; for(lst=INF,j=0;j&lt;V;j++) if(!vis[j]&amp;&amp;d[j]&lt;lst)at=j,lst=d[j]; vis[at]=1; for(j=0;j&lt;V;j++) if(d[j]&gt;d[at]+mp[at][j])&#123; d[j]=d[at]+mp[at][j]; if(o)pre[j]=at; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;V,&amp;E); memset(mp,0x3f,sizeof(mp)); int i,j,u,v,ans=0,rec; for(i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;j), u--,v--,mp[u][v]=mp[v][u]=j; dijkstra(1),rec=d[V-1]; for(i=V-1;i!=-1;i=pre[i]) if(pre[i]!=-1) mp[i][pre[i]]&lt;&lt;=1, mp[pre[i]][i]&lt;&lt;=1, dijkstra(0), ans=max(ans,d[V-1]-rec), mp[i][pre[i]]&gt;&gt;=1, mp[pre[i]][i]&gt;&gt;=1; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Sabotage]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2115%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分答案，设为$ans$，那么判定条件 C(ans):\exists [i,j],\frac {sum[n]-sum[i...j]}{n-(j-i+1)}\le ans移项，等价于 sum[n]-ans\times n\le sum[j]-ans\times j-(sum[i-1]-ans\times (i-1))求右边的最大值即可。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 1000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[100005];double eps=1e-4,sum[100005]=&#123;0&#125;; bool C(double ans)&#123; double mini=sum[1]-ans,maxi=sum[2]-2*ans-(sum[1]-ans); for(int i=2;i&lt;n;i++)&#123; maxi=max(maxi,sum[i]-(double)i*ans-mini); mini=min(mini,sum[i]-(double)i*ans); &#125; return (sum[n]-(double)n*ans&lt;=maxi);&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];&#125;void solve()&#123; double L=0,R=(a[1]+a[n])*0.5,M; while(R-L&gt;eps)&#123; M=(R+L)*0.5; if(C(M))R=M;else L=M; &#125; printf("%.3lf\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO14MAR Mooo Moo]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2214%2F</url>
    <content type="text"><![CDATA[题目地址 题解一开始很智障的每一步都求了一个背包…实际上只要求一次，然后$O(1)$回答询问。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,b,v[1005],s[100005],a[1005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125; void init()&#123; n=read(),b=read(); for(int i=1;i&lt;=b;i++)v[i]=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); &#125;void solve()&#123; int ans=0,cur=a[1]; memset(s,0x7f,sizeof(s)); s[0]=0; for(int j=1;j&lt;=b;j++)&#123; int *A=s,*B=s+v[j]; for(;B-s&lt;=100000;A++,B++)&#123; *B=min(*B,*A+1); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cur=a[i]-a[i-1]; if(a[i-1])cur++; if(s[cur]==0x7f7f7f7f)&#123; ans=-1;break; &#125;else ans+=s[cur]; &#125; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12JAN Video Game Combos]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3041%2F</url>
    <content type="text"><![CDATA[题目地址 题解AC自动机学了一天之后，终于想明白了一件事：为什么有时候按照AC图的递推形式不用$fail$?因为在$buildfail$的时候，已经利用了“指向的点要打上同样结束标记的性质”。这样貌似就无形之中运用了$fail$数组。真是神奇的东西啊。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,m,que[10005],f,r;char T[10005],tmp[10005];int trie[10005][26]=&#123;0&#125;,cnt=0;int val[10005];int fail[10005],SIG_SIZE=26;int dp[1005][305]=&#123;0&#125;;bool vis[1005][305]=&#123;0&#125;;//0-&gt;rootvoid trie_insert(char *a)&#123; int p=0; for(;*a;a++)&#123; if(!trie[p][*a-'A']) trie[p][*a-'A']=++cnt; p=trie[p][*a-'A']; &#125; val[p]++;&#125;void getFail()&#123; f=r=0,fail[0]=0; for(int i=0;i&lt;SIG_SIZE;i++)&#123; int h=trie[0][i]; if(h) fail[h]=0,que[r++]=h; &#125; while(r-f)&#123; int h=que[f++],i,_v,f; for(i=0;i&lt;SIG_SIZE;i++)&#123; _v=trie[h][i]; if(!_v)&#123; trie[h][i]=trie[fail[h]][i]; continue; &#125; que[r++]=_v,f=fail[h]; for(;f&amp;&amp;!trie[f][i];f=fail[f]); fail[_v]=trie[f][i]; val[_v]+=val[fail[_v]];// &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",tmp),trie_insert(tmp); getFail(); for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=cnt;j++) dp[i][j]=-2000000000; dp[0][0]=0; for(int i=1;i&lt;=m;i++)&#123; for(int j=0;j&lt;=cnt;j++)&#123; int x; for(int k=0;k&lt;3;k++)&#123; x=trie[j][k]; dp[i][x]=max(dp[i][x],dp[i-1][j]+val[x]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;=cnt;i++) ans=max(ans,dp[m][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO12OPEN Bookshelf]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1848%2F</url>
    <content type="text"><![CDATA[题目地址 题解同poj cut the sequence然而开始我还没发现这是原题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,l=1,r=1,que[100005];ll m,h[100005],w[100005],f[100005];multiset&lt;ll&gt; s;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;h[i],&amp;w[i]);&#125;void solve()&#123; ll cnt=0,ans_; int j=0;//左边是开区间,que[l...r]递减 for(int i=1;i&lt;=n;i++)&#123; cnt+=w[i]; while(cnt&gt;m)cnt-=w[++j]; while(r-l&amp;&amp;que[l]&lt;=j)&#123; if(r-l&gt;1) s.erase(h[que[l+1]]+f[que[l]]); //在读这一段代码的时候，请仔细思考。 //有两个，更大的在l，更小的在l+1 l++; &#125; while(r-l&amp;&amp;h[que[r-1]]&lt;=h[i])&#123; if(r-l&gt;1) s.erase(h[que[r-1]]+f[que[r-2]]); r--; &#125; que[r++]=i; if(r-l&gt;1&amp;&amp;i&gt;que[r-2])s.insert(h[i]+f[que[r-2]]); ans_=*s.begin(); f[i]=h[que[l]]+f[j]; if(r-l&gt;1&amp;&amp;ans_&lt;f[i])f[i]=ans_; &#125; printf("%lld\n",f[n]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Cow Line]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3014%2F</url>
    <content type="text"><![CDATA[题目地址 题解虽然可以用高中数学题的思路，但也可以用康拓展开。实现上估计差别不会很大。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,m,a[40],vis[30];ll fac[40];void makep()&#123; ll x,t;int rk,j,k; scanf("%lld",&amp;x); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; t=0; for(j=1;j&lt;=n-i+1;j++)&#123; if(x&lt;=t+fac[n-i])break; t+=fac[n-i]; &#125; x-=t,rk=0; for(k=1;k&lt;=n;k++)&#123; if(!vis[k])rk++; if(rk==j)break; &#125; printf("%d ",k); vis[k]=1; &#125; for(int i=1;i&lt;=n;i++) if(!vis[i])printf("%d\n",i);&#125;ll query()&#123; ll ans=0;int rk,j,k; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;n;i++)&#123; rk=0; for(k=1;k&lt;a[i];k++) if(!vis[k])rk++; vis[a[i]]=1; ans+=(ll)rk*fac[n-i]; &#125; return ans+1;&#125;void init()&#123; n=read(),m=read(); fac[1]=fac[0]=1; for(int i=2;i&lt;=20;i++)fac[i]=fac[i-1]*(ll)i;&#125;void solve()&#123; char ord[3]; while(m--)&#123; scanf("%s",ord); if(ord[0]=='P')makep(); else&#123; for(int i=1;i&lt;=n;i++)a[i]=read(); printf("%lld\n",query()); &#125; &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11FEB Generic Cow Protest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu1569%2F</url>
    <content type="text"><![CDATA[题目地址 题解水$DP$，设$f(i)$为以$i$为某一组结尾的最大组数，那么 f(i)=\max \limits_{0\le j]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11DEC Grass Planting]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3038%2F</url>
    <content type="text"><![CDATA[题目地址 题解树剖，不过是边问题，所以把边问题改成边的下面那个点的问题。处理的时候注意一下即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int v,_next; &#125;; Edge edge[200005];int cnt=0,at[100005]=&#123;0&#125;;int fa[100005],son[100005]=&#123;0&#125;,siz[100005],top[100005],depth[100005],pos[100005],fp[100005],val[100005];int S,nows=0,n,m,_a,_b,C[400005];int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int k,int v)&#123; while(k&lt;=S)C[k]+=v,k+=lowbit(k);&#125;int query(int r)&#123; int res=0; while(r)res+=C[r],r-=lowbit(r); return res;&#125;void addedge(int _u,int _v)&#123; edge[++cnt].v=_v, edge[cnt]._next=at[_u], at[_u]=cnt;&#125; void dfs1(int x,int par,int d)&#123; depth[x]=d,fa[x]=par,siz[x]=1; for(int i=at[x];i;i=edge[i]._next)&#123; if(edge[i].v==par)continue; int _v=edge[i].v; dfs1(_v,x,d+1); siz[x]+=siz[_v]; if(!son[x]||siz[_v]&gt;siz[son[x]]) son[x]=_v; &#125;&#125;void dfs2(int x,int tp)&#123; top[x]=tp,pos[x]=++nows,fp[nows]=x; if(!son[x])return; dfs2(son[x],tp); for(int i=at[x];i;i=edge[i]._next) if(edge[i].v!=fa[x]&amp;&amp;edge[i].v!=son[x]) dfs2(edge[i].v,edge[i].v);&#125;void update_tr(int u,int v)&#123; while(top[u]!=top[v])&#123; if(depth[top[u]]&lt;depth[top[v]]) swap(u,v); update(pos[top[u]],1); update(pos[u]+1,-1); u=fa[top[u]]; &#125; if(depth[u]&lt;depth[v])swap(u,v); if(u==v)return ; v=son[v]; update(pos[u]+1,-1); update(pos[v],1);&#125;int query_tr(int u,int v)&#123; if(depth[u]&lt;depth[v])swap(u,v); return query(pos[u]);&#125;void init()&#123; n=read(),m=read(); for(S=1;S&lt;=n;S&lt;&lt;=1); int u,v; for(int i=1;i&lt;n;i++)&#123; u=read(),v=read(); addedge(u,v),addedge(v,u); &#125; dfs1(1,0,1); dfs2(1,1);&#125;void solve()&#123; char ord[3]; int x,y; while(m--)&#123; scanf("%s%d%d",ord,&amp;x,&amp;y); if(ord[0]=='P')update_tr(x,y); else printf("%d\n",query_tr(x,y)); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO11NOV Cow Steeplechase]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3033%2F</url>
    <content type="text"><![CDATA[题目地址 题解把线段抽象成点，线段相交就连一条边，然后求一个最大独立集。由于在二分图中，最大匹配就等于最小顶点覆盖，并且对于图来说，最大独立集加上最小顶点覆盖就等于点个数，所以直接上二分图匹配就行了。线段求交…计算几何123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,vis[255],match[255]=&#123;0&#125;,seg[255][4];int X[255],Y[255],cx=0,cy=0;bool mat[255][255]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; int Edmond(int S)&#123; for(int i=1;i&lt;=cy;i++)&#123; if(mat[S][i]&amp;&amp;!vis[i])&#123; vis[i]=1; if(!match[i]||Edmond(match[i]))&#123; match[i]=S; return 1; &#125; &#125; &#125; return 0;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=4;j++) seg[i][j]=read(); if(seg[i][1]==seg[i][3])&#123; Y[++cy]=i;//竖直 if(seg[i][2]&gt;seg[i][4]) swap(seg[i][2],seg[i][4]); &#125;else &#123; X[++cx]=i;//水平 if(seg[i][1]&gt;seg[i][3]) swap(seg[i][1],seg[i][3]); &#125; &#125; for(int i=1;i&lt;=cx;i++) for(int j=1;j&lt;=cy;j++) if(seg[Y[j]][1]&gt;=seg[X[i]][1]&amp;&amp;seg[Y[j]][1]&lt;=seg[X[i]][3]&amp;&amp; seg[X[i]][2]&gt;=seg[Y[j]][2]&amp;&amp;seg[X[i]][2]&lt;=seg[Y[j]][4]) mat[i][j]=1;&#125;void solve()&#123; int ans=0; for(int i=1;i&lt;=cx;i++)&#123; memset(vis,0,sizeof(vis)); if(Edmond(i))ans++; &#125; printf("%d\n",n-ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最大匹配</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Chocolate buying]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2983%2F</url>
    <content type="text"><![CDATA[题目地址 题解差点写成多重背包，好险好险其实就是水贪心…1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n;ll b;pair&lt;ll,ll&gt; P[100005];void init()&#123; scanf("%d%lld",&amp;n,&amp;b); for(int i=0;i&lt;n;i++) scanf("%lld%lld",&amp;P[i].first,&amp;P[i].second);&#125;void solve()&#123; ll ans=0; sort(P,P+n); for(int i=0;i&lt;n;i++)&#123; if(b&lt;P[i].first)break; ll res=min(b/P[i].first,P[i].second); ans+=res; b-=res*P[i].first; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO10FEB Treasure Chest]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu3004%2F</url>
    <content type="text"><![CDATA[题目地址 题解$DP$。时间复杂度为$O(n^2)$。我的方法是设$f(i,j)$表示从$i$到$j$先手最高分数，然后转移方程就是 f(i,j)=\max \left\{ c[i]+\min\left\{f(i+2,j),f(i+1,j-1)\right\} ,c[j]+\min\left\{f(i+1,j-1),f(i,j-2)\right\}\right\}但不知道为什么本机过了,洛谷上T了。当然本题的官方做法更巧妙。观察前面带有$\min$的式子，我们发现里面的$\min$可以拿掉，因为我们刚好也算出了第二个人作为先手的最大解。所以上面的$\min$就可以表示为$f$的形式，即 \min \left\{ f(i+2,j),f(i+1,j-1) \right\} =sum(i+1,j)-f(i+1,j)这样常数貌似很小，就可以过，还可以干掉一维空间。 修改前：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005][5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=0;i&lt;n;i++)c[i]=read();&#125;void solve()&#123; int d1,d2,d3,b1,b2,lim; for(int i=0;i&lt;n;i++) dp[i][i]=c[i]; for(int j=0;j&lt;n-1;j++) dp[j][j+1]=max(c[j],c[j+1]); for(int j=2;j&lt;n;j++)&#123; d1=dp[0][j-2],d2=dp[1][j-1],d3=dp[2][j]; lim=n-j; for(int i=0;i&lt;lim;i++)&#123; b1=d3;if(d2&lt;d3)b1=d2;b1+=c[i]; b2=d1;if(d2&lt;d1)b2=d2;b2+=c[i+j]; dp[i][i+j]=b1;if(b1&lt;b2)dp[i][i+j]=b2; d1=d2,d2=d3,d3=dp[i+3][i+1+j]; &#125; &#125; printf("%d\n",dp[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125; 修改后：123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,c[5005],dp[5005]=&#123;0&#125;,sum[5005]=&#123;0&#125;;int read()&#123; int x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x; &#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)c[i]=read(),sum[i]=sum[i-1]+c[i];&#125;void solve()&#123; for(int j=0;j&lt;n;j++) for(int i=1;i+j&lt;=n;i++) dp[i]=sum[i+j]-sum[i-1]-min(dp[i],dp[i+1]); printf("%d\n",dp[1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09MAR Look Up]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2947%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力肯定行不通，考虑到无用元素的去除以及单调性的维护，我们使用单调栈这一数据结构。实际上这题跟06年那道题一个意思，所以要看的话可以去前面找一下我写的另一篇题解。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int n,s[100005][2],dat[100005],top=0,ans[100005];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;dat[i]); s[top][0]=dat[n-1], s[top++][1]=n-1, ans[n-1]=-1; for(int i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;dat[i]&gt;=s[top-1][0]) top--; if(!top)ans[i]=-1; else ans[i]=s[top-1][1]; s[top][0]=dat[i], s[top++][1]=i; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09OPEN Cow Digit Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2953%2F</url>
    <content type="text"><![CDATA[题目地址 题解很标准的博弈论递推。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;bool sg[1000005];void init()&#123; sg[0]=0; int bit[9]=&#123;0&#125;,maxi,mini,len=1; for(int i=1;i&lt;=1000000;i++)&#123; bit[0]++; for(int j=0;bit[j]==10&amp;&amp;j&lt;len;j++) bit[j]=0,bit[j+1]++; if(bit[len])len++; mini=10,maxi=0; for(int j=0;j&lt;len;j++)&#123; if(bit[j]&gt;maxi)maxi=bit[j]; if(bit[j]&lt;mini&amp;&amp;bit[j])mini=bit[j]; &#125; if(!sg[i-maxi]||!sg[i-mini])sg[i]=1; &#125;&#125;void solve()&#123; int T=read(),n; while(T--) n=read(),printf("%s\n",sg[n]?"YES":"NO");&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09NOV A Coin Game]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2964%2F</url>
    <content type="text"><![CDATA[题目地址 题解设$dp(i,j)$表示还剩$i$个，之前选了$j$个的状态。正面非常不好做，所以要用这个倒着推的状态。转移只要$2$个，因为其他转移之前已经包含了。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int dp[2005][2005],n,a[2005],sum[2005],que[4000005][2],f=0,r=0;void init()&#123; n=read(); sum[0]=0; for(int i=n;i&gt;=1;i--)a[i]=read(); for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; //正面不好写 &#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=dp[i][j-1]; if(i-2*j&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j][2*j]); if(i-2*j+1&gt;=0)dp[i][j]=max(dp[i][j],sum[i]-dp[i-2*j+1][2*j-1]); &#125; &#125; printf("%d\n",dp[n][1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO09FEB Revamping Trails]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2939%2F</url>
    <content type="text"><![CDATA[题目地址 题解最短路模型，这很显然。顺带一提，不要用SPFA，真心卡成狗。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define INF 1010000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;struct Edge&#123; int to,_next,cost;&#125;;struct Node&#123; int h,e,dis; Node(int h_,int e_,int d_)&#123; h=h_,e=e_,dis=d_; &#125; Node()&#123;&#125;&#125;;bool operator &lt;(const Node &amp;n1,const Node &amp;n2)&#123; return n1.dis&gt;n2.dis;&#125;priority_queue&lt;Node&gt; pq;Edge edge[100005];int n,m,k,at[10005]=&#123;0&#125;,F[10005][21]=&#123;0&#125;,cnt=0;void addedge(int u,int v,int c)&#123; edge[++cnt].to=v, edge[cnt].cost=c, edge[cnt]._next=at[u], at[u]=cnt;&#125;void Dij()&#123; F[1][0]=0,pq.push(Node(1,0,0)); Node tmp; int h_,e_,d_,v_,c_; while(!pq.empty())&#123; tmp=pq.top(),pq.pop(); if(tmp.dis&gt;F[tmp.h][tmp.e])continue; h_=tmp.h,e_=tmp.e,d_=tmp.dis; for(int i=at[h_];i;i=edge[i]._next)&#123; v_=edge[i].to,c_=edge[i].cost; if(F[v_][e_]&gt;F[h_][e_]+c_) F[v_][e_]=F[h_][e_]+c_, pq.push(Node(v_,e_,F[v_][e_])); if(e_&lt;k&amp;&amp;F[v_][e_+1]&gt;F[h_][e_]) F[v_][e_+1]=F[h_][e_], pq.push(Node(v_,e_+1,F[v_][e_+1])); &#125; &#125;&#125;void init()&#123; n=read(),m=read(),k=read(); int u,v,c; for(int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),c=read(); addedge(u,v,c),addedge(v,u,c); &#125;&#125;void solve()&#123; memset(F,0x3F,sizeof(F)); Dij(); int ans=INF*2; for(int i=0;i&lt;=k;i++)ans=min(ans,F[n][i]); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08DEC Patting Heads]]></title>
    <url>%2F2018%2F08%2F04%2Fluogu2926%2F</url>
    <content type="text"><![CDATA[题目地址 题解大力筛倍数即可。12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int n,a[100005],cnt[1000005]=&#123;0&#125;,ans[1000005]=&#123;0&#125;;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]),cnt[a[i]]++;&#125;void solve()&#123; for(int i=1;i&lt;=1000000;i++)&#123; if(cnt[i])&#123; for(int j=i;j&lt;=1000000;j+=i) ans[j]+=cnt[i]; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[a[i]]-1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08JAN Telephone Lines]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu1948%2F</url>
    <content type="text"><![CDATA[题目地址 题解一看就知道是二分答案的类型。二分最小费用$x$，然后看路上最少经过几条费用比他多的路。这题就一个地方有点绕：怎么求$1$-$n$之间路上有几条这样的路？要么边跑最短路边特判，要么把边分类，大于$x$的边权设$1$，小于的设$0$。这样就解决了这道题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next;&#125;;Edge edge[20005],_edge[20005];int V,E,K,at[1005],cnt=0,maxi=0;int d[1005],que[50005],f,r,in[1005]=&#123;0&#125;;void addedge(int _u,int _v,int _c)&#123; edge[cnt].v=_v, edge[cnt].cost=_c, edge[cnt]._next=at[_u], at[_u]=cnt++; &#125;void spfa_bfs(int S)&#123; fill(d,d+V,INF); d[S]=0; f=r=0,que[r++]=S,in[S]=1; while(r-f)&#123; int h=que[f++],_v,_c; for(int i=at[h];i!=-1;i=_edge[i]._next)&#123; _v=_edge[i].v,_c=_edge[i].cost; if(d[_v]&gt;d[h]+_c)&#123; d[_v]=d[h]+_c; if(!in[_v]) in[_v]=1,que[r++]=_v; &#125; &#125; in[h]=0; &#125;&#125;void init()&#123; scanf("%d%d%d",&amp;V,&amp;E,&amp;K); memset(at,-1,sizeof(at)); int u,v,c; for(int i=0;i&lt;E;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;c), addedge(u-1,v-1,c), addedge(v-1,u-1,c), maxi=max(maxi,c);&#125;void solve()&#123; int L=0,R=maxi,M; memcpy(_edge,edge,sizeof(edge)); while(R-L)&#123; int M=(R+L)/2; for(int i=0;i&lt;cnt;i++) _edge[i].cost=(edge[i].cost&gt;M); spfa_bfs(0); if(d[V-1]==INF)&#123; printf("-1\n"); return ; &#125; if(d[V-1]&gt;K)L=M+1; else R=M; &#125; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Time Management]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2920%2F</url>
    <content type="text"><![CDATA[题目地址 题解二分+贪心每次优先完成期限最短且时间最短的任务。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,t[1005],s[1005],mini=INF;pair&lt;int,int&gt; P[1005];bool judge(int M)&#123; for(int i=0;i&lt;n;i++)&#123; if(M+P[i].second&lt;=P[i].first) M+=P[i].second; else return 0; &#125; return 1;&#125;void init()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;t[i],&amp;s[i]), P[i].first=s[i],P[i].second=t[i], mini=min(mini,s[i]); sort(P,P+n);&#125;void solve()&#123; int L=0,R=mini,M; while(R-L)&#123; M=(R+L+1)/2; if(judge(M)) L=M; else R=M-1; &#125; if(!judge(0))L=-1; printf("%d\n",L);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR River Crossing]]></title>
    <url>%2F2018%2F08%2F03%2Fluogu2904%2F</url>
    <content type="text"><![CDATA[题目地址 题解水DP注意划船回来的时间12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int sum[2505],n,f[2505]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; scanf("%d%d",&amp;n,&amp;sum[0]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;sum[i]), sum[i]+=sum[i-1];&#125;void solve()&#123; fill(f,f+n+1,INF); f[0]=0; for(int i=1;i&lt;=n;i++) for(int j=i-1;j&gt;=0;j--) f[i]=min(f[i],f[j]+sum[i-j]+sum[0]); printf("%d\n",f[n]-sum[0]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OPEN Cow Neighborhoods]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2906%2F</url>
    <content type="text"><![CDATA[题目地址 题解这个绝对值很难搞啊。拆开来试试看？ |x_1-x_2|+|y_1-y_2|=x_1-x_2+y_1-y_2或x_2-x_1+y_1-y_2或x_1-x_2+y_2-y_1或x_2-x_1+y_2-y_1发现前两个是相反数，中间俩也是。原式=|x_1+y_1-(x_ 2+y_2)|或|(x_1-y_1)-(x_2-y_2)|。这时候发现两个式子里面都是只与下标有关值的差，就设xx_i=x_i+y_i,yy_i=x_i-y_i。原式=|xx_1-xx_2|或|yy_1-yy_2|。我怎么知道取哪个?不知道，就让他们都满足。即使\max \left\{|xx_1-xx_2|,|yy_1-yy_2|\right\}\le c。之后就是乱搞了，维护一下差即可，用并查集合并可行部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,C,x[100005],y[100005],xx[100005],yy[100005],rk[100005];int par[100005],cnt[100005],ans1=0,ans2=0,S=0,ans,loc;int que[100005],f,r;struct Tr&#123; Tr *ch[2]; int r,v,id; int cmp(int w,int z) const &#123; if(w==v&amp;&amp;z==id)return -1; return w&gt;v||(w==v&amp;&amp;z&gt;id); &#125;&#125;;Tr tree[400005],*root=NULL;void rorate_tr(Tr* &amp;tr,int d)&#123; Tr *k=tr-&gt;ch[d^1]; tr-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=tr,tr=k;&#125;void insert_tr(Tr* &amp;tr,int _v,int _id)&#123; if(tr==NULL)&#123; S++,tr=&amp;tree[S],tr-&gt;v=_v,tr-&gt;id=_id; tr-&gt;ch[0]=tr-&gt;ch[1]=NULL,tr-&gt;r=rand(); return ; &#125; int d=tr-&gt;cmp(_v,_id); insert_tr(tr-&gt;ch[d],_v,_id); if(tr-&gt;ch[d]-&gt;r&gt;tr-&gt;r)rorate_tr(tr,d^1);&#125;void delete_tr(Tr* &amp;tr,int _v,int _id)&#123; int d=tr-&gt;cmp(_v,_id); if(d==-1)&#123; if(tr-&gt;ch[0]==NULL)tr=tr-&gt;ch[1]; else if(tr-&gt;ch[1]==NULL)tr=tr-&gt;ch[0]; else&#123; int d_=(tr-&gt;ch[0]-&gt;r&gt;tr-&gt;ch[1]-&gt;r); rorate_tr(tr,d_),delete_tr(tr-&gt;ch[d_],_v,_id); &#125; &#125;else delete_tr(tr-&gt;ch[d],_v,_id);&#125; void previous(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&gt;=tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,previous(tr-&gt;ch[1],_v); else previous(tr-&gt;ch[0],_v);&#125;void success(Tr *tr,int _v)&#123; if(tr==NULL)return ; if(_v&lt;tr-&gt;v) ans=tr-&gt;v,loc=tr-&gt;id,success(tr-&gt;ch[0],_v); else success(tr-&gt;ch[1],_v);&#125;int Find(int k)&#123; if(k==par[k])return k; return (par[k]=(Find(par[k])));&#125;void Unite(int u,int v)&#123; if(Find(u)==Find(v))return; par[Find(u)]=Find(v);&#125;bool cmp(int ia,int ib)&#123; return xx[ia]&lt;xx[ib]||(xx[ia]==xx[ib]&amp;&amp;yy[ia]&lt;yy[ib]);&#125;void init()&#123; srand(21451); n=read(),C=read(); for(int i=1;i&lt;=n;i++) x[i]=read(),y[i]=read(),xx[i]=x[i]+y[i],yy[i]=x[i]-y[i],rk[i]=par[i]=i; sort(rk+1,rk+1+n,cmp);&#125;void solve()&#123; f=r=0,que[r++]=rk[1],insert_tr(root,yy[rk[1]],rk[1]); for(int i=2;i&lt;=n;i++)&#123; int index=rk[i]; while(r&gt;f&amp;&amp;xx[index]-xx[que[f]]&gt;C) delete_tr(root,yy[que[f]],que[f]),f++; ans=-INF,success(root,yy[index]);//查后缀 if(ans&gt;-INF&amp;&amp;ans-yy[index]&lt;=C)Unite(loc,index); ans=INF,previous(root,yy[index]);//查前缀 if(ans&lt;INF&amp;&amp;yy[index]-ans&lt;=C)Unite(loc,index); insert_tr(root,yy[index],index); que[r++]=index; &#125; for(int i=1;i&lt;=n;i++)cnt[Find(i)]++; for(int i=1;i&lt;=n;i++)ans1+=(cnt[i]!=0),ans2=max(ans2,cnt[i]); printf("%d %d\n",ans1,ans2);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Eating Together]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2896%2F</url>
    <content type="text"><![CDATA[题目地址 题解方法一大力$O(nlogn)LIS$。优点：不容易错，缺点：时间复杂度高。 方法二运用特殊性质，分段$DP$，分别用$f(x),g(x),h(x)$表示以$1,2,3$为结尾的一段的最小修改次数。优点：时间复杂度线性缺点：容易错容易错容易错难调难调难调123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,a[30005],f[30005],g[30005],h[30005];void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();&#125;int dp()&#123; int mini,dif=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=1),f[i]=dif; dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=2),g[i]=mini+dif,mini=min(mini,f[i]-dif); dif=0,mini=0; for(int i=1;i&lt;=n;i++) dif+=(a[i]!=3),h[i]=mini+dif,mini=min(mini,min(g[i]-dif,f[i]-dif)); return min(f[n],min(g[n],h[n]));&#125;void solve()&#123; int ans=dp(); reverse(a+1,a+n+1); ans=min(ans,dp()); printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08FEB Game of Lines]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2665%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力统计即可。wa了2次的我就是sb啊12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,x[205],y[205],tot=0;double lis[40005],eps=1e-8;double slope(int a,int b)&#123; if(x[a]==x[b])return 1e9; return (double)(y[b]-y[a])/(x[b]-x[a]);&#125;int cmp(double a,double b)&#123; return (a-b)&gt;-eps&amp;&amp;(a-b)&lt;eps;&#125;void init()&#123; n=read(); for(int i=1;i&lt;=n;i++)x[i]=read(),y[i]=read();&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;i;j++) lis[++tot]=slope(i,j); sort(lis+1,lis+tot+1); int ans=0; for(int i=2;i&lt;=tot;i++)&#123; while(cmp(lis[i],lis[i-1])&amp;&amp;i&lt;=tot) i++; ans++; &#125; if(!cmp(lis[tot],lis[tot-1]))ans++; printf("%d\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08OCT Watering Hole]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1550%2F</url>
    <content type="text"><![CDATA[题目地址 题解如果没说全部连通的话就会形成一个特殊的局面：森林。把一个无向森林结合起来的常用方法就是加点。加一个超级源，使打井变成这个源到节点的边权，再MST即可。数据小，貌似暴力也行？12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 1000000000using namespace std;int mat[405][405],w[405],n;int vis[405],mini[405];int prim(int S)&#123; memset(mini,0x3f,sizeof(mini)); mini[S]=0; int i,j,_min,at,ans=0; for(i=0;i&lt;n;i++)&#123; for(at=-1,j=0;j&lt;n;j++) if(!vis[j]&amp;&amp;(at&lt;0||mini[j]&lt;mini[at])) at=j; vis[at]=1,ans+=mini[at]; for(j=0;j&lt;n;j++) mini[j]=min(mini[j],mat[at][j]); &#125; return ans; &#125;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;w[i]); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;mat[i][j]); for(int i=0;i&lt;n;i++) mat[i][n]=mat[n][i]=w[i]; mat[n][n]=0; n++; printf("%d\n",prim(n-1)); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO08MAR Land Acquisition]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2900%2F</url>
    <content type="text"><![CDATA[题目地址 题解斜率优化。 合并部分土地，使$y$递减，$x$递增 注意单调队列的增减性。 决策的单调性… 凸壳的中间点在什么情况下一定不优？考虑不同的限定条件，可以证明两端分别在2种情况下都更优。这是单调队列单调的理由。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; P;P a[50005],b[50005];int n,cnt=0,que[50005]=&#123;0&#125;,l=1,r=1; ll f[50005];double slope(int j,int k)&#123; return (f[k]-f[j])/(b[j+1].second-b[k+1].second);&#125;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i].first=read(),a[i].second=read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; //printf("%d %d\n",a[i].first,a[i].second); while(cnt&amp;&amp;a[i].second&gt;=b[cnt].second) cnt--; b[++cnt]=a[i]; &#125;&#125;void solve()&#123; que[r++]=0; for(int i=1;i&lt;=cnt;i++)&#123; while(r-l&gt;1&amp;&amp;slope(que[l],que[l+1])&lt;b[i].first) l++; f[i]=f[que[l]]+b[que[l]+1].second*b[i].first; while(r-l&gt;1&amp;&amp;slope(que[r-2],que[r-1])&gt;slope(que[r-1],i)) r--; que[r++]=i; &#125; printf("%lld\n",f[cnt]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OPEN Cheapest Palindrome]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2890%2F</url>
    <content type="text"><![CDATA[题目地址 题解区间DP没想出来的我该去看脑科12345678910111213141516171819202122232425262728293031323334353637 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,m,add[30],rem[30],dp[2005][2005];char s[2005],ord[3],is[2005][2005]=&#123;0&#125;;void init()&#123; scanf("%d%d%s",&amp;n,&amp;m,s); for(int i=0;i&lt;n;i++)&#123; scanf("%s",ord); scanf("%d%d",&amp;add[ord[0]-'a'],&amp;rem[ord[0]-'a']); &#125; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) dp[i][j]=(i&lt;j)?INF:0;&#125;void solve()&#123; for(int j=0;j&lt;m;j++) for(int i=0;i+j&lt;m;i++) if(s[i]==s[i+j])dp[i][i+j]=dp[i+1][i+j-1]; else&#123; dp[i][i+j]=min(dp[i+1][i+j]+rem[s[i]-'a'], min(dp[i+1][i+j]+add[s[i]-'a'], min(dp[i][i+j-1]+rem[s[i+j]-'a'], dp[i][i+j-1]+add[s[i+j]-'a']))); &#125; printf("%d\n",dp[0][m-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07JAN Protecting the Flowers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2878%2F</url>
    <content type="text"><![CDATA[题目地址 题解假设牛$i$和牛$j$相邻，那么比较他们谁先送走更划算的依据是$T_iD_j$和$T_jD_i$。$T_iD_j&gt;T_jD_i$那么$j$先走，否则$i$先走。由此得判断依据：$\frac {T_i}{D_i}$与$\frac {T_j}{D_j}$。小的先走。之后排序贪心即可。1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll n,t[100005],d[100005],ans=0,sum=0;pair&lt;double,ll&gt; P[100005];void init()&#123; scanf("%lld",&amp;n); for(ll i=0;i&lt;n;i++) scanf("%lld%lld",&amp;t[i],&amp;d[i]), P[i].first=(double)t[i]/d[i], P[i].second=i; sort(P,P+n); for(ll i=0;i&lt;n;i++) sum+=d[i];&#125;void solve()&#123; for(ll i=0;i&lt;n;i++)&#123; ll id=P[i].second; sum-=d[id]; ans+=2*t[id]*sum; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待考察 USACO07JAN Problem Solving]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2876%2F</url>
    <content type="text"><![CDATA[题目地址 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int n,b,f[605][305],A[305],B[305],sum[305],sumb[305],ans;void init()&#123; b=read(),n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(),B[i]=read(),sum[i]=sum[i-1]+A[i],sumb[i]=sumb[i-1]+B[i];&#125;void solve()&#123; f[2][0]=b; for(int i=1;i&lt;=n;i++) if(b&gt;=sum[i]&amp;&amp;b&gt;=sumb[i])f[2][i]=b-sumb[i]; else f[2][i]=-INF; for(int i=3;i&lt;=2*n;i++)&#123; f[i][0]=b; for(int j=1;j&lt;=n;j++)&#123; f[i][j]=-INF; for(int k=0;k&lt;=j;k++) if(f[i-1][k]-(sum[j]-sum[k])&gt;=0) f[i][j]=max(f[i][j],b-(sumb[j]-sumb[k])); &#125; if(f[i][n]&gt;=0)&#123; ans=i;break; &#125; &#125; printf("%d\n",ans+1);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>其他DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07OCT Obstacle Course]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu1649%2F</url>
    <content type="text"><![CDATA[题目地址 题解暴力建图跑SPFA即可。就是要注意建图的方式：一个点拆成4个。同时注意输入，有坑！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;struct Edge&#123; int v,cost,_next; &#125;; Edge edge[2000005];int cnt=0,at[40005],n,V;int d[40005],in[40005],que[500005],f=0,r=0;void spfa_bfs(int s)&#123; fill(d+1,d+4*V+1,INF); for(int i=0;i&lt;4;i++) d[s+i*V]=0,in[s+i*V]=1,que[r++]=s+i*V; int i,_u,_v,_co; while(r-f)&#123; _u=que[f++],in[_u]=0; for(i=at[_u];i!=-1;i=edge[i]._next)&#123; _v=edge[i].v,_co=edge[i].cost; if(d[_u]+_co&lt;d[_v])&#123; d[_v]=d[_u]+_co; if(!in[_v])&#123; in[_v]=1,que[r++]=_v; &#125; &#125; &#125; &#125;&#125;void addedge(int _u,int _v,int _cost)&#123; edge[cnt].v=_v, edge[cnt].cost=_cost, edge[cnt]._next=at[_u], at[_u]=cnt++;&#125; int xa,xb,ya,yb;char mat[105][105];int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); char ord[1005]; int tot,len; for(int i=1;i&lt;=n;i++)&#123; fgets(ord,300,stdin); len=strlen(ord),tot=1; for(int j=0;j&lt;len;j++) if(!isspace(ord[j]))mat[i][tot++]=ord[j]; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(mat[i][j]=='A')xa=i,ya=j; else if(mat[i][j]=='B')xb=i,yb=j; V=n*n; memset(at,-1,sizeof(at)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(mat[i][j]=='x') continue; //1上2下3左4右 int id=(i-1)*n+j; addedge(id,2*V+id,1),addedge(2*V+id,id,1), addedge(id,V+id,2),addedge(V+id,id,2), addedge(id,3*V+id,1),addedge(3*V+id,id,1), addedge(2*V+id,V+id,1),addedge(V+id,2*V+id,1), addedge(3*V+id,V+id,1),addedge(V+id,3*V+id,1), addedge(2*V+id,3*V+id,2),addedge(3*V+id,2*V+id,2); if(i!=1&amp;&amp;mat[i-1][j]!='x')addedge(id,id-n,0); if(i!=n&amp;&amp;mat[i+1][j]!='x')addedge(V+id,V+(id+n),0); if(j!=1&amp;&amp;mat[i][j-1]!='x')addedge(2*V+id,2*V+(id-1),0); if(j!=n&amp;&amp;mat[i][j+1]!='x')addedge(3*V+id,3*V+(id+1),0); &#125;&#125;void solve()&#123; int id=(xa-1)*n+ya; spfa_bfs(id); id=(xb-1)*n+yb; int ans=min(min(min(d[id],d[V+id]),d[2*V+id]),d[3*V+id]); printf("%d\n",ans==INF?-1:ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO07DEC Gourmet Grazers]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2869%2F</url>
    <content type="text"><![CDATA[题目地址 题解STL大法好multiset水题按照贪心的思想，每次给牛中对草的质量最高的安排一个草的质量比他高的，且最便宜的。用平衡树维护即可。时限宽松，所以用multiset暴力水过123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define INF 2000000000using namespace std;typedef long long ll;multiset&lt;int&gt; s;pair&lt;int,int&gt; P[100005],C[100005];ll ans=0; int n,m;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)C[i].second=read(),C[i].first=read(); for(int i=1;i&lt;=m;i++)P[i].second=read(),P[i].first=read(); sort(P+1,P+m+1); sort(C+1,C+n+1);&#125;void solve()&#123; for(int i=n,j=m;i&gt;=1;i--)&#123; while(j&gt;=1&amp;&amp;P[j].first&gt;=C[i].first) s.insert(P[j].second),j--; if(s.empty())&#123; printf("-1\n"); return ; &#125;else&#123; int ans_=*s.lower_bound(C[i].second); ans+=ans_,s.erase(s.find(ans_)); &#125; &#125; printf("%lld\n",ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06FEB Treats for the Cows]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2858%2F</url>
    <content type="text"><![CDATA[题目地址 题解傻DP…区间转移形式12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int n,v[2005],f[2005][2005]=&#123;0&#125;;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125; void init()&#123; n=read(); for(int i=0;i&lt;n;i++) v[i]=read();&#125;void solve()&#123; for(int i=0;i&lt;n;i++) f[i][i]=v[i]*n; for(int j=1;j&lt;n;j++) for(int i=0;i+j&lt;n;i++)&#123; f[i][i+j]=max(f[i+1][i+j]+v[i]*(n-j),f[i][i+j-1]+v[i+j]*(n-j)); &#125; printf("%d\n",f[0][n-1]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06NOV Bad Hair Day]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2866%2F</url>
    <content type="text"><![CDATA[题目地址 题解单调栈模板题。从右到左记录一个递减的序列即可。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; #include &lt;cstdlib&gt;using namespace std;int st[80005][2],top=0,n,h[80005];long long ans=0;int main()&#123; scanf("%d",&amp;n); int i,j; for(i=0;i&lt;n;i++) scanf("%d",&amp;h[i]); st[top][0]=h[n-1],st[top++][1]=n-1; for(i=n-2;i&gt;=0;i--)&#123; while(top&amp;&amp;h[i]&gt;st[top-1][0]) top--; if(!top) ans+=(n-1-i); else ans+=(st[top-1][1]-i-1); st[top][0]=h[i],st[top++][1]=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO06DEC Cow Roller Coaster]]></title>
    <url>%2F2018%2F08%2F02%2Fluogu2854%2F</url>
    <content type="text"><![CDATA[题目地址 题解先排序，把整个轨道考虑的顺序弄起来，再做01背包。注意状态的可行性。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define INF 2000000000using namespace std;typedef long long ll;int read()&#123; int f=1,x=0;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return f*x; &#125;int L,n,B,dp[1005][1005];struct C&#123; int l,r,fun,cost; bool operator &lt;(C &amp;a)&#123; return l&lt;a.l||(l==a.l&amp;&amp;r&lt;a.r); &#125;&#125;comp[10005];void init()&#123; L=read(),n=read(),B=read(); for(int i=1;i&lt;=n;i++) comp[i].l=read(),comp[i].r=read()+comp[i].l, comp[i].fun=read(),comp[i].cost=read(); sort(comp+1,comp+1+n);&#125;void solve()&#123; int c_,l_,r_,f_; memset(dp,-1,sizeof(dp)); for(int i=0;i&lt;=B;i++)dp[i][0]=0; for(int i=1;i&lt;=n;i++)&#123; c_=comp[i].cost,l_=comp[i].l,r_=comp[i].r,f_=comp[i].fun; for(int j=B;j&gt;=c_;j--) if(dp[j-c_][l_]&gt;=0) dp[j][r_]=max(dp[j][r_],dp[j-c_][l_]+f_); &#125; printf("%d\n",dp[B][L]);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2012 随机数生成器]]></title>
    <url>%2F2018%2F08%2F02%2Fnoi2012t1%2F</url>
    <content type="text"><![CDATA[题目地址 题解水矩乘。唯一要注意的是爆炸的乘法运算。快速乘解决即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;typedef struct&#123; ll dat[3][3]; int r,c;&#125;Mat;ll M,A,C,x0,n,G;Mat mid,tmp;ll mulll(ll a,ll b)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%M; a=(a+a)%M;b&gt;&gt;=1; &#125; return res;&#125; void mul(Mat &amp;a,Mat &amp;b,Mat *to)&#123; to-&gt;r=a.r,to-&gt;c=b.c; int i,j,k;ll t; for(i=0;i&lt;a.r;i++) for(j=0;j&lt;b.c;j++)&#123; t=0;for(k=0;k&lt;a.c;k++)t+=mulll(a.dat[i][k],b.dat[k][j]),t%=M; to-&gt;dat[i][j]=t%M; &#125;&#125;Mat pow(Mat a,ll p)&#123; Mat E,F; E.r=E.c=a.c; int i,j; for(i=0;i&lt;a.c;i++) for(j=0;j&lt;a.c;j++) E.dat[i][j]=(i==j)?1:0; while(p)&#123; if(p&amp;1)mul(E,a,&amp;F),E=F; mul(a,a,&amp;F),a=F;p&gt;&gt;=1; &#125;return E;&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;M,&amp;A,&amp;C,&amp;x0,&amp;n,&amp;G); Mat fib,d,u,v; fib.r=fib.c=2; fib.dat[0][0]=A%M; fib.dat[0][1]=fib.dat[1][1]=1; fib.dat[1][0]=0; u=pow(fib,n); d.r=2,d.c=1; d.dat[0][0]=x0%M,d.dat[1][0]=C%M; mul(u,d,&amp;v); printf("%lld\n",v.dat[0][0]%G); return 0;&#125;]]></content>
      <categories>
        <category>NOI题解</category>
        <category>NOI2012</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>快速乘</tag>
      </tags>
  </entry>
</search>
